var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;

if (typeof global$1.setTimeout === 'function') {
  cachedSetTimeout = setTimeout;
}

if (typeof global$1.clearTimeout === 'function') {
  cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

function nextTick(fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
} // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

var title$1 = 'browser';
var platform$1 = 'browser';
var browser$3 = true;
var env$1 = {};
var argv = [];
var version$8 = ''; // empty string to avoid regexp issues

var versions = {};
var release$1 = {};
var config = {};

function noop$3() {}

var on = noop$3;
var addListener = noop$3;
var once = noop$3;
var off = noop$3;
var removeListener = noop$3;
var removeAllListeners = noop$3;
var emit = noop$3;

function binding(name) {
  throw new Error('process.binding is not supported');
}

function cwd() {
  return '/';
}

function chdir(dir) {
  throw new Error('process.chdir is not supported');
}

function umask() {
  return 0;
} // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js


var performance = global$1.performance || {};

var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
  return new Date().getTime();
}; // generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime


function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);

  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];

    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }

  return [seconds, nanoseconds];
}

var startTime = new Date();

function uptime$1() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1$1 = {
  nextTick: nextTick,
  title: title$1,
  browser: browser$3,
  env: env$1,
  argv: argv,
  version: version$8,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform$1,
  release: release$1,
  config: config,
  uptime: uptime$1
};

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.


var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

var splitPath = function (filename) {
  return splitPathRe.exec(filename).slice(1);
}; // path.resolve([from ...], to)
// posix version


function resolve$1() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : '/'; // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter$2(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}
// posix version

function normalize(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter$2(path.split('/'), function (p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
}

function isAbsolute(path) {
  return path.charAt(0) === '/';
} // posix version

function join$1() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter$2(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
} // path.relative(from, to)
// posix version

function relative(from, to) {
  from = resolve$1(from).substr(1);
  to = resolve$1(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
}
var sep = '/';
var delimiter = ':';
function dirname(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}
function basename(path, ext) {
  var f = splitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
}
function extname(path) {
  return splitPath(path)[3];
}
var path$1 = {
  extname: extname,
  basename: basename,
  dirname: dirname,
  sep: sep,
  delimiter: delimiter,
  relative: relative,
  join: join$1,
  isAbsolute: isAbsolute,
  normalize: normalize,
  resolve: resolve$1
};

function filter$2(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};

var path$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  resolve: resolve$1,
  normalize: normalize,
  isAbsolute: isAbsolute,
  join: join$1,
  relative: relative,
  sep: sep,
  delimiter: delimiter,
  dirname: dirname,
  basename: basename,
  extname: extname,
  'default': path$1
});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;

function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray(b64) {
  if (!inited) {
    init();
  }

  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice


  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

  arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  if (!inited) {
    init();
  }

  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);
  return parts.join('');
}

function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}

function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;

var isArray$2 = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


var INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

Buffer.isBuffer = isBuffer$1;

function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}

Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }

  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }

  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
} // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually


function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}

function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var inherits;

if (typeof Object.create === 'function') {
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function () {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

var inherits$1 = inherits;

var formatRegExp = /%[sdj%]/g;
function format$1(f) {
  if (!isString$1(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect$1(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect$1(x);
    }
  }

  return str;
}
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.

function deprecate(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global$1.process)) {
    return function () {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (browser$1$1.noDeprecation === true) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (browser$1$1.throwDeprecation) {
        throw new Error(msg);
      } else if (browser$1$1.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron)) debugEnviron = browser$1$1.env.NODE_DEBUG || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = 0;

      debugs[set] = function () {
        var msg = format$1.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
}
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/

function inspect$1(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
} // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect$1.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect$1.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];

  if (style) {
    return '\u001b[' + inspect$1.colors[style][0] + 'm' + str + '\u001b[' + inspect$1.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction$1(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect$1 && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString$1(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction$1(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray$1(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction$1(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString$1(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty$1(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty$1(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function (prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray$1(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === 'number';
}
function isString$1(arg) {
  return typeof arg === 'string';
}
function isSymbol(arg) {
  return typeof arg === 'symbol';
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
function isFunction$1(arg) {
  return typeof arg === 'function';
}
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
function isBuffer(maybeBuf) {
  return Buffer.isBuffer(maybeBuf);
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


function log() {
  console.log('%s - %s', timestamp(), format$1.apply(null, arguments));
}
function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
}

function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var util$2 = {
  inherits: inherits$1,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive,
  isFunction: isFunction$1,
  isError: isError,
  isDate: isDate,
  isObject: isObject,
  isRegExp: isRegExp,
  isUndefined: isUndefined,
  isSymbol: isSymbol,
  isString: isString$1,
  isNumber: isNumber,
  isNullOrUndefined: isNullOrUndefined,
  isNull: isNull,
  isBoolean: isBoolean,
  isArray: isArray$1,
  inspect: inspect$1,
  deprecate: deprecate,
  format: format$1,
  debuglog: debuglog
};

var util$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  format: format$1,
  deprecate: deprecate,
  debuglog: debuglog,
  inspect: inspect$1,
  isArray: isArray$1,
  isBoolean: isBoolean,
  isNull: isNull,
  isNullOrUndefined: isNullOrUndefined,
  isNumber: isNumber,
  isString: isString$1,
  isSymbol: isSymbol,
  isUndefined: isUndefined,
  isRegExp: isRegExp,
  isObject: isObject,
  isDate: isDate,
  isError: isError,
  isFunction: isFunction$1,
  isPrimitive: isPrimitive,
  isBuffer: isBuffer,
  log: log,
  inherits: inherits$1,
  _extend: _extend,
  'default': util$2
});

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var hasOwn = Object.prototype.hasOwnProperty;

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }

  return keys;
}; // based on node assert, original notice:
var pSlice = Array.prototype.slice;

var _functionsHaveNames;

function functionsHaveNames() {
  if (typeof _functionsHaveNames !== 'undefined') {
    return _functionsHaveNames;
  }

  return _functionsHaveNames = function () {
    return function foo() {}.name === 'foo';
  }();
}

function pToString(obj) {
  return Object.prototype.toString.call(obj);
}

function isView(arrbuf) {
  if (isBuffer$1(arrbuf)) {
    return false;
  }

  if (typeof global$1.ArrayBuffer !== 'function') {
    return false;
  }

  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }

  if (!arrbuf) {
    return false;
  }

  if (arrbuf instanceof DataView) {
    return true;
  }

  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }

  return false;
} // 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.


function assert(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex$2 = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

function getName(func) {
  if (!isFunction$1(func)) {
    return;
  }

  if (functionsHaveNames()) {
    return func.name;
  }

  var str = func.toString();
  var match = str.match(regex$2);
  return match && match[1];
}

assert.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;

  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }

  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();

    if (err.stack) {
      var out = err.stack; // try to strip useless frames

      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);

      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
} // assert.AssertionError instanceof Error

inherits$1(AssertionError, Error);

function truncate$1(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function inspect(something) {
  if (functionsHaveNames() || !isFunction$1(something)) {
    return inspect$1(something);
  }

  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}

function getMessage(self) {
  return truncate$1(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate$1(inspect(self.expected), 128);
} // At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.


function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
} // EXTENSION! allows for well behaved errors defined elsewhere.

assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
assert.ok = ok;
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', equal);
} // 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', notEqual);
  }
} // 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', deepEqual);
  }
}
assert.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
  }
}

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
    return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);

    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

  if (isPrimitive(a) || isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }

  return true;
} // 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);


assert.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
  }
}
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
} // 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', strictEqual);
  }
} // 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', notStrictEqual);
  }
}

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;

  try {
    block();
  } catch (e) {
    error = e;
  }

  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
} // 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);


assert.throws = throws;
function throws(block,
/*optional*/
error,
/*optional*/
message) {
  _throws(true, block, error, message);
} // EXTENSION! This is annoying to write outside this module.

assert.doesNotThrow = doesNotThrow;
function doesNotThrow(block,
/*optional*/
error,
/*optional*/
message) {
  _throws(false, block, error, message);
}
assert.ifError = ifError;
function ifError(err) {
  if (err) throw err;
}

var assert$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': assert,
  AssertionError: AssertionError,
  fail: fail,
  ok: ok,
  assert: ok,
  equal: equal,
  notEqual: notEqual,
  deepEqual: deepEqual,
  deepStrictEqual: deepStrictEqual,
  notDeepEqual: notDeepEqual,
  notDeepStrictEqual: notDeepStrictEqual,
  strictEqual: strictEqual,
  notStrictEqual: notStrictEqual,
  throws: throws,
  doesNotThrow: doesNotThrow,
  ifError: ifError
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function createCommonjsModule$1(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var name$4 = "estraverse";
var description$6 = "ECMAScript JS AST traversal functions";
var homepage$4 = "https://github.com/estools/estraverse";
var main$4 = "estraverse.js";
var version$7 = "4.3.0";
var engines$5 = {
	node: ">=4.0"
};
var maintainers$2 = [
	{
		name: "Yusuke Suzuki",
		email: "utatane.tea@gmail.com",
		web: "http://github.com/Constellation"
	}
];
var repository$5 = {
	type: "git",
	url: "http://github.com/estools/estraverse.git"
};
var devDependencies$5 = {
	"babel-preset-env": "^1.6.1",
	"babel-register": "^6.3.13",
	chai: "^2.1.1",
	espree: "^1.11.0",
	gulp: "^3.8.10",
	"gulp-bump": "^0.2.2",
	"gulp-filter": "^2.0.0",
	"gulp-git": "^1.0.1",
	"gulp-tag-version": "^1.3.0",
	jshint: "^2.5.6",
	mocha: "^2.1.0"
};
var license$4 = "BSD-2-Clause";
var scripts$5 = {
	test: "npm run-script lint && npm run-script unit-test",
	lint: "jshint estraverse.js",
	"unit-test": "mocha --compilers js:babel-register"
};
var require$$0$3 = {
	name: name$4,
	description: description$6,
	homepage: homepage$4,
	main: main$4,
	version: version$7,
	engines: engines$5,
	maintainers: maintainers$2,
	repository: repository$5,
	devDependencies: devDependencies$5,
	license: license$4,
	scripts: scripts$5
};

/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var estraverse$1 = createCommonjsModule$1(function (module, exports) {
/*jslint vars:false, bitwise:true*/

/*jshint indent:4*/

/*global exports:true*/
(function clone(exports) {

  var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;

  function deepCopy(obj) {
    var ret = {},
        key,
        val;

    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        val = obj[key];

        if (typeof val === 'object' && val !== null) {
          ret[key] = deepCopy(val);
        } else {
          ret[key] = val;
        }
      }
    }

    return ret;
  } // based on LLVM libc++ upper_bound / lower_bound
  // MIT License


  function upperBound(array, func) {
    var diff, len, i, current;
    len = array.length;
    i = 0;

    while (len) {
      diff = len >>> 1;
      current = i + diff;

      if (func(array[current])) {
        len = diff;
      } else {
        i = current + 1;
        len -= diff + 1;
      }
    }

    return i;
  }

  Syntax = {
    AssignmentExpression: 'AssignmentExpression',
    AssignmentPattern: 'AssignmentPattern',
    ArrayExpression: 'ArrayExpression',
    ArrayPattern: 'ArrayPattern',
    ArrowFunctionExpression: 'ArrowFunctionExpression',
    AwaitExpression: 'AwaitExpression',
    // CAUTION: It's deferred to ES7.
    BlockStatement: 'BlockStatement',
    BinaryExpression: 'BinaryExpression',
    BreakStatement: 'BreakStatement',
    CallExpression: 'CallExpression',
    CatchClause: 'CatchClause',
    ClassBody: 'ClassBody',
    ClassDeclaration: 'ClassDeclaration',
    ClassExpression: 'ClassExpression',
    ComprehensionBlock: 'ComprehensionBlock',
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: 'ComprehensionExpression',
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: 'ConditionalExpression',
    ContinueStatement: 'ContinueStatement',
    DebuggerStatement: 'DebuggerStatement',
    DirectiveStatement: 'DirectiveStatement',
    DoWhileStatement: 'DoWhileStatement',
    EmptyStatement: 'EmptyStatement',
    ExportAllDeclaration: 'ExportAllDeclaration',
    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
    ExportNamedDeclaration: 'ExportNamedDeclaration',
    ExportSpecifier: 'ExportSpecifier',
    ExpressionStatement: 'ExpressionStatement',
    ForStatement: 'ForStatement',
    ForInStatement: 'ForInStatement',
    ForOfStatement: 'ForOfStatement',
    FunctionDeclaration: 'FunctionDeclaration',
    FunctionExpression: 'FunctionExpression',
    GeneratorExpression: 'GeneratorExpression',
    // CAUTION: It's deferred to ES7.
    Identifier: 'Identifier',
    IfStatement: 'IfStatement',
    ImportExpression: 'ImportExpression',
    ImportDeclaration: 'ImportDeclaration',
    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
    ImportSpecifier: 'ImportSpecifier',
    Literal: 'Literal',
    LabeledStatement: 'LabeledStatement',
    LogicalExpression: 'LogicalExpression',
    MemberExpression: 'MemberExpression',
    MetaProperty: 'MetaProperty',
    MethodDefinition: 'MethodDefinition',
    ModuleSpecifier: 'ModuleSpecifier',
    NewExpression: 'NewExpression',
    ObjectExpression: 'ObjectExpression',
    ObjectPattern: 'ObjectPattern',
    Program: 'Program',
    Property: 'Property',
    RestElement: 'RestElement',
    ReturnStatement: 'ReturnStatement',
    SequenceExpression: 'SequenceExpression',
    SpreadElement: 'SpreadElement',
    Super: 'Super',
    SwitchStatement: 'SwitchStatement',
    SwitchCase: 'SwitchCase',
    TaggedTemplateExpression: 'TaggedTemplateExpression',
    TemplateElement: 'TemplateElement',
    TemplateLiteral: 'TemplateLiteral',
    ThisExpression: 'ThisExpression',
    ThrowStatement: 'ThrowStatement',
    TryStatement: 'TryStatement',
    UnaryExpression: 'UnaryExpression',
    UpdateExpression: 'UpdateExpression',
    VariableDeclaration: 'VariableDeclaration',
    VariableDeclarator: 'VariableDeclarator',
    WhileStatement: 'WhileStatement',
    WithStatement: 'WithStatement',
    YieldExpression: 'YieldExpression'
  };
  VisitorKeys = {
    AssignmentExpression: ['left', 'right'],
    AssignmentPattern: ['left', 'right'],
    ArrayExpression: ['elements'],
    ArrayPattern: ['elements'],
    ArrowFunctionExpression: ['params', 'body'],
    AwaitExpression: ['argument'],
    // CAUTION: It's deferred to ES7.
    BlockStatement: ['body'],
    BinaryExpression: ['left', 'right'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments'],
    CatchClause: ['param', 'body'],
    ClassBody: ['body'],
    ClassDeclaration: ['id', 'superClass', 'body'],
    ClassExpression: ['id', 'superClass', 'body'],
    ComprehensionBlock: ['left', 'right'],
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DirectiveStatement: [],
    DoWhileStatement: ['body', 'test'],
    EmptyStatement: [],
    ExportAllDeclaration: ['source'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
    ExportSpecifier: ['exported', 'local'],
    ExpressionStatement: ['expression'],
    ForStatement: ['init', 'test', 'update', 'body'],
    ForInStatement: ['left', 'right', 'body'],
    ForOfStatement: ['left', 'right', 'body'],
    FunctionDeclaration: ['id', 'params', 'body'],
    FunctionExpression: ['id', 'params', 'body'],
    GeneratorExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    Identifier: [],
    IfStatement: ['test', 'consequent', 'alternate'],
    ImportExpression: ['source'],
    ImportDeclaration: ['specifiers', 'source'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['imported', 'local'],
    Literal: [],
    LabeledStatement: ['label', 'body'],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    MetaProperty: ['meta', 'property'],
    MethodDefinition: ['key', 'value'],
    ModuleSpecifier: [],
    NewExpression: ['callee', 'arguments'],
    ObjectExpression: ['properties'],
    ObjectPattern: ['properties'],
    Program: ['body'],
    Property: ['key', 'value'],
    RestElement: ['argument'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    SpreadElement: ['argument'],
    Super: [],
    SwitchStatement: ['discriminant', 'cases'],
    SwitchCase: ['test', 'consequent'],
    TaggedTemplateExpression: ['tag', 'quasi'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    YieldExpression: ['argument']
  }; // unique id

  BREAK = {};
  SKIP = {};
  REMOVE = {};
  VisitorOption = {
    Break: BREAK,
    Skip: SKIP,
    Remove: REMOVE
  };

  function Reference(parent, key) {
    this.parent = parent;
    this.key = key;
  }

  Reference.prototype.replace = function replace(node) {
    this.parent[this.key] = node;
  };

  Reference.prototype.remove = function remove() {
    if (Array.isArray(this.parent)) {
      this.parent.splice(this.key, 1);
      return true;
    } else {
      this.replace(null);
      return false;
    }
  };

  function Element(node, path, wrap, ref) {
    this.node = node;
    this.path = path;
    this.wrap = wrap;
    this.ref = ref;
  }

  function Controller() {} // API:
  // return property path array from root to current node


  Controller.prototype.path = function path() {
    var i, iz, j, jz, result, element;

    function addToPath(result, path) {
      if (Array.isArray(path)) {
        for (j = 0, jz = path.length; j < jz; ++j) {
          result.push(path[j]);
        }
      } else {
        result.push(path);
      }
    } // root node


    if (!this.__current.path) {
      return null;
    } // first node is sentinel, second node is root element


    result = [];

    for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
      element = this.__leavelist[i];
      addToPath(result, element.path);
    }

    addToPath(result, this.__current.path);
    return result;
  }; // API:
  // return type of current node


  Controller.prototype.type = function () {
    var node = this.current();
    return node.type || this.__current.wrap;
  }; // API:
  // return array of parent elements


  Controller.prototype.parents = function parents() {
    var i, iz, result; // first node is sentinel

    result = [];

    for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
      result.push(this.__leavelist[i].node);
    }

    return result;
  }; // API:
  // return current node


  Controller.prototype.current = function current() {
    return this.__current.node;
  };

  Controller.prototype.__execute = function __execute(callback, element) {
    var previous, result;
    result = undefined;
    previous = this.__current;
    this.__current = element;
    this.__state = null;

    if (callback) {
      result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
    }

    this.__current = previous;
    return result;
  }; // API:
  // notify control skip / break


  Controller.prototype.notify = function notify(flag) {
    this.__state = flag;
  }; // API:
  // skip child nodes of current node


  Controller.prototype.skip = function () {
    this.notify(SKIP);
  }; // API:
  // break traversals


  Controller.prototype['break'] = function () {
    this.notify(BREAK);
  }; // API:
  // remove node


  Controller.prototype.remove = function () {
    this.notify(REMOVE);
  };

  Controller.prototype.__initialize = function (root, visitor) {
    this.visitor = visitor;
    this.root = root;
    this.__worklist = [];
    this.__leavelist = [];
    this.__current = null;
    this.__state = null;
    this.__fallback = null;

    if (visitor.fallback === 'iteration') {
      this.__fallback = Object.keys;
    } else if (typeof visitor.fallback === 'function') {
      this.__fallback = visitor.fallback;
    }

    this.__keys = VisitorKeys;

    if (visitor.keys) {
      this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
    }
  };

  function isNode(node) {
    if (node == null) {
      return false;
    }

    return typeof node === 'object' && typeof node.type === 'string';
  }

  function isProperty(nodeType, key) {
    return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
  }

  Controller.prototype.traverse = function traverse(root, visitor) {
    var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;

    this.__initialize(root, visitor);

    sentinel = {}; // reference

    worklist = this.__worklist;
    leavelist = this.__leavelist; // initialize

    worklist.push(new Element(root, null, null, null));
    leavelist.push(new Element(null, null, null, null));

    while (worklist.length) {
      element = worklist.pop();

      if (element === sentinel) {
        element = leavelist.pop();
        ret = this.__execute(visitor.leave, element);

        if (this.__state === BREAK || ret === BREAK) {
          return;
        }

        continue;
      }

      if (element.node) {
        ret = this.__execute(visitor.enter, element);

        if (this.__state === BREAK || ret === BREAK) {
          return;
        }

        worklist.push(sentinel);
        leavelist.push(element);

        if (this.__state === SKIP || ret === SKIP) {
          continue;
        }

        node = element.node;
        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];

        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error('Unknown node type ' + nodeType + '.');
          }
        }

        current = candidates.length;

        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];

          if (!candidate) {
            continue;
          }

          if (Array.isArray(candidate)) {
            current2 = candidate.length;

            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }

              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], 'Property', null);
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, null);
              } else {
                continue;
              }

              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element(candidate, key, null, null));
          }
        }
      }
    }
  };

  Controller.prototype.replace = function replace(root, visitor) {
    var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;

    function removeElem(element) {
      var i, key, nextElem, parent;

      if (element.ref.remove()) {
        // When the reference is an element of an array.
        key = element.ref.key;
        parent = element.ref.parent; // If removed from array, then decrease following items' keys.

        i = worklist.length;

        while (i--) {
          nextElem = worklist[i];

          if (nextElem.ref && nextElem.ref.parent === parent) {
            if (nextElem.ref.key < key) {
              break;
            }

            --nextElem.ref.key;
          }
        }
      }
    }

    this.__initialize(root, visitor);

    sentinel = {}; // reference

    worklist = this.__worklist;
    leavelist = this.__leavelist; // initialize

    outer = {
      root: root
    };
    element = new Element(root, null, null, new Reference(outer, 'root'));
    worklist.push(element);
    leavelist.push(element);

    while (worklist.length) {
      element = worklist.pop();

      if (element === sentinel) {
        element = leavelist.pop();
        target = this.__execute(visitor.leave, element); // node may be replaced with null,
        // so distinguish between undefined and null in this place

        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
          // replace
          element.ref.replace(target);
        }

        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
        }

        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }

        continue;
      }

      target = this.__execute(visitor.enter, element); // node may be replaced with null,
      // so distinguish between undefined and null in this place

      if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
        // replace
        element.ref.replace(target);
        element.node = target;
      }

      if (this.__state === REMOVE || target === REMOVE) {
        removeElem(element);
        element.node = null;
      }

      if (this.__state === BREAK || target === BREAK) {
        return outer.root;
      } // node may be null


      node = element.node;

      if (!node) {
        continue;
      }

      worklist.push(sentinel);
      leavelist.push(element);

      if (this.__state === SKIP || target === SKIP) {
        continue;
      }

      nodeType = node.type || element.wrap;
      candidates = this.__keys[nodeType];

      if (!candidates) {
        if (this.__fallback) {
          candidates = this.__fallback(node);
        } else {
          throw new Error('Unknown node type ' + nodeType + '.');
        }
      }

      current = candidates.length;

      while ((current -= 1) >= 0) {
        key = candidates[current];
        candidate = node[key];

        if (!candidate) {
          continue;
        }

        if (Array.isArray(candidate)) {
          current2 = candidate.length;

          while ((current2 -= 1) >= 0) {
            if (!candidate[current2]) {
              continue;
            }

            if (isProperty(nodeType, candidates[current])) {
              element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
            } else if (isNode(candidate[current2])) {
              element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
            } else {
              continue;
            }

            worklist.push(element);
          }
        } else if (isNode(candidate)) {
          worklist.push(new Element(candidate, key, null, new Reference(node, key)));
        }
      }
    }

    return outer.root;
  };

  function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
  }

  function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
  }

  function extendCommentRange(comment, tokens) {
    var target;
    target = upperBound(tokens, function search(token) {
      return token.range[0] > comment.range[0];
    });
    comment.extendedRange = [comment.range[0], comment.range[1]];

    if (target !== tokens.length) {
      comment.extendedRange[1] = tokens[target].range[0];
    }

    target -= 1;

    if (target >= 0) {
      comment.extendedRange[0] = tokens[target].range[1];
    }

    return comment;
  }

  function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [],
        comment,
        len,
        i,
        cursor;

    if (!tree.range) {
      throw new Error('attachComments needs range information');
    } // tokens array is empty, we attach comments to tree as 'leadingComments'


    if (!tokens.length) {
      if (providedComments.length) {
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comment = deepCopy(providedComments[i]);
          comment.extendedRange = [0, tree.range[0]];
          comments.push(comment);
        }

        tree.leadingComments = comments;
      }

      return tree;
    }

    for (i = 0, len = providedComments.length; i < len; i += 1) {
      comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    } // This is based on John Freeman's implementation.


    cursor = 0;
    traverse(tree, {
      enter: function (node) {
        var comment;

        while (cursor < comments.length) {
          comment = comments[cursor];

          if (comment.extendedRange[1] > node.range[0]) {
            break;
          }

          if (comment.extendedRange[1] === node.range[0]) {
            if (!node.leadingComments) {
              node.leadingComments = [];
            }

            node.leadingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        } // already out of owned node


        if (cursor === comments.length) {
          return VisitorOption.Break;
        }

        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    cursor = 0;
    traverse(tree, {
      leave: function (node) {
        var comment;

        while (cursor < comments.length) {
          comment = comments[cursor];

          if (node.range[1] < comment.extendedRange[0]) {
            break;
          }

          if (node.range[1] === comment.extendedRange[0]) {
            if (!node.trailingComments) {
              node.trailingComments = [];
            }

            node.trailingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        } // already out of owned node


        if (cursor === comments.length) {
          return VisitorOption.Break;
        }

        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    return tree;
  }

  exports.version = require$$0$3.version;
  exports.Syntax = Syntax;
  exports.traverse = traverse;
  exports.replace = replace;
  exports.attachComments = attachComments;
  exports.VisitorKeys = VisitorKeys;
  exports.VisitorOption = VisitorOption;
  exports.Controller = Controller;

  exports.cloneEnvironment = function () {
    return clone({});
  };

  return exports;
})(exports);
/* vim: set sw=4 ts=4 et tw=80 : */
});

/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

const READ$1 = 0x1;
const WRITE = 0x2;
const RW = READ$1 | WRITE;
/**
 * A Reference represents a single occurrence of an identifier in code.
 * @class Reference
 */

class Reference {
  constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
    /**
     * Identifier syntax node.
     * @member {espreeIdentifier} Reference#identifier
     */
    this.identifier = ident;
    /**
     * Reference to the enclosing Scope.
     * @member {Scope} Reference#from
     */

    this.from = scope;
    /**
     * Whether the reference comes from a dynamic scope (such as 'eval',
     * 'with', etc.), and may be trapped by dynamic scopes.
     * @member {boolean} Reference#tainted
     */

    this.tainted = false;
    /**
     * The variable this reference is resolved with.
     * @member {Variable} Reference#resolved
     */

    this.resolved = null;
    /**
     * The read-write mode of the reference. (Value is one of {@link
     * Reference.READ}, {@link Reference.RW}, {@link Reference.WRITE}).
     * @member {number} Reference#flag
     * @private
     */

    this.flag = flag;

    if (this.isWrite()) {
      /**
       * If reference is writeable, this is the tree being written to it.
       * @member {espreeNode} Reference#writeExpr
       */
      this.writeExpr = writeExpr;
      /**
       * Whether the Reference might refer to a partial value of writeExpr.
       * @member {boolean} Reference#partial
       */

      this.partial = partial;
      /**
       * Whether the Reference is to write of initialization.
       * @member {boolean} Reference#init
       */

      this.init = init;
    }

    this.__maybeImplicitGlobal = maybeImplicitGlobal;
  }
  /**
   * Whether the reference is static.
   * @method Reference#isStatic
   * @returns {boolean} static
   */


  isStatic() {
    return !this.tainted && this.resolved && this.resolved.scope.isStatic();
  }
  /**
   * Whether the reference is writeable.
   * @method Reference#isWrite
   * @returns {boolean} write
   */


  isWrite() {
    return !!(this.flag & Reference.WRITE);
  }
  /**
   * Whether the reference is readable.
   * @method Reference#isRead
   * @returns {boolean} read
   */


  isRead() {
    return !!(this.flag & Reference.READ);
  }
  /**
   * Whether the reference is read-only.
   * @method Reference#isReadOnly
   * @returns {boolean} read only
   */


  isReadOnly() {
    return this.flag === Reference.READ;
  }
  /**
   * Whether the reference is write-only.
   * @method Reference#isWriteOnly
   * @returns {boolean} write only
   */


  isWriteOnly() {
    return this.flag === Reference.WRITE;
  }
  /**
   * Whether the reference is read-write.
   * @method Reference#isReadWrite
   * @returns {boolean} read write
   */


  isReadWrite() {
    return this.flag === Reference.RW;
  }

}
/**
 * @constant Reference.READ
 * @private
 */


Reference.READ = READ$1;
/**
 * @constant Reference.WRITE
 * @private
 */

Reference.WRITE = WRITE;
/**
 * @constant Reference.RW
 * @private
 */

Reference.RW = RW;
var reference = Reference;

/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * A Variable represents a locally scoped identifier. These include arguments to
 * functions.
 * @class Variable
 */

class Variable {
  constructor(name, scope) {
    /**
     * The variable name, as given in the source code.
     * @member {String} Variable#name
     */
    this.name = name;
    /**
     * List of defining occurrences of this variable (like in 'var ...'
     * statements or as parameter), as AST nodes.
     * @member {espree.Identifier[]} Variable#identifiers
     */

    this.identifiers = [];
    /**
     * List of {@link Reference|references} of this variable (excluding parameter entries)
     * in its defining scope and all nested scopes. For defining
     * occurrences only see {@link Variable#defs}.
     * @member {Reference[]} Variable#references
     */

    this.references = [];
    /**
     * List of defining occurrences of this variable (like in 'var ...'
     * statements or as parameter), as custom objects.
     * @member {Definition[]} Variable#defs
     */

    this.defs = [];
    this.tainted = false;
    /**
     * Whether this is a stack variable.
     * @member {boolean} Variable#stack
     */

    this.stack = true;
    /**
     * Reference to the enclosing Scope.
     * @member {Scope} Variable#scope
     */

    this.scope = scope;
  }

}

Variable.CatchClause = "CatchClause";
Variable.Parameter = "Parameter";
Variable.FunctionName = "FunctionName";
Variable.ClassName = "ClassName";
Variable.Variable = "Variable";
Variable.ImportBinding = "ImportBinding";
Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";
var variable = Variable;

/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/**
 * @class Definition
 */


class Definition$2 {
  constructor(type, name, node, parent, index, kind) {
    /**
     * @member {String} Definition#type - type of the occurrence (e.g. "Parameter", "Variable", ...).
     */
    this.type = type;
    /**
     * @member {espree.Identifier} Definition#name - the identifier AST node of the occurrence.
     */

    this.name = name;
    /**
     * @member {espree.Node} Definition#node - the enclosing node of the identifier.
     */

    this.node = node;
    /**
     * @member {espree.Node?} Definition#parent - the enclosing statement node of the identifier.
     */

    this.parent = parent;
    /**
     * @member {Number?} Definition#index - the index in the declaration statement.
     */

    this.index = index;
    /**
     * @member {String?} Definition#kind - the kind of the declaration statement.
     */

    this.kind = kind;
  }

}
/**
 * @class ParameterDefinition
 */


class ParameterDefinition$1 extends Definition$2 {
  constructor(name, node, index, rest) {
    super(variable.Parameter, name, node, null, index, null);
    /**
     * Whether the parameter definition is a part of a rest parameter.
     * @member {boolean} ParameterDefinition#rest
     */

    this.rest = rest;
  }

}

var definition = {
  ParameterDefinition: ParameterDefinition$1,
  Definition: Definition$2
};

var require$$1$4 = /*@__PURE__*/getAugmentedNamespace(assert$1);

/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* eslint-disable no-underscore-dangle */

/* eslint-disable no-undefined */

const Syntax$3 = estraverse$1.Syntax;





const Definition$1 = definition.Definition;


/**
 * Test if scope is struct
 * @param {Scope} scope - scope
 * @param {Block} block - block
 * @param {boolean} isMethodDefinition - is method definition
 * @param {boolean} useDirective - use directive
 * @returns {boolean} is strict scope
 */


function isStrictScope(scope, block, isMethodDefinition, useDirective) {
  let body; // When upper scope is exists and strict, inner scope is also strict.

  if (scope.upper && scope.upper.isStrict) {
    return true;
  }

  if (isMethodDefinition) {
    return true;
  }

  if (scope.type === "class" || scope.type === "module") {
    return true;
  }

  if (scope.type === "block" || scope.type === "switch") {
    return false;
  }

  if (scope.type === "function") {
    if (block.type === Syntax$3.ArrowFunctionExpression && block.body.type !== Syntax$3.BlockStatement) {
      return false;
    }

    if (block.type === Syntax$3.Program) {
      body = block;
    } else {
      body = block.body;
    }

    if (!body) {
      return false;
    }
  } else if (scope.type === "global") {
    body = block;
  } else {
    return false;
  } // Search 'use strict' directive.


  if (useDirective) {
    for (let i = 0, iz = body.body.length; i < iz; ++i) {
      const stmt = body.body[i];

      if (stmt.type !== Syntax$3.DirectiveStatement) {
        break;
      }

      if (stmt.raw === "\"use strict\"" || stmt.raw === "'use strict'") {
        return true;
      }
    }
  } else {
    for (let i = 0, iz = body.body.length; i < iz; ++i) {
      const stmt = body.body[i];

      if (stmt.type !== Syntax$3.ExpressionStatement) {
        break;
      }

      const expr = stmt.expression;

      if (expr.type !== Syntax$3.Literal || typeof expr.value !== "string") {
        break;
      }

      if (expr.raw !== null && expr.raw !== undefined) {
        if (expr.raw === "\"use strict\"" || expr.raw === "'use strict'") {
          return true;
        }
      } else {
        if (expr.value === "use strict") {
          return true;
        }
      }
    }
  }

  return false;
}
/**
 * Register scope
 * @param {ScopeManager} scopeManager - scope manager
 * @param {Scope} scope - scope
 * @returns {void}
 */


function registerScope(scopeManager, scope) {
  scopeManager.scopes.push(scope);

  const scopes = scopeManager.__nodeToScope.get(scope.block);

  if (scopes) {
    scopes.push(scope);
  } else {
    scopeManager.__nodeToScope.set(scope.block, [scope]);
  }
}
/**
 * Should be statically
 * @param {Object} def - def
 * @returns {boolean} should be statically
 */


function shouldBeStatically(def) {
  return def.type === variable.ClassName || def.type === variable.Variable && def.parent.kind !== "var";
}
/**
 * @class Scope
 */


class Scope$2 {
  constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
    /**
     * One of 'module', 'block', 'switch', 'function', 'catch', 'with', 'function', 'class', 'global'.
     * @member {String} Scope#type
     */
    this.type = type;
    /**
     * The scoped {@link Variable}s of this scope, as <code>{ Variable.name
     * : Variable }</code>.
     * @member {Map} Scope#set
     */

    this.set = new Map();
    /**
     * The tainted variables of this scope, as <code>{ Variable.name :
     * boolean }</code>.
     * @member {Map} Scope#taints */

    this.taints = new Map();
    /**
     * Generally, through the lexical scoping of JS you can always know
     * which variable an identifier in the source code refers to. There are
     * a few exceptions to this rule. With 'global' and 'with' scopes you
     * can only decide at runtime which variable a reference refers to.
     * Moreover, if 'eval()' is used in a scope, it might introduce new
     * bindings in this or its parent scopes.
     * All those scopes are considered 'dynamic'.
     * @member {boolean} Scope#dynamic
     */

    this.dynamic = this.type === "global" || this.type === "with";
    /**
     * A reference to the scope-defining syntax node.
     * @member {espree.Node} Scope#block
     */

    this.block = block;
    /**
     * The {@link Reference|references} that are not resolved with this scope.
     * @member {Reference[]} Scope#through
     */

    this.through = [];
    /**
     * The scoped {@link Variable}s of this scope. In the case of a
     * 'function' scope this includes the automatic argument <em>arguments</em> as
     * its first element, as well as all further formal arguments.
     * @member {Variable[]} Scope#variables
     */

    this.variables = [];
    /**
     * Any variable {@link Reference|reference} found in this scope. This
     * includes occurrences of local variables as well as variables from
     * parent scopes (including the global scope). For local variables
     * this also includes defining occurrences (like in a 'var' statement).
     * In a 'function' scope this does not include the occurrences of the
     * formal parameter in the parameter list.
     * @member {Reference[]} Scope#references
     */

    this.references = [];
    /**
     * For 'global' and 'function' scopes, this is a self-reference. For
     * other scope types this is the <em>variableScope</em> value of the
     * parent scope.
     * @member {Scope} Scope#variableScope
     */

    this.variableScope = this.type === "global" || this.type === "function" || this.type === "module" ? this : upperScope.variableScope;
    /**
     * Whether this scope is created by a FunctionExpression.
     * @member {boolean} Scope#functionExpressionScope
     */

    this.functionExpressionScope = false;
    /**
     * Whether this is a scope that contains an 'eval()' invocation.
     * @member {boolean} Scope#directCallToEvalScope
     */

    this.directCallToEvalScope = false;
    /**
     * @member {boolean} Scope#thisFound
     */

    this.thisFound = false;
    this.__left = [];
    /**
     * Reference to the parent {@link Scope|scope}.
     * @member {Scope} Scope#upper
     */

    this.upper = upperScope;
    /**
     * Whether 'use strict' is in effect in this scope.
     * @member {boolean} Scope#isStrict
     */

    this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());
    /**
     * List of nested {@link Scope}s.
     * @member {Scope[]} Scope#childScopes
     */

    this.childScopes = [];

    if (this.upper) {
      this.upper.childScopes.push(this);
    }

    this.__declaredVariables = scopeManager.__declaredVariables;
    registerScope(scopeManager, this);
  }

  __shouldStaticallyClose(scopeManager) {
    return !this.dynamic || scopeManager.__isOptimistic();
  }

  __shouldStaticallyCloseForGlobal(ref) {
    // On global scope, let/const/class declarations should be resolved statically.
    const name = ref.identifier.name;

    if (!this.set.has(name)) {
      return false;
    }

    const variable = this.set.get(name);
    const defs = variable.defs;
    return defs.length > 0 && defs.every(shouldBeStatically);
  }

  __staticCloseRef(ref) {
    if (!this.__resolve(ref)) {
      this.__delegateToUpperScope(ref);
    }
  }

  __dynamicCloseRef(ref) {
    // notify all names are through to global
    let current = this;

    do {
      current.through.push(ref);
      current = current.upper;
    } while (current);
  }

  __globalCloseRef(ref) {
    // let/const/class declarations should be resolved statically.
    // others should be resolved dynamically.
    if (this.__shouldStaticallyCloseForGlobal(ref)) {
      this.__staticCloseRef(ref);
    } else {
      this.__dynamicCloseRef(ref);
    }
  }

  __close(scopeManager) {
    let closeRef;

    if (this.__shouldStaticallyClose(scopeManager)) {
      closeRef = this.__staticCloseRef;
    } else if (this.type !== "global") {
      closeRef = this.__dynamicCloseRef;
    } else {
      closeRef = this.__globalCloseRef;
    } // Try Resolving all references in this scope.


    for (let i = 0, iz = this.__left.length; i < iz; ++i) {
      const ref = this.__left[i];
      closeRef.call(this, ref);
    }

    this.__left = null;
    return this.upper;
  } // To override by function scopes.
  // References in default parameters isn't resolved to variables which are in their function body.


  __isValidResolution(ref, variable) {
    // eslint-disable-line class-methods-use-this, no-unused-vars
    return true;
  }

  __resolve(ref) {
    const name = ref.identifier.name;

    if (!this.set.has(name)) {
      return false;
    }

    const variable = this.set.get(name);

    if (!this.__isValidResolution(ref, variable)) {
      return false;
    }

    variable.references.push(ref);
    variable.stack = variable.stack && ref.from.variableScope === this.variableScope;

    if (ref.tainted) {
      variable.tainted = true;
      this.taints.set(variable.name, true);
    }

    ref.resolved = variable;
    return true;
  }

  __delegateToUpperScope(ref) {
    if (this.upper) {
      this.upper.__left.push(ref);
    }

    this.through.push(ref);
  }

  __addDeclaredVariablesOfNode(variable, node) {
    if (node === null || node === undefined) {
      return;
    }

    let variables = this.__declaredVariables.get(node);

    if (variables === null || variables === undefined) {
      variables = [];

      this.__declaredVariables.set(node, variables);
    }

    if (variables.indexOf(variable) === -1) {
      variables.push(variable);
    }
  }

  __defineGeneric(name, set, variables, node, def) {
    let variable$1;
    variable$1 = set.get(name);

    if (!variable$1) {
      variable$1 = new variable(name, this);
      set.set(name, variable$1);
      variables.push(variable$1);
    }

    if (def) {
      variable$1.defs.push(def);

      this.__addDeclaredVariablesOfNode(variable$1, def.node);

      this.__addDeclaredVariablesOfNode(variable$1, def.parent);
    }

    if (node) {
      variable$1.identifiers.push(node);
    }
  }

  __define(node, def) {
    if (node && node.type === Syntax$3.Identifier) {
      this.__defineGeneric(node.name, this.set, this.variables, node, def);
    }
  }

  __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
    // because Array element may be null
    if (!node || node.type !== Syntax$3.Identifier) {
      return;
    } // Specially handle like `this`.


    if (node.name === "super") {
      return;
    }

    const ref = new reference(node, this, assign || reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
    this.references.push(ref);

    this.__left.push(ref);
  }

  __detectEval() {
    let current = this;
    this.directCallToEvalScope = true;

    do {
      current.dynamic = true;
      current = current.upper;
    } while (current);
  }

  __detectThis() {
    this.thisFound = true;
  }

  __isClosed() {
    return this.__left === null;
  }
  /**
   * returns resolved {Reference}
   * @method Scope#resolve
   * @param {Espree.Identifier} ident - identifier to be resolved.
   * @returns {Reference} reference
   */


  resolve(ident) {
    let ref, i, iz;
    require$$1$4(this.__isClosed(), "Scope should be closed.");
    require$$1$4(ident.type === Syntax$3.Identifier, "Target should be identifier.");

    for (i = 0, iz = this.references.length; i < iz; ++i) {
      ref = this.references[i];

      if (ref.identifier === ident) {
        return ref;
      }
    }

    return null;
  }
  /**
   * returns this scope is static
   * @method Scope#isStatic
   * @returns {boolean} static
   */


  isStatic() {
    return !this.dynamic;
  }
  /**
   * returns this scope has materialized arguments
   * @method Scope#isArgumentsMaterialized
   * @returns {boolean} arguemnts materialized
   */


  isArgumentsMaterialized() {
    // eslint-disable-line class-methods-use-this
    return true;
  }
  /**
   * returns this scope has materialized `this` reference
   * @method Scope#isThisMaterialized
   * @returns {boolean} this materialized
   */


  isThisMaterialized() {
    // eslint-disable-line class-methods-use-this
    return true;
  }

  isUsedName(name) {
    if (this.set.has(name)) {
      return true;
    }

    for (let i = 0, iz = this.through.length; i < iz; ++i) {
      if (this.through[i].identifier.name === name) {
        return true;
      }
    }

    return false;
  }

}

class GlobalScope$1 extends Scope$2 {
  constructor(scopeManager, block) {
    super(scopeManager, "global", null, block, false);
    this.implicit = {
      set: new Map(),
      variables: [],

      /**
      * List of {@link Reference}s that are left to be resolved (i.e. which
      * need to be linked to the variable they refer to).
      * @member {Reference[]} Scope#implicit#left
      */
      left: []
    };
  }

  __close(scopeManager) {
    const implicit = [];

    for (let i = 0, iz = this.__left.length; i < iz; ++i) {
      const ref = this.__left[i];

      if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
        implicit.push(ref.__maybeImplicitGlobal);
      }
    } // create an implicit global variable from assignment expression


    for (let i = 0, iz = implicit.length; i < iz; ++i) {
      const info = implicit[i];

      this.__defineImplicit(info.pattern, new Definition$1(variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
    }

    this.implicit.left = this.__left;
    return super.__close(scopeManager);
  }

  __defineImplicit(node, def) {
    if (node && node.type === Syntax$3.Identifier) {
      this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
    }
  }

}

class ModuleScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "module", upperScope, block, false);
  }

}

class FunctionExpressionNameScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "function-expression-name", upperScope, block, false);

    this.__define(block.id, new Definition$1(variable.FunctionName, block.id, block, null, null, null));

    this.functionExpressionScope = true;
  }

}

class CatchScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "catch", upperScope, block, false);
  }

}

class WithScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "with", upperScope, block, false);
  }

  __close(scopeManager) {
    if (this.__shouldStaticallyClose(scopeManager)) {
      return super.__close(scopeManager);
    }

    for (let i = 0, iz = this.__left.length; i < iz; ++i) {
      const ref = this.__left[i];
      ref.tainted = true;

      this.__delegateToUpperScope(ref);
    }

    this.__left = null;
    return this.upper;
  }

}

class BlockScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "block", upperScope, block, false);
  }

}

class SwitchScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "switch", upperScope, block, false);
  }

}

class FunctionScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block, isMethodDefinition) {
    super(scopeManager, "function", upperScope, block, isMethodDefinition); // section 9.2.13, FunctionDeclarationInstantiation.
    // NOTE Arrow functions never have an arguments objects.

    if (this.block.type !== Syntax$3.ArrowFunctionExpression) {
      this.__defineArguments();
    }
  }

  isArgumentsMaterialized() {
    // TODO(Constellation)
    // We can more aggressive on this condition like this.
    //
    // function t() {
    //     // arguments of t is always hidden.
    //     function arguments() {
    //     }
    // }
    if (this.block.type === Syntax$3.ArrowFunctionExpression) {
      return false;
    }

    if (!this.isStatic()) {
      return true;
    }

    const variable = this.set.get("arguments");
    require$$1$4(variable, "Always have arguments variable.");
    return variable.tainted || variable.references.length !== 0;
  }

  isThisMaterialized() {
    if (!this.isStatic()) {
      return true;
    }

    return this.thisFound;
  }

  __defineArguments() {
    this.__defineGeneric("arguments", this.set, this.variables, null, null);

    this.taints.set("arguments", true);
  } // References in default parameters isn't resolved to variables which are in their function body.
  //     const x = 1
  //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.
  //         const x = 2
  //         console.log(a)
  //     }


  __isValidResolution(ref, variable) {
    // If `options.nodejsScope` is true, `this.block` becomes a Program node.
    if (this.block.type === "Program") {
      return true;
    }

    const bodyStart = this.block.body.range[0]; // It's invalid resolution in the following case:

    return !(variable.scope === this && ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.
    variable.defs.every(d => d.name.range[0] >= bodyStart) // the variable is in the body.
    );
  }

}

class ForScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "for", upperScope, block, false);
  }

}

class ClassScope$1 extends Scope$2 {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "class", upperScope, block, false);
  }

}

var scope = {
  Scope: Scope$2,
  GlobalScope: GlobalScope$1,
  ModuleScope: ModuleScope$1,
  FunctionExpressionNameScope: FunctionExpressionNameScope$1,
  CatchScope: CatchScope$1,
  WithScope: WithScope$1,
  BlockScope: BlockScope$1,
  SwitchScope: SwitchScope$1,
  FunctionScope: FunctionScope$1,
  ForScope: ForScope$1,
  ClassScope: ClassScope$1
};

/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* eslint-disable no-underscore-dangle */





const GlobalScope = scope.GlobalScope;
const CatchScope = scope.CatchScope;
const WithScope = scope.WithScope;
const ModuleScope = scope.ModuleScope;
const ClassScope = scope.ClassScope;
const SwitchScope = scope.SwitchScope;
const FunctionScope = scope.FunctionScope;
const ForScope = scope.ForScope;
const FunctionExpressionNameScope = scope.FunctionExpressionNameScope;
const BlockScope = scope.BlockScope;
/**
 * @class ScopeManager
 */

class ScopeManager {
  constructor(options) {
    this.scopes = [];
    this.globalScope = null;
    this.__nodeToScope = new WeakMap();
    this.__currentScope = null;
    this.__options = options;
    this.__declaredVariables = new WeakMap();
  }

  __useDirective() {
    return this.__options.directive;
  }

  __isOptimistic() {
    return this.__options.optimistic;
  }

  __ignoreEval() {
    return this.__options.ignoreEval;
  }

  __isNodejsScope() {
    return this.__options.nodejsScope;
  }

  isModule() {
    return this.__options.sourceType === "module";
  }

  isImpliedStrict() {
    return this.__options.impliedStrict;
  }

  isStrictModeSupported() {
    return this.__options.ecmaVersion >= 5;
  } // Returns appropriate scope for this node.


  __get(node) {
    return this.__nodeToScope.get(node);
  }
  /**
   * Get variables that are declared by the node.
   *
   * "are declared by the node" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.
   * If the node declares nothing, this method returns an empty array.
   * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.
   *
   * @param {Espree.Node} node - a node to get.
   * @returns {Variable[]} variables that declared by the node.
   */


  getDeclaredVariables(node) {
    return this.__declaredVariables.get(node) || [];
  }
  /**
   * acquire scope from node.
   * @method ScopeManager#acquire
   * @param {Espree.Node} node - node for the acquired scope.
   * @param {boolean=} inner - look up the most inner scope, default value is false.
   * @returns {Scope?} Scope from node
   */


  acquire(node, inner) {
    /**
     * predicate
     * @param {Scope} testScope - scope to test
     * @returns {boolean} predicate
     */
    function predicate(testScope) {
      if (testScope.type === "function" && testScope.functionExpressionScope) {
        return false;
      }

      return true;
    }

    const scopes = this.__get(node);

    if (!scopes || scopes.length === 0) {
      return null;
    } // Heuristic selection from all scopes.
    // If you would like to get all scopes, please use ScopeManager#acquireAll.


    if (scopes.length === 1) {
      return scopes[0];
    }

    if (inner) {
      for (let i = scopes.length - 1; i >= 0; --i) {
        const scope = scopes[i];

        if (predicate(scope)) {
          return scope;
        }
      }
    } else {
      for (let i = 0, iz = scopes.length; i < iz; ++i) {
        const scope = scopes[i];

        if (predicate(scope)) {
          return scope;
        }
      }
    }

    return null;
  }
  /**
   * acquire all scopes from node.
   * @method ScopeManager#acquireAll
   * @param {Espree.Node} node - node for the acquired scope.
   * @returns {Scopes?} Scope array
   */


  acquireAll(node) {
    return this.__get(node);
  }
  /**
   * release the node.
   * @method ScopeManager#release
   * @param {Espree.Node} node - releasing node.
   * @param {boolean=} inner - look up the most inner scope, default value is false.
   * @returns {Scope?} upper scope for the node.
   */


  release(node, inner) {
    const scopes = this.__get(node);

    if (scopes && scopes.length) {
      const scope = scopes[0].upper;

      if (!scope) {
        return null;
      }

      return this.acquire(scope.block, inner);
    }

    return null;
  }

  attach() {} // eslint-disable-line class-methods-use-this


  detach() {} // eslint-disable-line class-methods-use-this


  __nestScope(scope) {
    if (scope instanceof GlobalScope) {
      require$$1$4(this.__currentScope === null);
      this.globalScope = scope;
    }

    this.__currentScope = scope;
    return scope;
  }

  __nestGlobalScope(node) {
    return this.__nestScope(new GlobalScope(this, node));
  }

  __nestBlockScope(node) {
    return this.__nestScope(new BlockScope(this, this.__currentScope, node));
  }

  __nestFunctionScope(node, isMethodDefinition) {
    return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
  }

  __nestForScope(node) {
    return this.__nestScope(new ForScope(this, this.__currentScope, node));
  }

  __nestCatchScope(node) {
    return this.__nestScope(new CatchScope(this, this.__currentScope, node));
  }

  __nestWithScope(node) {
    return this.__nestScope(new WithScope(this, this.__currentScope, node));
  }

  __nestClassScope(node) {
    return this.__nestScope(new ClassScope(this, this.__currentScope, node));
  }

  __nestSwitchScope(node) {
    return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
  }

  __nestModuleScope(node) {
    return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
  }

  __nestFunctionExpressionNameScope(node) {
    return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
  }

  __isES6() {
    return this.__options.ecmaVersion >= 6;
  }

}

var scopeManager = ScopeManager;

/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var estraverse = createCommonjsModule$1(function (module, exports) {
/*jslint vars:false, bitwise:true*/

/*jshint indent:4*/

/*global exports:true*/
(function clone(exports) {

  var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;

  function deepCopy(obj) {
    var ret = {},
        key,
        val;

    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        val = obj[key];

        if (typeof val === 'object' && val !== null) {
          ret[key] = deepCopy(val);
        } else {
          ret[key] = val;
        }
      }
    }

    return ret;
  } // based on LLVM libc++ upper_bound / lower_bound
  // MIT License


  function upperBound(array, func) {
    var diff, len, i, current;
    len = array.length;
    i = 0;

    while (len) {
      diff = len >>> 1;
      current = i + diff;

      if (func(array[current])) {
        len = diff;
      } else {
        i = current + 1;
        len -= diff + 1;
      }
    }

    return i;
  }

  Syntax = {
    AssignmentExpression: 'AssignmentExpression',
    AssignmentPattern: 'AssignmentPattern',
    ArrayExpression: 'ArrayExpression',
    ArrayPattern: 'ArrayPattern',
    ArrowFunctionExpression: 'ArrowFunctionExpression',
    AwaitExpression: 'AwaitExpression',
    // CAUTION: It's deferred to ES7.
    BlockStatement: 'BlockStatement',
    BinaryExpression: 'BinaryExpression',
    BreakStatement: 'BreakStatement',
    CallExpression: 'CallExpression',
    CatchClause: 'CatchClause',
    ChainExpression: 'ChainExpression',
    ClassBody: 'ClassBody',
    ClassDeclaration: 'ClassDeclaration',
    ClassExpression: 'ClassExpression',
    ComprehensionBlock: 'ComprehensionBlock',
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: 'ComprehensionExpression',
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: 'ConditionalExpression',
    ContinueStatement: 'ContinueStatement',
    DebuggerStatement: 'DebuggerStatement',
    DirectiveStatement: 'DirectiveStatement',
    DoWhileStatement: 'DoWhileStatement',
    EmptyStatement: 'EmptyStatement',
    ExportAllDeclaration: 'ExportAllDeclaration',
    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
    ExportNamedDeclaration: 'ExportNamedDeclaration',
    ExportSpecifier: 'ExportSpecifier',
    ExpressionStatement: 'ExpressionStatement',
    ForStatement: 'ForStatement',
    ForInStatement: 'ForInStatement',
    ForOfStatement: 'ForOfStatement',
    FunctionDeclaration: 'FunctionDeclaration',
    FunctionExpression: 'FunctionExpression',
    GeneratorExpression: 'GeneratorExpression',
    // CAUTION: It's deferred to ES7.
    Identifier: 'Identifier',
    IfStatement: 'IfStatement',
    ImportExpression: 'ImportExpression',
    ImportDeclaration: 'ImportDeclaration',
    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
    ImportSpecifier: 'ImportSpecifier',
    Literal: 'Literal',
    LabeledStatement: 'LabeledStatement',
    LogicalExpression: 'LogicalExpression',
    MemberExpression: 'MemberExpression',
    MetaProperty: 'MetaProperty',
    MethodDefinition: 'MethodDefinition',
    ModuleSpecifier: 'ModuleSpecifier',
    NewExpression: 'NewExpression',
    ObjectExpression: 'ObjectExpression',
    ObjectPattern: 'ObjectPattern',
    Program: 'Program',
    Property: 'Property',
    RestElement: 'RestElement',
    ReturnStatement: 'ReturnStatement',
    SequenceExpression: 'SequenceExpression',
    SpreadElement: 'SpreadElement',
    Super: 'Super',
    SwitchStatement: 'SwitchStatement',
    SwitchCase: 'SwitchCase',
    TaggedTemplateExpression: 'TaggedTemplateExpression',
    TemplateElement: 'TemplateElement',
    TemplateLiteral: 'TemplateLiteral',
    ThisExpression: 'ThisExpression',
    ThrowStatement: 'ThrowStatement',
    TryStatement: 'TryStatement',
    UnaryExpression: 'UnaryExpression',
    UpdateExpression: 'UpdateExpression',
    VariableDeclaration: 'VariableDeclaration',
    VariableDeclarator: 'VariableDeclarator',
    WhileStatement: 'WhileStatement',
    WithStatement: 'WithStatement',
    YieldExpression: 'YieldExpression'
  };
  VisitorKeys = {
    AssignmentExpression: ['left', 'right'],
    AssignmentPattern: ['left', 'right'],
    ArrayExpression: ['elements'],
    ArrayPattern: ['elements'],
    ArrowFunctionExpression: ['params', 'body'],
    AwaitExpression: ['argument'],
    // CAUTION: It's deferred to ES7.
    BlockStatement: ['body'],
    BinaryExpression: ['left', 'right'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments'],
    CatchClause: ['param', 'body'],
    ChainExpression: ['expression'],
    ClassBody: ['body'],
    ClassDeclaration: ['id', 'superClass', 'body'],
    ClassExpression: ['id', 'superClass', 'body'],
    ComprehensionBlock: ['left', 'right'],
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DirectiveStatement: [],
    DoWhileStatement: ['body', 'test'],
    EmptyStatement: [],
    ExportAllDeclaration: ['source'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
    ExportSpecifier: ['exported', 'local'],
    ExpressionStatement: ['expression'],
    ForStatement: ['init', 'test', 'update', 'body'],
    ForInStatement: ['left', 'right', 'body'],
    ForOfStatement: ['left', 'right', 'body'],
    FunctionDeclaration: ['id', 'params', 'body'],
    FunctionExpression: ['id', 'params', 'body'],
    GeneratorExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    Identifier: [],
    IfStatement: ['test', 'consequent', 'alternate'],
    ImportExpression: ['source'],
    ImportDeclaration: ['specifiers', 'source'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['imported', 'local'],
    Literal: [],
    LabeledStatement: ['label', 'body'],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    MetaProperty: ['meta', 'property'],
    MethodDefinition: ['key', 'value'],
    ModuleSpecifier: [],
    NewExpression: ['callee', 'arguments'],
    ObjectExpression: ['properties'],
    ObjectPattern: ['properties'],
    Program: ['body'],
    Property: ['key', 'value'],
    RestElement: ['argument'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    SpreadElement: ['argument'],
    Super: [],
    SwitchStatement: ['discriminant', 'cases'],
    SwitchCase: ['test', 'consequent'],
    TaggedTemplateExpression: ['tag', 'quasi'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    YieldExpression: ['argument']
  }; // unique id

  BREAK = {};
  SKIP = {};
  REMOVE = {};
  VisitorOption = {
    Break: BREAK,
    Skip: SKIP,
    Remove: REMOVE
  };

  function Reference(parent, key) {
    this.parent = parent;
    this.key = key;
  }

  Reference.prototype.replace = function replace(node) {
    this.parent[this.key] = node;
  };

  Reference.prototype.remove = function remove() {
    if (Array.isArray(this.parent)) {
      this.parent.splice(this.key, 1);
      return true;
    } else {
      this.replace(null);
      return false;
    }
  };

  function Element(node, path, wrap, ref) {
    this.node = node;
    this.path = path;
    this.wrap = wrap;
    this.ref = ref;
  }

  function Controller() {} // API:
  // return property path array from root to current node


  Controller.prototype.path = function path() {
    var i, iz, j, jz, result, element;

    function addToPath(result, path) {
      if (Array.isArray(path)) {
        for (j = 0, jz = path.length; j < jz; ++j) {
          result.push(path[j]);
        }
      } else {
        result.push(path);
      }
    } // root node


    if (!this.__current.path) {
      return null;
    } // first node is sentinel, second node is root element


    result = [];

    for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
      element = this.__leavelist[i];
      addToPath(result, element.path);
    }

    addToPath(result, this.__current.path);
    return result;
  }; // API:
  // return type of current node


  Controller.prototype.type = function () {
    var node = this.current();
    return node.type || this.__current.wrap;
  }; // API:
  // return array of parent elements


  Controller.prototype.parents = function parents() {
    var i, iz, result; // first node is sentinel

    result = [];

    for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
      result.push(this.__leavelist[i].node);
    }

    return result;
  }; // API:
  // return current node


  Controller.prototype.current = function current() {
    return this.__current.node;
  };

  Controller.prototype.__execute = function __execute(callback, element) {
    var previous, result;
    result = undefined;
    previous = this.__current;
    this.__current = element;
    this.__state = null;

    if (callback) {
      result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
    }

    this.__current = previous;
    return result;
  }; // API:
  // notify control skip / break


  Controller.prototype.notify = function notify(flag) {
    this.__state = flag;
  }; // API:
  // skip child nodes of current node


  Controller.prototype.skip = function () {
    this.notify(SKIP);
  }; // API:
  // break traversals


  Controller.prototype['break'] = function () {
    this.notify(BREAK);
  }; // API:
  // remove node


  Controller.prototype.remove = function () {
    this.notify(REMOVE);
  };

  Controller.prototype.__initialize = function (root, visitor) {
    this.visitor = visitor;
    this.root = root;
    this.__worklist = [];
    this.__leavelist = [];
    this.__current = null;
    this.__state = null;
    this.__fallback = null;

    if (visitor.fallback === 'iteration') {
      this.__fallback = Object.keys;
    } else if (typeof visitor.fallback === 'function') {
      this.__fallback = visitor.fallback;
    }

    this.__keys = VisitorKeys;

    if (visitor.keys) {
      this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
    }
  };

  function isNode(node) {
    if (node == null) {
      return false;
    }

    return typeof node === 'object' && typeof node.type === 'string';
  }

  function isProperty(nodeType, key) {
    return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
  }

  function candidateExistsInLeaveList(leavelist, candidate) {
    for (var i = leavelist.length - 1; i >= 0; --i) {
      if (leavelist[i].node === candidate) {
        return true;
      }
    }

    return false;
  }

  Controller.prototype.traverse = function traverse(root, visitor) {
    var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;

    this.__initialize(root, visitor);

    sentinel = {}; // reference

    worklist = this.__worklist;
    leavelist = this.__leavelist; // initialize

    worklist.push(new Element(root, null, null, null));
    leavelist.push(new Element(null, null, null, null));

    while (worklist.length) {
      element = worklist.pop();

      if (element === sentinel) {
        element = leavelist.pop();
        ret = this.__execute(visitor.leave, element);

        if (this.__state === BREAK || ret === BREAK) {
          return;
        }

        continue;
      }

      if (element.node) {
        ret = this.__execute(visitor.enter, element);

        if (this.__state === BREAK || ret === BREAK) {
          return;
        }

        worklist.push(sentinel);
        leavelist.push(element);

        if (this.__state === SKIP || ret === SKIP) {
          continue;
        }

        node = element.node;
        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];

        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error('Unknown node type ' + nodeType + '.');
          }
        }

        current = candidates.length;

        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];

          if (!candidate) {
            continue;
          }

          if (Array.isArray(candidate)) {
            current2 = candidate.length;

            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }

              if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                continue;
              }

              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], 'Property', null);
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, null);
              } else {
                continue;
              }

              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            if (candidateExistsInLeaveList(leavelist, candidate)) {
              continue;
            }

            worklist.push(new Element(candidate, key, null, null));
          }
        }
      }
    }
  };

  Controller.prototype.replace = function replace(root, visitor) {
    var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;

    function removeElem(element) {
      var i, key, nextElem, parent;

      if (element.ref.remove()) {
        // When the reference is an element of an array.
        key = element.ref.key;
        parent = element.ref.parent; // If removed from array, then decrease following items' keys.

        i = worklist.length;

        while (i--) {
          nextElem = worklist[i];

          if (nextElem.ref && nextElem.ref.parent === parent) {
            if (nextElem.ref.key < key) {
              break;
            }

            --nextElem.ref.key;
          }
        }
      }
    }

    this.__initialize(root, visitor);

    sentinel = {}; // reference

    worklist = this.__worklist;
    leavelist = this.__leavelist; // initialize

    outer = {
      root: root
    };
    element = new Element(root, null, null, new Reference(outer, 'root'));
    worklist.push(element);
    leavelist.push(element);

    while (worklist.length) {
      element = worklist.pop();

      if (element === sentinel) {
        element = leavelist.pop();
        target = this.__execute(visitor.leave, element); // node may be replaced with null,
        // so distinguish between undefined and null in this place

        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
          // replace
          element.ref.replace(target);
        }

        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
        }

        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }

        continue;
      }

      target = this.__execute(visitor.enter, element); // node may be replaced with null,
      // so distinguish between undefined and null in this place

      if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
        // replace
        element.ref.replace(target);
        element.node = target;
      }

      if (this.__state === REMOVE || target === REMOVE) {
        removeElem(element);
        element.node = null;
      }

      if (this.__state === BREAK || target === BREAK) {
        return outer.root;
      } // node may be null


      node = element.node;

      if (!node) {
        continue;
      }

      worklist.push(sentinel);
      leavelist.push(element);

      if (this.__state === SKIP || target === SKIP) {
        continue;
      }

      nodeType = node.type || element.wrap;
      candidates = this.__keys[nodeType];

      if (!candidates) {
        if (this.__fallback) {
          candidates = this.__fallback(node);
        } else {
          throw new Error('Unknown node type ' + nodeType + '.');
        }
      }

      current = candidates.length;

      while ((current -= 1) >= 0) {
        key = candidates[current];
        candidate = node[key];

        if (!candidate) {
          continue;
        }

        if (Array.isArray(candidate)) {
          current2 = candidate.length;

          while ((current2 -= 1) >= 0) {
            if (!candidate[current2]) {
              continue;
            }

            if (isProperty(nodeType, candidates[current])) {
              element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
            } else if (isNode(candidate[current2])) {
              element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
            } else {
              continue;
            }

            worklist.push(element);
          }
        } else if (isNode(candidate)) {
          worklist.push(new Element(candidate, key, null, new Reference(node, key)));
        }
      }
    }

    return outer.root;
  };

  function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
  }

  function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
  }

  function extendCommentRange(comment, tokens) {
    var target;
    target = upperBound(tokens, function search(token) {
      return token.range[0] > comment.range[0];
    });
    comment.extendedRange = [comment.range[0], comment.range[1]];

    if (target !== tokens.length) {
      comment.extendedRange[1] = tokens[target].range[0];
    }

    target -= 1;

    if (target >= 0) {
      comment.extendedRange[0] = tokens[target].range[1];
    }

    return comment;
  }

  function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [],
        comment,
        len,
        i,
        cursor;

    if (!tree.range) {
      throw new Error('attachComments needs range information');
    } // tokens array is empty, we attach comments to tree as 'leadingComments'


    if (!tokens.length) {
      if (providedComments.length) {
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comment = deepCopy(providedComments[i]);
          comment.extendedRange = [0, tree.range[0]];
          comments.push(comment);
        }

        tree.leadingComments = comments;
      }

      return tree;
    }

    for (i = 0, len = providedComments.length; i < len; i += 1) {
      comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    } // This is based on John Freeman's implementation.


    cursor = 0;
    traverse(tree, {
      enter: function (node) {
        var comment;

        while (cursor < comments.length) {
          comment = comments[cursor];

          if (comment.extendedRange[1] > node.range[0]) {
            break;
          }

          if (comment.extendedRange[1] === node.range[0]) {
            if (!node.leadingComments) {
              node.leadingComments = [];
            }

            node.leadingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        } // already out of owned node


        if (cursor === comments.length) {
          return VisitorOption.Break;
        }

        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    cursor = 0;
    traverse(tree, {
      leave: function (node) {
        var comment;

        while (cursor < comments.length) {
          comment = comments[cursor];

          if (node.range[1] < comment.extendedRange[0]) {
            break;
          }

          if (node.range[1] === comment.extendedRange[0]) {
            if (!node.trailingComments) {
              node.trailingComments = [];
            }

            node.trailingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        } // already out of owned node


        if (cursor === comments.length) {
          return VisitorOption.Break;
        }

        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    return tree;
  }

  exports.Syntax = Syntax;
  exports.traverse = traverse;
  exports.replace = replace;
  exports.attachComments = attachComments;
  exports.VisitorKeys = VisitorKeys;
  exports.VisitorOption = VisitorOption;
  exports.Controller = Controller;

  exports.cloneEnvironment = function () {
    return clone({});
  };

  return exports;
})(exports);
/* vim: set sw=4 ts=4 et tw=80 : */
});

var name$3 = "esrecurse";
var description$5 = "ECMAScript AST recursive visitor";
var homepage$3 = "https://github.com/estools/esrecurse";
var main$3 = "esrecurse.js";
var version$6 = "4.3.0";
var engines$4 = {
	node: ">=4.0"
};
var maintainers$1 = [
	{
		name: "Yusuke Suzuki",
		email: "utatane.tea@gmail.com",
		web: "https://github.com/Constellation"
	}
];
var repository$4 = {
	type: "git",
	url: "https://github.com/estools/esrecurse.git"
};
var dependencies$6 = {
	estraverse: "^5.2.0"
};
var devDependencies$4 = {
	"babel-cli": "^6.24.1",
	"babel-eslint": "^7.2.3",
	"babel-preset-es2015": "^6.24.1",
	"babel-register": "^6.24.1",
	chai: "^4.0.2",
	esprima: "^4.0.0",
	gulp: "^3.9.0",
	"gulp-bump": "^2.7.0",
	"gulp-eslint": "^4.0.0",
	"gulp-filter": "^5.0.0",
	"gulp-git": "^2.4.1",
	"gulp-mocha": "^4.3.1",
	"gulp-tag-version": "^1.2.1",
	jsdoc: "^3.3.0-alpha10",
	minimist: "^1.1.0"
};
var license$3 = "BSD-2-Clause";
var scripts$4 = {
	test: "gulp travis",
	"unit-test": "gulp test",
	lint: "gulp lint"
};
var babel = {
	presets: [
		"es2015"
	]
};
var require$$1$3 = {
	name: name$3,
	description: description$5,
	homepage: homepage$3,
	main: main$3,
	version: version$6,
	engines: engines$4,
	maintainers: maintainers$1,
	repository: repository$4,
	dependencies: dependencies$6,
	devDependencies: devDependencies$4,
	license: license$3,
	scripts: scripts$4,
	babel: babel
};

/*
  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var esrecurse = createCommonjsModule$1(function (module, exports) {
(function () {

  var estraverse$1 = estraverse;

  function isNode(node) {
    if (node == null) {
      return false;
    }

    return typeof node === 'object' && typeof node.type === 'string';
  }

  function isProperty(nodeType, key) {
    return (nodeType === estraverse$1.Syntax.ObjectExpression || nodeType === estraverse$1.Syntax.ObjectPattern) && key === 'properties';
  }

  function Visitor(visitor, options) {
    options = options || {};
    this.__visitor = visitor || this;
    this.__childVisitorKeys = options.childVisitorKeys ? Object.assign({}, estraverse$1.VisitorKeys, options.childVisitorKeys) : estraverse$1.VisitorKeys;

    if (options.fallback === 'iteration') {
      this.__fallback = Object.keys;
    } else if (typeof options.fallback === 'function') {
      this.__fallback = options.fallback;
    }
  }
  /* Default method for visiting children.
   * When you need to call default visiting operation inside custom visiting
   * operation, you can use it with `this.visitChildren(node)`.
   */


  Visitor.prototype.visitChildren = function (node) {
    var type, children, i, iz, j, jz, child;

    if (node == null) {
      return;
    }

    type = node.type || estraverse$1.Syntax.Property;
    children = this.__childVisitorKeys[type];

    if (!children) {
      if (this.__fallback) {
        children = this.__fallback(node);
      } else {
        throw new Error('Unknown node type ' + type + '.');
      }
    }

    for (i = 0, iz = children.length; i < iz; ++i) {
      child = node[children[i]];

      if (child) {
        if (Array.isArray(child)) {
          for (j = 0, jz = child.length; j < jz; ++j) {
            if (child[j]) {
              if (isNode(child[j]) || isProperty(type, children[i])) {
                this.visit(child[j]);
              }
            }
          }
        } else if (isNode(child)) {
          this.visit(child);
        }
      }
    }
  };
  /* Dispatching node. */


  Visitor.prototype.visit = function (node) {
    var type;

    if (node == null) {
      return;
    }

    type = node.type || estraverse$1.Syntax.Property;

    if (this.__visitor[type]) {
      this.__visitor[type].call(this, node);

      return;
    }

    this.visitChildren(node);
  };

  exports.version = require$$1$3.version;
  exports.Visitor = Visitor;

  exports.visit = function (node, visitor, options) {
    var v = new Visitor(visitor, options);
    v.visit(node);
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
});

/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* eslint-disable no-undefined */

const Syntax$2 = estraverse$1.Syntax;


/**
 * Get last array element
 * @param {array} xs - array
 * @returns {any} Last elment
 */


function getLast(xs) {
  return xs[xs.length - 1] || null;
}

class PatternVisitor extends esrecurse.Visitor {
  static isPattern(node) {
    const nodeType = node.type;
    return nodeType === Syntax$2.Identifier || nodeType === Syntax$2.ObjectPattern || nodeType === Syntax$2.ArrayPattern || nodeType === Syntax$2.SpreadElement || nodeType === Syntax$2.RestElement || nodeType === Syntax$2.AssignmentPattern;
  }

  constructor(options, rootPattern, callback) {
    super(null, options);
    this.rootPattern = rootPattern;
    this.callback = callback;
    this.assignments = [];
    this.rightHandNodes = [];
    this.restElements = [];
  }

  Identifier(pattern) {
    const lastRestElement = getLast(this.restElements);
    this.callback(pattern, {
      topLevel: pattern === this.rootPattern,
      rest: lastRestElement !== null && lastRestElement !== undefined && lastRestElement.argument === pattern,
      assignments: this.assignments
    });
  }

  Property(property) {
    // Computed property's key is a right hand node.
    if (property.computed) {
      this.rightHandNodes.push(property.key);
    } // If it's shorthand, its key is same as its value.
    // If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).
    // If it's not shorthand, the name of new variable is its value's.


    this.visit(property.value);
  }

  ArrayPattern(pattern) {
    for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {
      const element = pattern.elements[i];
      this.visit(element);
    }
  }

  AssignmentPattern(pattern) {
    this.assignments.push(pattern);
    this.visit(pattern.left);
    this.rightHandNodes.push(pattern.right);
    this.assignments.pop();
  }

  RestElement(pattern) {
    this.restElements.push(pattern);
    this.visit(pattern.argument);
    this.restElements.pop();
  }

  MemberExpression(node) {
    // Computed property's key is a right hand node.
    if (node.computed) {
      this.rightHandNodes.push(node.property);
    } // the object is only read, write to its property.


    this.rightHandNodes.push(node.object);
  } //
  // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.
  // By spec, LeftHandSideExpression is Pattern or MemberExpression.
  //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)
  // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...
  //


  SpreadElement(node) {
    this.visit(node.argument);
  }

  ArrayExpression(node) {
    node.elements.forEach(this.visit, this);
  }

  AssignmentExpression(node) {
    this.assignments.push(node);
    this.visit(node.left);
    this.rightHandNodes.push(node.right);
    this.assignments.pop();
  }

  CallExpression(node) {
    // arguments are right hand nodes.
    node.arguments.forEach(a => {
      this.rightHandNodes.push(a);
    });
    this.visit(node.callee);
  }

}

var patternVisitor = PatternVisitor;

/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* eslint-disable no-underscore-dangle */

/* eslint-disable no-undefined */

const Syntax$1 = estraverse$1.Syntax;













const ParameterDefinition = definition.ParameterDefinition;
const Definition = definition.Definition;
/**
 * Traverse identifier in pattern
 * @param {Object} options - options
 * @param {pattern} rootPattern - root pattern
 * @param {Refencer} referencer - referencer
 * @param {callback} callback - callback
 * @returns {void}
 */

function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
  // Call the callback at left hand identifier nodes, and Collect right hand nodes.
  const visitor = new patternVisitor(options, rootPattern, callback);
  visitor.visit(rootPattern); // Process the right hand nodes recursively.

  if (referencer !== null && referencer !== undefined) {
    visitor.rightHandNodes.forEach(referencer.visit, referencer);
  }
} // Importing ImportDeclaration.
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation
// https://github.com/estree/estree/blob/master/es6.md#importdeclaration
// FIXME: Now, we don't create module environment, because the context is
// implementation dependent.


class Importer extends esrecurse.Visitor {
  constructor(declaration, referencer) {
    super(null, referencer.options);
    this.declaration = declaration;
    this.referencer = referencer;
  }

  visitImport(id, specifier) {
    this.referencer.visitPattern(id, pattern => {
      this.referencer.currentScope().__define(pattern, new Definition(variable.ImportBinding, pattern, specifier, this.declaration, null, null));
    });
  }

  ImportNamespaceSpecifier(node) {
    const local = node.local || node.id;

    if (local) {
      this.visitImport(local, node);
    }
  }

  ImportDefaultSpecifier(node) {
    const local = node.local || node.id;
    this.visitImport(local, node);
  }

  ImportSpecifier(node) {
    const local = node.local || node.id;

    if (node.name) {
      this.visitImport(node.name, node);
    } else {
      this.visitImport(local, node);
    }
  }

} // Referencing variables and creating bindings.


class Referencer extends esrecurse.Visitor {
  constructor(options, scopeManager) {
    super(null, options);
    this.options = options;
    this.scopeManager = scopeManager;
    this.parent = null;
    this.isInnerMethodDefinition = false;
  }

  currentScope() {
    return this.scopeManager.__currentScope;
  }

  close(node) {
    while (this.currentScope() && node === this.currentScope().block) {
      this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
    }
  }

  pushInnerMethodDefinition(isInnerMethodDefinition) {
    const previous = this.isInnerMethodDefinition;
    this.isInnerMethodDefinition = isInnerMethodDefinition;
    return previous;
  }

  popInnerMethodDefinition(isInnerMethodDefinition) {
    this.isInnerMethodDefinition = isInnerMethodDefinition;
  }

  referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
    const scope = this.currentScope();
    assignments.forEach(assignment => {
      scope.__referencing(pattern, reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
    });
  }

  visitPattern(node, options, callback) {
    let visitPatternOptions = options;
    let visitPatternCallback = callback;

    if (typeof options === "function") {
      visitPatternCallback = options;
      visitPatternOptions = {
        processRightHandNodes: false
      };
    }

    traverseIdentifierInPattern(this.options, node, visitPatternOptions.processRightHandNodes ? this : null, visitPatternCallback);
  }

  visitFunction(node) {
    let i, iz; // FunctionDeclaration name is defined in upper scope
    // NOTE: Not referring variableScope. It is intended.
    // Since
    //  in ES5, FunctionDeclaration should be in FunctionBody.
    //  in ES6, FunctionDeclaration should be block scoped.

    if (node.type === Syntax$1.FunctionDeclaration) {
      // id is defined in upper scope
      this.currentScope().__define(node.id, new Definition(variable.FunctionName, node.id, node, null, null, null));
    } // FunctionExpression with name creates its special scope;
    // FunctionExpressionNameScope.


    if (node.type === Syntax$1.FunctionExpression && node.id) {
      this.scopeManager.__nestFunctionExpressionNameScope(node);
    } // Consider this function is in the MethodDefinition.


    this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);

    const that = this;
    /**
     * Visit pattern callback
     * @param {pattern} pattern - pattern
     * @param {Object} info - info
     * @returns {void}
     */

    function visitPatternCallback(pattern, info) {
      that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest));

      that.referencingDefaultValue(pattern, info.assignments, null, true);
    } // Process parameter declarations.


    for (i = 0, iz = node.params.length; i < iz; ++i) {
      this.visitPattern(node.params[i], {
        processRightHandNodes: true
      }, visitPatternCallback);
    } // if there's a rest argument, add that


    if (node.rest) {
      this.visitPattern({
        type: "RestElement",
        argument: node.rest
      }, pattern => {
        this.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, true));
      });
    } // In TypeScript there are a number of function-like constructs which have no body,
    // so check it exists before traversing


    if (node.body) {
      // Skip BlockStatement to prevent creating BlockStatement scope.
      if (node.body.type === Syntax$1.BlockStatement) {
        this.visitChildren(node.body);
      } else {
        this.visit(node.body);
      }
    }

    this.close(node);
  }

  visitClass(node) {
    if (node.type === Syntax$1.ClassDeclaration) {
      this.currentScope().__define(node.id, new Definition(variable.ClassName, node.id, node, null, null, null));
    }

    this.visit(node.superClass);

    this.scopeManager.__nestClassScope(node);

    if (node.id) {
      this.currentScope().__define(node.id, new Definition(variable.ClassName, node.id, node));
    }

    this.visit(node.body);
    this.close(node);
  }

  visitProperty(node) {
    let previous;

    if (node.computed) {
      this.visit(node.key);
    }

    const isMethodDefinition = node.type === Syntax$1.MethodDefinition;

    if (isMethodDefinition) {
      previous = this.pushInnerMethodDefinition(true);
    }

    this.visit(node.value);

    if (isMethodDefinition) {
      this.popInnerMethodDefinition(previous);
    }
  }

  visitForIn(node) {
    if (node.left.type === Syntax$1.VariableDeclaration && node.left.kind !== "var") {
      this.scopeManager.__nestForScope(node);
    }

    if (node.left.type === Syntax$1.VariableDeclaration) {
      this.visit(node.left);
      this.visitPattern(node.left.declarations[0].id, pattern => {
        this.currentScope().__referencing(pattern, reference.WRITE, node.right, null, true, true);
      });
    } else {
      this.visitPattern(node.left, {
        processRightHandNodes: true
      }, (pattern, info) => {
        let maybeImplicitGlobal = null;

        if (!this.currentScope().isStrict) {
          maybeImplicitGlobal = {
            pattern,
            node
          };
        }

        this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);

        this.currentScope().__referencing(pattern, reference.WRITE, node.right, maybeImplicitGlobal, true, false);
      });
    }

    this.visit(node.right);
    this.visit(node.body);
    this.close(node);
  }

  visitVariableDeclaration(variableTargetScope, type, node, index) {
    const decl = node.declarations[index];
    const init = decl.init;
    this.visitPattern(decl.id, {
      processRightHandNodes: true
    }, (pattern, info) => {
      variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind));

      this.referencingDefaultValue(pattern, info.assignments, null, true);

      if (init) {
        this.currentScope().__referencing(pattern, reference.WRITE, init, null, !info.topLevel, true);
      }
    });
  }

  AssignmentExpression(node) {
    if (patternVisitor.isPattern(node.left)) {
      if (node.operator === "=") {
        this.visitPattern(node.left, {
          processRightHandNodes: true
        }, (pattern, info) => {
          let maybeImplicitGlobal = null;

          if (!this.currentScope().isStrict) {
            maybeImplicitGlobal = {
              pattern,
              node
            };
          }

          this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);

          this.currentScope().__referencing(pattern, reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
        });
      } else {
        this.currentScope().__referencing(node.left, reference.RW, node.right);
      }
    } else {
      this.visit(node.left);
    }

    this.visit(node.right);
  }

  CatchClause(node) {
    this.scopeManager.__nestCatchScope(node);

    this.visitPattern(node.param, {
      processRightHandNodes: true
    }, (pattern, info) => {
      this.currentScope().__define(pattern, new Definition(variable.CatchClause, node.param, node, null, null, null));

      this.referencingDefaultValue(pattern, info.assignments, null, true);
    });
    this.visit(node.body);
    this.close(node);
  }

  Program(node) {
    this.scopeManager.__nestGlobalScope(node);

    if (this.scopeManager.__isNodejsScope()) {
      // Force strictness of GlobalScope to false when using node.js scope.
      this.currentScope().isStrict = false;

      this.scopeManager.__nestFunctionScope(node, false);
    }

    if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
      this.scopeManager.__nestModuleScope(node);
    }

    if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
      this.currentScope().isStrict = true;
    }

    this.visitChildren(node);
    this.close(node);
  }

  Identifier(node) {
    this.currentScope().__referencing(node);
  }

  UpdateExpression(node) {
    if (patternVisitor.isPattern(node.argument)) {
      this.currentScope().__referencing(node.argument, reference.RW, null);
    } else {
      this.visitChildren(node);
    }
  }

  MemberExpression(node) {
    this.visit(node.object);

    if (node.computed) {
      this.visit(node.property);
    }
  }

  Property(node) {
    this.visitProperty(node);
  }

  MethodDefinition(node) {
    this.visitProperty(node);
  }

  BreakStatement() {} // eslint-disable-line class-methods-use-this


  ContinueStatement() {} // eslint-disable-line class-methods-use-this


  LabeledStatement(node) {
    this.visit(node.body);
  }

  ForStatement(node) {
    // Create ForStatement declaration.
    // NOTE: In ES6, ForStatement dynamically generates
    // per iteration environment. However, escope is
    // a static analyzer, we only generate one scope for ForStatement.
    if (node.init && node.init.type === Syntax$1.VariableDeclaration && node.init.kind !== "var") {
      this.scopeManager.__nestForScope(node);
    }

    this.visitChildren(node);
    this.close(node);
  }

  ClassExpression(node) {
    this.visitClass(node);
  }

  ClassDeclaration(node) {
    this.visitClass(node);
  }

  CallExpression(node) {
    // Check this is direct call to eval
    if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax$1.Identifier && node.callee.name === "eval") {
      // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and
      // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.
      this.currentScope().variableScope.__detectEval();
    }

    this.visitChildren(node);
  }

  BlockStatement(node) {
    if (this.scopeManager.__isES6()) {
      this.scopeManager.__nestBlockScope(node);
    }

    this.visitChildren(node);
    this.close(node);
  }

  ThisExpression() {
    this.currentScope().variableScope.__detectThis();
  }

  WithStatement(node) {
    this.visit(node.object); // Then nest scope for WithStatement.

    this.scopeManager.__nestWithScope(node);

    this.visit(node.body);
    this.close(node);
  }

  VariableDeclaration(node) {
    const variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();

    for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
      const decl = node.declarations[i];
      this.visitVariableDeclaration(variableTargetScope, variable.Variable, node, i);

      if (decl.init) {
        this.visit(decl.init);
      }
    }
  } // sec 13.11.8


  SwitchStatement(node) {
    this.visit(node.discriminant);

    if (this.scopeManager.__isES6()) {
      this.scopeManager.__nestSwitchScope(node);
    }

    for (let i = 0, iz = node.cases.length; i < iz; ++i) {
      this.visit(node.cases[i]);
    }

    this.close(node);
  }

  FunctionDeclaration(node) {
    this.visitFunction(node);
  }

  FunctionExpression(node) {
    this.visitFunction(node);
  }

  ForOfStatement(node) {
    this.visitForIn(node);
  }

  ForInStatement(node) {
    this.visitForIn(node);
  }

  ArrowFunctionExpression(node) {
    this.visitFunction(node);
  }

  ImportDeclaration(node) {
    require$$1$4(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
    const importer = new Importer(node, this);
    importer.visit(node);
  }

  visitExportDeclaration(node) {
    if (node.source) {
      return;
    }

    if (node.declaration) {
      this.visit(node.declaration);
      return;
    }

    this.visitChildren(node);
  } // TODO: ExportDeclaration doesn't exist. for bc?


  ExportDeclaration(node) {
    this.visitExportDeclaration(node);
  }

  ExportAllDeclaration(node) {
    this.visitExportDeclaration(node);
  }

  ExportDefaultDeclaration(node) {
    this.visitExportDeclaration(node);
  }

  ExportNamedDeclaration(node) {
    this.visitExportDeclaration(node);
  }

  ExportSpecifier(node) {
    // TODO: `node.id` doesn't exist. for bc?
    const local = node.id || node.local;
    this.visit(local);
  }

  MetaProperty() {// eslint-disable-line class-methods-use-this
    // do nothing.
  }

}

var referencer = Referencer;

var name$2 = "eslint-scope";
var description$4 = "ECMAScript scope analyzer for ESLint";
var homepage$2 = "http://github.com/eslint/eslint-scope";
var main$2 = "lib/index.js";
var version$5 = "5.1.1";
var engines$3 = {
	node: ">=8.0.0"
};
var repository$3 = "eslint/eslint-scope";
var bugs$2 = {
	url: "https://github.com/eslint/eslint-scope/issues"
};
var license$2 = "BSD-2-Clause";
var scripts$3 = {
	test: "node Makefile.js test",
	lint: "node Makefile.js lint",
	"generate-release": "eslint-generate-release",
	"generate-alpharelease": "eslint-generate-prerelease alpha",
	"generate-betarelease": "eslint-generate-prerelease beta",
	"generate-rcrelease": "eslint-generate-prerelease rc",
	"publish-release": "eslint-publish-release"
};
var files$3 = [
	"LICENSE",
	"README.md",
	"lib"
];
var dependencies$5 = {
	esrecurse: "^4.3.0",
	estraverse: "^4.1.1"
};
var devDependencies$3 = {
	"@typescript-eslint/parser": "^1.11.0",
	chai: "^4.2.0",
	eslint: "^6.0.1",
	"eslint-config-eslint": "^5.0.1",
	"eslint-plugin-node": "^9.1.0",
	"eslint-release": "^1.0.0",
	"eslint-visitor-keys": "^1.2.0",
	espree: "^7.1.0",
	istanbul: "^0.4.5",
	mocha: "^6.1.4",
	"npm-license": "^0.3.3",
	shelljs: "^0.8.3",
	typescript: "^3.5.2"
};
var require$$1$2 = {
	name: name$2,
	description: description$4,
	homepage: homepage$2,
	main: main$2,
	version: version$5,
	engines: engines$3,
	repository: repository$3,
	bugs: bugs$2,
	license: license$2,
	scripts: scripts$3,
	files: files$3,
	dependencies: dependencies$5,
	devDependencies: devDependencies$3
};

/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>
  Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* eslint no-underscore-dangle: ["error", { "allow": ["__currentScope"] }] */











const Scope$1 = scope.Scope;

const version$4 = require$$1$2.version;
/**
 * Set the default options
 * @returns {Object} options
 */


function defaultOptions$1() {
  return {
    optimistic: false,
    directive: false,
    nodejsScope: false,
    impliedStrict: false,
    sourceType: "script",
    // one of ['script', 'module']
    ecmaVersion: 5,
    childVisitorKeys: null,
    fallback: "iteration"
  };
}
/**
 * Preform deep update on option object
 * @param {Object} target - Options
 * @param {Object} override - Updates
 * @returns {Object} Updated options
 */


function updateDeeply(target, override) {
  /**
   * Is hash object
   * @param {Object} value - Test value
   * @returns {boolean} Result
   */
  function isHashObject(value) {
    return typeof value === "object" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
  }

  for (const key in override) {
    if (Object.prototype.hasOwnProperty.call(override, key)) {
      const val = override[key];

      if (isHashObject(val)) {
        if (isHashObject(target[key])) {
          updateDeeply(target[key], val);
        } else {
          target[key] = updateDeeply({}, val);
        }
      } else {
        target[key] = val;
      }
    }
  }

  return target;
}
/**
 * Main interface function. Takes an Espree syntax tree and returns the
 * analyzed scopes.
 * @function analyze
 * @param {espree.Tree} tree - Abstract Syntax Tree
 * @param {Object} providedOptions - Options that tailor the scope analysis
 * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag
 * @param {boolean} [providedOptions.directive=false]- the directive flag
 * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls
 * @param {boolean} [providedOptions.nodejsScope=false]- whether the whole
 * script is executed under node.js environment. When enabled, escope adds
 * a function scope immediately following the global scope.
 * @param {boolean} [providedOptions.impliedStrict=false]- implied strict mode
 * (if ecmaVersion >= 5).
 * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'
 * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered
 * @param {Object} [providedOptions.childVisitorKeys=null] - Additional known visitor keys. See [esrecurse](https://github.com/estools/esrecurse)'s the `childVisitorKeys` option.
 * @param {string} [providedOptions.fallback='iteration'] - A kind of the fallback in order to encounter with unknown node. See [esrecurse](https://github.com/estools/esrecurse)'s the `fallback` option.
 * @returns {ScopeManager} ScopeManager
 */


function analyze(tree, providedOptions) {
  const options = updateDeeply(defaultOptions$1(), providedOptions);
  const scopeManager$1 = new scopeManager(options);
  const referencer$1 = new referencer(options, scopeManager$1);
  referencer$1.visit(tree);
  require$$1$4(scopeManager$1.__currentScope === null, "currentScope should be null.");
  return scopeManager$1;
}

var lib$6 = {
  /** @name module:escope.version */
  version: version$4,

  /** @name module:escope.Reference */
  Reference: reference,

  /** @name module:escope.Variable */
  Variable: variable,

  /** @name module:escope.Scope */
  Scope: Scope$1,

  /** @name module:escope.ScopeManager */
  ScopeManager: scopeManager,
  analyze
};

var AssignmentExpression$2 = [
	"left",
	"right"
];
var AssignmentPattern$2 = [
	"left",
	"right"
];
var ArrayExpression$2 = [
	"elements"
];
var ArrayPattern$2 = [
	"elements"
];
var ArrowFunctionExpression$2 = [
	"params",
	"body"
];
var AwaitExpression$2 = [
	"argument"
];
var BlockStatement$2 = [
	"body"
];
var BinaryExpression$2 = [
	"left",
	"right"
];
var BreakStatement$2 = [
	"label"
];
var CallExpression$2 = [
	"callee",
	"arguments"
];
var CatchClause$2 = [
	"param",
	"body"
];
var ChainExpression$2 = [
	"expression"
];
var ClassBody$2 = [
	"body"
];
var ClassDeclaration$2 = [
	"id",
	"superClass",
	"body"
];
var ClassExpression$2 = [
	"id",
	"superClass",
	"body"
];
var ConditionalExpression$2 = [
	"test",
	"consequent",
	"alternate"
];
var ContinueStatement$2 = [
	"label"
];
var DebuggerStatement$2 = [
];
var DoWhileStatement$2 = [
	"body",
	"test"
];
var EmptyStatement$2 = [
];
var ExportAllDeclaration$2 = [
	"exported",
	"source"
];
var ExportDefaultDeclaration$2 = [
	"declaration"
];
var ExportNamedDeclaration$2 = [
	"declaration",
	"specifiers",
	"source"
];
var ExportSpecifier$2 = [
	"exported",
	"local"
];
var ExpressionStatement$2 = [
	"expression"
];
var ExperimentalRestProperty$2 = [
	"argument"
];
var ExperimentalSpreadProperty$2 = [
	"argument"
];
var ForStatement$2 = [
	"init",
	"test",
	"update",
	"body"
];
var ForInStatement$2 = [
	"left",
	"right",
	"body"
];
var ForOfStatement$2 = [
	"left",
	"right",
	"body"
];
var FunctionDeclaration$2 = [
	"id",
	"params",
	"body"
];
var FunctionExpression$2 = [
	"id",
	"params",
	"body"
];
var Identifier$2 = [
];
var IfStatement$2 = [
	"test",
	"consequent",
	"alternate"
];
var ImportDeclaration$2 = [
	"specifiers",
	"source"
];
var ImportDefaultSpecifier$2 = [
	"local"
];
var ImportExpression$2 = [
	"source"
];
var ImportNamespaceSpecifier$2 = [
	"local"
];
var ImportSpecifier$2 = [
	"imported",
	"local"
];
var JSXAttribute$2 = [
	"name",
	"value"
];
var JSXClosingElement$2 = [
	"name"
];
var JSXElement$2 = [
	"openingElement",
	"children",
	"closingElement"
];
var JSXEmptyExpression$2 = [
];
var JSXExpressionContainer$2 = [
	"expression"
];
var JSXIdentifier$2 = [
];
var JSXMemberExpression$2 = [
	"object",
	"property"
];
var JSXNamespacedName$2 = [
	"namespace",
	"name"
];
var JSXOpeningElement$2 = [
	"name",
	"attributes"
];
var JSXSpreadAttribute$2 = [
	"argument"
];
var JSXText$2 = [
];
var JSXFragment$2 = [
	"openingFragment",
	"children",
	"closingFragment"
];
var Literal$2 = [
];
var LabeledStatement$2 = [
	"label",
	"body"
];
var LogicalExpression$2 = [
	"left",
	"right"
];
var MemberExpression$2 = [
	"object",
	"property"
];
var MetaProperty$2 = [
	"meta",
	"property"
];
var MethodDefinition$2 = [
	"key",
	"value"
];
var NewExpression$2 = [
	"callee",
	"arguments"
];
var ObjectExpression$2 = [
	"properties"
];
var ObjectPattern$2 = [
	"properties"
];
var Program$2 = [
	"body"
];
var Property$2 = [
	"key",
	"value"
];
var RestElement$2 = [
	"argument"
];
var ReturnStatement$2 = [
	"argument"
];
var SequenceExpression$2 = [
	"expressions"
];
var SpreadElement$2 = [
	"argument"
];
var Super$2 = [
];
var SwitchStatement$2 = [
	"discriminant",
	"cases"
];
var SwitchCase$2 = [
	"test",
	"consequent"
];
var TaggedTemplateExpression$2 = [
	"tag",
	"quasi"
];
var TemplateElement$2 = [
];
var TemplateLiteral$2 = [
	"quasis",
	"expressions"
];
var ThisExpression$2 = [
];
var ThrowStatement$2 = [
	"argument"
];
var TryStatement$2 = [
	"block",
	"handler",
	"finalizer"
];
var UnaryExpression$2 = [
	"argument"
];
var UpdateExpression$2 = [
	"argument"
];
var VariableDeclaration$2 = [
	"declarations"
];
var VariableDeclarator$2 = [
	"id",
	"init"
];
var WhileStatement$2 = [
	"test",
	"body"
];
var WithStatement$2 = [
	"object",
	"body"
];
var YieldExpression$2 = [
	"argument"
];
var KEYS$3 = {
	AssignmentExpression: AssignmentExpression$2,
	AssignmentPattern: AssignmentPattern$2,
	ArrayExpression: ArrayExpression$2,
	ArrayPattern: ArrayPattern$2,
	ArrowFunctionExpression: ArrowFunctionExpression$2,
	AwaitExpression: AwaitExpression$2,
	BlockStatement: BlockStatement$2,
	BinaryExpression: BinaryExpression$2,
	BreakStatement: BreakStatement$2,
	CallExpression: CallExpression$2,
	CatchClause: CatchClause$2,
	ChainExpression: ChainExpression$2,
	ClassBody: ClassBody$2,
	ClassDeclaration: ClassDeclaration$2,
	ClassExpression: ClassExpression$2,
	ConditionalExpression: ConditionalExpression$2,
	ContinueStatement: ContinueStatement$2,
	DebuggerStatement: DebuggerStatement$2,
	DoWhileStatement: DoWhileStatement$2,
	EmptyStatement: EmptyStatement$2,
	ExportAllDeclaration: ExportAllDeclaration$2,
	ExportDefaultDeclaration: ExportDefaultDeclaration$2,
	ExportNamedDeclaration: ExportNamedDeclaration$2,
	ExportSpecifier: ExportSpecifier$2,
	ExpressionStatement: ExpressionStatement$2,
	ExperimentalRestProperty: ExperimentalRestProperty$2,
	ExperimentalSpreadProperty: ExperimentalSpreadProperty$2,
	ForStatement: ForStatement$2,
	ForInStatement: ForInStatement$2,
	ForOfStatement: ForOfStatement$2,
	FunctionDeclaration: FunctionDeclaration$2,
	FunctionExpression: FunctionExpression$2,
	Identifier: Identifier$2,
	IfStatement: IfStatement$2,
	ImportDeclaration: ImportDeclaration$2,
	ImportDefaultSpecifier: ImportDefaultSpecifier$2,
	ImportExpression: ImportExpression$2,
	ImportNamespaceSpecifier: ImportNamespaceSpecifier$2,
	ImportSpecifier: ImportSpecifier$2,
	JSXAttribute: JSXAttribute$2,
	JSXClosingElement: JSXClosingElement$2,
	JSXElement: JSXElement$2,
	JSXEmptyExpression: JSXEmptyExpression$2,
	JSXExpressionContainer: JSXExpressionContainer$2,
	JSXIdentifier: JSXIdentifier$2,
	JSXMemberExpression: JSXMemberExpression$2,
	JSXNamespacedName: JSXNamespacedName$2,
	JSXOpeningElement: JSXOpeningElement$2,
	JSXSpreadAttribute: JSXSpreadAttribute$2,
	JSXText: JSXText$2,
	JSXFragment: JSXFragment$2,
	Literal: Literal$2,
	LabeledStatement: LabeledStatement$2,
	LogicalExpression: LogicalExpression$2,
	MemberExpression: MemberExpression$2,
	MetaProperty: MetaProperty$2,
	MethodDefinition: MethodDefinition$2,
	NewExpression: NewExpression$2,
	ObjectExpression: ObjectExpression$2,
	ObjectPattern: ObjectPattern$2,
	Program: Program$2,
	Property: Property$2,
	RestElement: RestElement$2,
	ReturnStatement: ReturnStatement$2,
	SequenceExpression: SequenceExpression$2,
	SpreadElement: SpreadElement$2,
	Super: Super$2,
	SwitchStatement: SwitchStatement$2,
	SwitchCase: SwitchCase$2,
	TaggedTemplateExpression: TaggedTemplateExpression$2,
	TemplateElement: TemplateElement$2,
	TemplateLiteral: TemplateLiteral$2,
	ThisExpression: ThisExpression$2,
	ThrowStatement: ThrowStatement$2,
	TryStatement: TryStatement$2,
	UnaryExpression: UnaryExpression$2,
	UpdateExpression: UpdateExpression$2,
	VariableDeclaration: VariableDeclaration$2,
	VariableDeclarator: VariableDeclarator$2,
	WhileStatement: WhileStatement$2,
	WithStatement: WithStatement$2,
	YieldExpression: YieldExpression$2
};

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */

 // Types.


const NODE_TYPES$2 = Object.freeze(Object.keys(KEYS$3)); // Freeze the keys.

for (const type of NODE_TYPES$2) {
  Object.freeze(KEYS$3[type]);
}

Object.freeze(KEYS$3); // List to ignore keys.

const KEY_BLACKLIST$2 = new Set(["parent", "leadingComments", "trailingComments"]);
/**
 * Check whether a given key should be used or not.
 * @param {string} key The key to check.
 * @returns {boolean} `true` if the key should be used.
 */

function filterKey$2(key) {
  return !KEY_BLACKLIST$2.has(key) && key[0] !== "_";
} //------------------------------------------------------------------------------
// Public interfaces
//------------------------------------------------------------------------------


var lib$5 = Object.freeze({
  /**
   * Visitor keys.
   * @type {{ [type: string]: string[] | undefined }}
   */
  KEYS: KEYS$3,

  /**
   * Get visitor keys of a given node.
   * @param {Object} node The AST node to get keys.
   * @returns {string[]} Visitor keys of the node.
   */
  getKeys(node) {
    return Object.keys(node).filter(filterKey$2);
  },

  // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
  // eslint-disable-next-line valid-jsdoc

  /**
   * Make the union set with `KEYS` and given keys.
   * @param {Object} additionalKeys The additional keys.
   * @returns {{ [type: string]: string[] | undefined }} The union set.
   */
  unionWith(additionalKeys) {
    const retv = Object.assign({}, KEYS$3);

    for (const type of Object.keys(additionalKeys)) {
      if (retv.hasOwnProperty(type)) {
        const keys = new Set(additionalKeys[type]);

        for (const key of retv[type]) {
          keys.add(key);
        }

        retv[type] = Object.freeze(Array.from(keys));
      } else {
        retv[type] = Object.freeze(Array.from(additionalKeys[type]));
      }
    }

    return Object.freeze(retv);
  }

});

// Reserved word lists for various dialects of the language
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}; // And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$3 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/; // ## Character categories
// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js
// eslint-disable-next-line comma-spacing

var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938]; // eslint-disable-next-line comma-spacing

var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239]; // This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.

function isInAstralSet(code, set) {
  var pos = 0x10000;

  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];

    if (pos > code) {
      return false;
    }

    pos += set[i + 1];

    if (pos >= code) {
      return true;
    }
  }
} // Test whether a given character code starts an identifier.


function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }

  if (code < 91) {
    return true;
  }

  if (code < 97) {
    return code === 95;
  }

  if (code < 123) {
    return true;
  }

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  if (astral === false) {
    return false;
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
} // Test whether a given character is part of an identifier.


function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }

  if (code < 58) {
    return true;
  }

  if (code < 65) {
    return false;
  }

  if (code < 91) {
    return true;
  }

  if (code < 97) {
    return code === 95;
  }

  if (code < 123) {
    return true;
  }

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  if (astral === false) {
    return false;
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
} // ## Token types
// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.
// All token type variables start with an underscore, to make them
// easy to recognize.
// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.


var TokenType = function TokenType(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {
    beforeExpr: true,
    binop: prec
  });
}

var beforeExpr = {
  beforeExpr: true
},
    startsExpr = {
  startsExpr: true
}; // Map keyword names to token types.

var keywords$1$1 = {}; // Succinct definitions of keyword token types

function kw(name, options) {
  if (options === void 0) options = {};
  options.keyword = name;
  return keywords$1$1[name] = new TokenType(name, options);
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", {
    beforeExpr: true,
    startsExpr: true
  }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {
    beforeExpr: true,
    startsExpr: true
  }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {
    beforeExpr: true,
    startsExpr: true
  }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {
    beforeExpr: true,
    startsExpr: true
  }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", {
    beforeExpr: true,
    isAssign: true
  }),
  assign: new TokenType("_=", {
    beforeExpr: true,
    isAssign: true
  }),
  incDec: new TokenType("++/--", {
    prefix: true,
    postfix: true,
    startsExpr: true
  }),
  prefix: new TokenType("!/~", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {
    beforeExpr: true,
    binop: 9,
    prefix: true,
    startsExpr: true
  }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {
    beforeExpr: true
  }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {
    isLoop: true,
    beforeExpr: true
  }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {
    isLoop: true
  }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {
    isLoop: true
  }),
  _with: kw("with"),
  _new: kw("new", {
    beforeExpr: true,
    startsExpr: true
  }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {
    beforeExpr: true,
    binop: 7
  }),
  _instanceof: kw("instanceof", {
    beforeExpr: true,
    binop: 7
  }),
  _typeof: kw("typeof", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _void: kw("void", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  }),
  _delete: kw("delete", {
    beforeExpr: true,
    prefix: true,
    startsExpr: true
  })
}; // Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref$1 = Object.prototype;
var hasOwnProperty = ref$1.hasOwnProperty;
var toString = ref$1.toString; // Checks if an object has a property.

function has$1(obj, propName) {
  return hasOwnProperty.call(obj, propName);
}

var isArray = Array.isArray || function (obj) {
  return toString.call(obj) === "[object Array]";
};

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
} // These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.


var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;

  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
}; // The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.


function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);

    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
} // A second optional argument can be given to further configure
// the parser process. These options are recognized:


var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 10.
  ecmaVersion: 10,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
}; // Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions) {
    options[opt] = opts && has$1(opts, opt) ? opts[opt] : defaultOptions[opt];
  }

  if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;

    options.onToken = function (token) {
      return tokens.push(token);
    };
  }

  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };

    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }

    if (options.ranges) {
      comment.range = [start, end];
    }

    array.push(comment);
  };
} // Each scope gets a bitset that may contain these flags


var SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
} // Used in checkLVal and declareName to determine the type of a binding


var BIND_NONE = 0,
    // Not a binding
BIND_VAR = 1,
    // Var-style binding
BIND_LEXICAL = 2,
    // Let- or const-style binding
BIND_FUNCTION = 3,
    // Function declaration
BIND_SIMPLE_CATCH = 4,
    // Simple (identifier pattern) catch binding
BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$3[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";

  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--) {
      if (reserved = reservedWords[v]) {
        break;
      }
    }

    if (options.sourceType === "module") {
      reserved += " await";
    }
  }

  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input); // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.

  this.containsEsc = false; // Set up token state
  // The current position of the tokenizer in the input.

  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  } // Properties of the current token:
  // Its type


  this.type = types.eof; // For tokens that include more information than their type, the value

  this.value = null; // Its start and end offset

  this.start = this.end = this.pos; // And, if locations are used, the {line, column} object
  // corresponding to those offsets

  this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token

  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.

  this.context = this.initialContext();
  this.exprAllowed = true; // Figure out if it's a module code.

  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos); // Used to signify the start of a potential arrow function

  this.potentialArrowAt = -1; // Positions to delayed-check that yield/await does not exist in default parameters.

  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0; // Labels in scope.

  this.labels = []; // Thus-far undefined exports.

  this.undefinedExports = {}; // If enabled, skip leading hashbang line.

  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  } // Scope tracking for duplicate variable names (see scope.js)


  this.scopeStack = [];
  this.enterScope(SCOPE_TOP); // For RegExp validation

  this.regexpState = null;
};

var prototypeAccessors = {
  inFunction: {
    configurable: true
  },
  inGenerator: {
    configurable: true
  },
  inAsync: {
    configurable: true
  },
  allowSuper: {
    configurable: true
  },
  allowDirectSuper: {
    configurable: true
  },
  treatFunctionsAsVar: {
    configurable: true
  }
};

Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};

prototypeAccessors.inFunction.get = function () {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};

prototypeAccessors.inGenerator.get = function () {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};

prototypeAccessors.inAsync.get = function () {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};

prototypeAccessors.allowSuper.get = function () {
  return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
};

prototypeAccessors.allowDirectSuper.get = function () {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};

prototypeAccessors.treatFunctionsAsVar.get = function () {
  return this.treatFunctionsAsVarInScope(this.currentScope());
}; // Switch to a getter for 7.0.0.


Parser.prototype.inNonArrowFunction = function inNonArrowFunction() {
  return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
};

Parser.extend = function extend() {
  var plugins = [],
      len = arguments.length;

  while (len--) plugins[len] = arguments[len];

  var cls = this;

  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }

  return cls;
};

Parser.parse = function parse(input, options) {
  return new this(options, input).parse();
};

Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};

Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};

Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp = Parser.prototype; // ## Parser utilities

var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;

pp.strictDirective = function (start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));

    if (!match) {
      return false;
    }

    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input),
          end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }

    start += match[0].length; // Skip semicolon, if any.

    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;

    if (this.input[start] === ";") {
      start++;
    }
  }
}; // Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.


pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
}; // Tests whether parsed token is a contextual keyword.


pp.isContextual = function (name) {
  return this.type === types.name && this.value === name && !this.containsEsc;
}; // Consumes contextual keyword if possible.


pp.eatContextual = function (name) {
  if (!this.isContextual(name)) {
    return false;
  }

  this.next();
  return true;
}; // Asserts that following token is given contextual keyword.


pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
}; // Test whether a semicolon can be inserted at the current position.


pp.canInsertSemicolon = function () {
  return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }

    return true;
  }
}; // Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.


pp.semicolon = function () {
  if (!this.eat(types.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};

pp.afterTrailingComma = function (tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }

    if (!notNext) {
      this.next();
    }

    return true;
  }
}; // Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.


pp.expect = function (type) {
  this.eat(type) || this.unexpected();
}; // Raise an unexpected token error.


pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}

pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }

  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }

  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;

  if (parens > -1) {
    this.raiseRecoverable(parens, "Parenthesized pattern");
  }
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }

  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;

  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }

  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }

  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};

pp.checkYieldAwaitInDefaultParams = function () {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }

  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};

pp.isSimpleAssignTarget = function (expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }

  return expr.type === "Identifier" || expr.type === "MemberExpression";
};

var pp$1 = Parser.prototype; // ### Statement parsing
// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function (node) {
  var exports = {};

  if (!node.body) {
    node.body = [];
  }

  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }

  if (this.inModule) {
    for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
      var name = list[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }

  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};

var loopLabel = {
  kind: "loop"
},
    switchLabel = {
  kind: "switch"
};

pp$1.isLet = function (context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next); // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.

  if (nextCh === 91) {
    return true;
  } // '['


  if (context) {
    return false;
  }

  if (nextCh === 123) {
    return true;
  } // '{'


  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;

    while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
      ++pos;
    }

    var ident = this.input.slice(next, pos);

    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }

  return false;
}; // check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.


pp$1.isAsyncFunction = function () {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
}; // Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.


pp$1.parseStatement = function (context, topLevel, exports) {
  var starttype = this.type,
      node = this.startNode(),
      kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = "let";
  } // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.


  switch (starttype) {
    case types._break:
    case types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);

    case types._debugger:
      return this.parseDebuggerStatement(node);

    case types._do:
      return this.parseDoStatement(node);

    case types._for:
      return this.parseForStatement(node);

    case types._function:
      // Function as sole body of either an if statement or a labeled statement
      // works, but not when it is part of a labeled statement that is the sole
      // body of an if statement.
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }

      return this.parseFunctionStatement(node, false, !context);

    case types._class:
      if (context) {
        this.unexpected();
      }

      return this.parseClass(node, true);

    case types._if:
      return this.parseIfStatement(node);

    case types._return:
      return this.parseReturnStatement(node);

    case types._switch:
      return this.parseSwitchStatement(node);

    case types._throw:
      return this.parseThrowStatement(node);

    case types._try:
      return this.parseTryStatement(node);

    case types._const:
    case types._var:
      kind = kind || this.value;

      if (context && kind !== "var") {
        this.unexpected();
      }

      return this.parseVarStatement(node, kind);

    case types._while:
      return this.parseWhileStatement(node);

    case types._with:
      return this.parseWithStatement(node);

    case types.braceL:
      return this.parseBlock(true, node);

    case types.semi:
      return this.parseEmptyStatement(node);

    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length,
            nextCh = this.input.charCodeAt(next);

        if (nextCh === 40 || nextCh === 46) // '(' or '.'
          {
            return this.parseExpressionStatement(node, this.parseExpression());
          }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }

        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }

      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.

    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }

        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }

      var maybeName = this.value,
          expr = this.parseExpression();

      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }

  }
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword === "break";
  this.next();

  if (this.eat(types.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  } // Verify that there is an actual destination to break or
  // continue to.


  var i = 0;

  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];

    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }

      if (node.label && isBreak) {
        break;
      }
    }
  }

  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }

  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();

  if (this.options.ecmaVersion >= 6) {
    this.eat(types.semi);
  } else {
    this.semicolon();
  }

  return this.finishNode(node, "DoWhileStatement");
}; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.


pp$1.parseForStatement = function (node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);

  if (this.type === types.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }

    return this.parseFor(node, null);
  }

  var isLet = this.isLet();

  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(),
        kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");

    if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }

      return this.parseForIn(node, init$1);
    }

    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }

    return this.parseFor(node, init$1);
  }

  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(true, refDestructuringErrors);

  if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }

    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }

  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }

  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression(); // allow function declarations in branches, but only in non-strict mode

  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }

  this.next(); // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0); // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;

  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;

      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }

      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();

      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }

        sawDefault = true;
        cur.test = null;
      }

      this.expect(types.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }

      cur.consequent.push(this.parseStatement(null));
    }
  }

  this.exitScope();

  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }

  this.next(); // Closing brace

  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();

  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }

  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
}; // Reused empty array added for node fields that are always empty.


var empty$2 = [];

pp$1.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;

  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();

    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }

      clause.param = null;
      this.enterScope(0);
    }

    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }

  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }

  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }

  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];

    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }

  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;

  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];

    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }

  this.labels.push({
    name: maybeName,
    kind: kind,
    statementStart: this.start
  });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
}; // Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).


pp$1.parseBlock = function (createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node === void 0) node = this.startNode();
  node.body = [];
  this.expect(types.braceL);

  if (createNewLexicalScope) {
    this.enterScope(0);
  }

  while (this.type !== types.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }

  if (exitStrict) {
    this.strict = false;
  }

  this.next();

  if (createNewLexicalScope) {
    this.exitScope();
  }

  return this.finishNode(node, "BlockStatement");
}; // Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.


pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
}; // Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.


pp$1.parseForIn = function (node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
  } else if (init.type === "AssignmentPattern") {
    this.raise(init.start, "Invalid left-hand side in for-loop");
  }

  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
}; // Parse a list of variable declarations.


pp$1.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;

  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);

    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }

    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));

    if (!this.eat(types.comma)) {
      break;
    }
  }

  return node;
};

pp$1.parseVarId = function (decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1,
    FUNC_HANGING_STATEMENT = 2,
    FUNC_NULLABLE_ID = 4; // Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).
// Remove `allowExpressionBody` for 7.0.0, as it is only called with false

pp$1.parseFunction = function (node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);

  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }

    node.generator = this.eat(types.star);
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();

    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      {
        this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
      }
  }

  var oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types.name ? this.parseIdent() : null;
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
}; // Parse a class declaration or literal (depending on the
// `isStatement` parameter).


pp$1.parseClass = function (node, isStatement) {
  this.next(); // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.

  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);

  while (this.type !== types.braceR) {
    var element = this.parseClassElement(node.superClass !== null);

    if (element) {
      classBody.body.push(element);

      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raise(element.start, "Duplicate constructor in the same class");
        }

        hadConstructor = true;
      }
    }
  }

  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.parseClassElement = function (constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) {
    return null;
  }

  var method = this.startNode();

  var tryContextual = function (k, noLineBreak) {
    if (noLineBreak === void 0) noLineBreak = false;
    var start = this$1.start,
        startLoc = this$1.startLoc;

    if (!this$1.eatContextual(k)) {
      return false;
    }

    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {
      return true;
    }

    if (method.key) {
      this$1.unexpected();
    }

    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false;
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;

  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }

  if (!method.key) {
    this.parsePropertyName(method);
  }

  var key = method.key;
  var allowsDirectSuper = false;

  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") {
      this.raise(key.start, "Constructor can't have get/set modifier");
    }

    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }

    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }

    method.kind = "constructor";
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }

  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);

  if (method.kind === "get" && method.value.params.length !== 0) {
    this.raiseRecoverable(method.value.start, "getter should have no params");
  }

  if (method.kind === "set" && method.value.params.length !== 1) {
    this.raiseRecoverable(method.value.start, "setter should have exactly one param");
  }

  if (method.kind === "set" && method.value.params[0].type === "RestElement") {
    this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
  }

  return method;
};

pp$1.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition");
};

pp$1.parseClassId = function (node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();

    if (isStatement) {
      this.checkLVal(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }

    node.id = null;
  }
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
}; // Parses module export declaration.


pp$1.parseExport = function (node, exports) {
  this.next(); // export * from '...'

  if (this.eat(types.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node.exported = this.parseIdent(true);
        this.checkExport(exports, node.exported.name, this.lastTokStart);
      } else {
        node.exported = null;
      }
    }

    this.expectContextual("from");

    if (this.type !== types.string) {
      this.unexpected();
    }

    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }

  if (this.eat(types._default)) {
    // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;

    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();

      if (isAsync) {
        this.next();
      }

      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }

    return this.finishNode(node, "ExportDefaultDeclaration");
  } // export var|const|let|function|class ...


  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);

    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
    }

    node.specifiers = [];
    node.source = null;
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);

    if (this.eatContextual("from")) {
      if (this.type !== types.string) {
        this.unexpected();
      }

      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];
        this.checkUnreserved(spec.local); // check if export is defined

        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }

    this.semicolon();
  }

  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.checkExport = function (exports, name, pos) {
  if (!exports) {
    return;
  }

  if (has$1(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }

  exports[name] = true;
};

pp$1.checkPatternExport = function (exports, pat) {
  var type = pat.type;

  if (type === "Identifier") {
    this.checkExport(exports, pat.name, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};

pp$1.checkVariableExport = function (exports, decls) {
  if (!exports) {
    return;
  }

  for (var i = 0, list = decls; i < list.length; i += 1) {
    var decl = list[i];
    this.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function () {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
}; // Parses a comma-separated list of module exports.


pp$1.parseExportSpecifiers = function (exports) {
  var nodes = [],
      first = true; // export { x, y as z } [from '...']

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);

      if (this.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }

  return nodes;
}; // Parses import declaration.


pp$1.parseImport = function (node) {
  this.next(); // import '...'

  if (this.type === types.string) {
    node.specifiers = empty$2;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }

  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
}; // Parses a comma-separated list of module imports.


pp$1.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;

  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));

    if (!this.eat(types.comma)) {
      return nodes;
    }
  }

  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes;
  }

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);

      if (this.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);

    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }

    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }

  return nodes;
}; // Set `ExpressionStatement#directive` property for directive prologues.


pp$1.adaptDirectivePrologue = function (statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};

pp$1.isDirectiveCandidate = function (statement) {
  return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && ( // Reject parenthesized strings.
  this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};

var pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }

        break;

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";

        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }

        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.toAssignable(prop, isBinding); // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.

          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }

        break;

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }

        this.toAssignable(node.value, isBinding);
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";

        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }

        this.toAssignableList(node.elements, isBinding);
        break;

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);

        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }

        break;

      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }

        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

      case "AssignmentPattern":
        break;

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;

      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;

      case "MemberExpression":
        if (!isBinding) {
          break;
        }

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }

  return node;
}; // Convert list of expression atoms to binding list.


pp$2.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;

  for (var i = 0; i < end; i++) {
    var elt = exprList[i];

    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }

  if (end) {
    var last = exprList[end - 1];

    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }

  return exprList;
}; // Parses spread element.


pp$2.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRestBinding = function () {
  var node = this.startNode();
  this.next(); // RestElement inside of a function parameter must be an identifier

  if (this.options.ecmaVersion === 6 && this.type !== types.name) {
    this.unexpected();
  }

  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
}; // Parses lvalue (assignable) atom.


pp$2.parseBindingAtom = function () {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");

      case types.braceL:
        return this.parseObj(true);
    }
  }

  return this.parseIdent();
};

pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
  var elts = [],
      first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
    }

    if (allowEmpty && this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);

      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }

      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }

  return elts;
};

pp$2.parseBindingListItem = function (param) {
  return param;
}; // Parses assignment pattern around given atom if possible.


pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();

  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
    return left;
  }

  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
}; // Verify that a node is an lval  something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references


pp$2.checkLVal = function (expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;

  switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let") {
        this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
      }

      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }

      if (checkClashes) {
        if (has$1(checkClashes, expr.name)) {
          this.raiseRecoverable(expr.start, "Argument name clash");
        }

        checkClashes[expr.name] = true;
      }

      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) {
        this.declareName(expr.name, bindingType, expr.start);
      }

      break;

    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;

    case "MemberExpression":
      if (bindingType) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }

      break;

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.checkLVal(prop, bindingType, checkClashes);
      }

      break;

    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLVal(expr.value, bindingType, checkClashes);
      break;

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

        if (elem) {
          this.checkLVal(elem, bindingType, checkClashes);
        }
      }

      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break;

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
}; // A recursive descent parser operates by defining functions for all


var pp$3 = Parser.prototype; // Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }

  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }

  var key = prop.key;
  var name;

  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;

    case "Literal":
      name = String(key.value);
      break;

    default:
      return;
  }

  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          } // Backwards-compat kludge. Can be removed in version 6.0

        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }

      propHash.proto = true;
    }

    return;
  }

  name = "$" + name;
  var other = propHash[name];

  if (other) {
    var redefinition;

    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }

    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }

  other[kind] = true;
}; // ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).


pp$3.parseExpression = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);

  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];

    while (this.eat(types.comma)) {
      node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
    }

    return this.finishNode(node, "SequenceExpression");
  }

  return expr;
}; // Parse an assignment expression. This includes applications of
// operators like `+=`.


pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(noIn);
    } // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else {
        this.exprAllowed = false;
      }
  }

  var ownDestructuringErrors = false,
      oldParenAssign = -1,
      oldTrailingComma = -1;

  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }

  var startPos = this.start,
      startLoc = this.startLoc;

  if (this.type === types.parenL || this.type === types.name) {
    this.potentialArrowAt = this.start;
  }

  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);

  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }

  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;

    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }

    if (refDestructuringErrors.shorthandAssign >= node.left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    } // reset because shorthand default was used correctly


    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }

  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }

  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }

  return left;
}; // Parse a ternary conditional (`?:`) operator.


pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);

  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }

  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }

  return expr;
}; // Start the precedence parser.


pp$3.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);

  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }

  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
}; // Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.


pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;

  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var coalesce = this.type === types.coalesce;

      if (coalesce) {
        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
        prec = types.logicalAND.binop;
      }

      var op = this.value;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);

      if (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }

      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }

  return left;
};

pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
}; // Parse unary operators, both prefix and postfix.


pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var startPos = this.start,
      startLoc = this.startLoc,
      expr;

  if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (update) {
      this.checkLVal(node.argument);
    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else {
      sawUnary = true;
    }

    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);

    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }

    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar)) {
    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
  } else {
    return expr;
  }
}; // Parse call, dot, and `[]`-subscript expressions.


pp$3.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);

  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }

  var result = this.parseSubscripts(expr, startPos, startLoc);

  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }

    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
  }

  return result;
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;

  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);

    if (element.optional) {
      optionalChained = true;
    }

    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }

      return element;
    }

    base = element;
  }
};

pp$3.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types.questionDot);

  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }

  var computed = this.eat(types.bracketL);

  if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
    node.computed = !!computed;

    if (computed) {
      this.expect(types.bracketR);
    }

    if (optionalSupported) {
      node.optional = optional;
    }

    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(),
        oldYieldPos = this.yieldPos,
        oldAwaitPos = this.awaitPos,
        oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);

    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();

      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
    }

    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;

    if (optionalSupported) {
      node$1.optional = optional;
    }

    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }

    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({
      isTagged: true
    });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }

  return base;
}; // Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.


pp$3.parseExprAtom = function (refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) {
    this.readRegexp();
  }

  var node,
      canBeArrow = this.potentialArrowAt === this.start;

  switch (this.type) {
    case types._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }

      node = this.startNode();
      this.next();

      if (this.type === types.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      } // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super ( Arguments )


      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
        this.unexpected();
      }

      return this.finishNode(node, "Super");

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");

    case types.name:
      var startPos = this.start,
          startLoc = this.startLoc,
          containsEsc = this.containsEsc;
      var id = this.parseIdent(false);

      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
      }

      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
        }

        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);

          if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
            this.unexpected();
          }

          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
        }
      }

      return id;

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {
        pattern: value.pattern,
        flags: value.flags
      };
      return node;

    case types.num:
    case types.string:
      return this.parseLiteral(this.value);

    case types._null:
    case types._true:
    case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case types.parenL:
      var start = this.start,
          expr = this.parseParenAndDistinguishExpression(canBeArrow);

      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }

        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }

      return expr;

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);

    case types._class:
      return this.parseClass(this.startNode(), false);

    case types._new:
      return this.parseNew();

    case types.backQuote:
      return this.parseTemplate();

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport();
      } else {
        return this.unexpected();
      }

    default:
      this.unexpected();
  }
};

pp$3.parseExprImport = function () {
  var node = this.startNode(); // Consume `import` as an identifier for `import.meta`.
  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.

  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }

  var meta = this.parseIdent(true);

  switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node);

    case types.dot:
      node.meta = meta;
      return this.parseImportMeta(node);

    default:
      this.unexpected();
  }
};

pp$3.parseDynamicImport = function (node) {
  this.next(); // skip `(`
  // Parse node.source.

  node.source = this.parseMaybeAssign(); // Verify ending.

  if (!this.eat(types.parenR)) {
    var errorPos = this.start;

    if (this.eat(types.comma) && this.eat(types.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }

  return this.finishNode(node, "ImportExpression");
};

pp$3.parseImportMeta = function (node) {
  this.next(); // skip `.`

  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);

  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }

  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }

  if (this.options.sourceType !== "module") {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }

  return this.finishNode(node, "MetaProperty");
};

pp$3.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);

  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
  }

  this.next();
  return this.finishNode(node, "Literal");
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {
  var startPos = this.start,
      startLoc = this.startLoc,
      val,
      allowTrailingComma = this.options.ecmaVersion >= 8;

  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true,
        lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(),
        oldYieldPos = this.yieldPos,
        oldAwaitPos = this.awaitPos,
        spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0; // Do not save awaitIdentPos to allow checking awaits nested in parameters

    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);

      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));

        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }

        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }

    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }

    if (spreadStart) {
      this.unexpected(spreadStart);
    }

    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp$3.parseParenItem = function (item) {
  return item;
};

pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
}; // New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.


var empty$1$1 = [];

pp$3.parseNew = function () {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }

  var node = this.startNode();
  var meta = this.parseIdent(true);

  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }

    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }

    if (!this.inNonArrowFunction()) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions");
    }

    return this.finishNode(node, "MetaProperty");
  }

  var startPos = this.start,
      startLoc = this.startLoc,
      isImport = this.type === types._import;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);

  if (isImport && node.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }

  if (this.eat(types.parenL)) {
    node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty$1$1;
  }

  return this.finishNode(node, "NewExpression");
}; // Parse template expression.


pp$3.parseTemplateElement = function (ref) {
  var isTagged = ref.isTagged;
  var elem = this.startNode();

  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }

    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }

  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function (ref) {
  if (ref === void 0) ref = {};
  var isTagged = ref.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({
    isTagged: isTagged
  });
  node.quasis = [curElt];

  while (!curElt.tail) {
    if (this.type === types.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }

    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({
      isTagged: isTagged
    }));
  }

  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

pp$3.isAsyncProp = function (prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
}; // Parse an object literal or binding pattern.


pp$3.parseObj = function (isPattern, refDestructuringErrors) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();

  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);

      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) {
        break;
      }
    } else {
      first = false;
    }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);

    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }

    node.properties.push(prop);
  }

  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.parseProperty = function (isPattern, refDestructuringErrors) {
  var prop = this.startNode(),
      isGenerator,
      isAsync,
      startPos,
      startLoc;

  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);

      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }

      return this.finishNode(prop, "RestElement");
    } // To disallow parenthesized identifier via `this.toAssignable()`.


    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }

      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    } // Parse argument.


    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors); // To disallow trailing comma via `this.toAssignable()`.

    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    } // Finish


    return this.finishNode(prop, "SpreadElement");
  }

  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;

    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(types.star);
    }
  }

  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);

  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }

  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};

pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon) {
    this.unexpected();
  }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) {
      this.unexpected();
    }

    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }

    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;

    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;

      if (prop.kind === "get") {
        this.raiseRecoverable(start, "getter should have no params");
      } else {
        this.raiseRecoverable(start, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }

    this.checkUnreserved(prop.key);

    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }

    prop.kind = "init";

    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }

      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }

    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};

pp$3.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }

  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
}; // Initialize empty function node.


pp$3.initFunction = function (node) {
  node.id = null;

  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
}; // Parse object or class method.


pp$3.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(),
      oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);

  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
}; // Parse arrow function expression with given parameters.


pp$3.parseArrowExpression = function (node, params, isAsync) {
  var oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
}; // Parse function body and check parameters.


pp$3.parseFunctionBody = function (node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict,
      useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);

    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end); // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.

      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    } // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).


    var oldLabels = this.labels;
    this.labels = [];

    if (useStrict) {
      this.strict = true;
    } // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.


    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params)); // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'

    if (this.strict && node.id) {
      this.checkLVal(node.id, BIND_OUTSIDE);
    }

    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }

  this.exitScope();
};

pp$3.isSimpleParamList = function (params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
    var param = list[i];

    if (param.type !== "Identifier") {
      return false;
    }
  }

  return true;
}; // Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.


pp$3.checkParams = function (node, allowDuplicates) {
  var nameHash = {};

  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
}; // Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).


pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [],
      first = true;

  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);

      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }

    var elt = void 0;

    if (allowEmpty && this.type === types.comma) {
      elt = null;
    } else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);

      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }

    elts.push(elt);
  }

  return elts;
};

pp$3.checkUnreserved = function (ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }

  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }

  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }

  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }

  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;

  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }

    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
}; // Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.


pp$3.parseIdent = function (liberal, isBinding) {
  var node = this.startNode();

  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword; // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword

    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }

  this.next(!!liberal);
  this.finishNode(node, "Identifier");

  if (!liberal) {
    this.checkUnreserved(node);

    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }

  return node;
}; // Parses yield expression inside generator.


pp$3.parseYield = function (noIn) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }

  var node = this.startNode();
  this.next();

  if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }

  return this.finishNode(node, "YieldExpression");
};

pp$3.parseAwait = function () {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, false);
  return this.finishNode(node, "AwaitExpression");
};

var pp$4 = Parser.prototype; // This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function () {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};

var pp$5 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags; // A list of var-declared names in the current lexical scope

  this.var = []; // A list of lexically-declared names in the current lexical scope

  this.lexical = []; // A list of lexically-declared FunctionDeclaration names in the current lexical scope

  this.functions = [];
}; // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.


pp$5.enterScope = function (flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$5.exitScope = function () {
  this.scopeStack.pop();
}; // The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.


pp$5.treatFunctionsAsVarInScope = function (scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};

pp$5.declareName = function (name, bindingType, pos) {
  var redeclared = false;

  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);

    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();

    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }

    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];

      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }

      scope$3.var.push(name);

      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }

      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }

  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};

pp$5.checkLocalExport = function (id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$5.currentScope = function () {
  return this.scopeStack[this.scopeStack.length - 1];
};

pp$5.currentVarScope = function () {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];

    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
}; // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.


pp$5.currentThisScope = function () {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];

    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;

  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }

  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }

  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
}; // Start an AST node, attaching a start offset.


var pp$6 = Parser.prototype;

pp$6.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp$6.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
}; // Finish an AST node, adding `type` and `end` properties.


function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;

  if (this.options.locations) {
    node.loc.end = loc;
  }

  if (this.options.ranges) {
    node.range[1] = pos;
  }

  return node;
}

pp$6.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
}; // Finish node at given position


pp$6.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
}; // The algorithm used to determine whether a regexp can appear at a


var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$7 = Parser.prototype;

pp$7.initialContext = function () {
  return [types$1.b_stat];
};

pp$7.braceIsBlock = function (prevType) {
  var parent = this.curContext();

  if (parent === types$1.f_expr || parent === types$1.f_stat) {
    return true;
  }

  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
    return !parent.isExpr;
  } // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.


  if (prevType === types._return || prevType === types.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }

  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
    return true;
  }

  if (prevType === types.braceL) {
    return parent === types$1.b_stat;
  }

  if (prevType === types._var || prevType === types._const || prevType === types.name) {
    return false;
  }

  return !this.exprAllowed;
};

pp$7.inGeneratorContext = function () {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];

    if (context.token === "function") {
      return context.generator;
    }
  }

  return false;
};

pp$7.updateContext = function (prevType) {
  var update,
      type = this.type;

  if (type.keyword && prevType === types.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
}; // Token-specific context update code


types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }

  var out = this.context.pop();

  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }

  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function () {// tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
    this.context.push(types$1.f_expr);
  } else {
    this.context.push(types$1.f_stat);
  }

  this.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types$1.q_tmpl);
  }

  this.exprAllowed = false;
};

types.star.updateContext = function (prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;

    if (this.context[index] === types$1.f_expr) {
      this.context[index] = types$1.f_expr_gen;
    } else {
      this.context[index] = types$1.f_gen;
    }
  }

  this.exprAllowed = true;
};

types.name.updateContext = function (prevType) {
  var allowed = false;

  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }

  this.exprAllowed = allowed;
}; // This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)
// #table-binary-unicode-properties


var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties
}; // #table-unicode-general-category-values

var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu"; // #table-unicode-script-values

var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues
};
var data$1 = {};

function buildUnicodeData(ecmaVersion) {
  var d = data$1[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}

buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);
var pp$8 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.unicodeProperties = data$1[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
}; // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).


RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;

  if (i >= l) {
    return -1;
  }

  var c = s.charCodeAt(i);

  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c;
  }

  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;
};

RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;

  if (i >= l) {
    return l;
  }

  var c = s.charCodeAt(i),
      next;

  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1;
  }

  return i + 2;
};

RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};

RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};

RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};

RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;

  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }

  return false;
};

function codePointToString(ch) {
  if (ch <= 0xFFFF) {
    return String.fromCharCode(ch);
  }

  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);
}
/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */


pp$8.validateRegExpFlags = function (state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);

    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }

    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};
/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */


pp$8.validateRegExpPattern = function (state) {
  this.regexp_pattern(state); // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.

  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern


pp$8.regexp_pattern = function (state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29
    /* ) */
    )) {
      state.raise("Unmatched ')'");
    }

    if (state.eat(0x5D
    /* ] */
    ) || state.eat(0x7D
    /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }

  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }

  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction


pp$8.regexp_disjunction = function (state) {
  this.regexp_alternative(state);

  while (state.eat(0x7C
  /* | */
  )) {
    this.regexp_alternative(state);
  } // Make the same message as V8.


  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }

  if (state.eat(0x7B
  /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative


pp$8.regexp_alternative = function (state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term


pp$8.regexp_eatTerm = function (state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }

    return true;
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion


pp$8.regexp_eatAssertion = function (state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false; // ^, $

  if (state.eat(0x5E
  /* ^ */
  ) || state.eat(0x24
  /* $ */
  )) {
    return true;
  } // \b \B


  if (state.eat(0x5C
  /* \ */
  )) {
    if (state.eat(0x42
    /* B */
    ) || state.eat(0x62
    /* b */
    )) {
      return true;
    }

    state.pos = start;
  } // Lookahead / Lookbehind


  if (state.eat(0x28
  /* ( */
  ) && state.eat(0x3F
  /* ? */
  )) {
    var lookbehind = false;

    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C
      /* < */
      );
    }

    if (state.eat(0x3D
    /* = */
    ) || state.eat(0x21
    /* ! */
    )) {
      this.regexp_disjunction(state);

      if (!state.eat(0x29
      /* ) */
      )) {
        state.raise("Unterminated group");
      }

      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }

  state.pos = start;
  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier


pp$8.regexp_eatQuantifier = function (state, noError) {
  if (noError === void 0) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F
    /* ? */
    );
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix


pp$8.regexp_eatQuantifierPrefix = function (state, noError) {
  return state.eat(0x2A
  /* * */
  ) || state.eat(0x2B
  /* + */
  ) || state.eat(0x3F
  /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};

pp$8.regexp_eatBracedQuantifier = function (state, noError) {
  var start = state.pos;

  if (state.eat(0x7B
  /* { */
  )) {
    var min = 0,
        max = -1;

    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;

      if (state.eat(0x2C
      /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }

      if (state.eat(0x7D
      /* } */
      )) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }

        return true;
      }
    }

    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }

    state.pos = start;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom


pp$8.regexp_eatAtom = function (state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(0x2E
  /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};

pp$8.regexp_eatReverseSolidusAtomEscape = function (state) {
  var start = state.pos;

  if (state.eat(0x5C
  /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$8.regexp_eatUncapturingGroup = function (state) {
  var start = state.pos;

  if (state.eat(0x28
  /* ( */
  )) {
    if (state.eat(0x3F
    /* ? */
    ) && state.eat(0x3A
    /* : */
    )) {
      this.regexp_disjunction(state);

      if (state.eat(0x29
      /* ) */
      )) {
        return true;
      }

      state.raise("Unterminated group");
    }

    state.pos = start;
  }

  return false;
};

pp$8.regexp_eatCapturingGroup = function (state) {
  if (state.eat(0x28
  /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F
    /* ? */
    ) {
        state.raise("Invalid group");
      }

    this.regexp_disjunction(state);

    if (state.eat(0x29
    /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }

    state.raise("Unterminated group");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom


pp$8.regexp_eatExtendedAtom = function (state) {
  return state.eat(0x2E
  /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier


pp$8.regexp_eatInvalidBracedQuantifier = function (state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter


pp$8.regexp_eatSyntaxCharacter = function (state) {
  var ch = state.current();

  if (isSyntaxCharacter$1(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }

  return false;
};

function isSyntaxCharacter$1(ch) {
  return ch === 0x24
  /* $ */
  || ch >= 0x28
  /* ( */
  && ch <= 0x2B
  /* + */
  || ch === 0x2E
  /* . */
  || ch === 0x3F
  /* ? */
  || ch >= 0x5B
  /* [ */
  && ch <= 0x5E
  /* ^ */
  || ch >= 0x7B
  /* { */
  && ch <= 0x7D
  /* } */
  ;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.


pp$8.regexp_eatPatternCharacters = function (state) {
  var start = state.pos;
  var ch = 0;

  while ((ch = state.current()) !== -1 && !isSyntaxCharacter$1(ch)) {
    state.advance();
  }

  return state.pos !== start;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter


pp$8.regexp_eatExtendedPatternCharacter = function (state) {
  var ch = state.current();

  if (ch !== -1 && ch !== 0x24
  /* $ */
  && !(ch >= 0x28
  /* ( */
  && ch <= 0x2B
  /* + */
  ) && ch !== 0x2E
  /* . */
  && ch !== 0x3F
  /* ? */
  && ch !== 0x5B
  /* [ */
  && ch !== 0x5E
  /* ^ */
  && ch !== 0x7C
  /* | */
  ) {
      state.advance();
      return true;
    }

  return false;
}; // GroupSpecifier ::
//   [empty]
//   `?` GroupName


pp$8.regexp_groupSpecifier = function (state) {
  if (state.eat(0x3F
  /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }

      state.groupNames.push(state.lastStringValue);
      return;
    }

    state.raise("Invalid group");
  }
}; // GroupName ::
//   `<` RegExpIdentifierName `>`
// Note: this updates `state.lastStringValue` property with the eaten name.


pp$8.regexp_eatGroupName = function (state) {
  state.lastStringValue = "";

  if (state.eat(0x3C
  /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E
    /* > */
    )) {
      return true;
    }

    state.raise("Invalid capture group name");
  }

  return false;
}; // RegExpIdentifierName ::
//   RegExpIdentifierStart
//   RegExpIdentifierName RegExpIdentifierPart
// Note: this updates `state.lastStringValue` property with the eaten name.


pp$8.regexp_eatRegExpIdentifierName = function (state) {
  state.lastStringValue = "";

  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);

    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }

    return true;
  }

  return false;
}; // RegExpIdentifierStart ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]


pp$8.regexp_eatRegExpIdentifierStart = function (state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C
  /* \ */
  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }

  if (isRegExpIdentifierStart$1(ch)) {
    state.lastIntValue = ch;
    return true;
  }

  state.pos = start;
  return false;
};

function isRegExpIdentifierStart$1(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24
  /* $ */
  || ch === 0x5F;
  /* _ */
} // RegExpIdentifierPart ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
//   <ZWNJ>
//   <ZWJ>


pp$8.regexp_eatRegExpIdentifierPart = function (state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C
  /* \ */
  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }

  if (isRegExpIdentifierPart$1(ch)) {
    state.lastIntValue = ch;
    return true;
  }

  state.pos = start;
  return false;
};

function isRegExpIdentifierPart$1(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24
  /* $ */
  || ch === 0x5F
  /* _ */
  || ch === 0x200C
  /* <ZWNJ> */
  || ch === 0x200D;
  /* <ZWJ> */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape


pp$8.regexp_eatAtomEscape = function (state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }

  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63
    /* c */
    ) {
        state.raise("Invalid unicode escape");
      }

    state.raise("Invalid escape");
  }

  return false;
};

pp$8.regexp_eatBackReference = function (state) {
  var start = state.pos;

  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;

    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }

      return true;
    }

    if (n <= state.numCapturingParens) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$8.regexp_eatKGroupName = function (state) {
  if (state.eat(0x6B
  /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }

    state.raise("Invalid named reference");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape


pp$8.regexp_eatCharacterEscape = function (state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};

pp$8.regexp_eatCControlLetter = function (state) {
  var start = state.pos;

  if (state.eat(0x63
  /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }

    state.pos = start;
  }

  return false;
};

pp$8.regexp_eatZero = function (state) {
  if (state.current() === 0x30
  /* 0 */
  && !isDecimalDigit$1(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape


pp$8.regexp_eatControlEscape = function (state) {
  var ch = state.current();

  if (ch === 0x74
  /* t */
  ) {
      state.lastIntValue = 0x09;
      /* \t */

      state.advance();
      return true;
    }

  if (ch === 0x6E
  /* n */
  ) {
      state.lastIntValue = 0x0A;
      /* \n */

      state.advance();
      return true;
    }

  if (ch === 0x76
  /* v */
  ) {
      state.lastIntValue = 0x0B;
      /* \v */

      state.advance();
      return true;
    }

  if (ch === 0x66
  /* f */
  ) {
      state.lastIntValue = 0x0C;
      /* \f */

      state.advance();
      return true;
    }

  if (ch === 0x72
  /* r */
  ) {
      state.lastIntValue = 0x0D;
      /* \r */

      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter


pp$8.regexp_eatControlLetter = function (state) {
  var ch = state.current();

  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true;
  }

  return false;
};

function isControlLetter(ch) {
  return ch >= 0x41
  /* A */
  && ch <= 0x5A
  /* Z */
  || ch >= 0x61
  /* a */
  && ch <= 0x7A
  /* z */
  ;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence


pp$8.regexp_eatRegExpUnicodeEscapeSequence = function (state, forceU) {
  if (forceU === void 0) forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;

  if (state.eat(0x75
  /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;

      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;

        if (state.eat(0x5C
        /* \ */
        ) && state.eat(0x75
        /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;

          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true;
          }
        }

        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }

      return true;
    }

    if (switchU && state.eat(0x7B
    /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(0x7D
    /* } */
    ) && isValidUnicode$1(state.lastIntValue)) {
      return true;
    }

    if (switchU) {
      state.raise("Invalid unicode escape");
    }

    state.pos = start;
  }

  return false;
};

function isValidUnicode$1(ch) {
  return ch >= 0 && ch <= 0x10FFFF;
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape


pp$8.regexp_eatIdentityEscape = function (state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }

    if (state.eat(0x2F
    /* / */
    )) {
      state.lastIntValue = 0x2F;
      /* / */

      return true;
    }

    return false;
  }

  var ch = state.current();

  if (ch !== 0x63
  /* c */
  && (!state.switchN || ch !== 0x6B
  /* k */
  )) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape


pp$8.regexp_eatDecimalEscape = function (state) {
  state.lastIntValue = 0;
  var ch = state.current();

  if (ch >= 0x31
  /* 1 */
  && ch <= 0x39
  /* 9 */
  ) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30
        /* 0 */
        );
        state.advance();
      } while ((ch = state.current()) >= 0x30
      /* 0 */
      && ch <= 0x39
      /* 9 */
      );

      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape


pp$8.regexp_eatCharacterClassEscape = function (state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true;
  }

  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50
  /* P */
  || ch === 0x70
  /* p */
  )) {
    state.lastIntValue = -1;
    state.advance();

    if (state.eat(0x7B
    /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D
    /* } */
    )) {
      return true;
    }

    state.raise("Invalid property name");
  }

  return false;
};

function isCharacterClassEscape(ch) {
  return ch === 0x64
  /* d */
  || ch === 0x44
  /* D */
  || ch === 0x73
  /* s */
  || ch === 0x53
  /* S */
  || ch === 0x77
  /* w */
  || ch === 0x57
  /* W */
  ;
} // UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue


pp$8.regexp_eatUnicodePropertyValueExpression = function (state) {
  var start = state.pos; // UnicodePropertyName `=` UnicodePropertyValue

  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D
  /* = */
  )) {
    var name = state.lastStringValue;

    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true;
    }
  }

  state.pos = start; // LoneUnicodePropertyNameOrValue

  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true;
  }

  return false;
};

pp$8.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
  if (!has$1(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }

  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};

pp$8.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue)) {
    state.raise("Invalid property name");
  }
}; // UnicodePropertyName ::
//   UnicodePropertyNameCharacters


pp$8.regexp_eatUnicodePropertyName = function (state) {
  var ch = 0;
  state.lastStringValue = "";

  while (isUnicodePropertyNameCharacter$1(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }

  return state.lastStringValue !== "";
};

function isUnicodePropertyNameCharacter$1(ch) {
  return isControlLetter(ch) || ch === 0x5F;
  /* _ */
} // UnicodePropertyValue ::
//   UnicodePropertyValueCharacters


pp$8.regexp_eatUnicodePropertyValue = function (state) {
  var ch = 0;
  state.lastStringValue = "";

  while (isUnicodePropertyValueCharacter$1(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }

  return state.lastStringValue !== "";
};

function isUnicodePropertyValueCharacter$1(ch) {
  return isUnicodePropertyNameCharacter$1(ch) || isDecimalDigit$1(ch);
} // LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters


pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
  return this.regexp_eatUnicodePropertyValue(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass


pp$8.regexp_eatCharacterClass = function (state) {
  if (state.eat(0x5B
  /* [ */
  )) {
    state.eat(0x5E
    /* ^ */
    );
    this.regexp_classRanges(state);

    if (state.eat(0x5D
    /* ] */
    )) {
      return true;
    } // Unreachable since it threw "unterminated regular expression" error before.


    state.raise("Unterminated character class");
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash


pp$8.regexp_classRanges = function (state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;

    if (state.eat(0x2D
    /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;

      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }

      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash


pp$8.regexp_eatClassAtom = function (state) {
  var start = state.pos;

  if (state.eat(0x5C
  /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }

    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();

      if (ch$1 === 0x63
      /* c */
      || isOctalDigit$1(ch$1)) {
        state.raise("Invalid class escape");
      }

      state.raise("Invalid escape");
    }

    state.pos = start;
  }

  var ch = state.current();

  if (ch !== 0x5D
  /* ] */
  ) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape


pp$8.regexp_eatClassEscape = function (state) {
  var start = state.pos;

  if (state.eat(0x62
  /* b */
  )) {
    state.lastIntValue = 0x08;
    /* <BS> */

    return true;
  }

  if (state.switchU && state.eat(0x2D
  /* - */
  )) {
    state.lastIntValue = 0x2D;
    /* - */

    return true;
  }

  if (!state.switchU && state.eat(0x63
  /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }

    state.pos = start;
  }

  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter


pp$8.regexp_eatClassControlLetter = function (state) {
  var ch = state.current();

  if (isDecimalDigit$1(ch) || ch === 0x5F
  /* _ */
  ) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true;
    }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence


pp$8.regexp_eatHexEscapeSequence = function (state) {
  var start = state.pos;

  if (state.eat(0x78
  /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }

    if (state.switchU) {
      state.raise("Invalid escape");
    }

    state.pos = start;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits


pp$8.regexp_eatDecimalDigits = function (state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;

  while (isDecimalDigit$1(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30
    /* 0 */
    );
    state.advance();
  }

  return state.pos !== start;
};

function isDecimalDigit$1(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x39;
  /* 9 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits


pp$8.regexp_eatHexDigits = function (state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;

  while (isHexDigit$1(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }

  return state.pos !== start;
};

function isHexDigit$1(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x39
  /* 9 */
  || ch >= 0x41
  /* A */
  && ch <= 0x46
  /* F */
  || ch >= 0x61
  /* a */
  && ch <= 0x66
  /* f */
  ;
}

function hexToInt(ch) {
  if (ch >= 0x41
  /* A */
  && ch <= 0x46
  /* F */
  ) {
      return 10 + (ch - 0x41
      /* A */
      );
    }

  if (ch >= 0x61
  /* a */
  && ch <= 0x66
  /* f */
  ) {
      return 10 + (ch - 0x61
      /* a */
      );
    }

  return ch - 0x30;
  /* 0 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).


pp$8.regexp_eatLegacyOctalEscapeSequence = function (state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;

    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;

      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }

    return true;
  }

  return false;
}; // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit


pp$8.regexp_eatOctalDigit = function (state) {
  var ch = state.current();

  if (isOctalDigit$1(ch)) {
    state.lastIntValue = ch - 0x30;
    /* 0 */

    state.advance();
    return true;
  }

  state.lastIntValue = 0;
  return false;
};

function isOctalDigit$1(ch) {
  return ch >= 0x30
  /* 0 */
  && ch <= 0x37;
  /* 7 */
} // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence


pp$8.regexp_eatFixedHexDigits = function (state, length) {
  var start = state.pos;
  state.lastIntValue = 0;

  for (var i = 0; i < length; ++i) {
    var ch = state.current();

    if (!isHexDigit$1(ch)) {
      state.pos = start;
      return false;
    }

    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }

  return true;
}; // Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.


var Token$1 = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;

  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }

  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
}; // ## Tokenizer


var pp$9 = Parser.prototype; // Move to the next token

pp$9.next = function (ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }

  if (this.options.onToken) {
    this.options.onToken(new Token$1(this));
  }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$9.getToken = function () {
  this.next();
  return new Token$1(this);
}; // If we're in an ES6 environment, make parsers iterable


if (typeof Symbol !== "undefined") {
  pp$9[Symbol.iterator] = function () {
    var this$1 = this;
    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        };
      }
    };
  };
} // Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).


pp$9.curContext = function () {
  return this.context[this.context.length - 1];
}; // Read a single token, updating the parser object's token-related
// properties.


pp$9.nextToken = function () {
  var curContext = this.curContext();

  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }

  this.start = this.pos;

  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }

  if (this.pos >= this.input.length) {
    return this.finishToken(types.eof);
  }

  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};

pp$9.readToken = function (code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92
  /* '\' */
  ) {
      return this.readWord();
    }

  return this.getTokenFromCode(code);
};

pp$9.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);

  if (code <= 0xd7ff || code >= 0xe000) {
    return code;
  }

  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp$9.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);

  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }

  this.pos = end + 2;

  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;

    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }

  if (this.options.onComment) {
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  }
};

pp$9.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);

  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }

  if (this.options.onComment) {
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  }
}; // Called at the start of the parse and after every token. Skips
// whitespace and comments, and.


pp$9.skipSpace = function () {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);

    switch (ch) {
      case 32:
      case 160:
        // ' '
        ++this.pos;
        break;

      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }

      case 10:
      case 8232:
      case 8233:
        ++this.pos;

        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }

        break;

      case 47:
        // '/'
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            // '*'
            this.skipBlockComment();
            break;

          case 47:
            this.skipLineComment(2);
            break;

          default:
            break loop;
        }

        break;

      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }

    }
  }
}; // Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.


pp$9.finishToken = function (type, val) {
  this.end = this.pos;

  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }

  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
}; // ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//


pp$9.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);

  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }

  var next2 = this.input.charCodeAt(this.pos + 2);

  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types.dot);
  }
};

pp$9.readToken_slash = function () {
  // '/'
  var next = this.input.charCodeAt(this.pos + 1);

  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.slash, 1);
};

pp$9.readToken_mult_modulo_exp = function (code) {
  // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo; // exponentiation operator ** and **=

  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, size + 1);
  }

  return this.finishOp(tokentype, size);
};

pp$9.readToken_pipe_amp = function (code) {
  // '|&'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);

      if (next2 === 61) {
        return this.finishOp(types.assign, 3);
      }
    }

    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
};

pp$9.readToken_caret = function () {
  // '^'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.bitwiseXOR, 1);
};

pp$9.readToken_plus_min = function (code) {
  // '+-'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }

    return this.finishOp(types.incDec, 2);
  }

  if (next === 61) {
    return this.finishOp(types.assign, 2);
  }

  return this.finishOp(types.plusMin, 1);
};

pp$9.readToken_lt_gt = function (code) {
  // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;

  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;

    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types.assign, size + 1);
    }

    return this.finishOp(types.bitShift, size);
  }

  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }

  if (next === 61) {
    size = 2;
  }

  return this.finishOp(types.relational, size);
};

pp$9.readToken_eq_excl = function (code) {
  // '=!'
  var next = this.input.charCodeAt(this.pos + 1);

  if (next === 61) {
    return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }

  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow);
  }

  return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
};

pp$9.readToken_question = function () {
  // '?'
  var ecmaVersion = this.options.ecmaVersion;

  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);

    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);

      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types.questionDot, 2);
      }
    }

    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);

        if (next2$1 === 61) {
          return this.finishOp(types.assign, 3);
        }
      }

      return this.finishOp(types.coalesce, 2);
    }
  }

  return this.finishOp(types.question, 1);
};

pp$9.getTokenFromCode = function (code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      // '.'
      return this.readToken_dot();
    // Punctuation tokens.

    case 40:
      ++this.pos;
      return this.finishToken(types.parenL);

    case 41:
      ++this.pos;
      return this.finishToken(types.parenR);

    case 59:
      ++this.pos;
      return this.finishToken(types.semi);

    case 44:
      ++this.pos;
      return this.finishToken(types.comma);

    case 91:
      ++this.pos;
      return this.finishToken(types.bracketL);

    case 93:
      ++this.pos;
      return this.finishToken(types.bracketR);

    case 123:
      ++this.pos;
      return this.finishToken(types.braceL);

    case 125:
      ++this.pos;
      return this.finishToken(types.braceR);

    case 58:
      ++this.pos;
      return this.finishToken(types.colon);

    case 96:
      // '`'
      if (this.options.ecmaVersion < 6) {
        break;
      }

      ++this.pos;
      return this.finishToken(types.backQuote);

    case 48:
      // '0'
      var next = this.input.charCodeAt(this.pos + 1);

      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      } // '0x', '0X' - hex number


      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        } // '0o', '0O' - octal number


        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        } // '0b', '0B' - binary number

      }

    // Anything else beginning with a digit is an integer, octal
    // number, or float.

    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      // 1-9
      return this.readNumber(false);
    // Quotes produce strings.

    case 34:
    case 39:
      // '"', "'"
      return this.readString(code);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47:
      // '/'
      return this.readToken_slash();

    case 37:
    case 42:
      // '%*'
      return this.readToken_mult_modulo_exp(code);

    case 124:
    case 38:
      // '|&'
      return this.readToken_pipe_amp(code);

    case 94:
      // '^'
      return this.readToken_caret();

    case 43:
    case 45:
      // '+-'
      return this.readToken_plus_min(code);

    case 60:
    case 62:
      // '<>'
      return this.readToken_lt_gt(code);

    case 61:
    case 33:
      // '=!'
      return this.readToken_eq_excl(code);

    case 63:
      // '?'
      return this.readToken_question();

    case 126:
      // '~'
      return this.finishOp(types.prefix, 1);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};

pp$9.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};

pp$9.readRegexp = function () {
  var escaped,
      inClass,
      start = this.pos;

  for (;;) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }

    var ch = this.input.charAt(this.pos);

    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }

    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }

      escaped = ch === "\\";
    } else {
      escaped = false;
    }

    ++this.pos;
  }

  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();

  if (this.containsEsc) {
    this.unexpected(flagsStart);
  } // Validate pattern


  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state); // Create Literal#value property value.

  var value = null;

  try {
    value = new RegExp(pattern, flags);
  } catch (e) {// ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {
    pattern: pattern,
    flags: flags,
    value: value
  });
}; // Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.


pp$9.readInt = function (radix, len, maybeLegacyOctalNumericLiteral) {
  // `len` is used for character escape sequences. In that case, disallow separators.
  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined; // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
  // and isn't fraction part nor exponent part. In that case, if the first digit
  // is zero then disallow separators.

  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos,
      total = 0,
      lastCode = 0;

  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos),
        val = void 0;

    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }

      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }

      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }

      lastCode = code;
      continue;
    }

    if (code >= 97) {
      val = code - 97 + 10;
    } // a
    else if (code >= 65) {
        val = code - 65 + 10;
      } // A
      else if (code >= 48 && code <= 57) {
          val = code - 48;
        } // 0-9
        else {
            val = Infinity;
          }

    if (val >= radix) {
      break;
    }

    lastCode = code;
    total = total * radix + val;
  }

  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }

  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }

  return total;
};

function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  } // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.


  return parseFloat(str.replace(/_/g, ""));
}

function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  } // `BigInt(value)` throws syntax error if the string contains numeric separators.


  return BigInt(str.replace(/_/g, ""));
}

pp$9.readRadixNumber = function (radix) {
  var start = this.pos;
  this.pos += 2; // 0x

  var val = this.readInt(radix);

  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }

  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }

  return this.finishToken(types.num, val);
}; // Read an integer, octal integer, or floating-point number.


pp$9.readNumber = function (startsWithDot) {
  var start = this.pos;

  if (!startsWithDot && this.readInt(10, undefined, true) === null) {
    this.raise(start, "Invalid number");
  }

  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;

  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }

  var next = this.input.charCodeAt(this.pos);

  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;

    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }

    return this.finishToken(types.num, val$1);
  }

  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }

  if (next === 46 && !octal) {
    // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }

  if ((next === 69 || next === 101) && !octal) {
    // 'eE'
    next = this.input.charCodeAt(++this.pos);

    if (next === 43 || next === 45) {
      ++this.pos;
    } // '+-'


    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }

  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }

  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types.num, val);
}; // Read a string value, interpreting backslash-escapes.


pp$9.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code;

  if (ch === 123) {
    // '{'
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }

    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;

    if (code > 0x10FFFF) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }

  return code;
};

function codePointToString$1(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  }

  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp$9.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;

  for (;;) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }

    var ch = this.input.charCodeAt(this.pos);

    if (ch === quote) {
      break;
    }

    if (ch === 92) {
      // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion >= 10)) {
        this.raise(this.start, "Unterminated string constant");
      }

      ++this.pos;
    }
  }

  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out);
}; // Reads template string tokens.


var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function () {
  this.inTemplateElement = true;

  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }

  this.inTemplateElement = false;
};

pp$9.invalidStringToken = function (position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};

pp$9.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;

  for (;;) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }

    var ch = this.input.charCodeAt(this.pos);

    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      // '`', '${'
      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote);
        }
      }

      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out);
    }

    if (ch === 92) {
      // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;

      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }

        case 10:
          out += "\n";
          break;

        default:
          out += String.fromCharCode(ch);
          break;
      }

      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }

      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
}; // Reads a template token to search for the end, without validating any escape sequences


pp$9.readInvalidTemplateToken = function () {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }

      // falls through

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
      // no default
    }
  }

  this.raise(this.start, "Unterminated template");
}; // Used to read escaped characters


pp$9.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;

  switch (ch) {
    case 110:
      return "\n";
    // 'n' -> '\n'

    case 114:
      return "\r";
    // 'r' -> '\r'

    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'

    case 117:
      return codePointToString$1(this.readCodePoint());
    // 'u'

    case 116:
      return "\t";
    // 't' -> '\t'

    case 98:
      return "\b";
    // 'b' -> '\b'

    case 118:
      return "\u000b";
    // 'v' -> '\u000b'

    case 102:
      return "\f";
    // 'f' -> '\f'

    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }

    // '\r\n'

    case 10:
      // ' \n'
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }

      return "";

    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(codePos, "Invalid escape sequence in template string");
        return null;
      }

    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);

        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }

        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);

        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
        }

        return String.fromCharCode(octal);
      }

      if (isNewLine(ch)) {
        // Unicode new line characters after \ get removed from output in both
        // template literals and strings
        return "";
      }

      return String.fromCharCode(ch);
  }
}; // Used to read character escape sequences ('\x', '\u', '\U').


pp$9.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);

  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }

  return n;
}; // Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.


pp$9.readWord1 = function () {
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;

  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();

    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;

      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        {
          this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

      ++this.pos;
      var esc = this.readCodePoint();

      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }

      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break;
    }

    first = false;
  }

  return word + this.input.slice(chunkStart, this.pos);
}; // Read an identifier or keyword token. Will check for reserved
// words when necessary.


pp$9.readWord = function () {
  var word = this.readWord1();
  var type = types.name;

  if (this.keywords.test(word)) {
    type = keywords$1$1[word];
  }

  return this.finishToken(type, word);
}; // Acorn is a tiny, fast JavaScript parser written in JavaScript.


var version$3 = "7.4.1";
Parser.acorn = {
  Parser: Parser,
  version: version$3,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types,
  keywordTypes: keywords$1$1,
  TokContext: TokContext,
  tokContexts: types$1,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  Token: Token$1,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
}; // The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse$3(input, options) {
  return Parser.parse(input, options);
} // This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.


function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options);
} // Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.


function tokenizer(input, options) {
  return Parser.tokenizer(input, options);
}

var acorn$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Node: Node,
  Parser: Parser,
  Position: Position,
  SourceLocation: SourceLocation,
  TokContext: TokContext,
  Token: Token$1,
  TokenType: TokenType,
  defaultOptions: defaultOptions,
  getLineInfo: getLineInfo,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart,
  isNewLine: isNewLine,
  keywordTypes: keywords$1$1,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace,
  parse: parse$3,
  parseExpressionAt: parseExpressionAt,
  tokContexts: types$1,
  tokTypes: types,
  tokenizer: tokenizer,
  version: version$3
});

var xhtml = {
  quot: '\u0022',
  amp: '&',
  apos: '\u0027',
  lt: '<',
  gt: '>',
  nbsp: '\u00A0',
  iexcl: '\u00A1',
  cent: '\u00A2',
  pound: '\u00A3',
  curren: '\u00A4',
  yen: '\u00A5',
  brvbar: '\u00A6',
  sect: '\u00A7',
  uml: '\u00A8',
  copy: '\u00A9',
  ordf: '\u00AA',
  laquo: '\u00AB',
  not: '\u00AC',
  shy: '\u00AD',
  reg: '\u00AE',
  macr: '\u00AF',
  deg: '\u00B0',
  plusmn: '\u00B1',
  sup2: '\u00B2',
  sup3: '\u00B3',
  acute: '\u00B4',
  micro: '\u00B5',
  para: '\u00B6',
  middot: '\u00B7',
  cedil: '\u00B8',
  sup1: '\u00B9',
  ordm: '\u00BA',
  raquo: '\u00BB',
  frac14: '\u00BC',
  frac12: '\u00BD',
  frac34: '\u00BE',
  iquest: '\u00BF',
  Agrave: '\u00C0',
  Aacute: '\u00C1',
  Acirc: '\u00C2',
  Atilde: '\u00C3',
  Auml: '\u00C4',
  Aring: '\u00C5',
  AElig: '\u00C6',
  Ccedil: '\u00C7',
  Egrave: '\u00C8',
  Eacute: '\u00C9',
  Ecirc: '\u00CA',
  Euml: '\u00CB',
  Igrave: '\u00CC',
  Iacute: '\u00CD',
  Icirc: '\u00CE',
  Iuml: '\u00CF',
  ETH: '\u00D0',
  Ntilde: '\u00D1',
  Ograve: '\u00D2',
  Oacute: '\u00D3',
  Ocirc: '\u00D4',
  Otilde: '\u00D5',
  Ouml: '\u00D6',
  times: '\u00D7',
  Oslash: '\u00D8',
  Ugrave: '\u00D9',
  Uacute: '\u00DA',
  Ucirc: '\u00DB',
  Uuml: '\u00DC',
  Yacute: '\u00DD',
  THORN: '\u00DE',
  szlig: '\u00DF',
  agrave: '\u00E0',
  aacute: '\u00E1',
  acirc: '\u00E2',
  atilde: '\u00E3',
  auml: '\u00E4',
  aring: '\u00E5',
  aelig: '\u00E6',
  ccedil: '\u00E7',
  egrave: '\u00E8',
  eacute: '\u00E9',
  ecirc: '\u00EA',
  euml: '\u00EB',
  igrave: '\u00EC',
  iacute: '\u00ED',
  icirc: '\u00EE',
  iuml: '\u00EF',
  eth: '\u00F0',
  ntilde: '\u00F1',
  ograve: '\u00F2',
  oacute: '\u00F3',
  ocirc: '\u00F4',
  otilde: '\u00F5',
  ouml: '\u00F6',
  divide: '\u00F7',
  oslash: '\u00F8',
  ugrave: '\u00F9',
  uacute: '\u00FA',
  ucirc: '\u00FB',
  uuml: '\u00FC',
  yacute: '\u00FD',
  thorn: '\u00FE',
  yuml: '\u00FF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  'int': '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666'
};

var acorn = /*@__PURE__*/getAugmentedNamespace(acorn$1);

var acornJsx = createCommonjsModule$1(function (module) {



const hexNumber = /^[\da-fA-F]+$/;
const decimalNumber = /^\d+$/; // The map to `acorn-jsx` tokens from `acorn` namespace objects.

const acornJsxMap = new WeakMap(); // Get the original tokens for the given `acorn` namespace object.

function getJsxTokens(acorn) {
  acorn = acorn.Parser.acorn || acorn;
  let acornJsx = acornJsxMap.get(acorn);

  if (!acornJsx) {
    const tt = acorn.tokTypes;
    const TokContext = acorn.TokContext;
    const TokenType = acorn.TokenType;
    const tc_oTag = new TokContext('<tag', false);
    const tc_cTag = new TokContext('</tag', false);
    const tc_expr = new TokContext('<tag>...</tag>', true, true);
    const tokContexts = {
      tc_oTag: tc_oTag,
      tc_cTag: tc_cTag,
      tc_expr: tc_expr
    };
    const tokTypes = {
      jsxName: new TokenType('jsxName'),
      jsxText: new TokenType('jsxText', {
        beforeExpr: true
      }),
      jsxTagStart: new TokenType('jsxTagStart', {
        startsExpr: true
      }),
      jsxTagEnd: new TokenType('jsxTagEnd')
    };

    tokTypes.jsxTagStart.updateContext = function () {
      this.context.push(tc_expr); // treat as beginning of JSX expression

      this.context.push(tc_oTag); // start opening tag context

      this.exprAllowed = false;
    };

    tokTypes.jsxTagEnd.updateContext = function (prevType) {
      let out = this.context.pop();

      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
        this.context.pop();
        this.exprAllowed = this.curContext() === tc_expr;
      } else {
        this.exprAllowed = true;
      }
    };

    acornJsx = {
      tokContexts: tokContexts,
      tokTypes: tokTypes
    };
    acornJsxMap.set(acorn, acornJsx);
  }

  return acornJsx;
} // Transforms JSX element name to string.


function getQualifiedJSXName(object) {
  if (!object) return object;
  if (object.type === 'JSXIdentifier') return object.name;
  if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;
  if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);
}

module.exports = function (options) {
  options = options || {};
  return function (Parser) {
    return plugin({
      allowNamespaces: options.allowNamespaces !== false,
      allowNamespacedObjects: !!options.allowNamespacedObjects
    }, Parser);
  };
}; // This is `tokTypes` of the peer dep.
// This can be different instances from the actual `tokTypes` this plugin uses.


Object.defineProperty(module.exports, "tokTypes", {
  get: function get_tokTypes() {
    return getJsxTokens(acorn).tokTypes;
  },
  configurable: true,
  enumerable: true
});

function plugin(options, Parser) {
  const acorn$1 = Parser.acorn || acorn;

  const acornJsx = getJsxTokens(acorn$1);
  const tt = acorn$1.tokTypes;
  const tok = acornJsx.tokTypes;
  const tokContexts = acorn$1.tokContexts;
  const tc_oTag = acornJsx.tokContexts.tc_oTag;
  const tc_cTag = acornJsx.tokContexts.tc_cTag;
  const tc_expr = acornJsx.tokContexts.tc_expr;
  const isNewLine = acorn$1.isNewLine;
  const isIdentifierStart = acorn$1.isIdentifierStart;
  const isIdentifierChar = acorn$1.isIdentifierChar;
  return class extends Parser {
    // Expose actual `tokTypes` and `tokContexts` to other plugins.
    static get acornJsx() {
      return acornJsx;
    } // Reads inline JSX contents token.


    jsx_readToken() {
      let out = '',
          chunkStart = this.pos;

      for (;;) {
        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');
        let ch = this.input.charCodeAt(this.pos);

        switch (ch) {
          case 60: // '<'

          case 123:
            // '{'
            if (this.pos === this.start) {
              if (ch === 60 && this.exprAllowed) {
                ++this.pos;
                return this.finishToken(tok.jsxTagStart);
              }

              return this.getTokenFromCode(ch);
            }

            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(tok.jsxText, out);

          case 38:
            // '&'
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readEntity();
            chunkStart = this.pos;
            break;

          case 62: // '>'

          case 125:
            // '}'
            this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + "` or " + "`{\"" + this.input[this.pos] + "\"}" + "`?");

          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(true);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }

        }
      }
    }

    jsx_readNewLine(normalizeCRLF) {
      let ch = this.input.charCodeAt(this.pos);
      let out;
      ++this.pos;

      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
        out = normalizeCRLF ? '\n' : '\r\n';
      } else {
        out = String.fromCharCode(ch);
      }

      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }

      return out;
    }

    jsx_readString(quote) {
      let out = '',
          chunkStart = ++this.pos;

      for (;;) {
        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');
        let ch = this.input.charCodeAt(this.pos);
        if (ch === quote) break;

        if (ch === 38) {
          // '&'
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readEntity();
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readNewLine(false);
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }

      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(tt.string, out);
    }

    jsx_readEntity() {
      let str = '',
          count = 0,
          entity;
      let ch = this.input[this.pos];
      if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');
      let startPos = ++this.pos;

      while (this.pos < this.input.length && count++ < 10) {
        ch = this.input[this.pos++];

        if (ch === ';') {
          if (str[0] === '#') {
            if (str[1] === 'x') {
              str = str.substr(2);
              if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));
            } else {
              str = str.substr(1);
              if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));
            }
          } else {
            entity = xhtml[str];
          }

          break;
        }

        str += ch;
      }

      if (!entity) {
        this.pos = startPos;
        return '&';
      }

      return entity;
    } // Read a JSX identifier (valid tag or attribute name).
    //
    // Optimized version since JSX identifiers can't contain
    // escape characters and so can be read as single slice.
    // Also assumes that first character was already checked
    // by isIdentifierStart in readToken.


    jsx_readWord() {
      let ch,
          start = this.pos;

      do {
        ch = this.input.charCodeAt(++this.pos);
      } while (isIdentifierChar(ch) || ch === 45); // '-'


      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
    } // Parse next token as JSX identifier


    jsx_parseIdentifier() {
      let node = this.startNode();
      if (this.type === tok.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();
      this.next();
      return this.finishNode(node, 'JSXIdentifier');
    } // Parse namespaced identifier.


    jsx_parseNamespacedName() {
      let startPos = this.start,
          startLoc = this.startLoc;
      let name = this.jsx_parseIdentifier();
      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;
      var node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsx_parseIdentifier();
      return this.finishNode(node, 'JSXNamespacedName');
    } // Parses element name in any form - namespaced, member
    // or single identifier.


    jsx_parseElementName() {
      if (this.type === tok.jsxTagEnd) return '';
      let startPos = this.start,
          startLoc = this.startLoc;
      let node = this.jsx_parseNamespacedName();

      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {
        this.unexpected();
      }

      while (this.eat(tt.dot)) {
        let newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsx_parseIdentifier();
        node = this.finishNode(newNode, 'JSXMemberExpression');
      }

      return node;
    } // Parses any type of JSX attribute value.


    jsx_parseAttributeValue() {
      switch (this.type) {
        case tt.braceL:
          let node = this.jsx_parseExpressionContainer();
          if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
          return node;

        case tok.jsxTagStart:
        case tt.string:
          return this.parseExprAtom();

        default:
          this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
      }
    } // JSXEmptyExpression is unique type since it doesn't actually parse anything,
    // and so it should start at the end of last read token (left brace) and finish
    // at the beginning of the next one (right brace).


    jsx_parseEmptyExpression() {
      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
    } // Parses JSX expression enclosed into curly brackets.


    jsx_parseExpressionContainer() {
      let node = this.startNode();
      this.next();
      node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
      this.expect(tt.braceR);
      return this.finishNode(node, 'JSXExpressionContainer');
    } // Parses following JSX attribute name-value pair.


    jsx_parseAttribute() {
      let node = this.startNode();

      if (this.eat(tt.braceL)) {
        this.expect(tt.ellipsis);
        node.argument = this.parseMaybeAssign();
        this.expect(tt.braceR);
        return this.finishNode(node, 'JSXSpreadAttribute');
      }

      node.name = this.jsx_parseNamespacedName();
      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
      return this.finishNode(node, 'JSXAttribute');
    } // Parses JSX opening tag starting after '<'.


    jsx_parseOpeningElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      node.attributes = [];
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;

      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());

      node.selfClosing = this.eat(tt.slash);
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');
    } // Parses JSX closing tag starting after '</'.


    jsx_parseClosingElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');
    } // Parses entire JSX element, including it's opening tag
    // (starting after '<'), attributes, contents and closing tag.


    jsx_parseElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let children = [];
      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
      let closingElement = null;

      if (!openingElement.selfClosing) {
        contents: for (;;) {
          switch (this.type) {
            case tok.jsxTagStart:
              startPos = this.start;
              startLoc = this.startLoc;
              this.next();

              if (this.eat(tt.slash)) {
                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                break contents;
              }

              children.push(this.jsx_parseElementAt(startPos, startLoc));
              break;

            case tok.jsxText:
              children.push(this.parseExprAtom());
              break;

            case tt.braceL:
              children.push(this.jsx_parseExpressionContainer());
              break;

            default:
              this.unexpected();
          }
        }

        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
        }
      }

      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';
      node['opening' + fragmentOrElement] = openingElement;
      node['closing' + fragmentOrElement] = closingElement;
      node.children = children;

      if (this.type === tt.relational && this.value === "<") {
        this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
      }

      return this.finishNode(node, 'JSX' + fragmentOrElement);
    } // Parse JSX text


    jsx_parseText() {
      let node = this.parseLiteral(this.value);
      node.type = "JSXText";
      return node;
    } // Parses entire JSX element from current position.


    jsx_parseElement() {
      let startPos = this.start,
          startLoc = this.startLoc;
      this.next();
      return this.jsx_parseElementAt(startPos, startLoc);
    }

    parseExprAtom(refShortHandDefaultPos) {
      if (this.type === tok.jsxText) return this.jsx_parseText();else if (this.type === tok.jsxTagStart) return this.jsx_parseElement();else return super.parseExprAtom(refShortHandDefaultPos);
    }

    readToken(code) {
      let context = this.curContext();
      if (context === tc_expr) return this.jsx_readToken();

      if (context === tc_oTag || context === tc_cTag) {
        if (isIdentifierStart(code)) return this.jsx_readWord();

        if (code == 62) {
          ++this.pos;
          return this.finishToken(tok.jsxTagEnd);
        }

        if ((code === 34 || code === 39) && context == tc_oTag) return this.jsx_readString(code);
      }

      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
        ++this.pos;
        return this.finishToken(tok.jsxTagStart);
      }

      return super.readToken(code);
    }

    updateContext(prevType) {
      if (this.type == tt.braceL) {
        var curContext = this.curContext();
        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);else super.updateContext(prevType);
        this.exprAllowed = true;
      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore

        this.context.push(tc_cTag); // reconsider as closing tag context

        this.exprAllowed = false;
      } else {
        return super.updateContext(prevType);
      }
    }

  };
}
});

/**
 * @fileoverview The AST node types produced by the parser.
 * @author Nicholas C. Zakas
 */
// Requirements
//------------------------------------------------------------------------------
// None!
//------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------

var astNodeTypes = {
  AssignmentExpression: "AssignmentExpression",
  AssignmentPattern: "AssignmentPattern",
  ArrayExpression: "ArrayExpression",
  ArrayPattern: "ArrayPattern",
  ArrowFunctionExpression: "ArrowFunctionExpression",
  AwaitExpression: "AwaitExpression",
  BlockStatement: "BlockStatement",
  BinaryExpression: "BinaryExpression",
  BreakStatement: "BreakStatement",
  CallExpression: "CallExpression",
  CatchClause: "CatchClause",
  ClassBody: "ClassBody",
  ClassDeclaration: "ClassDeclaration",
  ClassExpression: "ClassExpression",
  ConditionalExpression: "ConditionalExpression",
  ContinueStatement: "ContinueStatement",
  DoWhileStatement: "DoWhileStatement",
  DebuggerStatement: "DebuggerStatement",
  EmptyStatement: "EmptyStatement",
  ExpressionStatement: "ExpressionStatement",
  ForStatement: "ForStatement",
  ForInStatement: "ForInStatement",
  ForOfStatement: "ForOfStatement",
  FunctionDeclaration: "FunctionDeclaration",
  FunctionExpression: "FunctionExpression",
  Identifier: "Identifier",
  IfStatement: "IfStatement",
  Literal: "Literal",
  LabeledStatement: "LabeledStatement",
  LogicalExpression: "LogicalExpression",
  MemberExpression: "MemberExpression",
  MetaProperty: "MetaProperty",
  MethodDefinition: "MethodDefinition",
  NewExpression: "NewExpression",
  ObjectExpression: "ObjectExpression",
  ObjectPattern: "ObjectPattern",
  Program: "Program",
  Property: "Property",
  RestElement: "RestElement",
  ReturnStatement: "ReturnStatement",
  SequenceExpression: "SequenceExpression",
  SpreadElement: "SpreadElement",
  Super: "Super",
  SwitchCase: "SwitchCase",
  SwitchStatement: "SwitchStatement",
  TaggedTemplateExpression: "TaggedTemplateExpression",
  TemplateElement: "TemplateElement",
  TemplateLiteral: "TemplateLiteral",
  ThisExpression: "ThisExpression",
  ThrowStatement: "ThrowStatement",
  TryStatement: "TryStatement",
  UnaryExpression: "UnaryExpression",
  UpdateExpression: "UpdateExpression",
  VariableDeclaration: "VariableDeclaration",
  VariableDeclarator: "VariableDeclarator",
  WhileStatement: "WhileStatement",
  WithStatement: "WithStatement",
  YieldExpression: "YieldExpression",
  JSXIdentifier: "JSXIdentifier",
  JSXNamespacedName: "JSXNamespacedName",
  JSXMemberExpression: "JSXMemberExpression",
  JSXEmptyExpression: "JSXEmptyExpression",
  JSXExpressionContainer: "JSXExpressionContainer",
  JSXElement: "JSXElement",
  JSXClosingElement: "JSXClosingElement",
  JSXOpeningElement: "JSXOpeningElement",
  JSXAttribute: "JSXAttribute",
  JSXSpreadAttribute: "JSXSpreadAttribute",
  JSXText: "JSXText",
  ExportDefaultDeclaration: "ExportDefaultDeclaration",
  ExportNamedDeclaration: "ExportNamedDeclaration",
  ExportAllDeclaration: "ExportAllDeclaration",
  ExportSpecifier: "ExportSpecifier",
  ImportDeclaration: "ImportDeclaration",
  ImportSpecifier: "ImportSpecifier",
  ImportDefaultSpecifier: "ImportDefaultSpecifier",
  ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
};

/**
 * @fileoverview Translates tokens between Acorn format and Esprima format.
 * @author Nicholas C. Zakas
 */
// Requirements
//------------------------------------------------------------------------------
// none!
//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------
// Esprima Token Types

const Token = {
  Boolean: "Boolean",
  EOF: "<end>",
  Identifier: "Identifier",
  Keyword: "Keyword",
  Null: "Null",
  Numeric: "Numeric",
  Punctuator: "Punctuator",
  String: "String",
  RegularExpression: "RegularExpression",
  Template: "Template",
  JSXIdentifier: "JSXIdentifier",
  JSXText: "JSXText"
};
/**
 * Converts part of a template into an Esprima token.
 * @param {AcornToken[]} tokens The Acorn tokens representing the template.
 * @param {string} code The source code.
 * @returns {EsprimaToken} The Esprima equivalent of the template token.
 * @private
 */

function convertTemplatePart(tokens, code) {
  const firstToken = tokens[0],
        lastTemplateToken = tokens[tokens.length - 1];
  const token = {
    type: Token.Template,
    value: code.slice(firstToken.start, lastTemplateToken.end)
  };

  if (firstToken.loc) {
    token.loc = {
      start: firstToken.loc.start,
      end: lastTemplateToken.loc.end
    };
  }

  if (firstToken.range) {
    token.start = firstToken.range[0];
    token.end = lastTemplateToken.range[1];
    token.range = [token.start, token.end];
  }

  return token;
}
/**
 * Contains logic to translate Acorn tokens into Esprima tokens.
 * @param {Object} acornTokTypes The Acorn token types.
 * @param {string} code The source code Acorn is parsing. This is necessary
 *      to correct the "value" property of some tokens.
 * @constructor
 */


function TokenTranslator(acornTokTypes, code) {
  // token types
  this._acornTokTypes = acornTokTypes; // token buffer for templates

  this._tokens = []; // track the last curly brace

  this._curlyBrace = null; // the source code

  this._code = code;
}

TokenTranslator.prototype = {
  constructor: TokenTranslator,

  /**
   * Translates a single Esprima token to a single Acorn token. This may be
   * inaccurate due to how templates are handled differently in Esprima and
   * Acorn, but should be accurate for all other tokens.
   * @param {AcornToken} token The Acorn token to translate.
   * @param {Object} extra Espree extra object.
   * @returns {EsprimaToken} The Esprima version of the token.
   */
  translate(token, extra) {
    const type = token.type,
          tt = this._acornTokTypes;

    if (type === tt.name) {
      token.type = Token.Identifier; // TODO: See if this is an Acorn bug

      if (token.value === "static") {
        token.type = Token.Keyword;
      }

      if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
        token.type = Token.Keyword;
      }
    } else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type === tt.questionDot || type.binop && !type.keyword || type.isAssign) {
      token.type = Token.Punctuator;
      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.jsxName) {
      token.type = Token.JSXIdentifier;
    } else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
      token.type = Token.JSXText;
    } else if (type.keyword) {
      if (type.keyword === "true" || type.keyword === "false") {
        token.type = Token.Boolean;
      } else if (type.keyword === "null") {
        token.type = Token.Null;
      } else {
        token.type = Token.Keyword;
      }
    } else if (type === tt.num) {
      token.type = Token.Numeric;
      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.string) {
      if (extra.jsxAttrValueToken) {
        extra.jsxAttrValueToken = false;
        token.type = Token.JSXText;
      } else {
        token.type = Token.String;
      }

      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.regexp) {
      token.type = Token.RegularExpression;
      const value = token.value;
      token.regex = {
        flags: value.flags,
        pattern: value.pattern
      };
      token.value = `/${value.pattern}/${value.flags}`;
    }

    return token;
  },

  /**
   * Function to call during Acorn's onToken handler.
   * @param {AcornToken} token The Acorn token.
   * @param {Object} extra The Espree extra object.
   * @returns {void}
   */
  onToken(token, extra) {
    const that = this,
          tt = this._acornTokTypes,
          tokens = extra.tokens,
          templateTokens = this._tokens;
    /**
     * Flushes the buffered template tokens and resets the template
     * tracking.
     * @returns {void}
     * @private
     */

    function translateTemplateTokens() {
      tokens.push(convertTemplatePart(that._tokens, that._code));
      that._tokens = [];
    }

    if (token.type === tt.eof) {
      // might be one last curlyBrace
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
      }

      return;
    }

    if (token.type === tt.backQuote) {
      // if there's already a curly, it's not part of the template
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
        this._curlyBrace = null;
      }

      templateTokens.push(token); // it's the end

      if (templateTokens.length > 1) {
        translateTemplateTokens();
      }

      return;
    }

    if (token.type === tt.dollarBraceL) {
      templateTokens.push(token);
      translateTemplateTokens();
      return;
    }

    if (token.type === tt.braceR) {
      // if there's already a curly, it's not part of the template
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
      } // store new curly for later


      this._curlyBrace = token;
      return;
    }

    if (token.type === tt.template || token.type === tt.invalidTemplate) {
      if (this._curlyBrace) {
        templateTokens.push(this._curlyBrace);
        this._curlyBrace = null;
      }

      templateTokens.push(token);
      return;
    }

    if (this._curlyBrace) {
      tokens.push(this.translate(this._curlyBrace, extra));
      this._curlyBrace = null;
    }

    tokens.push(this.translate(token, extra));
  }

}; //------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------

var tokenTranslator = TokenTranslator;

/**
 * @fileoverview A collection of methods for processing Espree's options.
 * @author Kai Cataldo
 */
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_ECMA_VERSION = 5;
const SUPPORTED_VERSIONS = [3, 5, 6, 7, 8, 9, 10, 11, 12];
/**
 * Normalize ECMAScript version from the initial config
 * @param {number} ecmaVersion ECMAScript version from the initial config
 * @throws {Error} throws an error if the ecmaVersion is invalid.
 * @returns {number} normalized ECMAScript version
 */

function normalizeEcmaVersion$1(ecmaVersion = DEFAULT_ECMA_VERSION) {
  if (typeof ecmaVersion !== "number") {
    throw new Error(`ecmaVersion must be a number. Received value of type ${typeof ecmaVersion} instead.`);
  }

  let version = ecmaVersion; // Calculate ECMAScript edition number from official year version starting with
  // ES2015, which corresponds with ES6 (or a difference of 2009).

  if (version >= 2015) {
    version -= 2009;
  }

  if (!SUPPORTED_VERSIONS.includes(version)) {
    throw new Error("Invalid ecmaVersion.");
  }

  return version;
}
/**
 * Normalize sourceType from the initial config
 * @param {string} sourceType to normalize
 * @throws {Error} throw an error if sourceType is invalid
 * @returns {string} normalized sourceType
 */


function normalizeSourceType(sourceType = "script") {
  if (sourceType === "script" || sourceType === "module") {
    return sourceType;
  }

  throw new Error("Invalid sourceType.");
}
/**
 * Normalize parserOptions
 * @param {Object} options the parser options to normalize
 * @throws {Error} throw an error if found invalid option.
 * @returns {Object} normalized options
 */


function normalizeOptions$4(options) {
  const ecmaVersion = normalizeEcmaVersion$1(options.ecmaVersion);
  const sourceType = normalizeSourceType(options.sourceType);
  const ranges = options.range === true;
  const locations = options.loc === true;

  if (sourceType === "module" && ecmaVersion < 6) {
    throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.");
  }

  return Object.assign({}, options, {
    ecmaVersion,
    sourceType,
    ranges,
    locations
  });
}
/**
 * Get the latest ECMAScript version supported by Espree.
 * @returns {number} The latest ECMAScript version.
 */


function getLatestEcmaVersion$1() {
  return SUPPORTED_VERSIONS[SUPPORTED_VERSIONS.length - 1];
}
/**
 * Get the list of ECMAScript versions supported by Espree.
 * @returns {number[]} An array containing the supported ECMAScript versions.
 */


function getSupportedEcmaVersions$1() {
  return [...SUPPORTED_VERSIONS];
} //------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------


var options = {
  normalizeOptions: normalizeOptions$4,
  getLatestEcmaVersion: getLatestEcmaVersion$1,
  getSupportedEcmaVersions: getSupportedEcmaVersions$1
};

/* eslint-disable no-param-reassign*/



const {
  normalizeOptions: normalizeOptions$3
} = options;

const STATE = Symbol("espree's internal state");
const ESPRIMA_FINISH_NODE = Symbol("espree's esprimaFinishNode");
/**
 * Converts an Acorn comment to a Esprima comment.
 * @param {boolean} block True if it's a block comment, false if not.
 * @param {string} text The text of the comment.
 * @param {int} start The index at which the comment starts.
 * @param {int} end The index at which the comment ends.
 * @param {Location} startLoc The location at which the comment starts.
 * @param {Location} endLoc The location at which the comment ends.
 * @returns {Object} The comment object.
 * @private
 */

function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
  const comment = {
    type: block ? "Block" : "Line",
    value: text
  };

  if (typeof start === "number") {
    comment.start = start;
    comment.end = end;
    comment.range = [start, end];
  }

  if (typeof startLoc === "object") {
    comment.loc = {
      start: startLoc,
      end: endLoc
    };
  }

  return comment;
}

var espree = () => Parser => {
  const tokTypes = Object.assign({}, Parser.acorn.tokTypes);

  if (Parser.acornJsx) {
    Object.assign(tokTypes, Parser.acornJsx.tokTypes);
  }

  return class Espree extends Parser {
    constructor(opts, code) {
      if (typeof opts !== "object" || opts === null) {
        opts = {};
      }

      if (typeof code !== "string" && !(code instanceof String)) {
        code = String(code);
      }

      const options = normalizeOptions$3(opts);
      const ecmaFeatures = options.ecmaFeatures || {};
      const tokenTranslator$1 = options.tokens === true ? new tokenTranslator(tokTypes, code) : null; // Initialize acorn parser.

      super({
        // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).
        ecmaVersion: options.ecmaVersion,
        sourceType: options.sourceType,
        ranges: options.ranges,
        locations: options.locations,
        // Truthy value is true for backward compatibility.
        allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),
        // Collect tokens
        onToken: token => {
          if (tokenTranslator$1) {
            // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.
            tokenTranslator$1.onToken(token, this[STATE]);
          }

          if (token.type !== tokTypes.eof) {
            this[STATE].lastToken = token;
          }
        },
        // Collect comments
        onComment: (block, text, start, end, startLoc, endLoc) => {
          if (this[STATE].comments) {
            const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);
            this[STATE].comments.push(comment);
          }
        }
      }, code); // Initialize internal state.

      this[STATE] = {
        tokens: tokenTranslator$1 ? [] : null,
        comments: options.comment === true ? [] : null,
        impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,
        ecmaVersion: this.options.ecmaVersion,
        jsxAttrValueToken: false,
        lastToken: null
      };
    }

    tokenize() {
      do {
        this.next();
      } while (this.type !== tokTypes.eof); // Consume the final eof token


      this.next();
      const extra = this[STATE];
      const tokens = extra.tokens;

      if (extra.comments) {
        tokens.comments = extra.comments;
      }

      return tokens;
    }

    finishNode(...args) {
      const result = super.finishNode(...args);
      return this[ESPRIMA_FINISH_NODE](result);
    }

    finishNodeAt(...args) {
      const result = super.finishNodeAt(...args);
      return this[ESPRIMA_FINISH_NODE](result);
    }

    parse() {
      const extra = this[STATE];
      const program = super.parse();
      program.sourceType = this.options.sourceType;

      if (extra.comments) {
        program.comments = extra.comments;
      }

      if (extra.tokens) {
        program.tokens = extra.tokens;
      }
      /*
       * Adjust opening and closing position of program to match Esprima.
       * Acorn always starts programs at range 0 whereas Esprima starts at the
       * first AST node's start (the only real difference is when there's leading
       * whitespace or leading comments). Acorn also counts trailing whitespace
       * as part of the program whereas Esprima only counts up to the last token.
       */


      if (program.range) {
        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
        program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];
      }

      if (program.loc) {
        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
        program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;
      }

      return program;
    }

    parseTopLevel(node) {
      if (this[STATE].impliedStrict) {
        this.strict = true;
      }

      return super.parseTopLevel(node);
    }
    /**
     * Overwrites the default raise method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @param {string} message The error message.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */


    raise(pos, message) {
      const loc = Parser.acorn.getLineInfo(this.input, pos);
      const err = new SyntaxError(message);
      err.index = pos;
      err.lineNumber = loc.line;
      err.column = loc.column + 1; // acorn uses 0-based columns

      throw err;
    }
    /**
     * Overwrites the default raise method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @param {string} message The error message.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */


    raiseRecoverable(pos, message) {
      this.raise(pos, message);
    }
    /**
     * Overwrites the default unexpected method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */


    unexpected(pos) {
      let message = "Unexpected token";

      if (pos !== null && pos !== void 0) {
        this.pos = pos;

        if (this.options.locations) {
          while (this.pos < this.lineStart) {
            this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
            --this.curLine;
          }
        }

        this.nextToken();
      }

      if (this.end > this.start) {
        message += ` ${this.input.slice(this.start, this.end)}`;
      }

      this.raise(this.start, message);
    }
    /*
    * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
    * uses regular tt.string without any distinction between this and regular JS
    * strings. As such, we intercept an attempt to read a JSX string and set a flag
    * on extra so that when tokens are converted, the next token will be switched
    * to JSXText via onToken.
    */


    jsx_readString(quote) {
      // eslint-disable-line camelcase
      const result = super.jsx_readString(quote);

      if (this.type === tokTypes.string) {
        this[STATE].jsxAttrValueToken = true;
      }

      return result;
    }
    /**
     * Performs last-minute Esprima-specific compatibility checks and fixes.
     * @param {ASTNode} result The node to check.
     * @returns {ASTNode} The finished node.
     */


    [ESPRIMA_FINISH_NODE](result) {
      // Acorn doesn't count the opening and closing backticks as part of templates
      // so we have to adjust ranges/locations appropriately.
      if (result.type === "TemplateElement") {
        // additional adjustment needed if ${ is the last token
        const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${";

        if (result.range) {
          result.range[0]--;
          result.range[1] += terminalDollarBraceL ? 2 : 1;
        }

        if (result.loc) {
          result.loc.start.column--;
          result.loc.end.column += terminalDollarBraceL ? 2 : 1;
        }
      }

      if (result.type.indexOf("Function") > -1 && !result.generator) {
        result.generator = false;
      }

      return result;
    }

  };
};

var name$1 = "espree";
var description$3 = "An Esprima-compatible JavaScript parser built on Acorn";
var author$1 = "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>";
var homepage$1 = "https://github.com/eslint/espree";
var main$1 = "espree.js";
var version$2 = "7.3.1";
var files$2 = [
	"lib",
	"espree.js"
];
var engines$2 = {
	node: "^10.12.0 || >=12.0.0"
};
var repository$2 = "eslint/espree";
var bugs$1 = {
	url: "http://github.com/eslint/espree.git"
};
var license$1 = "BSD-2-Clause";
var dependencies$4 = {
	acorn: "^7.4.0",
	"acorn-jsx": "^5.3.1",
	"eslint-visitor-keys": "^1.3.0"
};
var devDependencies$2 = {
	browserify: "^16.5.0",
	chai: "^4.2.0",
	eslint: "^6.0.1",
	"eslint-config-eslint": "^5.0.1",
	"eslint-plugin-node": "^9.1.0",
	"eslint-release": "^1.0.0",
	esprima: "latest",
	"esprima-fb": "^8001.2001.0-dev-harmony-fb",
	"json-diff": "^0.5.4",
	leche: "^2.3.0",
	mocha: "^6.2.0",
	nyc: "^14.1.1",
	regenerate: "^1.4.0",
	shelljs: "^0.3.0",
	"shelljs-nodecli": "^0.1.1",
	"unicode-6.3.0": "^0.7.5"
};
var keywords$2 = [
	"ast",
	"ecmascript",
	"javascript",
	"parser",
	"syntax",
	"acorn"
];
var scripts$2 = {
	"generate-regex": "node tools/generate-identifier-regex.js",
	test: "npm run-script lint && node Makefile.js test",
	lint: "node Makefile.js lint",
	fixlint: "node Makefile.js lint --fix",
	"sync-docs": "node Makefile.js docs",
	browserify: "node Makefile.js browserify",
	"generate-release": "eslint-generate-release",
	"generate-alpharelease": "eslint-generate-prerelease alpha",
	"generate-betarelease": "eslint-generate-prerelease beta",
	"generate-rcrelease": "eslint-generate-prerelease rc",
	"publish-release": "eslint-publish-release"
};
var require$$1$1 = {
	name: name$1,
	description: description$3,
	author: author$1,
	homepage: homepage$1,
	main: main$1,
	version: version$2,
	files: files$2,
	engines: engines$2,
	repository: repository$2,
	bugs: bugs$1,
	license: license$1,
	dependencies: dependencies$4,
	devDependencies: devDependencies$2,
	keywords: keywords$2,
	scripts: scripts$2
};

var AssignmentExpression$1 = [
	"left",
	"right"
];
var AssignmentPattern$1 = [
	"left",
	"right"
];
var ArrayExpression$1 = [
	"elements"
];
var ArrayPattern$1 = [
	"elements"
];
var ArrowFunctionExpression$1 = [
	"params",
	"body"
];
var AwaitExpression$1 = [
	"argument"
];
var BlockStatement$1 = [
	"body"
];
var BinaryExpression$1 = [
	"left",
	"right"
];
var BreakStatement$1 = [
	"label"
];
var CallExpression$1 = [
	"callee",
	"arguments"
];
var CatchClause$1 = [
	"param",
	"body"
];
var ChainExpression$1 = [
	"expression"
];
var ClassBody$1 = [
	"body"
];
var ClassDeclaration$1 = [
	"id",
	"superClass",
	"body"
];
var ClassExpression$1 = [
	"id",
	"superClass",
	"body"
];
var ConditionalExpression$1 = [
	"test",
	"consequent",
	"alternate"
];
var ContinueStatement$1 = [
	"label"
];
var DebuggerStatement$1 = [
];
var DoWhileStatement$1 = [
	"body",
	"test"
];
var EmptyStatement$1 = [
];
var ExportAllDeclaration$1 = [
	"exported",
	"source"
];
var ExportDefaultDeclaration$1 = [
	"declaration"
];
var ExportNamedDeclaration$1 = [
	"declaration",
	"specifiers",
	"source"
];
var ExportSpecifier$1 = [
	"exported",
	"local"
];
var ExpressionStatement$1 = [
	"expression"
];
var ExperimentalRestProperty$1 = [
	"argument"
];
var ExperimentalSpreadProperty$1 = [
	"argument"
];
var ForStatement$1 = [
	"init",
	"test",
	"update",
	"body"
];
var ForInStatement$1 = [
	"left",
	"right",
	"body"
];
var ForOfStatement$1 = [
	"left",
	"right",
	"body"
];
var FunctionDeclaration$1 = [
	"id",
	"params",
	"body"
];
var FunctionExpression$1 = [
	"id",
	"params",
	"body"
];
var Identifier$1 = [
];
var IfStatement$1 = [
	"test",
	"consequent",
	"alternate"
];
var ImportDeclaration$1 = [
	"specifiers",
	"source"
];
var ImportDefaultSpecifier$1 = [
	"local"
];
var ImportExpression$1 = [
	"source"
];
var ImportNamespaceSpecifier$1 = [
	"local"
];
var ImportSpecifier$1 = [
	"imported",
	"local"
];
var JSXAttribute$1 = [
	"name",
	"value"
];
var JSXClosingElement$1 = [
	"name"
];
var JSXElement$1 = [
	"openingElement",
	"children",
	"closingElement"
];
var JSXEmptyExpression$1 = [
];
var JSXExpressionContainer$1 = [
	"expression"
];
var JSXIdentifier$1 = [
];
var JSXMemberExpression$1 = [
	"object",
	"property"
];
var JSXNamespacedName$1 = [
	"namespace",
	"name"
];
var JSXOpeningElement$1 = [
	"name",
	"attributes"
];
var JSXSpreadAttribute$1 = [
	"argument"
];
var JSXText$1 = [
];
var JSXFragment$1 = [
	"openingFragment",
	"children",
	"closingFragment"
];
var Literal$1 = [
];
var LabeledStatement$1 = [
	"label",
	"body"
];
var LogicalExpression$1 = [
	"left",
	"right"
];
var MemberExpression$1 = [
	"object",
	"property"
];
var MetaProperty$1 = [
	"meta",
	"property"
];
var MethodDefinition$1 = [
	"key",
	"value"
];
var NewExpression$1 = [
	"callee",
	"arguments"
];
var ObjectExpression$1 = [
	"properties"
];
var ObjectPattern$1 = [
	"properties"
];
var Program$1 = [
	"body"
];
var Property$1 = [
	"key",
	"value"
];
var RestElement$1 = [
	"argument"
];
var ReturnStatement$1 = [
	"argument"
];
var SequenceExpression$1 = [
	"expressions"
];
var SpreadElement$1 = [
	"argument"
];
var Super$1 = [
];
var SwitchStatement$1 = [
	"discriminant",
	"cases"
];
var SwitchCase$1 = [
	"test",
	"consequent"
];
var TaggedTemplateExpression$1 = [
	"tag",
	"quasi"
];
var TemplateElement$1 = [
];
var TemplateLiteral$1 = [
	"quasis",
	"expressions"
];
var ThisExpression$1 = [
];
var ThrowStatement$1 = [
	"argument"
];
var TryStatement$1 = [
	"block",
	"handler",
	"finalizer"
];
var UnaryExpression$1 = [
	"argument"
];
var UpdateExpression$1 = [
	"argument"
];
var VariableDeclaration$1 = [
	"declarations"
];
var VariableDeclarator$1 = [
	"id",
	"init"
];
var WhileStatement$1 = [
	"test",
	"body"
];
var WithStatement$1 = [
	"object",
	"body"
];
var YieldExpression$1 = [
	"argument"
];
var KEYS$2 = {
	AssignmentExpression: AssignmentExpression$1,
	AssignmentPattern: AssignmentPattern$1,
	ArrayExpression: ArrayExpression$1,
	ArrayPattern: ArrayPattern$1,
	ArrowFunctionExpression: ArrowFunctionExpression$1,
	AwaitExpression: AwaitExpression$1,
	BlockStatement: BlockStatement$1,
	BinaryExpression: BinaryExpression$1,
	BreakStatement: BreakStatement$1,
	CallExpression: CallExpression$1,
	CatchClause: CatchClause$1,
	ChainExpression: ChainExpression$1,
	ClassBody: ClassBody$1,
	ClassDeclaration: ClassDeclaration$1,
	ClassExpression: ClassExpression$1,
	ConditionalExpression: ConditionalExpression$1,
	ContinueStatement: ContinueStatement$1,
	DebuggerStatement: DebuggerStatement$1,
	DoWhileStatement: DoWhileStatement$1,
	EmptyStatement: EmptyStatement$1,
	ExportAllDeclaration: ExportAllDeclaration$1,
	ExportDefaultDeclaration: ExportDefaultDeclaration$1,
	ExportNamedDeclaration: ExportNamedDeclaration$1,
	ExportSpecifier: ExportSpecifier$1,
	ExpressionStatement: ExpressionStatement$1,
	ExperimentalRestProperty: ExperimentalRestProperty$1,
	ExperimentalSpreadProperty: ExperimentalSpreadProperty$1,
	ForStatement: ForStatement$1,
	ForInStatement: ForInStatement$1,
	ForOfStatement: ForOfStatement$1,
	FunctionDeclaration: FunctionDeclaration$1,
	FunctionExpression: FunctionExpression$1,
	Identifier: Identifier$1,
	IfStatement: IfStatement$1,
	ImportDeclaration: ImportDeclaration$1,
	ImportDefaultSpecifier: ImportDefaultSpecifier$1,
	ImportExpression: ImportExpression$1,
	ImportNamespaceSpecifier: ImportNamespaceSpecifier$1,
	ImportSpecifier: ImportSpecifier$1,
	JSXAttribute: JSXAttribute$1,
	JSXClosingElement: JSXClosingElement$1,
	JSXElement: JSXElement$1,
	JSXEmptyExpression: JSXEmptyExpression$1,
	JSXExpressionContainer: JSXExpressionContainer$1,
	JSXIdentifier: JSXIdentifier$1,
	JSXMemberExpression: JSXMemberExpression$1,
	JSXNamespacedName: JSXNamespacedName$1,
	JSXOpeningElement: JSXOpeningElement$1,
	JSXSpreadAttribute: JSXSpreadAttribute$1,
	JSXText: JSXText$1,
	JSXFragment: JSXFragment$1,
	Literal: Literal$1,
	LabeledStatement: LabeledStatement$1,
	LogicalExpression: LogicalExpression$1,
	MemberExpression: MemberExpression$1,
	MetaProperty: MetaProperty$1,
	MethodDefinition: MethodDefinition$1,
	NewExpression: NewExpression$1,
	ObjectExpression: ObjectExpression$1,
	ObjectPattern: ObjectPattern$1,
	Program: Program$1,
	Property: Property$1,
	RestElement: RestElement$1,
	ReturnStatement: ReturnStatement$1,
	SequenceExpression: SequenceExpression$1,
	SpreadElement: SpreadElement$1,
	Super: Super$1,
	SwitchStatement: SwitchStatement$1,
	SwitchCase: SwitchCase$1,
	TaggedTemplateExpression: TaggedTemplateExpression$1,
	TemplateElement: TemplateElement$1,
	TemplateLiteral: TemplateLiteral$1,
	ThisExpression: ThisExpression$1,
	ThrowStatement: ThrowStatement$1,
	TryStatement: TryStatement$1,
	UnaryExpression: UnaryExpression$1,
	UpdateExpression: UpdateExpression$1,
	VariableDeclaration: VariableDeclaration$1,
	VariableDeclarator: VariableDeclarator$1,
	WhileStatement: WhileStatement$1,
	WithStatement: WithStatement$1,
	YieldExpression: YieldExpression$1
};

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */

 // Types.


const NODE_TYPES$1 = Object.freeze(Object.keys(KEYS$2)); // Freeze the keys.

for (const type of NODE_TYPES$1) {
  Object.freeze(KEYS$2[type]);
}

Object.freeze(KEYS$2); // List to ignore keys.

const KEY_BLACKLIST$1 = new Set(["parent", "leadingComments", "trailingComments"]);
/**
 * Check whether a given key should be used or not.
 * @param {string} key The key to check.
 * @returns {boolean} `true` if the key should be used.
 */

function filterKey$1(key) {
  return !KEY_BLACKLIST$1.has(key) && key[0] !== "_";
} //------------------------------------------------------------------------------
// Public interfaces
//------------------------------------------------------------------------------


var lib$4 = Object.freeze({
  /**
   * Visitor keys.
   * @type {{ [type: string]: string[] | undefined }}
   */
  KEYS: KEYS$2,

  /**
   * Get visitor keys of a given node.
   * @param {Object} node The AST node to get keys.
   * @returns {string[]} Visitor keys of the node.
   */
  getKeys(node) {
    return Object.keys(node).filter(filterKey$1);
  },

  // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
  // eslint-disable-next-line valid-jsdoc

  /**
   * Make the union set with `KEYS` and given keys.
   * @param {Object} additionalKeys The additional keys.
   * @returns {{ [type: string]: string[] | undefined }} The union set.
   */
  unionWith(additionalKeys) {
    const retv = Object.assign({}, KEYS$2);

    for (const type of Object.keys(additionalKeys)) {
      if (retv.hasOwnProperty(type)) {
        const keys = new Set(additionalKeys[type]);

        for (const key of retv[type]) {
          keys.add(key);
        }

        retv[type] = Object.freeze(Array.from(keys));
      } else {
        retv[type] = Object.freeze(Array.from(additionalKeys[type]));
      }
    }

    return Object.freeze(retv);
  }

});

/**
 * @fileoverview Main Espree file that converts Acorn into Esprima output.
 *
 * This file contains code from the following MIT-licensed projects:
 * 1. Acorn
 * 2. Babylon
 * 3. Babel-ESLint
 *
 * This file also contains code from Esprima, which is BSD licensed.
 *
 * Acorn is Copyright 2012-2015 Acorn Contributors (https://github.com/marijnh/acorn/blob/master/AUTHORS)
 * Babylon is Copyright 2014-2015 various contributors (https://github.com/babel/babel/blob/master/packages/babylon/AUTHORS)
 * Babel-ESLint is Copyright 2014-2015 Sebastian McKenzie <sebmck@gmail.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Esprima is Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */









const {
  getLatestEcmaVersion,
  getSupportedEcmaVersions
} = options; // To initialize lazily.


const parsers = {
  _regular: null,
  _jsx: null,

  get regular() {
    if (this._regular === null) {
      this._regular = acorn.Parser.extend(espree());
    }

    return this._regular;
  },

  get jsx() {
    if (this._jsx === null) {
      this._jsx = acorn.Parser.extend(acornJsx(), espree());
    }

    return this._jsx;
  },

  get(options) {
    const useJsx = Boolean(options && options.ecmaFeatures && options.ecmaFeatures.jsx);
    return useJsx ? this.jsx : this.regular;
  }

}; //------------------------------------------------------------------------------
// Tokenizer
//------------------------------------------------------------------------------

/**
 * Tokenizes the given code.
 * @param {string} code The code to tokenize.
 * @param {Object} options Options defining how to tokenize.
 * @returns {Token[]} An array of tokens.
 * @throws {SyntaxError} If the input code is invalid.
 * @private
 */

function tokenize(code, options) {
  const Parser = parsers.get(options); // Ensure to collect tokens.

  if (!options || options.tokens !== true) {
    options = Object.assign({}, options, {
      tokens: true
    }); // eslint-disable-line no-param-reassign
  }

  return new Parser(options, code).tokenize();
} //------------------------------------------------------------------------------
// Parser
//------------------------------------------------------------------------------

/**
 * Parses the given code.
 * @param {string} code The code to tokenize.
 * @param {Object} options Options defining how to tokenize.
 * @returns {ASTNode} The "Program" AST node.
 * @throws {SyntaxError} If the input code is invalid.
 */


function parse$2(code, options) {
  const Parser = parsers.get(options);
  return new Parser(options, code).parse();
} //------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------


var version$1 = require$$1$1.version;
var tokenize_1 = tokenize;
var parse_1 = parse$2; // Deep copy.

/* istanbul ignore next */

var Syntax = function () {
  let name,
      types = {};

  if (typeof Object.create === "function") {
    types = Object.create(null);
  }

  for (name in astNodeTypes) {
    if (Object.hasOwnProperty.call(astNodeTypes, name)) {
      types[name] = astNodeTypes[name];
    }
  }

  if (typeof Object.freeze === "function") {
    Object.freeze(types);
  }

  return types;
}();
/* istanbul ignore next */


var VisitorKeys = function () {
  return lib$4.KEYS;
}();

var latestEcmaVersion = getLatestEcmaVersion();
var supportedEcmaVersions = getSupportedEcmaVersions();

var espree_1 = {
	version: version$1,
	tokenize: tokenize_1,
	parse: parse_1,
	Syntax: Syntax,
	VisitorKeys: VisitorKeys,
	latestEcmaVersion: latestEcmaVersion,
	supportedEcmaVersions: supportedEcmaVersions
};

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash = createCommonjsModule$1(function (module, exports) {
(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined$1;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof commonjsGlobal=='object'&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&'object'=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return !!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return -1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return -1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined$1:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined$1:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined$1){result=result===undefined$1?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return [key,object[key]];});}/**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return '\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined$1:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return -1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined$1,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined$1,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined$1,symIterator=Symbol?Symbol.iterator:undefined$1,symToStringTag=Symbol?Symbol.toStringTag:undefined$1;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined$1,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined$1,symbolValueOf=symbolProto?symbolProto.valueOf:undefined$1,symbolToString=symbolProto?symbolProto.toString:undefined$1;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return {};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined$1;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined$1;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else {result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else {break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined$1:result;}return hasOwnProperty.call(data,key)?data[key]:undefined$1;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined$1:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined$1?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else {splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined$1:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else {data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined$1;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined$1&&!eq(object[key],value)||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return -1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else {object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined$1:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined$1){number=number<=upper?number:upper;}if(lower!==undefined$1){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined$1){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else {var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else {if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined$1:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return !length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined$1&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined$1,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined$1?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined$1||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else {arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined$1;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined$1?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined$1;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined$1:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return !length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined$1&&!(key in object)){return false;}}else {var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined$1?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined$1&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else {var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined$1;if(newValue===undefined$1){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined$1;var isCommon=newValue===undefined$1;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else {newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else {isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined$1;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else {iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return {'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else {baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined$1;if(newValue===undefined$1){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return !result;});return !!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else {high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined$1;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined$1,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else {setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else {high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return +value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else {seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined$1;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined$1?length:end;return !start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined$1,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined$1,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return -1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined$1;if(newValue===undefined$1){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else {assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined$1,guard=length>2?sources[2]:undefined$1;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined$1:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined$1;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined$1,args,holders,undefined$1,undefined$1,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined$1;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined$1;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else {wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined$1:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined$1&&other===undefined$1){return defaultValue;}if(value!==undefined$1){result=value;}if(other!==undefined$1){if(result===undefined$1){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else {value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined$1?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined$1;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}step=step===undefined$1?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined$1,newHoldersRight=isCurry?undefined$1:holders,newPartials=isCurry?partials:undefined$1,newPartialsRight=isCurry?undefined$1:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined$1,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return +(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined$1;}ary=ary===undefined$1?ary:nativeMax(toInteger(ary),0);arity=arity===undefined$1?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined$1;}var data=isBindKey?undefined$1:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined$1?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else {result=createHybrid.apply(undefined$1,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined$1||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined$1,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined$1:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined$1;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined$1){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined$1?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined$1,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined$1;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined$1;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else {delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return [];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined$1,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return {'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return !!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return !!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return !!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return !!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined$1||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined$1?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined$1;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else {count=0;}return func.apply(undefined$1,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined$1?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return '';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined$1){size=1;}else {size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return [];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return [];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined$1,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return [];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length-1;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return [];}depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined$1;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined$1;}else {mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined$1;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined$1,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined$1;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined$1;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined$1,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return [];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else {start=start==null?0:toInteger(start);end=end===undefined$1?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return -1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return -1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined$1,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined$1;return array&&array.length?baseUniq(array,undefined$1,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return [];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return [];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined$1,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined$1,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined$1;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined$1;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined$1);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined$1){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined$1:this.__values__[this.__index__++];return {'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined$1;if(result){previous.__wrapped__=clone;}else {result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined$1});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else {baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else {baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return [];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined$1:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return [[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return [];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined$1:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined$1;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined$1;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined$1||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined$1;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined$1;return result;}function cancel(){if(timerId!==undefined$1){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined$1;}function flush(){return timerId===undefined$1?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined$1){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined$1){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return !predicate.call(this);case 1:return !predicate.call(this,args[0]);case 2:return !predicate.call(this,args[0],args[1]);case 3:return !predicate.call(this,args[0],args[1],args[2]);}return !predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined$1,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined$1,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined$1,undefined$1,undefined$1,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined$1?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return [];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return !value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return !value.size;}if(isPrototype(value)){return !baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;var result=customizer?customizer(value,other):undefined$1;return result===undefined$1?baseIsEqual(value,other,undefined$1,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined$1;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return [];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined$1||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined$1,customDefaultsMerge);return apply(mergeWith,undefined$1,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined$1:baseGet(object,path);return result===undefined$1?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else {result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return {};}var props=arrayMap(getAllKeysIn(object),function(prop){return [prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined$1;}while(++index<length){var value=object==null?undefined$1:object[toKey(path[index])];if(value===undefined$1){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else {accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined$1){upper=lower;lower=undefined$1;}if(upper!==undefined$1){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined$1){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined$1;}if(floating===undefined$1){if(typeof upper=='boolean'){floating=upper;upper=undefined$1;}else if(typeof lower=='boolean'){floating=lower;lower=undefined$1;}}if(lower===undefined$1&&upper===undefined$1){lower=0;upper=1;}else {lower=toFinite(lower);if(upper===undefined$1){upper=lower;lower=0;}else {upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined$1?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined$1;}limit=limit===undefined$1?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return [];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined$1;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
// potential command injection attacks.
else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined$1,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined$1){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined$1?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined$1:pattern;if(pattern===undefined$1){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined$1,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return [toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined$1:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return [];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return {};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return '';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return [];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined$1;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined$1;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined$1;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined$1;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined$1?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else {result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined$1){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined$1,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined$1}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(freeModule){// Export for Node.js.
(freeModule.exports=_)._=_;// Export for CommonJS support.
freeExports._=_;}else {// Export to the global object.
root._=_;}}).call(commonjsGlobal);
});

var builtin$1 = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es5$1 = {
	"Array": false,
	"Boolean": false,
	constructor: false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	propertyIsEnumerable: false,
	"RangeError": false,
	"ReferenceError": false,
	"RegExp": false,
	"String": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false
};
var es2015$1 = {
	"Array": false,
	"ArrayBuffer": false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es2017$1 = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var browser$2 = {
	AbortController: false,
	AbortSignal: false,
	addEventListener: false,
	alert: false,
	AnalyserNode: false,
	Animation: false,
	AnimationEffectReadOnly: false,
	AnimationEffectTiming: false,
	AnimationEffectTimingReadOnly: false,
	AnimationEvent: false,
	AnimationPlaybackEvent: false,
	AnimationTimeline: false,
	applicationCache: false,
	ApplicationCache: false,
	ApplicationCacheErrorEvent: false,
	atob: false,
	Attr: false,
	Audio: false,
	AudioBuffer: false,
	AudioBufferSourceNode: false,
	AudioContext: false,
	AudioDestinationNode: false,
	AudioListener: false,
	AudioNode: false,
	AudioParam: false,
	AudioProcessingEvent: false,
	AudioScheduledSourceNode: false,
	"AudioWorkletGlobalScope ": false,
	AudioWorkletNode: false,
	AudioWorkletProcessor: false,
	BarProp: false,
	BaseAudioContext: false,
	BatteryManager: false,
	BeforeUnloadEvent: false,
	BiquadFilterNode: false,
	Blob: false,
	BlobEvent: false,
	blur: false,
	BroadcastChannel: false,
	btoa: false,
	BudgetService: false,
	ByteLengthQueuingStrategy: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	cancelAnimationFrame: false,
	cancelIdleCallback: false,
	CanvasCaptureMediaStreamTrack: false,
	CanvasGradient: false,
	CanvasPattern: false,
	CanvasRenderingContext2D: false,
	ChannelMergerNode: false,
	ChannelSplitterNode: false,
	CharacterData: false,
	clearInterval: false,
	clearTimeout: false,
	clientInformation: false,
	ClipboardEvent: false,
	close: false,
	closed: false,
	CloseEvent: false,
	Comment: false,
	CompositionEvent: false,
	confirm: false,
	console: false,
	ConstantSourceNode: false,
	ConvolverNode: false,
	CountQueuingStrategy: false,
	createImageBitmap: false,
	Credential: false,
	CredentialsContainer: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CSS: false,
	CSSConditionRule: false,
	CSSFontFaceRule: false,
	CSSGroupingRule: false,
	CSSImportRule: false,
	CSSKeyframeRule: false,
	CSSKeyframesRule: false,
	CSSMediaRule: false,
	CSSNamespaceRule: false,
	CSSPageRule: false,
	CSSRule: false,
	CSSRuleList: false,
	CSSStyleDeclaration: false,
	CSSStyleRule: false,
	CSSStyleSheet: false,
	CSSSupportsRule: false,
	CustomElementRegistry: false,
	customElements: false,
	CustomEvent: false,
	DataTransfer: false,
	DataTransferItem: false,
	DataTransferItemList: false,
	defaultstatus: false,
	defaultStatus: false,
	DelayNode: false,
	DeviceMotionEvent: false,
	DeviceOrientationEvent: false,
	devicePixelRatio: false,
	dispatchEvent: false,
	document: false,
	Document: false,
	DocumentFragment: false,
	DocumentType: false,
	DOMError: false,
	DOMException: false,
	DOMImplementation: false,
	DOMMatrix: false,
	DOMMatrixReadOnly: false,
	DOMParser: false,
	DOMPoint: false,
	DOMPointReadOnly: false,
	DOMQuad: false,
	DOMRect: false,
	DOMRectReadOnly: false,
	DOMStringList: false,
	DOMStringMap: false,
	DOMTokenList: false,
	DragEvent: false,
	DynamicsCompressorNode: false,
	Element: false,
	ErrorEvent: false,
	event: false,
	Event: false,
	EventSource: false,
	EventTarget: false,
	external: false,
	fetch: false,
	File: false,
	FileList: false,
	FileReader: false,
	find: false,
	focus: false,
	FocusEvent: false,
	FontFace: false,
	FontFaceSetLoadEvent: false,
	FormData: false,
	frameElement: false,
	frames: false,
	GainNode: false,
	Gamepad: false,
	GamepadButton: false,
	GamepadEvent: false,
	getComputedStyle: false,
	getSelection: false,
	HashChangeEvent: false,
	Headers: false,
	history: false,
	History: false,
	HTMLAllCollection: false,
	HTMLAnchorElement: false,
	HTMLAreaElement: false,
	HTMLAudioElement: false,
	HTMLBaseElement: false,
	HTMLBodyElement: false,
	HTMLBRElement: false,
	HTMLButtonElement: false,
	HTMLCanvasElement: false,
	HTMLCollection: false,
	HTMLContentElement: false,
	HTMLDataElement: false,
	HTMLDataListElement: false,
	HTMLDetailsElement: false,
	HTMLDialogElement: false,
	HTMLDirectoryElement: false,
	HTMLDivElement: false,
	HTMLDListElement: false,
	HTMLDocument: false,
	HTMLElement: false,
	HTMLEmbedElement: false,
	HTMLFieldSetElement: false,
	HTMLFontElement: false,
	HTMLFormControlsCollection: false,
	HTMLFormElement: false,
	HTMLFrameElement: false,
	HTMLFrameSetElement: false,
	HTMLHeadElement: false,
	HTMLHeadingElement: false,
	HTMLHRElement: false,
	HTMLHtmlElement: false,
	HTMLIFrameElement: false,
	HTMLImageElement: false,
	HTMLInputElement: false,
	HTMLLabelElement: false,
	HTMLLegendElement: false,
	HTMLLIElement: false,
	HTMLLinkElement: false,
	HTMLMapElement: false,
	HTMLMarqueeElement: false,
	HTMLMediaElement: false,
	HTMLMenuElement: false,
	HTMLMetaElement: false,
	HTMLMeterElement: false,
	HTMLModElement: false,
	HTMLObjectElement: false,
	HTMLOListElement: false,
	HTMLOptGroupElement: false,
	HTMLOptionElement: false,
	HTMLOptionsCollection: false,
	HTMLOutputElement: false,
	HTMLParagraphElement: false,
	HTMLParamElement: false,
	HTMLPictureElement: false,
	HTMLPreElement: false,
	HTMLProgressElement: false,
	HTMLQuoteElement: false,
	HTMLScriptElement: false,
	HTMLSelectElement: false,
	HTMLShadowElement: false,
	HTMLSlotElement: false,
	HTMLSourceElement: false,
	HTMLSpanElement: false,
	HTMLStyleElement: false,
	HTMLTableCaptionElement: false,
	HTMLTableCellElement: false,
	HTMLTableColElement: false,
	HTMLTableElement: false,
	HTMLTableRowElement: false,
	HTMLTableSectionElement: false,
	HTMLTemplateElement: false,
	HTMLTextAreaElement: false,
	HTMLTimeElement: false,
	HTMLTitleElement: false,
	HTMLTrackElement: false,
	HTMLUListElement: false,
	HTMLUnknownElement: false,
	HTMLVideoElement: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	IdleDeadline: false,
	IIRFilterNode: false,
	Image: false,
	ImageBitmap: false,
	ImageBitmapRenderingContext: false,
	ImageCapture: false,
	ImageData: false,
	indexedDB: false,
	innerHeight: false,
	innerWidth: false,
	InputEvent: false,
	IntersectionObserver: false,
	IntersectionObserverEntry: false,
	"Intl": false,
	isSecureContext: false,
	KeyboardEvent: false,
	KeyframeEffect: false,
	KeyframeEffectReadOnly: false,
	length: false,
	localStorage: false,
	location: true,
	Location: false,
	locationbar: false,
	matchMedia: false,
	MediaDeviceInfo: false,
	MediaDevices: false,
	MediaElementAudioSourceNode: false,
	MediaEncryptedEvent: false,
	MediaError: false,
	MediaKeyMessageEvent: false,
	MediaKeySession: false,
	MediaKeyStatusMap: false,
	MediaKeySystemAccess: false,
	MediaList: false,
	MediaQueryList: false,
	MediaQueryListEvent: false,
	MediaRecorder: false,
	MediaSettingsRange: false,
	MediaSource: false,
	MediaStream: false,
	MediaStreamAudioDestinationNode: false,
	MediaStreamAudioSourceNode: false,
	MediaStreamEvent: false,
	MediaStreamTrack: false,
	MediaStreamTrackEvent: false,
	menubar: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	MIDIAccess: false,
	MIDIConnectionEvent: false,
	MIDIInput: false,
	MIDIInputMap: false,
	MIDIMessageEvent: false,
	MIDIOutput: false,
	MIDIOutputMap: false,
	MIDIPort: false,
	MimeType: false,
	MimeTypeArray: false,
	MouseEvent: false,
	moveBy: false,
	moveTo: false,
	MutationEvent: false,
	MutationObserver: false,
	MutationRecord: false,
	name: false,
	NamedNodeMap: false,
	NavigationPreloadManager: false,
	navigator: false,
	Navigator: false,
	NetworkInformation: false,
	Node: false,
	NodeFilter: false,
	NodeIterator: false,
	NodeList: false,
	Notification: false,
	OfflineAudioCompletionEvent: false,
	OfflineAudioContext: false,
	offscreenBuffering: false,
	OffscreenCanvas: true,
	onabort: true,
	onafterprint: true,
	onanimationend: true,
	onanimationiteration: true,
	onanimationstart: true,
	onappinstalled: true,
	onauxclick: true,
	onbeforeinstallprompt: true,
	onbeforeprint: true,
	onbeforeunload: true,
	onblur: true,
	oncancel: true,
	oncanplay: true,
	oncanplaythrough: true,
	onchange: true,
	onclick: true,
	onclose: true,
	oncontextmenu: true,
	oncuechange: true,
	ondblclick: true,
	ondevicemotion: true,
	ondeviceorientation: true,
	ondeviceorientationabsolute: true,
	ondrag: true,
	ondragend: true,
	ondragenter: true,
	ondragleave: true,
	ondragover: true,
	ondragstart: true,
	ondrop: true,
	ondurationchange: true,
	onemptied: true,
	onended: true,
	onerror: true,
	onfocus: true,
	ongotpointercapture: true,
	onhashchange: true,
	oninput: true,
	oninvalid: true,
	onkeydown: true,
	onkeypress: true,
	onkeyup: true,
	onlanguagechange: true,
	onload: true,
	onloadeddata: true,
	onloadedmetadata: true,
	onloadstart: true,
	onlostpointercapture: true,
	onmessage: true,
	onmessageerror: true,
	onmousedown: true,
	onmouseenter: true,
	onmouseleave: true,
	onmousemove: true,
	onmouseout: true,
	onmouseover: true,
	onmouseup: true,
	onmousewheel: true,
	onoffline: true,
	ononline: true,
	onpagehide: true,
	onpageshow: true,
	onpause: true,
	onplay: true,
	onplaying: true,
	onpointercancel: true,
	onpointerdown: true,
	onpointerenter: true,
	onpointerleave: true,
	onpointermove: true,
	onpointerout: true,
	onpointerover: true,
	onpointerup: true,
	onpopstate: true,
	onprogress: true,
	onratechange: true,
	onrejectionhandled: true,
	onreset: true,
	onresize: true,
	onscroll: true,
	onsearch: true,
	onseeked: true,
	onseeking: true,
	onselect: true,
	onstalled: true,
	onstorage: true,
	onsubmit: true,
	onsuspend: true,
	ontimeupdate: true,
	ontoggle: true,
	ontransitionend: true,
	onunhandledrejection: true,
	onunload: true,
	onvolumechange: true,
	onwaiting: true,
	onwheel: true,
	open: false,
	openDatabase: false,
	opener: false,
	Option: false,
	origin: false,
	OscillatorNode: false,
	outerHeight: false,
	outerWidth: false,
	PageTransitionEvent: false,
	pageXOffset: false,
	pageYOffset: false,
	PannerNode: false,
	parent: false,
	Path2D: false,
	PaymentAddress: false,
	PaymentRequest: false,
	PaymentRequestUpdateEvent: false,
	PaymentResponse: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceLongTaskTiming: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceNavigationTiming: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformancePaintTiming: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	PeriodicWave: false,
	Permissions: false,
	PermissionStatus: false,
	personalbar: false,
	PhotoCapabilities: false,
	Plugin: false,
	PluginArray: false,
	PointerEvent: false,
	PopStateEvent: false,
	postMessage: false,
	Presentation: false,
	PresentationAvailability: false,
	PresentationConnection: false,
	PresentationConnectionAvailableEvent: false,
	PresentationConnectionCloseEvent: false,
	PresentationConnectionList: false,
	PresentationReceiver: false,
	PresentationRequest: false,
	print: false,
	ProcessingInstruction: false,
	ProgressEvent: false,
	PromiseRejectionEvent: false,
	prompt: false,
	PushManager: false,
	PushSubscription: false,
	PushSubscriptionOptions: false,
	queueMicrotask: false,
	RadioNodeList: false,
	Range: false,
	ReadableStream: false,
	registerProcessor: false,
	RemotePlayback: false,
	removeEventListener: false,
	Request: false,
	requestAnimationFrame: false,
	requestIdleCallback: false,
	resizeBy: false,
	ResizeObserver: false,
	ResizeObserverEntry: false,
	resizeTo: false,
	Response: false,
	RTCCertificate: false,
	RTCDataChannel: false,
	RTCDataChannelEvent: false,
	RTCDtlsTransport: false,
	RTCIceCandidate: false,
	RTCIceGatherer: false,
	RTCIceTransport: false,
	RTCPeerConnection: false,
	RTCPeerConnectionIceEvent: false,
	RTCRtpContributingSource: false,
	RTCRtpReceiver: false,
	RTCRtpSender: false,
	RTCSctpTransport: false,
	RTCSessionDescription: false,
	RTCStatsReport: false,
	RTCTrackEvent: false,
	screen: false,
	Screen: false,
	screenLeft: false,
	ScreenOrientation: false,
	screenTop: false,
	screenX: false,
	screenY: false,
	ScriptProcessorNode: false,
	scroll: false,
	scrollbars: false,
	scrollBy: false,
	scrollTo: false,
	scrollX: false,
	scrollY: false,
	SecurityPolicyViolationEvent: false,
	Selection: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerRegistration: false,
	sessionStorage: false,
	setInterval: false,
	setTimeout: false,
	ShadowRoot: false,
	SharedWorker: false,
	SourceBuffer: false,
	SourceBufferList: false,
	speechSynthesis: false,
	SpeechSynthesisEvent: false,
	SpeechSynthesisUtterance: false,
	StaticRange: false,
	status: false,
	statusbar: false,
	StereoPannerNode: false,
	stop: false,
	Storage: false,
	StorageEvent: false,
	StorageManager: false,
	styleMedia: false,
	StyleSheet: false,
	StyleSheetList: false,
	SubtleCrypto: false,
	SVGAElement: false,
	SVGAngle: false,
	SVGAnimatedAngle: false,
	SVGAnimatedBoolean: false,
	SVGAnimatedEnumeration: false,
	SVGAnimatedInteger: false,
	SVGAnimatedLength: false,
	SVGAnimatedLengthList: false,
	SVGAnimatedNumber: false,
	SVGAnimatedNumberList: false,
	SVGAnimatedPreserveAspectRatio: false,
	SVGAnimatedRect: false,
	SVGAnimatedString: false,
	SVGAnimatedTransformList: false,
	SVGAnimateElement: false,
	SVGAnimateMotionElement: false,
	SVGAnimateTransformElement: false,
	SVGAnimationElement: false,
	SVGCircleElement: false,
	SVGClipPathElement: false,
	SVGComponentTransferFunctionElement: false,
	SVGDefsElement: false,
	SVGDescElement: false,
	SVGDiscardElement: false,
	SVGElement: false,
	SVGEllipseElement: false,
	SVGFEBlendElement: false,
	SVGFEColorMatrixElement: false,
	SVGFEComponentTransferElement: false,
	SVGFECompositeElement: false,
	SVGFEConvolveMatrixElement: false,
	SVGFEDiffuseLightingElement: false,
	SVGFEDisplacementMapElement: false,
	SVGFEDistantLightElement: false,
	SVGFEDropShadowElement: false,
	SVGFEFloodElement: false,
	SVGFEFuncAElement: false,
	SVGFEFuncBElement: false,
	SVGFEFuncGElement: false,
	SVGFEFuncRElement: false,
	SVGFEGaussianBlurElement: false,
	SVGFEImageElement: false,
	SVGFEMergeElement: false,
	SVGFEMergeNodeElement: false,
	SVGFEMorphologyElement: false,
	SVGFEOffsetElement: false,
	SVGFEPointLightElement: false,
	SVGFESpecularLightingElement: false,
	SVGFESpotLightElement: false,
	SVGFETileElement: false,
	SVGFETurbulenceElement: false,
	SVGFilterElement: false,
	SVGForeignObjectElement: false,
	SVGGElement: false,
	SVGGeometryElement: false,
	SVGGradientElement: false,
	SVGGraphicsElement: false,
	SVGImageElement: false,
	SVGLength: false,
	SVGLengthList: false,
	SVGLinearGradientElement: false,
	SVGLineElement: false,
	SVGMarkerElement: false,
	SVGMaskElement: false,
	SVGMatrix: false,
	SVGMetadataElement: false,
	SVGMPathElement: false,
	SVGNumber: false,
	SVGNumberList: false,
	SVGPathElement: false,
	SVGPatternElement: false,
	SVGPoint: false,
	SVGPointList: false,
	SVGPolygonElement: false,
	SVGPolylineElement: false,
	SVGPreserveAspectRatio: false,
	SVGRadialGradientElement: false,
	SVGRect: false,
	SVGRectElement: false,
	SVGScriptElement: false,
	SVGSetElement: false,
	SVGStopElement: false,
	SVGStringList: false,
	SVGStyleElement: false,
	SVGSVGElement: false,
	SVGSwitchElement: false,
	SVGSymbolElement: false,
	SVGTextContentElement: false,
	SVGTextElement: false,
	SVGTextPathElement: false,
	SVGTextPositioningElement: false,
	SVGTitleElement: false,
	SVGTransform: false,
	SVGTransformList: false,
	SVGTSpanElement: false,
	SVGUnitTypes: false,
	SVGUseElement: false,
	SVGViewElement: false,
	TaskAttributionTiming: false,
	Text: false,
	TextDecoder: false,
	TextEncoder: false,
	TextEvent: false,
	TextMetrics: false,
	TextTrack: false,
	TextTrackCue: false,
	TextTrackCueList: false,
	TextTrackList: false,
	TimeRanges: false,
	toolbar: false,
	top: false,
	Touch: false,
	TouchEvent: false,
	TouchList: false,
	TrackEvent: false,
	TransitionEvent: false,
	TreeWalker: false,
	UIEvent: false,
	URL: false,
	URLSearchParams: false,
	ValidityState: false,
	visualViewport: false,
	VisualViewport: false,
	VTTCue: false,
	WaveShaperNode: false,
	WebAssembly: false,
	WebGL2RenderingContext: false,
	WebGLActiveInfo: false,
	WebGLBuffer: false,
	WebGLContextEvent: false,
	WebGLFramebuffer: false,
	WebGLProgram: false,
	WebGLQuery: false,
	WebGLRenderbuffer: false,
	WebGLRenderingContext: false,
	WebGLSampler: false,
	WebGLShader: false,
	WebGLShaderPrecisionFormat: false,
	WebGLSync: false,
	WebGLTexture: false,
	WebGLTransformFeedback: false,
	WebGLUniformLocation: false,
	WebGLVertexArrayObject: false,
	WebSocket: false,
	WheelEvent: false,
	window: false,
	Window: false,
	Worker: false,
	WritableStream: false,
	XMLDocument: false,
	XMLHttpRequest: false,
	XMLHttpRequestEventTarget: false,
	XMLHttpRequestUpload: false,
	XMLSerializer: false,
	XPathEvaluator: false,
	XPathExpression: false,
	XPathResult: false,
	XSLTProcessor: false
};
var worker$1 = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	clearInterval: false,
	clearTimeout: false,
	close: true,
	console: false,
	fetch: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: true,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onlanguagechange: true,
	onmessage: true,
	onoffline: true,
	ononline: true,
	onrejectionhandled: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	queueMicrotask: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: true,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false,
	WebSocket: false,
	Worker: false,
	WorkerGlobalScope: false,
	XMLHttpRequest: false
};
var node$2 = {
	__dirname: false,
	__filename: false,
	Buffer: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	console: false,
	exports: true,
	global: false,
	"Intl": false,
	module: false,
	process: false,
	queueMicrotask: false,
	require: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false
};
var nodeBuiltin$1 = {
	Buffer: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	console: false,
	global: false,
	"Intl": false,
	process: false,
	queueMicrotask: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false
};
var commonjs$1 = {
	exports: true,
	global: false,
	module: false,
	require: false
};
var amd$1 = {
	define: false,
	require: false
};
var mocha$1 = {
	after: false,
	afterEach: false,
	before: false,
	beforeEach: false,
	context: false,
	describe: false,
	it: false,
	mocha: false,
	run: false,
	setup: false,
	specify: false,
	suite: false,
	suiteSetup: false,
	suiteTeardown: false,
	teardown: false,
	test: false,
	xcontext: false,
	xdescribe: false,
	xit: false,
	xspecify: false
};
var jasmine$1 = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	expectAsync: false,
	fail: false,
	fdescribe: false,
	fit: false,
	it: false,
	jasmine: false,
	pending: false,
	runs: false,
	spyOn: false,
	spyOnAllFunctions: false,
	spyOnProperty: false,
	waits: false,
	waitsFor: false,
	xdescribe: false,
	xit: false
};
var jest$1 = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	fdescribe: false,
	fit: false,
	it: false,
	jest: false,
	pit: false,
	require: false,
	test: false,
	xdescribe: false,
	xit: false,
	xtest: false
};
var qunit$1 = {
	asyncTest: false,
	deepEqual: false,
	equal: false,
	expect: false,
	module: false,
	notDeepEqual: false,
	notEqual: false,
	notOk: false,
	notPropEqual: false,
	notStrictEqual: false,
	ok: false,
	propEqual: false,
	QUnit: false,
	raises: false,
	start: false,
	stop: false,
	strictEqual: false,
	test: false,
	throws: false
};
var phantomjs$1 = {
	console: true,
	exports: true,
	phantom: true,
	require: true,
	WebPage: true
};
var couch$1 = {
	emit: false,
	exports: false,
	getRow: false,
	log: false,
	module: false,
	provides: false,
	require: false,
	respond: false,
	send: false,
	start: false,
	sum: false
};
var rhino$1 = {
	defineClass: false,
	deserialize: false,
	gc: false,
	help: false,
	importClass: false,
	importPackage: false,
	java: false,
	load: false,
	loadClass: false,
	Packages: false,
	print: false,
	quit: false,
	readFile: false,
	readUrl: false,
	runCommand: false,
	seal: false,
	serialize: false,
	spawn: false,
	sync: false,
	toint32: false,
	version: false
};
var nashorn$1 = {
	__DIR__: false,
	__FILE__: false,
	__LINE__: false,
	com: false,
	edu: false,
	exit: false,
	java: false,
	Java: false,
	javafx: false,
	JavaImporter: false,
	javax: false,
	JSAdapter: false,
	load: false,
	loadWithNewGlobal: false,
	org: false,
	Packages: false,
	print: false,
	quit: false
};
var wsh$1 = {
	ActiveXObject: true,
	CollectGarbage: true,
	Debug: true,
	Enumerator: true,
	GetObject: true,
	RuntimeObject: true,
	ScriptEngine: true,
	ScriptEngineBuildVersion: true,
	ScriptEngineMajorVersion: true,
	ScriptEngineMinorVersion: true,
	VBArray: true,
	WScript: true,
	WSH: true,
	XDomainRequest: true
};
var jquery$1 = {
	$: false,
	jQuery: false
};
var yui$1 = {
	YAHOO: false,
	YAHOO_config: false,
	YUI: false,
	YUI_config: false
};
var shelljs$1 = {
	cat: false,
	cd: false,
	chmod: false,
	config: false,
	cp: false,
	dirs: false,
	echo: false,
	env: false,
	error: false,
	exec: false,
	exit: false,
	find: false,
	grep: false,
	ln: false,
	ls: false,
	mkdir: false,
	mv: false,
	popd: false,
	pushd: false,
	pwd: false,
	rm: false,
	sed: false,
	set: false,
	target: false,
	tempdir: false,
	test: false,
	touch: false,
	which: false
};
var prototypejs$1 = {
	$: false,
	$$: false,
	$A: false,
	$break: false,
	$continue: false,
	$F: false,
	$H: false,
	$R: false,
	$w: false,
	Abstract: false,
	Ajax: false,
	Autocompleter: false,
	Builder: false,
	Class: false,
	Control: false,
	Draggable: false,
	Draggables: false,
	Droppables: false,
	Effect: false,
	Element: false,
	Enumerable: false,
	Event: false,
	Field: false,
	Form: false,
	Hash: false,
	Insertion: false,
	ObjectRange: false,
	PeriodicalExecuter: false,
	Position: false,
	Prototype: false,
	Scriptaculous: false,
	Selector: false,
	Sortable: false,
	SortableObserver: false,
	Sound: false,
	Template: false,
	Toggle: false,
	Try: false
};
var meteor$1 = {
	_: false,
	$: false,
	Accounts: false,
	AccountsClient: false,
	AccountsCommon: false,
	AccountsServer: false,
	App: false,
	Assets: false,
	Blaze: false,
	check: false,
	Cordova: false,
	DDP: false,
	DDPRateLimiter: false,
	DDPServer: false,
	Deps: false,
	EJSON: false,
	Email: false,
	HTTP: false,
	Log: false,
	Match: false,
	Meteor: false,
	Mongo: false,
	MongoInternals: false,
	Npm: false,
	Package: false,
	Plugin: false,
	process: false,
	Random: false,
	ReactiveDict: false,
	ReactiveVar: false,
	Router: false,
	ServiceConfiguration: false,
	Session: false,
	share: false,
	Spacebars: false,
	Template: false,
	Tinytest: false,
	Tracker: false,
	UI: false,
	Utils: false,
	WebApp: false,
	WebAppInternals: false
};
var mongo$1 = {
	_isWindows: false,
	_rand: false,
	BulkWriteResult: false,
	cat: false,
	cd: false,
	connect: false,
	db: false,
	getHostName: false,
	getMemInfo: false,
	hostname: false,
	ISODate: false,
	listFiles: false,
	load: false,
	ls: false,
	md5sumFile: false,
	mkdir: false,
	Mongo: false,
	NumberInt: false,
	NumberLong: false,
	ObjectId: false,
	PlanCache: false,
	print: false,
	printjson: false,
	pwd: false,
	quit: false,
	removeFile: false,
	rs: false,
	sh: false,
	UUID: false,
	version: false,
	WriteResult: false
};
var applescript$1 = {
	$: false,
	Application: false,
	Automation: false,
	console: false,
	delay: false,
	Library: false,
	ObjC: false,
	ObjectSpecifier: false,
	Path: false,
	Progress: false,
	Ref: false
};
var serviceworker$1 = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	clearInterval: false,
	clearTimeout: false,
	Client: false,
	clients: false,
	Clients: false,
	close: true,
	console: false,
	ExtendableEvent: false,
	ExtendableMessageEvent: false,
	fetch: false,
	FetchEvent: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: false,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onfetch: true,
	oninstall: true,
	onlanguagechange: true,
	onmessage: true,
	onmessageerror: true,
	onnotificationclick: true,
	onnotificationclose: true,
	onoffline: true,
	ononline: true,
	onpush: true,
	onpushsubscriptionchange: true,
	onrejectionhandled: true,
	onsync: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	queueMicrotask: false,
	registration: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerGlobalScope: false,
	ServiceWorkerMessageEvent: false,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	skipWaiting: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false,
	WebSocket: false,
	WindowClient: false,
	Worker: false,
	WorkerGlobalScope: false,
	XMLHttpRequest: false
};
var atomtest$1 = {
	advanceClock: false,
	fakeClearInterval: false,
	fakeClearTimeout: false,
	fakeSetInterval: false,
	fakeSetTimeout: false,
	resetTimeouts: false,
	waitsForPromise: false
};
var embertest$1 = {
	andThen: false,
	click: false,
	currentPath: false,
	currentRouteName: false,
	currentURL: false,
	fillIn: false,
	find: false,
	findAll: false,
	findWithAssert: false,
	keyEvent: false,
	pauseTest: false,
	resumeTest: false,
	triggerEvent: false,
	visit: false,
	wait: false
};
var protractor$1 = {
	$: false,
	$$: false,
	browser: false,
	by: false,
	By: false,
	DartObject: false,
	element: false,
	protractor: false
};
var webextensions$1 = {
	browser: false,
	chrome: false,
	opr: false
};
var greasemonkey$1 = {
	cloneInto: false,
	createObjectIn: false,
	exportFunction: false,
	GM: false,
	GM_addStyle: false,
	GM_deleteValue: false,
	GM_getResourceText: false,
	GM_getResourceURL: false,
	GM_getValue: false,
	GM_info: false,
	GM_listValues: false,
	GM_log: false,
	GM_openInTab: false,
	GM_registerMenuCommand: false,
	GM_setClipboard: false,
	GM_setValue: false,
	GM_xmlhttpRequest: false,
	unsafeWindow: false
};
var devtools$1 = {
	$: false,
	$_: false,
	$$: false,
	$0: false,
	$1: false,
	$2: false,
	$3: false,
	$4: false,
	$x: false,
	chrome: false,
	clear: false,
	copy: false,
	debug: false,
	dir: false,
	dirxml: false,
	getEventListeners: false,
	inspect: false,
	keys: false,
	monitor: false,
	monitorEvents: false,
	profile: false,
	profileEnd: false,
	queryObjects: false,
	table: false,
	undebug: false,
	unmonitor: false,
	unmonitorEvents: false,
	values: false
};
var require$$0$2 = {
	builtin: builtin$1,
	es5: es5$1,
	es2015: es2015$1,
	es2017: es2017$1,
	browser: browser$2,
	worker: worker$1,
	node: node$2,
	nodeBuiltin: nodeBuiltin$1,
	commonjs: commonjs$1,
	amd: amd$1,
	mocha: mocha$1,
	jasmine: jasmine$1,
	jest: jest$1,
	qunit: qunit$1,
	phantomjs: phantomjs$1,
	couch: couch$1,
	rhino: rhino$1,
	nashorn: nashorn$1,
	wsh: wsh$1,
	jquery: jquery$1,
	yui: yui$1,
	shelljs: shelljs$1,
	prototypejs: prototypejs$1,
	meteor: meteor$1,
	mongo: mongo$1,
	applescript: applescript$1,
	serviceworker: serviceworker$1,
	atomtest: atomtest$1,
	embertest: embertest$1,
	protractor: protractor$1,
	"shared-node-browser": {
	clearInterval: false,
	clearTimeout: false,
	console: false,
	setInterval: false,
	setTimeout: false,
	URL: false,
	URLSearchParams: false
},
	webextensions: webextensions$1,
	greasemonkey: greasemonkey$1,
	devtools: devtools$1
};

var globals$1 = require$$0$2;

/**
 * @fileoverview Defines environment settings and globals.
 * @author Elan Shanker
 */
// Requirements
//------------------------------------------------------------------------------

 //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Get the object that has difference.
 * @param {Record<string,boolean>} current The newer object.
 * @param {Record<string,boolean>} prev The older object.
 * @returns {Record<string,boolean>} The difference object.
 */


function getDiff(current, prev) {
  const retv = {};

  for (const [key, value] of Object.entries(current)) {
    if (!Object.hasOwnProperty.call(prev, key)) {
      retv[key] = value;
    }
  }

  return retv;
}

const newGlobals2015 = getDiff(globals$1.es2015, globals$1.es5); // 19 variables such as Promise, Map, ...

const newGlobals2017 = {
  Atomics: false,
  SharedArrayBuffer: false
};
const newGlobals2020 = {
  BigInt: false,
  BigInt64Array: false,
  BigUint64Array: false,
  globalThis: false
};
const newGlobals2021 = {
  AggregateError: false,
  FinalizationRegistry: false,
  WeakRef: false
}; //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/** @type {Map<string, import("../lib/shared/types").Environment>} */

var environments = new Map(Object.entries({
  // Language
  builtin: {
    globals: globals$1.es5
  },
  es6: {
    globals: newGlobals2015,
    parserOptions: {
      ecmaVersion: 6
    }
  },
  es2015: {
    globals: newGlobals2015,
    parserOptions: {
      ecmaVersion: 6
    }
  },
  es2017: {
    globals: { ...newGlobals2015,
      ...newGlobals2017
    },
    parserOptions: {
      ecmaVersion: 8
    }
  },
  es2020: {
    globals: { ...newGlobals2015,
      ...newGlobals2017,
      ...newGlobals2020
    },
    parserOptions: {
      ecmaVersion: 11
    }
  },
  es2021: {
    globals: { ...newGlobals2015,
      ...newGlobals2017,
      ...newGlobals2020,
      ...newGlobals2021
    },
    parserOptions: {
      ecmaVersion: 12
    }
  },
  // Platforms
  browser: {
    globals: globals$1.browser
  },
  node: {
    globals: globals$1.node,
    parserOptions: {
      ecmaFeatures: {
        globalReturn: true
      }
    }
  },
  "shared-node-browser": {
    globals: globals$1["shared-node-browser"]
  },
  worker: {
    globals: globals$1.worker
  },
  serviceworker: {
    globals: globals$1.serviceworker
  },
  // Frameworks
  commonjs: {
    globals: globals$1.commonjs,
    parserOptions: {
      ecmaFeatures: {
        globalReturn: true
      }
    }
  },
  amd: {
    globals: globals$1.amd
  },
  mocha: {
    globals: globals$1.mocha
  },
  jasmine: {
    globals: globals$1.jasmine
  },
  jest: {
    globals: globals$1.jest
  },
  phantomjs: {
    globals: globals$1.phantomjs
  },
  jquery: {
    globals: globals$1.jquery
  },
  qunit: {
    globals: globals$1.qunit
  },
  prototypejs: {
    globals: globals$1.prototypejs
  },
  shelljs: {
    globals: globals$1.shelljs
  },
  meteor: {
    globals: globals$1.meteor
  },
  mongo: {
    globals: globals$1.mongo
  },
  protractor: {
    globals: globals$1.protractor
  },
  applescript: {
    globals: globals$1.applescript
  },
  nashorn: {
    globals: globals$1.nashorn
  },
  atomtest: {
    globals: globals$1.atomtest
  },
  embertest: {
    globals: globals$1.embertest
  },
  webextensions: {
    globals: globals$1.webextensions
  },
  greasemonkey: {
    globals: globals$1.greasemonkey
  }
}));

/**
 * Helpers.
 */
var s$1 = 1000;
var m$1 = s$1 * 60;
var h$1 = m$1 * 60;
var d$1 = h$1 * 24;
var w = d$1 * 7;
var y$1 = d$1 * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse$1(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$1;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d$1;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$1;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$1;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$1;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d$1) {
    return Math.round(ms / d$1) + 'd';
  }

  if (msAbs >= h$1) {
    return Math.round(ms / h$1) + 'h';
  }

  if (msAbs >= m$1) {
    return Math.round(ms / m$1) + 'm';
  }

  if (msAbs >= s$1) {
    return Math.round(ms / s$1) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d$1) {
    return plural(ms, msAbs, d$1, 'day');
  }

  if (msAbs >= h$1) {
    return plural(ms, msAbs, h$1, 'hour');
  }

  if (msAbs >= m$1) {
    return plural(ms, msAbs, m$1, 'minute');
  }

  if (msAbs >= s$1) {
    return plural(ms, msAbs, s$1, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  createDebug.destroy = destroy;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    let hash = 0;

    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;

    function debug(...args) {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      const self = debug; // Set `diff` timestamp

      const curr = Number(new Date());
      const ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        const formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
      set: v => {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    const len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    let i;
    let len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

var common = setup;

var browser$1 = createCommonjsModule$1(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = (() => {
  let warned = false;
  return () => {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
})();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  const c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, match => {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || (() => {});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  let r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof browser$1$1 !== 'undefined' && 'env' in browser$1$1) {
    r = browser$1$1.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = common(exports);
const {
  formatters
} = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};
});

// MIT lisence
// from https://github.com/substack/tty-browserify/blob/1ba769a6429d242f36226538835b4034bf6b7886/index.js
function isatty() {
  return false;
}
function ReadStream() {
  throw new Error('tty.ReadStream is not implemented');
}
function WriteStream() {
  throw new Error('tty.ReadStream is not implemented');
}
var tty$1 = {
  isatty: isatty,
  ReadStream: ReadStream,
  WriteStream: WriteStream
};

var tty$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isatty: isatty,
  ReadStream: ReadStream,
  WriteStream: WriteStream,
  'default': tty$1
});

/*
The MIT License (MIT)

Copyright (c) 2016 CoderPuppy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/
var _endianness;

function endianness() {
  if (typeof _endianness === 'undefined') {
    var a = new ArrayBuffer(2);
    var b = new Uint8Array(a);
    var c = new Uint16Array(a);
    b[0] = 1;
    b[1] = 2;

    if (c[0] === 258) {
      _endianness = 'BE';
    } else if (c[0] === 513) {
      _endianness = 'LE';
    } else {
      throw new Error('unable to figure out endianess');
    }
  }

  return _endianness;
}
function hostname() {
  if (typeof global$1.location !== 'undefined') {
    return global$1.location.hostname;
  } else return '';
}
function loadavg() {
  return [];
}
function uptime() {
  return 0;
}
function freemem() {
  return Number.MAX_VALUE;
}
function totalmem() {
  return Number.MAX_VALUE;
}
function cpus() {
  return [];
}
function type$3() {
  return 'Browser';
}
function release() {
  if (typeof global$1.navigator !== 'undefined') {
    return global$1.navigator.appVersion;
  }

  return '';
}
function networkInterfaces() {}
function getNetworkInterfaces() {}
function arch() {
  return 'javascript';
}
function platform() {
  return 'browser';
}
function tmpDir() {
  return '/tmp';
}
var tmpdir = tmpDir;
var EOL = '\n';
var os$1 = {
  EOL: EOL,
  tmpdir: tmpdir,
  tmpDir: tmpDir,
  networkInterfaces: networkInterfaces,
  getNetworkInterfaces: getNetworkInterfaces,
  release: release,
  type: type$3,
  cpus: cpus,
  totalmem: totalmem,
  freemem: freemem,
  uptime: uptime,
  loadavg: loadavg,
  hostname: hostname,
  endianness: endianness
};

var os$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  endianness: endianness,
  hostname: hostname,
  loadavg: loadavg,
  uptime: uptime,
  freemem: freemem,
  totalmem: totalmem,
  cpus: cpus,
  type: type$3,
  release: release,
  networkInterfaces: networkInterfaces,
  getNetworkInterfaces: getNetworkInterfaces,
  arch: arch,
  platform: platform,
  tmpDir: tmpDir,
  tmpdir: tmpdir,
  EOL: EOL,
  'default': os$1
});

var hasFlag = (flag, argv = browser$1$1.argv) => {
  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf('--');
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};

var os = /*@__PURE__*/getAugmentedNamespace(os$2);

var tty = /*@__PURE__*/getAugmentedNamespace(tty$2);

const {
  env
} = browser$1$1;
let forceColor;

if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
  forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
  forceColor = 1;
}

if ('FORCE_COLOR' in env) {
  if (env.FORCE_COLOR === 'true') {
    forceColor = 1;
  } else if (env.FORCE_COLOR === 'false') {
    forceColor = 0;
  } else {
    forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
  }
}

function translateLevel(level) {
  if (level === 0) {
    return false;
  }

  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}

function supportsColor(haveStream, streamIsTTY) {
  if (forceColor === 0) {
    return 0;
  }

  if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
    return 3;
  }

  if (hasFlag('color=256')) {
    return 2;
  }

  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }

  const min = forceColor || 0;

  if (env.TERM === 'dumb') {
    return min;
  }

  if (browser$1$1.platform === 'win32') {
    // Windows 10 build 10586 is the first Windows release that supports 256 colors.
    // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
    const osRelease = os.release().split('.');

    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }

    return 1;
  }

  if ('CI' in env) {
    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
      return 1;
    }

    return min;
  }

  if ('TEAMCITY_VERSION' in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }

  if (env.COLORTERM === 'truecolor') {
    return 3;
  }

  if ('TERM_PROGRAM' in env) {
    const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;

      case 'Apple_Terminal':
        return 2;
      // No default
    }
  }

  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }

  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }

  if ('COLORTERM' in env) {
    return 1;
  }

  return min;
}

function getSupportLevel(stream) {
  const level = supportsColor(stream, stream && stream.isTTY);
  return translateLevel(level);
}

var supportsColor_1 = {
  supportsColor: getSupportLevel,
  stdout: translateLevel(supportsColor(true, tty.isatty(1))),
  stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};

var util$1 = /*@__PURE__*/getAugmentedNamespace(util$3);

var node$1 = createCommonjsModule$1(function (module, exports) {
/**
 * This is the Node.js implementation of `debug()`.
 */


exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util$1.deprecate(() => {}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
  // eslint-disable-next-line import/no-extraneous-dependencies
  const supportsColor = supportsColor_1;

  if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
  }
} catch (error) {// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */


exports.inspectOpts = Object.keys(browser$1$1.env).filter(key => {
  return /^debug_/i.test(key);
}).reduce((obj, key) => {
  // Camel-case
  const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
    return k.toUpperCase();
  }); // Coerce string value into JS value

  let val = browser$1$1.env[key];

  if (/^(yes|on|true|enabled)$/i.test(val)) {
    val = true;
  } else if (/^(no|off|false|disabled)$/i.test(val)) {
    val = false;
  } else if (val === 'null') {
    val = null;
  } else {
    val = Number(val);
  }

  obj[prop] = val;
  return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(browser$1$1.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  const {
    namespace: name,
    useColors
  } = this;

  if (useColors) {
    const c = this.color;
    const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
    const prefix = `  ${colorCode};1m${name} \u001B[0m`;
    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  }

  return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */


function log(...args) {
  return browser$1$1.stderr.write(util$1.format(...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  if (namespaces) {
    browser$1$1.env.DEBUG = namespaces;
  } else {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete browser$1$1.env.DEBUG;
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  return browser$1$1.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */


function init(debug) {
  debug.inspectOpts = {};
  const keys = Object.keys(exports.inspectOpts);

  for (let i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

module.exports = common(exports);
const {
  formatters
} = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util$1.inspect(v, this.inspectOpts).split('\n').map(str => str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */


formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util$1.inspect(v, this.inspectOpts);
};
});

var src = createCommonjsModule$1(function (module) {
if (typeof browser$1$1 === 'undefined' || browser$1$1.type === 'renderer' || browser$1$1.browser === true || browser$1$1.__nwjs) {
  module.exports = browser$1;
} else {
  module.exports = node$1;
}
});

function _interopDefaultLegacy$2(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var eslintVisitorKeys__default$1 = _interopDefaultLegacy$2(lib$5);

var debug__default$1 = _interopDefaultLegacy$2(src);

const breakableTypePattern$1 = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u;
const lineBreakPattern = /\r\n|[\r\n\u2028\u2029]/u;
const shebangPattern = /^#!([^\r\n]+)/u;

function createGlobalLinebreakMatcher() {
  return new RegExp(lineBreakPattern.source, "gu");
}

var astUtils$1 = {
  breakableTypePattern: breakableTypePattern$1,
  lineBreakPattern,
  createGlobalLinebreakMatcher,
  shebangPattern
};
const debug$4 = debug__default$1['default']("eslint:traverser");

function noop$2() {}

function isNode$1(x) {
  return x !== null && typeof x === "object" && typeof x.type === "string";
}

function getVisitorKeys(visitorKeys, node) {
  let keys = visitorKeys[node.type];

  if (!keys) {
    keys = eslintVisitorKeys__default$1['default'].getKeys(node);
    debug$4("Unknown node type \"%s\": Estimated visitor keys %j", node.type, keys);
  }

  return keys;
}

class Traverser {
  constructor() {
    this._current = null;
    this._parents = [];
    this._skipped = false;
    this._broken = false;
    this._visitorKeys = null;
    this._enter = null;
    this._leave = null;
  }

  current() {
    return this._current;
  }

  parents() {
    return this._parents.slice(0);
  }

  break() {
    this._broken = true;
  }

  skip() {
    this._skipped = true;
  }

  traverse(node, options) {
    this._current = null;
    this._parents = [];
    this._skipped = false;
    this._broken = false;
    this._visitorKeys = options.visitorKeys || eslintVisitorKeys__default$1['default'].KEYS;
    this._enter = options.enter || noop$2;
    this._leave = options.leave || noop$2;

    this._traverse(node, null);
  }

  _traverse(node, parent) {
    if (!isNode$1(node)) {
      return;
    }

    this._current = node;
    this._skipped = false;

    this._enter(node, parent);

    if (!this._skipped && !this._broken) {
      const keys = getVisitorKeys(this._visitorKeys, node);

      if (keys.length >= 1) {
        this._parents.push(node);

        for (let i = 0; i < keys.length && !this._broken; ++i) {
          const child = node[keys[i]];

          if (Array.isArray(child)) {
            for (let j = 0; j < child.length && !this._broken; ++j) {
              this._traverse(child[j], node);
            }
          } else {
            this._traverse(child, node);
          }
        }

        this._parents.pop();
      }
    }

    if (!this._broken) {
      this._leave(node, parent);
    }

    this._current = parent;
  }

  static getKeys(node) {
    return eslintVisitorKeys__default$1['default'].getKeys(node);
  }

  static traverse(node, options) {
    new Traverser().traverse(node, options);
  }

  static get DEFAULT_VISITOR_KEYS() {
    return eslintVisitorKeys__default$1['default'].KEYS;
  }

}

var traverser = Traverser;

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace(n) {
  return n && n['default'] || n;
}

var astUtils_1 = astUtils$1;
var createCommonjsModule_1 = createCommonjsModule;
var getCjsExportFromNamespace_1 = getCjsExportFromNamespace;
var traverser_1 = traverser;

var _commonjsHelpers11cbc178 = {
	astUtils: astUtils_1,
	createCommonjsModule: createCommonjsModule_1,
	getCjsExportFromNamespace: getCjsExportFromNamespace_1,
	traverser: traverser_1
};

/**
 * @fileoverview Config file operations. This file must be usable in the browser,
 * so no Node-specific code can be here.
 * @author Nicholas C. Zakas
 */

var configOps = createCommonjsModule$1(function (module) {
// Private
//------------------------------------------------------------------------------

const RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
      RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {
  map[value] = index;
  return map;
}, {}),
      VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"]; //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
  /**
   * Normalizes the severity value of a rule's configuration to a number
   * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally
   * received from the user. A valid config value is either 0, 1, 2, the string "off" (treated the same as 0),
   * the string "warn" (treated the same as 1), the string "error" (treated the same as 2), or an array
   * whose first element is one of the above values. Strings are matched case-insensitively.
   * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.
   */
  getRuleSeverity(ruleConfig) {
    const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

    if (severityValue === 0 || severityValue === 1 || severityValue === 2) {
      return severityValue;
    }

    if (typeof severityValue === "string") {
      return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
    }

    return 0;
  },

  /**
   * Converts old-style severity settings (0, 1, 2) into new-style
   * severity settings (off, warn, error) for all rules. Assumption is that severity
   * values have already been validated as correct.
   * @param {Object} config The config object to normalize.
   * @returns {void}
   */
  normalizeToStrings(config) {
    if (config.rules) {
      Object.keys(config.rules).forEach(ruleId => {
        const ruleConfig = config.rules[ruleId];

        if (typeof ruleConfig === "number") {
          config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
        } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
          ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
        }
      });
    }
  },

  /**
   * Determines if the severity for the given rule configuration represents an error.
   * @param {int|string|Array} ruleConfig The configuration for an individual rule.
   * @returns {boolean} True if the rule represents an error, false if not.
   */
  isErrorSeverity(ruleConfig) {
    return module.exports.getRuleSeverity(ruleConfig) === 2;
  },

  /**
   * Checks whether a given config has valid severity or not.
   * @param {number|string|Array} ruleConfig The configuration for an individual rule.
   * @returns {boolean} `true` if the configuration has valid severity.
   */
  isValidSeverity(ruleConfig) {
    let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

    if (typeof severity === "string") {
      severity = severity.toLowerCase();
    }

    return VALID_SEVERITIES.indexOf(severity) !== -1;
  },

  /**
   * Checks whether every rule of a given config has valid severity or not.
   * @param {Object} config The configuration for rules.
   * @returns {boolean} `true` if the configuration has valid severity.
   */
  isEverySeverityValid(config) {
    return Object.keys(config).every(ruleId => this.isValidSeverity(config[ruleId]));
  },

  /**
   * Normalizes a value for a global in a config
   * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in
   * a global directive comment
   * @returns {("readable"|"writeable"|"off")} The value normalized as a string
   * @throws Error if global value is invalid
   */
  normalizeConfigGlobal(configuredValue) {
    switch (configuredValue) {
      case "off":
        return "off";

      case true:
      case "true":
      case "writeable":
      case "writable":
        return "writable";

      case null:
      case false:
      case "false":
      case "readable":
      case "readonly":
        return "readonly";

      default:
        throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
    }
  }

};
});

/**
 * @fileoverview Defines a schema for configs.
 * @author Sylvan Mably
 */

const baseConfigProperties = {
  $schema: {
    type: "string"
  },
  env: {
    type: "object"
  },
  extends: {
    $ref: "#/definitions/stringOrStrings"
  },
  globals: {
    type: "object"
  },
  overrides: {
    type: "array",
    items: {
      $ref: "#/definitions/overrideConfig"
    },
    additionalItems: false
  },
  parser: {
    type: ["string", "null"]
  },
  parserOptions: {
    type: "object"
  },
  plugins: {
    type: "array"
  },
  processor: {
    type: "string"
  },
  rules: {
    type: "object"
  },
  settings: {
    type: "object"
  },
  noInlineConfig: {
    type: "boolean"
  },
  reportUnusedDisableDirectives: {
    type: "boolean"
  },
  ecmaFeatures: {
    type: "object"
  } // deprecated; logs a warning when used

};
const configSchema = {
  definitions: {
    stringOrStrings: {
      oneOf: [{
        type: "string"
      }, {
        type: "array",
        items: {
          type: "string"
        },
        additionalItems: false
      }]
    },
    stringOrStringsRequired: {
      oneOf: [{
        type: "string"
      }, {
        type: "array",
        items: {
          type: "string"
        },
        additionalItems: false,
        minItems: 1
      }]
    },
    // Config at top-level.
    objectConfig: {
      type: "object",
      properties: {
        root: {
          type: "boolean"
        },
        ignorePatterns: {
          $ref: "#/definitions/stringOrStrings"
        },
        ...baseConfigProperties
      },
      additionalProperties: false
    },
    // Config in `overrides`.
    overrideConfig: {
      type: "object",
      properties: {
        excludedFiles: {
          $ref: "#/definitions/stringOrStrings"
        },
        files: {
          $ref: "#/definitions/stringOrStringsRequired"
        },
        ...baseConfigProperties
      },
      required: ["files"],
      additionalProperties: false
    }
  },
  $ref: "#/definitions/objectConfig"
};
var configSchema_1 = configSchema;

var path = /*@__PURE__*/getAugmentedNamespace(path$2);

// Requirements
//------------------------------------------------------------------------------

 //------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------
// Defitions for deprecation warnings.


const deprecationWarningMessages = {
  ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated and has no effect.",
  ESLINT_PERSONAL_CONFIG_LOAD: "'~/.eslintrc.*' config files have been deprecated. " + "Please use a config file per project or the '--config' option.",
  ESLINT_PERSONAL_CONFIG_SUPPRESS: "'~/.eslintrc.*' config files have been deprecated. " + "Please remove it or add 'root:true' to the config files in your " + "projects in order to avoid loading '~/.eslintrc.*' accidentally."
};
const sourceFileErrorCache = new Set();
/**
 * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted
 * for each unique file path, but repeated invocations with the same file path have no effect.
 * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.
 * @param {string} source The name of the configuration source to report the warning for.
 * @param {string} errorCode The warning message to show.
 * @returns {void}
 */

function emitDeprecationWarning$1(source, errorCode) {
  const cacheKey = JSON.stringify({
    source,
    errorCode
  });

  if (sourceFileErrorCache.has(cacheKey)) {
    return;
  }

  sourceFileErrorCache.add(cacheKey);
  const rel = path.relative(browser$1$1.cwd(), source);
  const message = deprecationWarningMessages[errorCode];
  browser$1$1.emitWarning(`${message} (found in "${rel}")`, "DeprecationWarning", errorCode);
} //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------


var deprecationWarnings = {
  emitDeprecationWarning: emitDeprecationWarning$1
};

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */

var uri_all = createCommonjsModule$1(function (module, exports) {
(function (global, factory) {
  factory(exports) ;
})(commonjsGlobal, function (exports) {

  function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
      sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
      sets[0] = sets[0].slice(0, -1);
      var xl = sets.length - 1;

      for (var x = 1; x < xl; ++x) {
        sets[x] = sets[x].slice(1, -1);
      }

      sets[xl] = sets[xl].slice(1);
      return sets.join('');
    } else {
      return sets[0];
    }
  }

  function subexp(str) {
    return "(?:" + str + ")";
  }

  function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
  }

  function toUpperCase(str) {
    return str.toUpperCase();
  }

  function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
  }

  function assign(target, source) {
    var obj = target;

    if (source) {
      for (var key in source) {
        obj[key] = source[key];
      }
    }

    return obj;
  }

  function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        DIGIT$$ = "[0-9]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
        //RFC 6874, with relaxed parsing rules
    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
        //RFC 6874
    subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
    return {
      NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
      NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
      NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
      ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      UNRESERVED: new RegExp(UNRESERVED$$, "g"),
      OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
      PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
      IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
      IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules

    };
  }

  var URI_PROTOCOL = buildExps(false);
  var IRI_PROTOCOL = buildExps(true);

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };
  /** Highest positive signed 32-bit float value */


  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */

  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80

  var delimiter = '-'; // '\x2D'

  /** Regular expressions */

  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars

  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */

  var errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  };
  /** Convenience shortcuts */

  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error$1(type) {
    throw new RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var result = [];
    var length = array.length;

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;

    while (counter < length) {
      var value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // It's a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // It's an unmatched surrogate; only append this code unit, in case the
          // next code unit is the high surrogate of a surrogate pair.
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  var ucs2encode = function ucs2encode(array) {
    return String.fromCodePoint.apply(String, toConsumableArray(array));
  };
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  var basicToDigit = function basicToDigit(codePoint) {
    if (codePoint - 0x30 < 0x0A) {
      return codePoint - 0x16;
    }

    if (codePoint - 0x41 < 0x1A) {
      return codePoint - 0x41;
    }

    if (codePoint - 0x61 < 0x1A) {
      return codePoint - 0x61;
    }

    return base;
  };
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  var digitToBasic = function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  var adapt = function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  var decode = function decode(input) {
    // Don't use UCS-2.
    var output = [];
    var inputLength = input.length;
    var i = 0;
    var n = initialN;
    var bias = initialBias; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    var basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (var j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error$1('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;)
    /* no final expression */
    {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      var oldi = i;

      for (var w = 1, k = base;;
      /* no condition */
      k += base) {
        if (index >= inputLength) {
          error$1('invalid-input');
        }

        var digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error$1('overflow');
        }

        i += digit * w;
        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        var baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error$1('overflow');
        }

        w *= baseMinusT;
      }

      var out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error$1('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output.

      output.splice(i++, 0, n);
    }

    return String.fromCodePoint.apply(String, output);
  };
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  var encode = function encode(input) {
    var output = []; // Convert the input in UCS-2 to an array of Unicode code points.

    input = ucs2decode(input); // Cache the length.

    var inputLength = input.length; // Initialize the state.

    var n = initialN;
    var delta = 0;
    var bias = initialBias; // Handle the basic code points.

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _currentValue2 = _step.value;

        if (_currentValue2 < 0x80) {
          output.push(stringFromCharCode(_currentValue2));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var basicLength = output.length;
    var handledCPCount = basicLength; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string with a delimiter unless it's empty.

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      var m = maxInt;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var currentValue = _step2.value;

          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow.

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error$1('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _currentValue = _step3.value;

          if (_currentValue < n && ++delta > maxInt) {
            error$1('overflow');
          }

          if (_currentValue == n) {
            // Represent delta as a generalized variable-length integer.
            var q = delta;

            for (var k = base;;
            /* no condition */
            k += base) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

              if (q < t) {
                break;
              }

              var qMinusT = q - t;
              var baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  };
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  var toUnicode = function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  var toASCII = function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  };
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  var punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '2.1.0',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /**
   * URI.js
   *
   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/uri-js
   */

  /**
   * Copyright 2011 Gary Court. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without modification, are
   * permitted provided that the following conditions are met:
   *
   *    1. Redistributions of source code must retain the above copyright notice, this list of
   *       conditions and the following disclaimer.
   *
   *    2. Redistributions in binary form must reproduce the above copyright notice, this list
   *       of conditions and the following disclaimer in the documentation and/or other materials
   *       provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * The views and conclusions contained in the software and documentation are those of the
   * authors and should not be interpreted as representing official policies, either expressed
   * or implied, of Gary Court.
   */

  var SCHEMES = {};

  function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
  }

  function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;

    while (i < il) {
      var c = parseInt(str.substr(i + 1, 2), 16);

      if (c < 128) {
        newStr += String.fromCharCode(c);
        i += 3;
      } else if (c >= 194 && c < 224) {
        if (il - i >= 6) {
          var c2 = parseInt(str.substr(i + 4, 2), 16);
          newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
        } else {
          newStr += str.substr(i, 6);
        }

        i += 6;
      } else if (c >= 224) {
        if (il - i >= 9) {
          var _c = parseInt(str.substr(i + 4, 2), 16);

          var c3 = parseInt(str.substr(i + 7, 2), 16);
          newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
        } else {
          newStr += str.substr(i, 9);
        }

        i += 9;
      } else {
        newStr += str.substr(i, 3);
        i += 3;
      }
    }

    return newStr;
  }

  function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }

    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
  }

  function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
  }

  function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
      return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
      return host;
    }
  }

  function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
      var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
          _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
          last = _address$toLowerCase$2[0],
          first = _address$toLowerCase$2[1];

      var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
      var lastFields = last.split(":").map(_stripLeadingZeros);
      var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
      var fieldCount = isLastFieldIPv4Address ? 7 : 8;
      var lastFieldsStart = lastFields.length - fieldCount;
      var fields = Array(fieldCount);

      for (var x = 0; x < fieldCount; ++x) {
        fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
      }

      if (isLastFieldIPv4Address) {
        fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
      }

      var allZeroFields = fields.reduce(function (acc, field, index) {
        if (!field || field === "0") {
          var lastLongest = acc[acc.length - 1];

          if (lastLongest && lastLongest.index + lastLongest.length === index) {
            lastLongest.length++;
          } else {
            acc.push({
              index: index,
              length: 1
            });
          }
        }

        return acc;
      }, []);
      var longestZeroFields = allZeroFields.sort(function (a, b) {
        return b.length - a.length;
      })[0];
      var newHost = void 0;

      if (longestZeroFields && longestZeroFields.length > 1) {
        var newFirst = fields.slice(0, longestZeroFields.index);
        var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
        newHost = newFirst.join(":") + "::" + newLast.join(":");
      } else {
        newHost = fields.join(":");
      }

      if (zone) {
        newHost += "%" + zone;
      }

      return newHost;
    } else {
      return host;
    }
  }

  var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
  var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;

  function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);

    if (matches) {
      if (NO_MATCH_IS_UNDEFINED) {
        //store each component
        components.scheme = matches[1];
        components.userinfo = matches[3];
        components.host = matches[4];
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = matches[7];
        components.fragment = matches[8]; //fix port number

        if (isNaN(components.port)) {
          components.port = matches[5];
        }
      } else {
        //IE FIX for improper RegExp matching
        //store each component
        components.scheme = matches[1] || undefined;
        components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
        components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
        components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined; //fix port number

        if (isNaN(components.port)) {
          components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
        }
      }

      if (components.host) {
        //normalize IP hosts
        components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
      } //determine reference type


      if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
        components.reference = "same-document";
      } else if (components.scheme === undefined) {
        components.reference = "relative";
      } else if (components.fragment === undefined) {
        components.reference = "absolute";
      } else {
        components.reference = "uri";
      } //check for reference errors


      if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
        components.error = components.error || "URI is not a " + options.reference + " reference.";
      } //find scheme handler


      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()]; //check if scheme can't handle IRIs

      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        //if host component is a domain name
        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
          //convert Unicode IDN -> ASCII IDN
          try {
            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
          }
        } //convert IRI -> URI


        _normalizeComponentEncoding(components, URI_PROTOCOL);
      } else {
        //normalize encodings
        _normalizeComponentEncoding(components, protocol);
      } //perform scheme specific parsing


      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(components, options);
      }
    } else {
      components.error = components.error || "URI can not be parsed.";
    }

    return components;
  }

  function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];

    if (components.userinfo !== undefined) {
      uriTokens.push(components.userinfo);
      uriTokens.push("@");
    }

    if (components.host !== undefined) {
      //normalize IP hosts, add brackets and escape zone separator for IPv6
      uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
        return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
      }));
    }

    if (typeof components.port === "number" || typeof components.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(components.port));
    }

    return uriTokens.length ? uriTokens.join("") : undefined;
  }

  var RDS1 = /^\.\.?\//;
  var RDS2 = /^\/\.(\/|$)/;
  var RDS3 = /^\/\.\.(\/|$)/;
  var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;

  function removeDotSegments(input) {
    var output = [];

    while (input.length) {
      if (input.match(RDS1)) {
        input = input.replace(RDS1, "");
      } else if (input.match(RDS2)) {
        input = input.replace(RDS2, "/");
      } else if (input.match(RDS3)) {
        input = input.replace(RDS3, "/");
        output.pop();
      } else if (input === "." || input === "..") {
        input = "";
      } else {
        var im = input.match(RDS5);

        if (im) {
          var s = im[0];
          input = input.slice(s.length);
          output.push(s);
        } else {
          throw new Error("Unexpected dot segment condition");
        }
      }
    }

    return output.join("");
  }

  function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = []; //find scheme handler

    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()]; //perform scheme specific serialization

    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

    if (components.host) {
      //if host component is an IPv6 address
      if (protocol.IPV6ADDRESS.test(components.host)) ; //TODO: normalize IPv6 address as per RFC 5952
      //if host component is a domain name
      else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          //convert IDN via punycode
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
    } //normalize encoding


    _normalizeComponentEncoding(components, protocol);

    if (options.reference !== "suffix" && components.scheme) {
      uriTokens.push(components.scheme);
      uriTokens.push(":");
    }

    var authority = _recomposeAuthority(components, options);

    if (authority !== undefined) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }

      uriTokens.push(authority);

      if (components.path && components.path.charAt(0) !== "/") {
        uriTokens.push("/");
      }
    }

    if (components.path !== undefined) {
      var s = components.path;

      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }

      if (authority === undefined) {
        s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
      }

      uriTokens.push(s);
    }

    if (components.query !== undefined) {
      uriTokens.push("?");
      uriTokens.push(components.query);
    }

    if (components.fragment !== undefined) {
      uriTokens.push("#");
      uriTokens.push(components.fragment);
    }

    return uriTokens.join(""); //merge tokens into a string
  }

  function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];
    var target = {};

    if (!skipNormalization) {
      base = parse(serialize(base, options), options); //normalize base components

      relative = parse(serialize(relative, options), options); //normalize relative components
    }

    options = options || {};

    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme; //target.authority = relative.authority;

      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;

          if (relative.query !== undefined) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path.charAt(0) === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }

            target.path = removeDotSegments(target.path);
          }

          target.query = relative.query;
        } //target.authority = base.authority;


        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }

      target.scheme = base.scheme;
    }

    target.fragment = relative.fragment;
    return target;
  }

  function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({
      scheme: 'null'
    }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
  }

  function normalize(uri, options) {
    if (typeof uri === "string") {
      uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
      uri = parse(serialize(uri, options), options);
    }

    return uri;
  }

  function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
      uriA = serialize(uriA, options);
    }

    if (typeof uriB === "string") {
      uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
      uriB = serialize(uriB, options);
    }

    return uriA === uriB;
  }

  function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
  }

  function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
  }

  var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
      //report missing host
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }

      return components;
    },
    serialize: function serialize(components, options) {
      var secure = String(components.scheme).toLowerCase() === "https"; //normalize the default port

      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = undefined;
      } //normalize the empty path


      if (!components.path) {
        components.path = "/";
      } //NOTE: We do not parse query strings for HTTP URIs
      //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
      //and not the HTTP spec.


      return components;
    }
  };
  var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
  };

  function isSecure(wsComponents) {
    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
  } //RFC 6455


  var handler$2 = {
    scheme: "ws",
    domainHost: true,
    parse: function parse(components, options) {
      var wsComponents = components; //indicate if the secure flag is set

      wsComponents.secure = isSecure(wsComponents); //construct resouce name

      wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
      wsComponents.path = undefined;
      wsComponents.query = undefined;
      return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
      //normalize the default port
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = undefined;
      } //ensure scheme matches secure flag


      if (typeof wsComponents.secure === 'boolean') {
        wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
        wsComponents.secure = undefined;
      } //reconstruct path from resource name


      if (wsComponents.resourceName) {
        var _wsComponents$resourc = wsComponents.resourceName.split('?'),
            _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
            path = _wsComponents$resourc2[0],
            query = _wsComponents$resourc2[1];

        wsComponents.path = path && path !== '/' ? path : undefined;
        wsComponents.query = query;
        wsComponents.resourceName = undefined;
      } //forbid fragment component


      wsComponents.fragment = undefined;
      return wsComponents;
    }
  };
  var handler$3 = {
    scheme: "wss",
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
  };
  var O = {};

  var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
  var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive

  var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
  //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
  //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
  //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
  //const VCHAR$$ = "[\\x21-\\x7E]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
  //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
  //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
  //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');

  var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
  var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
  var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
  var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
  var UNRESERVED = new RegExp(UNRESERVED$$, "g");
  var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
  var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
  var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
  var NOT_HFVALUE = NOT_HFNAME;

  function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
  }

  var handler$4 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
      var mailtoComponents = components;
      var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
      mailtoComponents.path = undefined;

      if (mailtoComponents.query) {
        var unknownHeaders = false;
        var headers = {};
        var hfields = mailtoComponents.query.split("&");

        for (var x = 0, xl = hfields.length; x < xl; ++x) {
          var hfield = hfields[x].split("=");

          switch (hfield[0]) {
            case "to":
              var toAddrs = hfield[1].split(",");

              for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                to.push(toAddrs[_x]);
              }

              break;

            case "subject":
              mailtoComponents.subject = unescapeComponent(hfield[1], options);
              break;

            case "body":
              mailtoComponents.body = unescapeComponent(hfield[1], options);
              break;

            default:
              unknownHeaders = true;
              headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
              break;
          }
        }

        if (unknownHeaders) mailtoComponents.headers = headers;
      }

      mailtoComponents.query = undefined;

      for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
        var addr = to[_x2].split("@");

        addr[0] = unescapeComponent(addr[0]);

        if (!options.unicodeSupport) {
          //convert Unicode IDN -> ASCII IDN
          try {
            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
          } catch (e) {
            mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
          }
        } else {
          addr[1] = unescapeComponent(addr[1], options).toLowerCase();
        }

        to[_x2] = addr.join("@");
      }

      return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
      var components = mailtoComponents;
      var to = toArray(mailtoComponents.to);

      if (to) {
        for (var x = 0, xl = to.length; x < xl; ++x) {
          var toAddr = String(to[x]);
          var atIdx = toAddr.lastIndexOf("@");
          var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
          var domain = toAddr.slice(atIdx + 1); //convert IDN via punycode

          try {
            domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
          } catch (e) {
            components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }

          to[x] = localPart + "@" + domain;
        }

        components.path = to.join(",");
      }

      var headers = mailtoComponents.headers = mailtoComponents.headers || {};
      if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
      if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
      var fields = [];

      for (var name in headers) {
        if (headers[name] !== O[name]) {
          fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
        }
      }

      if (fields.length) {
        components.query = fields.join("&");
      }

      return components;
    }
  };
  var URN_PARSE = /^([^\:]+)\:(.*)/; //RFC 2141

  var handler$5 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
      var matches = components.path && components.path.match(URN_PARSE);
      var urnComponents = components;

      if (matches) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = matches[1].toLowerCase();
        var nss = matches[2];
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        urnComponents.nid = nid;
        urnComponents.nss = nss;
        urnComponents.path = undefined;

        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }

      return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
      var scheme = options.scheme || urnComponents.scheme || "urn";
      var nid = urnComponents.nid;
      var urnScheme = scheme + ":" + (options.nid || nid);
      var schemeHandler = SCHEMES[urnScheme];

      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }

      var uriComponents = urnComponents;
      var nss = urnComponents.nss;
      uriComponents.path = (nid || options.nid) + ":" + nss;
      return uriComponents;
    }
  };
  var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/; //RFC 4122

  var handler$6 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
      var uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = undefined;

      if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }

      return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
      var urnComponents = uuidComponents; //normalize UUID

      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
  };
  SCHEMES[handler.scheme] = handler;
  SCHEMES[handler$1.scheme] = handler$1;
  SCHEMES[handler$2.scheme] = handler$2;
  SCHEMES[handler$3.scheme] = handler$3;
  SCHEMES[handler$4.scheme] = handler$4;
  SCHEMES[handler$5.scheme] = handler$5;
  SCHEMES[handler$6.scheme] = handler$6;
  exports.SCHEMES = SCHEMES;
  exports.pctEncChar = pctEncChar;
  exports.pctDecChars = pctDecChars;
  exports.parse = parse;
  exports.removeDotSegments = removeDotSegments;
  exports.serialize = serialize;
  exports.resolveComponents = resolveComponents;
  exports.resolve = resolve;
  exports.normalize = normalize;
  exports.equal = equal;
  exports.escapeComponent = escapeComponent;
  exports.unescapeComponent = unescapeComponent;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
});

var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;
    var length, i, keys;

    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;

      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  } // true if both NaN, false otherwise


  return a !== a && b !== b;
};

// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode

var ucs2length$1 = function ucs2length(str) {
  var length = 0,
      len = str.length,
      pos = 0,
      value;

  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);

    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }

  return length;
};

var util = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash$1,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: fastDeepEqual,
  ucs2length: ucs2length$1,
  varOccurences: varOccurences,
  varReplace: varReplace,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};

function copy(o, to) {
  to = to || {};

  for (var key in o) to[key] = o[key];

  return to;
}

function checkDataType(dataType, data, strictNumbers, negate) {
  var EQUAL = negate ? ' !== ' : ' === ',
      AND = negate ? ' || ' : ' && ',
      OK = negate ? '!' : '',
      NOT = negate ? '' : '!';

  switch (dataType) {
    case 'null':
      return data + EQUAL + 'null';

    case 'array':
      return OK + 'Array.isArray(' + data + ')';

    case 'object':
      return '(' + OK + data + AND + 'typeof ' + data + EQUAL + '"object"' + AND + NOT + 'Array.isArray(' + data + '))';

    case 'integer':
      return '(typeof ' + data + EQUAL + '"number"' + AND + NOT + '(' + data + ' % 1)' + AND + data + EQUAL + data + (strictNumbers ? AND + OK + 'isFinite(' + data + ')' : '') + ')';

    case 'number':
      return '(typeof ' + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + 'isFinite(' + data + ')' : '') + ')';

    default:
      return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}

function checkDataTypes(dataTypes, data, strictNumbers) {
  switch (dataTypes.length) {
    case 1:
      return checkDataType(dataTypes[0], data, strictNumbers, true);

    default:
      var code = '';
      var types = toHash$1(dataTypes);

      if (types.array && types.object) {
        code = types.null ? '(' : '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }

      if (types.number) delete types.integer;

      for (var t in types) code += (code ? ' && ' : '') + checkDataType(t, data, strictNumbers, true);

      return code;
  }
}

var COERCE_TO_TYPES = toHash$1(['string', 'number', 'integer', 'boolean', 'null']);

function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];

    for (var i = 0; i < dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }

    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}

function toHash$1(arr) {
  var hash = {};

  for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;

  return hash;
}

var IDENTIFIER$1 = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;

function getProperty(key) {
  return typeof key == 'number' ? '[' + key + ']' : IDENTIFIER$1.test(key) ? '.' + key : "['" + escapeQuotes(key) + "']";
}

function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\f/g, '\\f').replace(/\t/g, '\\t');
}

function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}

function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}

function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;

  for (var key in schema) if (rules[key]) return true;
}

function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';

  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}

function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;

  for (var key in schema) if (!rules[key]) return key;
}

function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}

function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
  ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')') : isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'';
  return joinPaths(currentPath, path);
}

function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
  ? toQuotedString('/' + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}

var JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;

function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';

  if ($data[0] == '/') {
    if (!JSON_POINTER$1.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER$1);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];

    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + (lvl - up || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];

    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }

  return expr;
}

function joinPaths(a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
}

function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}

function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}

function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

var schema_obj = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

var jsonSchemaTraverse = createCommonjsModule$1(function (module) {

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = typeof cb == 'function' ? cb : cb.pre || function () {};

  var post = cb.post || function () {};

  _traverse(opts, pre, post, schema, '', schema);
};

traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};
traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};

function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);

    for (var key in schema) {
      var sch = schema[key];

      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }

    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}

function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
});

var resolve_1 = resolve;
resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;
/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */

function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];

  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];

  if (refVal instanceof schema_obj) {
    return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;

  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof schema_obj) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}
/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */


function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = uri_all.parse(ref),
      refPath = _getFullPath(p),
      baseId = getFullPath(this._getId(root.schema));

  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];

    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof schema_obj) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];

      if (refVal instanceof schema_obj) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref)) return {
          schema: refVal,
          root: root,
          baseId: baseId
        };
        root = refVal;
      } else {
        return;
      }
    }

    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }

  return getJsonPointer.call(this, p, baseId, root.schema, root);
}
/* @this Ajv */


function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);

  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;

    var id = this._getId(schema);

    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}

var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */

function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0, 1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];

    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;

      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);

        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);

          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }

  if (schema !== undefined && schema !== root.schema) return {
    schema: schema,
    root: root,
    baseId: baseId
  };
}

var SIMPLE_INLINED = util.toHash(['type', 'format', 'pattern', 'maxLength', 'minLength', 'maxProperties', 'minProperties', 'maxItems', 'minItems', 'maximum', 'minimum', 'uniqueItems', 'multipleOf', 'required', 'enum']);

function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);else if (limit) return countKeys(schema) <= limit;
}

function checkNoRef(schema) {
  var item;

  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }

  return true;
}

function countKeys(schema) {
  var count = 0,
      item;

  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;

      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }

  return count;
}

function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = uri_all.parse(id);
  return _getFullPath(p);
}

function _getFullPath(p) {
  return uri_all.serialize(p).split('#')[0] + '#';
}

var TRAILING_SLASH_HASH = /#\/?$/;

function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}

function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return uri_all.resolve(baseId, id);
}
/* @this Ajv */


function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {
    '': schemaId
  };
  var fullPaths = {
    '': getFullPath(schemaId, false)
  };
  var localRefs = {};
  var self = this;
  jsonSchemaTraverse(schema, {
    allKeys: true
  }, function (sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;

    var id = self._getId(sch);

    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined) fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? uri_all.resolve(baseId, id) : id);
      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];

      if (refVal && refVal.schema) {
        if (!fastDeepEqual(sch, refVal.schema)) throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !fastDeepEqual(sch, localRefs[id])) throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }

    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });
  return localRefs;
}

var error_classes = {
  Validation: errorSubclass(ValidationError$1),
  MissingRef: errorSubclass(MissingRefError$1)
};

function ValidationError$1(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}

MissingRefError$1.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};

function MissingRefError$1(baseId, ref, message) {
  this.message = message || MissingRefError$1.message(baseId, ref);
  this.missingRef = resolve_1.url(baseId, ref);
  this.missingSchema = resolve_1.normalizeId(resolve_1.fullPath(this.missingRef));
}

function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}

var fastJsonStableStringify = function (data, opts) {
  if (!opts) opts = {};
  if (typeof opts === 'function') opts = {
    cmp: opts
  };
  var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;

  var cmp = opts.cmp && function (f) {
    return function (node) {
      return function (a, b) {
        var aobj = {
          key: a,
          value: node[a]
        };
        var bobj = {
          key: b,
          value: node[b]
        };
        return f(aobj, bobj);
      };
    };
  }(opts.cmp);

  var seen = [];
  return function stringify(node) {
    if (node && node.toJSON && typeof node.toJSON === 'function') {
      node = node.toJSON();
    }

    if (node === undefined) return;
    if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
    if (typeof node !== 'object') return JSON.stringify(node);
    var i, out;

    if (Array.isArray(node)) {
      out = '[';

      for (i = 0; i < node.length; i++) {
        if (i) out += ',';
        out += stringify(node[i]) || 'null';
      }

      return out + ']';
    }

    if (node === null) return 'null';

    if (seen.indexOf(node) !== -1) {
      if (cycles) return JSON.stringify('__cycle__');
      throw new TypeError('Converting circular structure to JSON');
    }

    var seenIndex = seen.push(node) - 1;
    var keys = Object.keys(node).sort(cmp && cmp(node));
    out = '';

    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = stringify(node[key]);
      if (!value) continue;
      if (out) out += ',';
      out += JSON.stringify(key) + ':' + value;
    }

    seen.splice(seenIndex, 1);
    return '{' + out + '}';
  }(data);
};

var validate$2 = function generate_validate(it, $keyword, $ruleType) {
  var out = '';

  var $async = it.schema.$async === true,
      $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
      $id = it.self._getId(it.schema);

  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);

    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);else throw new Error($keywordsMsg);
    }
  }

  if (it.isTop) {
    out += ' var validate = ';

    if ($async) {
      it.async = true;
      out += 'async ';
    }

    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';

    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }

  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;

    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + $valid + ' = false; ';
      }

      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      /* istanbul ignore else */

      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';

        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }

        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }

        out += ' } ';
      } else {
        out += ' {} ';
      }

      var __err = out;
      out = $$outStack.pop();

      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + $valid + ' = true; ';
      }
    }

    if (it.isTop) {
      out += ' }; return validate; ';
    }

    return out;
  }

  if (it.isTop) {
    var $top = it.isTop,
        $lvl = it.level = 0,
        $dataLvl = it.dataLevel = 0,
        $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [""];

    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);else throw new Error($defaultMsg);
    }

    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
        $dataLvl = it.dataLevel,
        $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + $lvl + ' = errors;';
  }

  var $valid = 'valid' + $lvl,
      $breakOnError = !it.opts.allErrors,
      $closingBraces1 = '',
      $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
      $typeIsArray = Array.isArray($typeSchema);

  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }

  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }

  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }

  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + it.RULES.all.$comment.code(it, '$comment');
  }

  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }

    var $rulesGroup = it.RULES.types[$typeSchema];

    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
      var $schemaPath = it.schemaPath + '.type',
          $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
          $errSchemaPath = it.errSchemaPath + '/type',
          $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ') { ';

      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
            $coerced = 'coerced' + $lvl;
        out += ' var ' + $dataType + ' = typeof ' + $data + '; var ' + $coerced + ' = undefined; ';

        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + $dataType + ' == \'object\' && Array.isArray(' + $data + ') && ' + $data + '.length == 1) { ' + $data + ' = ' + $data + '[0]; ' + $dataType + ' = typeof ' + $data + '; if (' + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ') ' + $coerced + ' = ' + $data + '; } ';
        }

        out += ' if (' + $coerced + ' !== undefined) ; ';
        var arr1 = $coerceToTypes;

        if (arr1) {
          var $type,
              $i = -1,
              l1 = arr1.length - 1;

          while ($i < l1) {
            $type = arr1[$i += 1];

            if ($type == 'string') {
              out += ' else if (' + $dataType + ' == \'number\' || ' + $dataType + ' == \'boolean\') ' + $coerced + ' = \'\' + ' + $data + '; else if (' + $data + ' === null) ' + $coerced + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' else if (' + $dataType + ' == \'boolean\' || ' + $data + ' === null || (' + $dataType + ' == \'string\' && ' + $data + ' && ' + $data + ' == +' + $data + ' ';

              if ($type == 'integer') {
                out += ' && !(' + $data + ' % 1)';
              }

              out += ')) ' + $coerced + ' = +' + $data + '; ';
            } else if ($type == 'boolean') {
              out += ' else if (' + $data + ' === \'false\' || ' + $data + ' === 0 || ' + $data + ' === null) ' + $coerced + ' = false; else if (' + $data + ' === \'true\' || ' + $data + ' === 1) ' + $coerced + ' = true; ';
            } else if ($type == 'null') {
              out += ' else if (' + $data + ' === \'\' || ' + $data + ' === 0 || ' + $data + ' === false) ' + $coerced + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' else if (' + $dataType + ' == \'string\' || ' + $dataType + ' == \'number\' || ' + $dataType + ' == \'boolean\' || ' + $data + ' == null) ' + $coerced + ' = [' + $data + ']; ';
            }
          }
        }

        out += ' else {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        /* istanbul ignore else */

        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';

          if ($typeIsArray) {
            out += '' + $typeSchema.join(",");
          } else {
            out += '' + $typeSchema;
          }

          out += '\' } ';

          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';

            if ($typeIsArray) {
              out += '' + $typeSchema.join(",");
            } else {
              out += '' + $typeSchema;
            }

            out += '\' ';
          }

          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }

          out += ' } ';
        } else {
          out += ' {} ';
        }

        var __err = out;
        out = $$outStack.pop();

        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }

        out += ' } if (' + $coerced + ' !== undefined) {  ';
        var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
            $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + $data + ' = ' + $coerced + '; ';

        if (!$dataLvl) {
          out += 'if (' + $parentData + ' !== undefined)';
        }

        out += ' ' + $parentData + '[' + $parentDataProperty + '] = ' + $coerced + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        /* istanbul ignore else */

        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';

          if ($typeIsArray) {
            out += '' + $typeSchema.join(",");
          } else {
            out += '' + $typeSchema;
          }

          out += '\' } ';

          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';

            if ($typeIsArray) {
              out += '' + $typeSchema.join(",");
            } else {
              out += '' + $typeSchema;
            }

            out += '\' ';
          }

          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }

          out += ' } ';
        } else {
          out += ' {} ';
        }

        var __err = out;
        out = $$outStack.pop();

        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }

      out += ' } ';
    }
  }

  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + it.RULES.all.$ref.code(it, '$ref') + ' ';

    if ($breakOnError) {
      out += ' } if (errors === ';

      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + $lvl;
      }

      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;

    if (arr2) {
      var $rulesGroup,
          i2 = -1,
          l2 = arr2.length - 1;

      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];

        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ') { ';
          }

          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                  $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;

              if (arr3) {
                var $propertyKey,
                    i3 = -1,
                    l3 = arr3.length - 1;

                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];

                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);

                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + $passData + ' === undefined ';

                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + $passData + ' === null || ' + $passData + ' === \'\' ';
                      }

                      out += ' ) ' + $passData + ' = ';

                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + it.useDefault($sch.default) + ' ';
                      } else {
                        out += ' ' + JSON.stringify($sch.default) + ' ';
                      }

                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;

              if (arr4) {
                var $sch,
                    $i = -1,
                    l4 = arr4.length - 1;

                while ($i < l4) {
                  $sch = arr4[$i += 1];

                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';

                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + $passData + ' === undefined ';

                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + $passData + ' === null || ' + $passData + ' === \'\' ';
                      }

                      out += ' ) ' + $passData + ' = ';

                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + it.useDefault($sch.default) + ' ';
                      } else {
                        out += ' ' + JSON.stringify($sch.default) + ' ';
                      }

                      out += '; ';
                    }
                  }
                }
              }
            }
          }

          var arr5 = $rulesGroup.rules;

          if (arr5) {
            var $rule,
                i5 = -1,
                l5 = arr5.length - 1;

            while (i5 < l5) {
              $rule = arr5[i5 += 1];

              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);

                if ($code) {
                  out += ' ' + $code + ' ';

                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }

          if ($breakOnError) {
            out += ' ' + $closingBraces1 + ' ';
            $closingBraces1 = '';
          }

          if ($rulesGroup.type) {
            out += ' } ';

            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                  $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = '';
              /* istanbul ignore else */

              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';

                if ($typeIsArray) {
                  out += '' + $typeSchema.join(",");
                } else {
                  out += '' + $typeSchema;
                }

                out += '\' } ';

                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';

                  if ($typeIsArray) {
                    out += '' + $typeSchema.join(",");
                  } else {
                    out += '' + $typeSchema;
                  }

                  out += '\' ';
                }

                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }

                out += ' } ';
              } else {
                out += ' {} ';
              }

              var __err = out;
              out = $$outStack.pop();

              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + __err + ']); ';
                } else {
                  out += ' validate.errors = [' + __err + ']; return false; ';
                }
              } else {
                out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }

              out += ' } ';
            }
          }

          if ($breakOnError) {
            out += ' if (errors === ';

            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + $lvl;
            }

            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }

  if ($breakOnError) {
    out += ' ' + $closingBraces2 + ' ';
  }

  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }

    out += ' }; return validate;';
  } else {
    out += ' var ' + $valid + ' = errors === errs_' + $lvl + ';';
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;

    for (var i = 0; i < rules.length; i++) if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || $rule.implements && $ruleImplementsSomeKeyword($rule);
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;

    for (var i = 0; i < impl.length; i++) if (it.schema[impl[i]] !== undefined) return true;
  }

  return out;
};

/**
 * Functions below are used inside compiled validations function
 */


var ucs2length = util.ucs2length;

 // this error is thrown by async schemas to return validation errors via exception


var ValidationError = error_classes.Validation;
var compile_1 = compile$1;
/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */

function compile$1(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */

  /* eslint no-shadow: 0 */
  var self = this,
      opts = this._opts,
      refVal = [undefined],
      refs = {},
      patterns = [],
      patternsHash = {},
      defaults = [],
      defaultsHash = {},
      customRules = [];
  root = root || {
    schema: schema,
    refVal: refVal,
    refs: refs
  };
  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return compilation.callValidate = callValidate;
  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;

    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }

    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }
  /* @this   {*} - custom context, see passContext option */


  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || _root && _root.schema == _schema;
    if (_root.schema != root.schema) return compile$1.call(self, _schema, _root, localRefs, baseId);
    var $async = _schema.$async === true;
    var sourceCode = validate$2({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: error_classes.MissingRef,
      RULES: RULES,
      validate: validate$2,
      util: util,
      resolve: resolve_1,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });
    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema); // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));

    var validate;

    try {
      var makeValidate = new Function('self', 'RULES', 'formats', 'root', 'refVal', 'defaults', 'customRules', 'equal', 'ucs2length', 'ValidationError', sourceCode);
      validate = makeValidate(self, RULES, formats, root, refVal, defaults, customRules, fastDeepEqual, ucs2length, ValidationError);
      refVal[0] = validate;
    } catch (e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;

    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve_1.url(baseId, ref);
    var refIndex = refs[ref];

    var _refVal, refCode;

    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }

    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];

      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve_1.call(self, localCompile, root, ref);

    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];

      if (localSchema) {
        v = resolve_1.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile$1.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean' ? {
      code: code,
      schema: refVal,
      inline: true
    } : {
      code: code,
      $async: refVal && !!refVal.$async
    };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];

    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }

    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;

      case 'string':
        return util.toQuotedString(value);

      case 'object':
        if (value === null) return 'null';
        var valueStr = fastJsonStableStringify(value);
        var index = defaultsHash[valueStr];

        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }

        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function (keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      })) throw new Error('parent schema must have all required keywords: ' + deps.join(','));
      var validateSchema = rule.definition.validateSchema;

      if (validateSchema) {
        var valid = validateSchema(schema);

        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile,
        inline = rule.definition.inline,
        macro = rule.definition.macro;
    var validate;

    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined) throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
    var index = customRules.length;
    customRules[index] = validate;
    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}
/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */


function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return {
    index: index,
    compiling: true
  };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return {
    index: index,
    compiling: false
  };
}
/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */


function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}
/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */


function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i = 0; i < this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }

  return -1;
}

function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}

function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}

function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}

function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}

function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';

  for (var i = 0; i < arr.length; i++) code += statement(i, arr);

  return code;
}

var cache$1 = createCommonjsModule$1(function (module) {

var Cache = module.exports = function Cache() {
  this._cache = {};
};

Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};

Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};

Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};

Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};
});

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i; // uri-template: https://tools.ietf.org/html/rfc6570

var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i; // For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;

var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var formats_1 = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}

formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex$1,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};
formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex$1,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};

function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;
  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}

function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;
  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}

var DATE_TIME_SEPARATOR = /t|\s/i;

function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}

var NOT_URI_FRAGMENT = /\/|:/;

function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}

var Z_ANCHOR = /[^\\]\\Z/;

function regex$1(str) {
  if (Z_ANCHOR.test(str)) return false;

  try {
    new RegExp(str);
    return true;
  } catch (e) {
    return false;
  }
}

var ref = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;

  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);

    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);

      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        /* istanbul ignore else */

        if (it.createErrors !== false) {
          out += ' { keyword: \'' + '$ref' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { ref: \'' + it.util.escapeQuotes($schema) + '\' } ';

          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + it.util.escapeQuotes($schema) + '\' ';
          }

          if (it.opts.verbose) {
            out += ' , schema: ' + it.util.toQuotedString($schema) + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }

          out += ' } ';
        } else {
          out += ' {} ';
        }

        var __err = out;
        out = $$outStack.pop();

        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }

        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);

        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + $code + ' ';

      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
      }
    } else {
      $async = $refVal.$async === true || it.async && $refVal.$async !== false;
      $refCode = $refVal.code;
    }
  }

  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';

    if (it.opts.passContext) {
      out += ' ' + $refCode + '.call(this, ';
    } else {
      out += ' ' + $refCode + '( ';
    }

    out += ' ' + $data + ', (dataPath || \'\')';

    if (it.errorPath != '""') {
      out += ' + ' + it.errorPath;
    }

    var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
        $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + $parentData + ' , ' + $parentDataProperty + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();

    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');

      if ($breakOnError) {
        out += ' var ' + $valid + '; ';
      }

      out += ' try { await ' + __callValidate + '; ';

      if ($breakOnError) {
        out += ' ' + $valid + ' = true; ';
      }

      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';

      if ($breakOnError) {
        out += ' ' + $valid + ' = false; ';
      }

      out += ' } ';

      if ($breakOnError) {
        out += ' if (' + $valid + ') { ';
      }
    } else {
      out += ' if (!' + __callValidate + ') { if (vErrors === null) vErrors = ' + $refCode + '.errors; else vErrors = vErrors.concat(' + $refCode + '.errors); errors = vErrors.length; } ';

      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }

  return out;
};

var allOf = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
      $allSchemasEmpty = true;
  var arr1 = $schema;

  if (arr1) {
    var $sch,
        $i = -1,
        l1 = arr1.length - 1;

    while ($i < l1) {
      $sch = arr1[$i += 1];

      if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;

        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }

  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + $closingBraces.slice(0, -1) + ' ';
    }
  }

  return out;
};

var anyOf = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function ($sch) {
    return it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all);
  });

  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + $errs + ' = errors; var ' + $valid + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;

    if (arr1) {
      var $sch,
          $i = -1,
          l1 = arr1.length - 1;

      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + $valid + ' = ' + $valid + ' || ' + $nextValid + '; if (!' + $valid + ') { ';
        $closingBraces += '}';
      }
    }

    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $closingBraces + ' if (!' + $valid + ') {   var err =   ';
    /* istanbul ignore else */

    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'anyOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';

      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }

      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }

      out += ' } ';
    } else {
      out += ' {} ';
    }

    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';

    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }

    out += ' } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';

    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }

  return out;
};

var comment = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);

  if (it.opts.$comment === true) {
    out += ' console.log(' + $comment + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + $comment + ', ' + it.util.toQuotedString($errSchemaPath) + ', validate.root.schema);';
  }

  return out;
};

var _const = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
  }

  if (!$isData) {
    out += ' var schema' + $lvl + ' = validate.schema' + $schemaPath + ';';
  }

  out += 'var ' + $valid + ' = equal(' + $data + ', schema' + $lvl + '); if (!' + $valid + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'const' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { allowedValue: schema' + $lvl + ' } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += ' }';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var contains = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $currentBaseId = it.baseId,
      $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';

  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + $nextValid + ' = false; for (var ' + $idx + ' = 0; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;

    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
    } else {
      out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
    }

    out += ' if (' + $nextValid + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $closingBraces + ' if (!' + $nextValid + ') {';
  } else {
    out += ' if (' + $data + '.length == 0) {';
  }

  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'contains' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += ' } else { ';

  if ($nonEmptySchema) {
    out += '  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
  }

  if (it.opts.allErrors) {
    out += ' } ';
  }

  return out;
};

var dependencies$3 = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
      $propertyDeps = {},
      $ownProperties = it.opts.ownProperties;

  for ($property in $schema) {
    if ($property == '__proto__') continue;
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }

  out += 'var ' + $errs + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + $lvl + ';';

  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];

    if ($deps.length) {
      out += ' if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';

      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($property) + '\') ';
      }

      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;

        if (arr1) {
          var $propertyKey,
              $i = -1,
              l1 = arr1.length - 1;

          while ($i < l1) {
            $propertyKey = arr1[$i += 1];

            if ($i) {
              out += ' || ';
            }

            var $prop = it.util.getProperty($propertyKey),
                $useData = $data + $prop;
            out += ' ( ( ' + $useData + ' === undefined ';

            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
            }

            out += ') && (missing' + $lvl + ' = ' + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
          }
        }

        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
            $missingProperty = '\' + ' + $propertyPath + ' + \'';

        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }

        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        /* istanbul ignore else */

        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'dependencies' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { property: \'' + it.util.escapeQuotes($property) + '\', missingProperty: \'' + $missingProperty + '\', depsCount: ' + $deps.length + ', deps: \'' + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + '\' } ';

          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';

            if ($deps.length == 1) {
              out += 'property ' + it.util.escapeQuotes($deps[0]);
            } else {
              out += 'properties ' + it.util.escapeQuotes($deps.join(", "));
            }

            out += ' when property ' + it.util.escapeQuotes($property) + ' is present\' ';
          }

          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }

          out += ' } ';
        } else {
          out += ' {} ';
        }

        var __err = out;
        out = $$outStack.pop();

        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;

        if (arr2) {
          var $propertyKey,
              i2 = -1,
              l2 = arr2.length - 1;

          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
                $missingProperty = it.util.escapeQuotes($propertyKey),
                $useData = $data + $prop;

            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }

            out += ' if ( ' + $useData + ' === undefined ';

            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
            }

            out += ') {  var err =   ';
            /* istanbul ignore else */

            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'dependencies' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { property: \'' + it.util.escapeQuotes($property) + '\', missingProperty: \'' + $missingProperty + '\', depsCount: ' + $deps.length + ', deps: \'' + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + '\' } ';

              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';

                if ($deps.length == 1) {
                  out += 'property ' + it.util.escapeQuotes($deps[0]);
                } else {
                  out += 'properties ' + it.util.escapeQuotes($deps.join(", "));
                }

                out += ' when property ' + it.util.escapeQuotes($property) + ' is present\' ';
              }

              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }

              out += ' } ';
            } else {
              out += ' {} ';
            }

            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }

      out += ' }   ';

      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }

  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;

  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];

    if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
      out += ' ' + $nextValid + ' = true; if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';

      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($property) + '\') ';
      }

      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + it.validate($it) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';

      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
        $closingBraces += '}';
      }
    }
  }

  if ($breakOnError) {
    out += '   ' + $closingBraces + ' if (' + $errs + ' == errors) {';
  }

  return out;
};

var _enum = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
  }

  var $i = 'i' + $lvl,
      $vSchema = 'schema' + $lvl;

  if (!$isData) {
    out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + ';';
  }

  out += 'var ' + $valid + ';';

  if ($isData) {
    out += ' if (schema' + $lvl + ' === undefined) ' + $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' + $valid + ' = false; else {';
  }

  out += '' + $valid + ' = false;for (var ' + $i + '=0; ' + $i + '<' + $vSchema + '.length; ' + $i + '++) if (equal(' + $data + ', ' + $vSchema + '[' + $i + '])) { ' + $valid + ' = true; break; }';

  if ($isData) {
    out += '  }  ';
  }

  out += ' if (!' + $valid + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'enum' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { allowedValues: schema' + $lvl + ' } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += ' }';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var format = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');

  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }

    return out;
  }

  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  var $unknownFormats = it.opts.unknownFormats,
      $allowUnknown = Array.isArray($unknownFormats);

  if ($isData) {
    var $format = 'format' + $lvl,
        $isObject = 'isObject' + $lvl,
        $formatType = 'formatType' + $lvl;
    out += ' var ' + $format + ' = formats[' + $schemaValue + ']; var ' + $isObject + ' = typeof ' + $format + ' == \'object\' && !(' + $format + ' instanceof RegExp) && ' + $format + '.validate; var ' + $formatType + ' = ' + $isObject + ' && ' + $format + '.type || \'string\'; if (' + $isObject + ') { ';

    if (it.async) {
      out += ' var async' + $lvl + ' = ' + $format + '.async; ';
    }

    out += ' ' + $format + ' = ' + $format + '.validate; } if (  ';

    if ($isData) {
      out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'string\') || ';
    }

    out += ' (';

    if ($unknownFormats != 'ignore') {
      out += ' (' + $schemaValue + ' && !' + $format + ' ';

      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + $schemaValue + ') == -1 ';
      }

      out += ') || ';
    }

    out += ' (' + $format + ' && ' + $formatType + ' == \'' + $ruleType + '\' && !(typeof ' + $format + ' == \'function\' ? ';

    if (it.async) {
      out += ' (async' + $lvl + ' ? await ' + $format + '(' + $data + ') : ' + $format + '(' + $data + ')) ';
    } else {
      out += ' ' + $format + '(' + $data + ') ';
    }

    out += ' : ' + $format + '.test(' + $data + '))))) {';
  } else {
    var $format = it.formats[$schema];

    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');

        if ($breakOnError) {
          out += ' if (true) { ';
        }

        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }

        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }

    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';

    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }

    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }

      return out;
    }

    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + $formatRef + '(' + $data + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';

      if (typeof $format == 'function') {
        out += ' ' + $formatRef + '(' + $data + ') ';
      } else {
        out += ' ' + $formatRef + '.test(' + $data + ') ';
      }

      out += ') { ';
    }
  }

  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'format' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { format:  ';

    if ($isData) {
      out += '' + $schemaValue;
    } else {
      out += '' + it.util.toQuotedString($schema);
    }

    out += '  } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';

      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + it.util.escapeQuotes($schema);
      }

      out += '"\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema:  ';

      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + it.util.toQuotedString($schema);
      }

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += ' } ';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var _if = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
      $elseSch = it.schema['else'],
      $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),
      $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),
      $currentBaseId = $it.baseId;

  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + $errs + ' = errors; var ' + $valid + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + it.validate($it) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;

    if ($thenPresent) {
      out += ' if (' + $nextValid + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + it.validate($it) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + $valid + ' = ' + $nextValid + '; ';

      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + $ifClause + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }

      out += ' } ';

      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + $nextValid + ') { ';
    }

    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + it.validate($it) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + $valid + ' = ' + $nextValid + '; ';

      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + $ifClause + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }

      out += ' } ';
    }

    out += ' if (!' + $valid + ') {   var err =   ';
    /* istanbul ignore else */

    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'if' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { failingKeyword: ' + $ifClause + ' } ';

      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + $ifClause + ' + \'" schema\' ';
      }

      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }

      out += ' } ';
    } else {
      out += ' {} ';
    }

    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';

    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }

    out += ' }   ';

    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }

  return out;
};

var items = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $currentBaseId = it.baseId;
  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';

  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;

    if ($additionalItems === false) {
      out += ' ' + $valid + ' = ' + $data + '.length <= ' + $schema.length + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + $valid + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      /* istanbul ignore else */

      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'additionalItems' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schema.length + ' } ';

        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + $schema.length + ' items\' ';
        }

        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }

        out += ' } ';
      } else {
        out += ' {} ';
      }

      var __err = out;
      out = $$outStack.pop();

      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }

      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;

      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }

    var arr1 = $schema;

    if (arr1) {
      var $sch,
          $i = -1,
          l1 = arr1.length - 1;

      while ($i < l1) {
        $sch = arr1[$i += 1];

        if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $i + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;

          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }

          out += ' }  ';

          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }

    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $schema.length + ') {  for (var ' + $idx + ' = ' + $schema.length + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;

      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
      } else {
        out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
      }

      if ($breakOnError) {
        out += ' if (!' + $nextValid + ') break; ';
      }

      out += ' } }  ';

      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
        $closingBraces += '}';
      }
    }
  } else if (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + $idx + ' = ' + 0 + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;

    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
    } else {
      out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
    }

    if ($breakOnError) {
      out += ' if (!' + $nextValid + ') break; ';
    }

    out += ' }';
  }

  if ($breakOnError) {
    out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
  }

  return out;
};

var _limit = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  var $isMax = $keyword == 'maximum',
      $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
      $schemaExcl = it.schema[$exclusiveKeyword],
      $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
      $op = $isMax ? '<' : '>',
      $notOp = $isMax ? '>' : '<',
      $errorKeyword = undefined;

  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {
    throw new Error($keyword + ' must be number');
  }

  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {
    throw new Error($exclusiveKeyword + ' must be number or boolean');
  }

  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
        $exclusive = 'exclusive' + $lvl,
        $exclType = 'exclType' + $lvl,
        $exclIsNumber = 'exclIsNumber' + $lvl,
        $opExpr = 'op' + $lvl,
        $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + $lvl + ' = ' + $schemaValueExcl + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + $exclusive + '; var ' + $exclType + ' = typeof ' + $schemaValueExcl + '; if (' + $exclType + ' != \'boolean\' && ' + $exclType + ' != \'undefined\' && ' + $exclType + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    /* istanbul ignore else */

    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';

      if (it.opts.messages !== false) {
        out += ' , message: \'' + $exclusiveKeyword + ' should be boolean\' ';
      }

      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }

      out += ' } ';
    } else {
      out += ' {} ';
    }

    var __err = out;
    out = $$outStack.pop();

    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }

    out += ' } else if ( ';

    if ($isData) {
      out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
    }

    out += ' ' + $exclType + ' == \'number\' ? ( (' + $exclusive + ' = ' + $schemaValue + ' === undefined || ' + $schemaValueExcl + ' ' + $op + '= ' + $schemaValue + ') ? ' + $data + ' ' + $notOp + '= ' + $schemaValueExcl + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) : ( (' + $exclusive + ' = ' + $schemaValueExcl + ' === true) ? ' + $data + ' ' + $notOp + '= ' + $schemaValue + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' + $data + ' !== ' + $data + ') { var op' + $lvl + ' = ' + $exclusive + ' ? \'' + $op + '\' : \'' + $op + '=\'; ';

    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
        $opStr = $op;

    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';

      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }

      out += ' ( ' + $schemaValue + ' === undefined || ' + $schemaExcl + ' ' + $op + '= ' + $schemaValue + ' ? ' + $data + ' ' + $notOp + '= ' + $schemaExcl + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' + $data + ' !== ' + $data + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);

        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }

      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';

      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }

      out += ' ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' || ' + $data + ' !== ' + $data + ') { ';
    }
  }

  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { comparison: ' + $opExpr + ', limit: ' + $schemaValue + ', exclusive: ' + $exclusive + ' } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + $opStr + ' ';

      if ($isData) {
        out += '\' + ' + $schemaValue;
      } else {
        out += '' + $schemaValue + '\'';
      }
    }

    if (it.opts.verbose) {
      out += ' , schema:  ';

      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += ' } ';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }

  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';

  if ($isData) {
    out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
  }

  out += ' ' + $data + '.length ' + $op + ' ' + $schemaValue + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';

      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }

      out += ' than ';

      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + $schema;
      }

      out += ' items\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema:  ';

      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += '} ';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }

  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';

  if ($isData) {
    out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
  }

  if (it.opts.unicode === false) {
    out += ' ' + $data + '.length ';
  } else {
    out += ' ucs2length(' + $data + ') ';
  }

  out += ' ' + $op + ' ' + $schemaValue + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';

      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }

      out += ' than ';

      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + $schema;
      }

      out += ' characters\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema:  ';

      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += '} ';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }

  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';

  if ($isData) {
    out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
  }

  out += ' Object.keys(' + $data + ').length ' + $op + ' ' + $schemaValue + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';

      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }

      out += ' than ';

      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + $schema;
      }

      out += ' properties\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema:  ';

      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += '} ';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }

  out += 'var division' + $lvl + ';if (';

  if ($isData) {
    out += ' ' + $schemaValue + ' !== undefined && ( typeof ' + $schemaValue + ' != \'number\' || ';
  }

  out += ' (division' + $lvl + ' = ' + $data + ' / ' + $schemaValue + ', ';

  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + $lvl + ') - division' + $lvl + ') > 1e-' + it.opts.multipleOfPrecision + ' ';
  } else {
    out += ' division' + $lvl + ' !== parseInt(division' + $lvl + ') ';
  }

  out += ' ) ';

  if ($isData) {
    out += '  )  ';
  }

  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'multipleOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { multipleOf: ' + $schemaValue + ' } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';

      if ($isData) {
        out += '\' + ' + $schemaValue;
      } else {
        out += '' + $schemaValue + '\'';
      }
    }

    if (it.opts.verbose) {
      out += ' , schema:  ';

      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += '} ';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var not = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;

  if (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + $errs + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;

    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }

    out += ' ' + it.validate($it) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + $nextValid + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    /* istanbul ignore else */

    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'not' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';

      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }

      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }

      out += ' } ';
    } else {
      out += ' {} ';
    }

    var __err = out;
    out = $$outStack.pop();

    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }

    out += ' } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';

    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   ';
    /* istanbul ignore else */

    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'not' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';

      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }

      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }

      out += ' } ';
    } else {
      out += ' {} ';
    }

    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';

    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }

  return out;
};

var oneOf = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
      $prevValid = 'prevValid' + $lvl,
      $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + $errs + ' = errors , ' + $prevValid + ' = false , ' + $valid + ' = false , ' + $passingSchemas + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;

  if (arr1) {
    var $sch,
        $i = -1,
        l1 = arr1.length - 1;

    while ($i < l1) {
      $sch = arr1[$i += 1];

      if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + $nextValid + ' = true; ';
      }

      if ($i) {
        out += ' if (' + $nextValid + ' && ' + $prevValid + ') { ' + $valid + ' = false; ' + $passingSchemas + ' = [' + $passingSchemas + ', ' + $i + ']; } else { ';
        $closingBraces += '}';
      }

      out += ' if (' + $nextValid + ') { ' + $valid + ' = ' + $prevValid + ' = true; ' + $passingSchemas + ' = ' + $i + '; }';
    }
  }

  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + $closingBraces + 'if (!' + $valid + ') {   var err =   ';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'oneOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { passingSchemas: ' + $passingSchemas + ' } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }

  out += '} else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; }';

  if (it.opts.allErrors) {
    out += ' } ';
  }

  return out;
};

var pattern = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';

  if ($isData) {
    out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'string\') || ';
  }

  out += ' !' + $regexp + '.test(' + $data + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  /* istanbul ignore else */

  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'pattern' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { pattern:  ';

    if ($isData) {
      out += '' + $schemaValue;
    } else {
      out += '' + it.util.toQuotedString($schema);
    }

    out += '  } ';

    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';

      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + it.util.escapeQuotes($schema);
      }

      out += '"\' ';
    }

    if (it.opts.verbose) {
      out += ' , schema:  ';

      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + it.util.toQuotedString($schema);
      }

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }

    out += ' } ';
  } else {
    out += ' {} ';
  }

  var __err = out;
  out = $$outStack.pop();

  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }

  out += '} ';

  if ($breakOnError) {
    out += ' else { ';
  }

  return out;
};

var properties$3 = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}).filter(notProto),
      $pProperties = it.schema.patternProperties || {},
      $pPropertyKeys = Object.keys($pProperties).filter(notProto),
      $aProperties = it.schema.additionalProperties,
      $someProperties = $schemaKeys.length || $pPropertyKeys.length,
      $noAdditional = $aProperties === false,
      $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
      $removeAdditional = it.opts.removeAdditional,
      $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
  var $required = it.schema.required;

  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }

  function notProto(p) {
    return p !== '__proto__';
  }

  out += 'var ' + $errs + ' = errors;var ' + $nextValid + ' = true;';

  if ($ownProperties) {
    out += ' var ' + $dataProperties + ' = undefined;';
  }

  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
    } else {
      out += ' for (var ' + $key + ' in ' + $data + ') { ';
    }

    if ($someProperties) {
      out += ' var isAdditional' + $lvl + ' = !(false ';

      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + $schemaPath + '.hasOwnProperty(' + $key + ') ';
        } else {
          var arr1 = $schemaKeys;

          if (arr1) {
            var $propertyKey,
                i1 = -1,
                l1 = arr1.length - 1;

            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + $key + ' == ' + it.util.toQuotedString($propertyKey) + ' ';
            }
          }
        }
      }

      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;

        if (arr2) {
          var $pProperty,
              $i = -1,
              l2 = arr2.length - 1;

          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + it.usePattern($pProperty) + '.test(' + $key + ') ';
          }
        }
      }

      out += ' ); if (isAdditional' + $lvl + ') { ';
    }

    if ($removeAdditional == 'all') {
      out += ' delete ' + $data + '[' + $key + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';

      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }

      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + $data + '[' + $key + ']; ';
        } else {
          out += ' ' + $nextValid + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = '';
          /* istanbul ignore else */

          if (it.createErrors !== false) {
            out += ' { keyword: \'' + 'additionalProperties' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { additionalProperty: \'' + $additionalProperty + '\' } ';

            if (it.opts.messages !== false) {
              out += ' , message: \'';

              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }

              out += '\' ';
            }

            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }

            out += ' } ';
          } else {
            out += ' {} ';
          }

          var __err = out;
          out = $$outStack.pop();

          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }

          $errSchemaPath = $currErrSchemaPath;

          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + $errs + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;

          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }

          out += ' if (!' + $nextValid + ') { errors = ' + $errs + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + $data + '[' + $key + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;

          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }

          if ($breakOnError) {
            out += ' if (!' + $nextValid + ') break; ';
          }
        }
      }

      it.errorPath = $currentErrorPath;
    }

    if ($someProperties) {
      out += ' } ';
    }

    out += ' }  ';

    if ($breakOnError) {
      out += ' if (' + $nextValid + ') { ';
      $closingBraces += '}';
    }
  }

  var $useDefaults = it.opts.useDefaults && !it.compositeRule;

  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;

    if (arr3) {
      var $propertyKey,
          i3 = -1,
          l3 = arr3.length - 1;

      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];

        if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey),
              $passData = $data + $prop,
              $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;

          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + $nextData + ' = ' + $passData + '; ';
          }

          if ($hasDefault) {
            out += ' ' + $code + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + $useData + ' === undefined ';

              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
              }

              out += ') { ' + $nextValid + ' = false; ';
              var $currentErrorPath = it.errorPath,
                  $currErrSchemaPath = $errSchemaPath,
                  $missingProperty = it.util.escapeQuotes($propertyKey);

              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }

              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = '';
              /* istanbul ignore else */

              if (it.createErrors !== false) {
                out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';

                if (it.opts.messages !== false) {
                  out += ' , message: \'';

                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + $missingProperty + '\\\'';
                  }

                  out += '\' ';
                }

                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }

                out += ' } ';
              } else {
                out += ' {} ';
              }

              var __err = out;
              out = $$outStack.pop();

              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + __err + ']); ';
                } else {
                  out += ' validate.errors = [' + __err + ']; return false; ';
                }
              } else {
                out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }

              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + $useData + ' === undefined ';

                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }

                out += ') { ' + $nextValid + ' = true; } else { ';
              } else {
                out += ' if (' + $useData + ' !== undefined ';

                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }

                out += ' ) { ';
              }
            }

            out += ' ' + $code + ' } ';
          }
        }

        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }

  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;

    if (arr4) {
      var $pProperty,
          i4 = -1,
          l4 = arr4.length - 1;

      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];

        if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);

          if ($ownProperties) {
            out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
          } else {
            out += ' for (var ' + $key + ' in ' + $data + ') { ';
          }

          out += ' if (' + it.usePattern($pProperty) + '.test(' + $key + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;

          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }

          if ($breakOnError) {
            out += ' if (!' + $nextValid + ') break; ';
          }

          out += ' } ';

          if ($breakOnError) {
            out += ' else ' + $nextValid + ' = true; ';
          }

          out += ' }  ';

          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }

  if ($breakOnError) {
    out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
  }

  return out;
};

var propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + $errs + ' = errors;';

  if (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
        $idx = 'idx' + $lvl,
        $i = 'i' + $lvl,
        $invalidName = '\' + ' + $key + ' + \'',
        $dataNxt = $it.dataLevel = it.dataLevel + 1,
        $nextData = 'data' + $dataNxt,
        $dataProperties = 'dataProperties' + $lvl,
        $ownProperties = it.opts.ownProperties,
        $currentBaseId = it.baseId;

    if ($ownProperties) {
      out += ' var ' + $dataProperties + ' = undefined; ';
    }

    if ($ownProperties) {
      out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
    } else {
      out += ' for (var ' + $key + ' in ' + $data + ') { ';
    }

    out += ' var startErrs' + $lvl + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;

    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
    } else {
      out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
    }

    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + $nextValid + ') { for (var ' + $i + '=startErrs' + $lvl + '; ' + $i + '<errors; ' + $i + '++) { vErrors[' + $i + '].propertyName = ' + $key + '; }   var err =   ';
    /* istanbul ignore else */

    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'propertyNames' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { propertyName: \'' + $invalidName + '\' } ';

      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + $invalidName + '\\\' is invalid\' ';
      }

      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }

      out += ' } ';
    } else {
      out += ' {} ';
    }

    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';

    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }

    if ($breakOnError) {
      out += ' break; ';
    }

    out += ' } }';
  }

  if ($breakOnError) {
    out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
  }

  return out;
};

var required$1 = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
  }

  var $vSchema = 'schema' + $lvl;

  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;

      if (arr1) {
        var $property,
            i1 = -1,
            l1 = arr1.length - 1;

        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];

          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }

  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
        $loopRequired = $isData || $required.length >= it.opts.loopRequired,
        $ownProperties = it.opts.ownProperties;

    if ($breakOnError) {
      out += ' var missing' + $lvl + '; ';

      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
        }

        var $i = 'i' + $lvl,
            $propertyPath = 'schema' + $lvl + '[' + $i + ']',
            $missingProperty = '\' + ' + $propertyPath + ' + \'';

        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }

        out += ' var ' + $valid + ' = true; ';

        if ($isData) {
          out += ' if (schema' + $lvl + ' === undefined) ' + $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' + $valid + ' = false; else {';
        }

        out += ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { ' + $valid + ' = ' + $data + '[' + $vSchema + '[' + $i + ']] !== undefined ';

        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';
        }

        out += '; if (!' + $valid + ') break; } ';

        if ($isData) {
          out += '  }  ';
        }

        out += '  if (!' + $valid + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        /* istanbul ignore else */

        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';

          if (it.opts.messages !== false) {
            out += ' , message: \'';

            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + $missingProperty + '\\\'';
            }

            out += '\' ';
          }

          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }

          out += ' } ';
        } else {
          out += ' {} ';
        }

        var __err = out;
        out = $$outStack.pop();

        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }

        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;

        if (arr2) {
          var $propertyKey,
              $i = -1,
              l2 = arr2.length - 1;

          while ($i < l2) {
            $propertyKey = arr2[$i += 1];

            if ($i) {
              out += ' || ';
            }

            var $prop = it.util.getProperty($propertyKey),
                $useData = $data + $prop;
            out += ' ( ( ' + $useData + ' === undefined ';

            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
            }

            out += ') && (missing' + $lvl + ' = ' + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
          }
        }

        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
            $missingProperty = '\' + ' + $propertyPath + ' + \'';

        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }

        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        /* istanbul ignore else */

        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';

          if (it.opts.messages !== false) {
            out += ' , message: \'';

            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + $missingProperty + '\\\'';
            }

            out += '\' ';
          }

          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }

          out += ' } ';
        } else {
          out += ' {} ';
        }

        var __err = out;
        out = $$outStack.pop();

        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }

        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
        }

        var $i = 'i' + $lvl,
            $propertyPath = 'schema' + $lvl + '[' + $i + ']',
            $missingProperty = '\' + ' + $propertyPath + ' + \'';

        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }

        if ($isData) {
          out += ' if (' + $vSchema + ' && !Array.isArray(' + $vSchema + ')) {  var err =   ';
          /* istanbul ignore else */

          if (it.createErrors !== false) {
            out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';

            if (it.opts.messages !== false) {
              out += ' , message: \'';

              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + $missingProperty + '\\\'';
              }

              out += '\' ';
            }

            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }

            out += ' } ';
          } else {
            out += ' {} ';
          }

          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + $vSchema + ' !== undefined) { ';
        }

        out += ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { if (' + $data + '[' + $vSchema + '[' + $i + ']] === undefined ';

        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';
        }

        out += ') {  var err =   ';
        /* istanbul ignore else */

        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';

          if (it.opts.messages !== false) {
            out += ' , message: \'';

            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + $missingProperty + '\\\'';
            }

            out += '\' ';
          }

          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }

          out += ' } ';
        } else {
          out += ' {} ';
        }

        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';

        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;

        if (arr3) {
          var $propertyKey,
              i3 = -1,
              l3 = arr3.length - 1;

          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
                $missingProperty = it.util.escapeQuotes($propertyKey),
                $useData = $data + $prop;

            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }

            out += ' if ( ' + $useData + ' === undefined ';

            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
            }

            out += ') {  var err =   ';
            /* istanbul ignore else */

            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';

              if (it.opts.messages !== false) {
                out += ' , message: \'';

                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + $missingProperty + '\\\'';
                }

                out += '\' ';
              }

              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }

              out += ' } ';
            } else {
              out += ' {} ';
            }

            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }

    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }

  return out;
};

var uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + $valid + '; if (' + $schemaValue + ' === false || ' + $schemaValue + ' === undefined) ' + $valid + ' = true; else if (typeof ' + $schemaValue + ' != \'boolean\') ' + $valid + ' = false; else { ';
    }

    out += ' var i = ' + $data + '.length , ' + $valid + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
        $typeIsArray = Array.isArray($itemType);

    if (!$itemType || $itemType == 'object' || $itemType == 'array' || $typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0)) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + $data + '[i], ' + $data + '[j])) { ' + $valid + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + $data + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + it.util[$method]($itemType, 'item', it.opts.strictNumbers, true) + ') continue; ';

      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }

      out += ' if (typeof itemIndices[item] == \'number\') { ' + $valid + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }

    out += ' } ';

    if ($isData) {
      out += '  }  ';
    }

    out += ' if (!' + $valid + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    /* istanbul ignore else */

    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'uniqueItems' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { i: i, j: j } ';

      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }

      if (it.opts.verbose) {
        out += ' , schema:  ';

        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + $schema;
        }

        out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }

      out += ' } ';
    } else {
      out += ' {} ';
    }

    var __err = out;
    out = $$outStack.pop();

    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }

    out += ' } ';

    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }

  return out;
};

var dotjs = {
  '$ref': ref,
  allOf: allOf,
  anyOf: anyOf,
  '$comment': comment,
  const: _const,
  contains: contains,
  dependencies: dependencies$3,
  'enum': _enum,
  format: format,
  'if': _if,
  items: items,
  maximum: _limit,
  minimum: _limit,
  maxItems: _limitItems,
  minItems: _limitItems,
  maxLength: _limitLength,
  minLength: _limitLength,
  maxProperties: _limitProperties,
  minProperties: _limitProperties,
  multipleOf: multipleOf,
  not: not,
  oneOf: oneOf,
  pattern: pattern,
  properties: properties$3,
  propertyNames: propertyNames,
  required: required$1,
  uniqueItems: uniqueItems,
  validate: validate$2
};

var toHash = util.toHash;

var rules$2 = function rules() {
  var RULES = [{
    type: 'number',
    rules: [{
      'maximum': ['exclusiveMaximum']
    }, {
      'minimum': ['exclusiveMinimum']
    }, 'multipleOf', 'format']
  }, {
    type: 'string',
    rules: ['maxLength', 'minLength', 'pattern', 'format']
  }, {
    type: 'array',
    rules: ['maxItems', 'minItems', 'items', 'contains', 'uniqueItems']
  }, {
    type: 'object',
    rules: ['maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames', {
      'properties': ['additionalProperties', 'patternProperties']
    }]
  }, {
    rules: ['$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if']
  }];
  var ALL = ['type', '$comment'];
  var KEYWORDS = ['$schema', '$id', 'id', '$data', '$async', 'title', 'description', 'default', 'definitions', 'examples', 'readOnly', 'writeOnly', 'contentMediaType', 'contentEncoding', 'additionalItems', 'then', 'else'];
  var TYPES = ['number', 'integer', 'string', 'array', 'object', 'boolean', 'null'];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);
  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;

      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }

      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: dotjs[keyword],
        implements: implKeywords
      };
      return rule;
    });
    RULES.all.$comment = {
      keyword: '$comment',
      code: dotjs.$comment
    };
    if (group.type) RULES.types[group.type] = group;
  });
  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};
  return RULES;
};

var KEYWORDS = ['multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum', 'maxLength', 'minLength', 'pattern', 'additionalItems', 'maxItems', 'minItems', 'uniqueItems', 'maxProperties', 'minProperties', 'required', 'additionalProperties', 'enum', 'format', 'const'];

var data = function (metaSchema, keywordsJsonPointers) {
  for (var i = 0; i < keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;

    for (j = 1; j < segments.length; j++) keywords = keywords[segments[j]];

    for (j = 0; j < KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];

      if (schema) {
        keywords[key] = {
          anyOf: [schema, {
            $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#'
          }]
        };
      }
    }
  }

  return metaSchema;
};

var MissingRefError = error_classes.MissingRef;

var async = compileAsync;
/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */

function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */

  /* global Promise */

  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function') throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);

    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(function (v) {
      callback(null, v);
    }, callback);
  }

  return p;

  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema) ? compileAsync.call(self, {
      $ref: $schema
    }, true) : Promise.resolve();
  }

  function _compileAsync(schemaObj) {
    try {
      return self._compile(schemaObj);
    } catch (e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }

    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');
      var schemaPromise = self._loadingSchemas[ref];

      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function () {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}

var custom = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;

  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }

  var $rule = this,
      $definition = 'definition' + $lvl,
      $rDef = $rule.definition,
      $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;

  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + $definition + ' = RULES.custom[\'' + $keyword + '\'].definition; var ' + $validateCode + ' = ' + $definition + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }

  var $ruleErrs = $validateCode + '.errors',
      $i = 'i' + $lvl,
      $ruleErr = 'ruleErr' + $lvl,
      $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');

  if (!($inline || $macro)) {
    out += '' + $ruleErrs + ' = null;';
  }

  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';

  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + $schemaValue + ' === undefined) { ' + $valid + ' = true; } else { ';

    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + $valid + ' = ' + $definition + '.validateSchema(' + $schemaValue + '); if (' + $valid + ') { ';
    }
  }

  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + $ruleValidate.validate + ' ';
    } else {
      out += ' ' + $valid + ' = ' + $ruleValidate.validate + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $code;
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + $validateCode + '.call( ';

    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }

    if ($compile || $rDef.schema === false) {
      out += ' , ' + $data + ' ';
    } else {
      out += ' , ' + $schemaValue + ' , ' + $data + ' , validate.schema' + it.schemaPath + ' ';
    }

    out += ' , (dataPath || \'\')';

    if (it.errorPath != '""') {
      out += ' + ' + it.errorPath;
    }

    var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
        $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + $parentData + ' , ' + $parentDataProperty + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();

    if ($rDef.errors === false) {
      out += ' ' + $valid + ' = ';

      if ($asyncKeyword) {
        out += 'await ';
      }

      out += '' + def_callRuleValidate + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + $ruleErrs + ' = null; try { ' + $valid + ' = await ' + def_callRuleValidate + '; } catch (e) { ' + $valid + ' = false; if (e instanceof ValidationError) ' + $ruleErrs + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + $ruleErrs + ' = null; ' + $valid + ' = ' + def_callRuleValidate + '; ';
      }
    }
  }

  if ($rDef.modifying) {
    out += ' if (' + $parentData + ') ' + $data + ' = ' + $parentData + '[' + $parentDataProperty + '];';
  }

  out += '' + $closingBraces;

  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';

    if ($rDef.valid === undefined) {
      out += ' !';

      if ($macro) {
        out += '' + $nextValid;
      } else {
        out += '' + $valid;
      }
    } else {
      out += ' ' + !$rDef.valid + ' ';
    }

    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    /* istanbul ignore else */

    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { keyword: \'' + $rule.keyword + '\' } ';

      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';
      }

      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }

      out += ' } ';
    } else {
      out += ' {} ';
    }

    var __err = out;
    out = $$outStack.pop();

    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }

    var def_customError = out;
    out = $$outStack.pop();

    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + '; if (' + $ruleErr + '.schemaPath === undefined) { ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';

          if (it.opts.verbose) {
            out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
          }

          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + def_customError + ' ';
        } else {
          out += ' if (' + $errs + ' == errors) { ' + def_customError + ' } else {  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + '; if (' + $ruleErr + '.schemaPath === undefined) { ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';

          if (it.opts.verbose) {
            out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
          }

          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   ';
      /* istanbul ignore else */

      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { keyword: \'' + $rule.keyword + '\' } ';

        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';
        }

        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }

        out += ' } ';
      } else {
        out += ' {} ';
      }

      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';

      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + def_customError + ' ';
      } else {
        out += ' if (Array.isArray(' + $ruleErrs + ')) { if (vErrors === null) vErrors = ' + $ruleErrs + '; else vErrors = vErrors.concat(' + $ruleErrs + '); errors = vErrors.length;  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + ';  ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';

        if (it.opts.verbose) {
          out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
        }

        out += ' } } else { ' + def_customError + ' } ';
      }
    }

    out += ' } ';

    if ($breakOnError) {
      out += ' else { ';
    }
  }

  return out;
};

var $schema$2 = "http://json-schema.org/draft-07/schema#";
var $id$1 = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions$1 = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$2 = [
	"object",
	"boolean"
];
var properties$2 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$2 = {
	$schema: $schema$2,
	$id: $id$1,
	title: title,
	definitions: definitions$1,
	type: type$2,
	properties: properties$2,
	"default": true
};

var definition_schema = {
  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: require$$2.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {
      not: {
        required: ['macro']
      }
    }
  },
  properties: {
    type: require$$2.properties.type,
    schema: {
      type: 'boolean'
    },
    statements: {
      type: 'boolean'
    },
    dependencies: {
      type: 'array',
      items: {
        type: 'string'
      }
    },
    metaSchema: {
      type: 'object'
    },
    modifying: {
      type: 'boolean'
    },
    valid: {
      type: 'boolean'
    },
    $data: {
      type: 'boolean'
    },
    async: {
      type: 'boolean'
    },
    errors: {
      anyOf: [{
        type: 'boolean'
      }, {
        const: 'full'
      }]
    }
  }
};

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;





var keyword$1 = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};
/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */

function addKeyword(keyword, definition) {
  /* jshint validthis: true */

  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword]) throw new Error('Keyword ' + keyword + ' is already defined');
  if (!IDENTIFIER.test(keyword)) throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);
    var dataType = definition.type;

    if (Array.isArray(dataType)) {
      for (var i = 0; i < dataType.length; i++) _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;

    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [metaSchema, {
            '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#'
          }]
        };
      }

      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;

  function _addRule(keyword, dataType, definition) {
    var ruleGroup;

    for (var i = 0; i < RULES.length; i++) {
      var rg = RULES[i];

      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = {
        type: dataType,
        rules: []
      };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: custom,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}
/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */


function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}
/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */


function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];

  for (var i = 0; i < RULES.length; i++) {
    var rules = RULES[i].rules;

    for (var j = 0; j < rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }

  return this;
}
/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */


function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword || this.compile(definition_schema, true);
  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError) throw new Error('custom keyword definition is invalid: ' + this.errorsText(v.errors));else return false;
}

var $schema$1 = "http://json-schema.org/draft-07/schema#";
var $id = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description$2 = "Meta-schema for $data reference (JSON Schema extension proposal)";
var type$1 = "object";
var required = [
	"$data"
];
var properties$1 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties = false;
var require$$1 = {
	$schema: $schema$1,
	$id: $id,
	description: description$2,
	type: type$1,
	required: required,
	properties: properties$1,
	additionalProperties: additionalProperties
};

var ajv$2 = Ajv;
Ajv.prototype.validate = validate$1;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema$1;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = async;



Ajv.prototype.addKeyword = keyword$1.add;
Ajv.prototype.getKeyword = keyword$1.get;
Ajv.prototype.removeKeyword = keyword$1.remove;
Ajv.prototype.validateKeyword = keyword$1.validate;



Ajv.ValidationError = error_classes.Validation;
Ajv.MissingRefError = error_classes.MissingRef;
Ajv.$dataMetaSchema = data;
var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';
var META_IGNORE_OPTIONS = ['removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults'];
var META_SUPPORT_DATA = ['/properties'];
/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */

function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats_1(opts.format);
  this._cache = opts.cache || new cache$1();
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules$2();
  this._getId = chooseGetId(opts);
  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = fastJsonStableStringify;
  this._metaOpts = getMetaSchemaOptions(this);
  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {
    metaSchema: {
      type: 'boolean'
    }
  });
  addInitialSchemas(this);
}
/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */


function validate$1(schemaKeyRef, data) {
  var v;

  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);

    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}
/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */


function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);

  return schemaObj.validate || this._compile(schemaObj);
}
/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */


function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);

    return this;
  }

  var id = this._getId(schema);

  if (id !== undefined && typeof id != 'string') throw new Error('schema id must be string');
  key = resolve_1.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}
/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */


function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}
/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */


function validateSchema$1(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string') throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);

  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }

  var valid = this.validate($schema, schema);

  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);else throw new Error(message);
  }

  return valid;
}

function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object' ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined;
  return self._opts.defaultMeta;
}
/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */


function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);

  switch (typeof schemaObj) {
    case 'object':
      return schemaObj.validate || this._compile(schemaObj);

    case 'string':
      return this.getSchema(schemaObj);

    case 'undefined':
      return _getSchemaFragment(this, keyRef);
  }
}

function _getSchemaFragment(self, ref) {
  var res = resolve_1.schema.call(self, {
    schema: {}
  }, ref);

  if (res) {
    var schema = res.schema,
        root = res.root,
        baseId = res.baseId;
    var v = compile_1.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new schema_obj({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}

function _getSchemaObj(self, keyRef) {
  keyRef = resolve_1.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}
/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */


function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);

    _removeAllSchemas(this, this._refs, schemaKeyRef);

    return this;
  }

  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);

      _removeAllSchemas(this, this._refs);

      this._cache.clear();

      return this;

    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);

      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;

    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;

      this._cache.del(cacheKey);

      var id = this._getId(schemaKeyRef);

      if (id) {
        id = resolve_1.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }

  }

  return this;
}

function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];

    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);

      delete schemas[keyRef];
    }
  }
}
/* @this   Ajv */


function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean') throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;

  var cached = this._cache.get(cacheKey);

  if (cached) return cached;
  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
  var id = resolve_1.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);
  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve_1.normalizeId(schema.$schema))) this.validateSchema(schema, true);
  var localRefs = resolve_1.ids.call(this, schema);
  var schemaObj = new schema_obj({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });
  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;

  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);
  return schemaObj;
}
/* @this   Ajv */


function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true) callValidate.$async = true;
    return callValidate;
  }

  schemaObj.compiling = true;
  var currentOpts;

  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;

  try {
    v = compile_1.call(this, schemaObj.schema, root, schemaObj.localRefs);
  } catch (e) {
    delete schemaObj.validate;
    throw e;
  } finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;
  /* @this   {*} - custom context, see passContext option */

  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;

    var result = _validate.apply(this, arguments);

    callValidate.errors = _validate.errors;
    return result;
  }
}

function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto':
      return _get$IdOrId;

    case 'id':
      return _getId;

    default:
      return _get$Id;
  }
}
/* @this   Ajv */


function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}
/* @this   Ajv */


function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}

function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id) throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}
/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */


function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;
  var text = '';

  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }

  return text.slice(0, -separator.length);
}
/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */


function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}

function addDefaultMetaSchema(self) {
  var $dataSchema;

  if (self._opts.$data) {
    $dataSchema = require$$1;
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }

  if (self._opts.meta === false) return;

  var metaSchema = require$$2;

  if (self._opts.$data) metaSchema = data(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}

function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}

function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}

function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}

function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id "' + id + '" already exists');
}

function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);

  for (var i = 0; i < META_IGNORE_OPTIONS.length; i++) delete metaOpts[META_IGNORE_OPTIONS[i]];

  return metaOpts;
}

function setLogger(self) {
  var logger = self._opts.logger;

  if (logger === false) {
    self.logger = {
      log: noop$1,
      warn: noop$1,
      error: noop$1
    };
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error)) throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}

function noop$1() {}

var id$1 = "http://json-schema.org/draft-04/schema#";
var $schema = "http://json-schema.org/draft-04/schema#";
var description$1 = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	positiveInteger: {
		type: "integer",
		minimum: 0
	},
	positiveIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/positiveInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		minItems: 1,
		uniqueItems: true
	}
};
var type = "object";
var properties = {
	id: {
		type: "string"
	},
	$schema: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": {
	},
	multipleOf: {
		type: "number",
		minimum: 0,
		exclusiveMinimum: true
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "boolean",
		"default": false
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "boolean",
		"default": false
	},
	maxLength: {
		$ref: "#/definitions/positiveInteger"
	},
	minLength: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		anyOf: [
			{
				type: "boolean"
			},
			{
				$ref: "#"
			}
		],
		"default": {
		}
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": {
		}
	},
	maxItems: {
		$ref: "#/definitions/positiveInteger"
	},
	minItems: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	maxProperties: {
		$ref: "#/definitions/positiveInteger"
	},
	minProperties: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		anyOf: [
			{
				type: "boolean"
			},
			{
				$ref: "#"
			}
		],
		"default": {
		}
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	"enum": {
		type: "array",
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var dependencies$2 = {
	exclusiveMaximum: [
		"maximum"
	],
	exclusiveMinimum: [
		"minimum"
	]
};
var metaSchema = {
	id: id$1,
	$schema: $schema,
	description: description$1,
	definitions: definitions,
	type: type,
	properties: properties,
	dependencies: dependencies$2,
	"default": {
}
};

/**
 * @fileoverview The instance of Ajv validator.
 * @author Evgeny Poberezkin
 */
// Requirements
//------------------------------------------------------------------------------

 //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------


var ajv$1 = (additionalOptions = {}) => {
  const ajv = new ajv$2({
    meta: false,
    useDefaults: true,
    validateSchema: false,
    missingRefs: "ignore",
    verbose: true,
    schemaId: "auto",
    ...additionalOptions
  });
  ajv.addMetaSchema(metaSchema); // eslint-disable-next-line no-underscore-dangle

  ajv._opts.defaultMeta = metaSchema.id;
  return ajv;
};

/**
 * @fileoverview Validates configs.
 * @author Brandon Mills
 */
// Requirements
//------------------------------------------------------------------------------

const {
  emitDeprecationWarning
} = deprecationWarnings;

const ajv = ajv$1();

const ruleValidators = new WeakMap();
const noop = Function.prototype; //------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

let validateSchema;
const severityMap = {
  error: 2,
  warn: 1,
  off: 0
};
const validated = new WeakSet(); //-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

var configValidator = class ConfigValidator {
  constructor({
    builtInRules = new Map()
  } = {}) {
    this.builtInRules = builtInRules;
  }
  /**
   * Gets a complete options schema for a rule.
   * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object
   * @returns {Object} JSON Schema for the rule's options.
   */


  getRuleOptionsSchema(rule) {
    if (!rule) {
      return null;
    }

    const schema = rule.schema || rule.meta && rule.meta.schema; // Given a tuple of schemas, insert warning level at the beginning

    if (Array.isArray(schema)) {
      if (schema.length) {
        return {
          type: "array",
          items: schema,
          minItems: 0,
          maxItems: schema.length
        };
      }

      return {
        type: "array",
        minItems: 0,
        maxItems: 0
      };
    } // Given a full schema, leave it alone


    return schema || null;
  }
  /**
   * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
   * @param {options} options The given options for the rule.
   * @returns {number|string} The rule's severity value
   */


  validateRuleSeverity(options) {
    const severity = Array.isArray(options) ? options[0] : options;
    const normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;

    if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
      return normSeverity;
    }

    throw new Error(`\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util$1.inspect(severity).replace(/'/gu, "\"").replace(/\n/gu, "")}').\n`);
  }
  /**
   * Validates the non-severity options passed to a rule, based on its schema.
   * @param {{create: Function}} rule The rule to validate
   * @param {Array} localOptions The options for the rule, excluding severity
   * @returns {void}
   */


  validateRuleSchema(rule, localOptions) {
    if (!ruleValidators.has(rule)) {
      const schema = this.getRuleOptionsSchema(rule);

      if (schema) {
        ruleValidators.set(rule, ajv.compile(schema));
      }
    }

    const validateRule = ruleValidators.get(rule);

    if (validateRule) {
      validateRule(localOptions);

      if (validateRule.errors) {
        throw new Error(validateRule.errors.map(error => `\tValue ${JSON.stringify(error.data)} ${error.message}.\n`).join(""));
      }
    }
  }
  /**
   * Validates a rule's options against its schema.
   * @param {{create: Function}|null} rule The rule that the config is being validated for
   * @param {string} ruleId The rule's unique name.
   * @param {Array|number} options The given options for the rule.
   * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,
   * no source is prepended to the message.
   * @returns {void}
   */


  validateRuleOptions(rule, ruleId, options, source = null) {
    try {
      const severity = this.validateRuleSeverity(options);

      if (severity !== 0) {
        this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
      }
    } catch (err) {
      const enhancedMessage = `Configuration for rule "${ruleId}" is invalid:\n${err.message}`;

      if (typeof source === "string") {
        throw new Error(`${source}:\n\t${enhancedMessage}`);
      } else {
        throw new Error(enhancedMessage);
      }
    }
  }
  /**
   * Validates an environment object
   * @param {Object} environment The environment config object to validate.
   * @param {string} source The name of the configuration source to report in any errors.
   * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.
   * @returns {void}
   */


  validateEnvironment(environment, source, getAdditionalEnv = noop) {
    // not having an environment is ok
    if (!environment) {
      return;
    }

    Object.keys(environment).forEach(id => {
      const env = getAdditionalEnv(id) || environments.get(id) || null;

      if (!env) {
        const message = `${source}:\n\tEnvironment key "${id}" is unknown\n`;
        throw new Error(message);
      }
    });
  }
  /**
   * Validates a rules config object
   * @param {Object} rulesConfig The rules config object to validate.
   * @param {string} source The name of the configuration source to report in any errors.
   * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules
   * @returns {void}
   */


  validateRules(rulesConfig, source, getAdditionalRule = noop) {
    if (!rulesConfig) {
      return;
    }

    Object.keys(rulesConfig).forEach(id => {
      const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;
      this.validateRuleOptions(rule, id, rulesConfig[id], source);
    });
  }
  /**
   * Validates a `globals` section of a config file
   * @param {Object} globalsConfig The `globals` section
   * @param {string|null} source The name of the configuration source to report in the event of an error.
   * @returns {void}
   */


  validateGlobals(globalsConfig, source = null) {
    if (!globalsConfig) {
      return;
    }

    Object.entries(globalsConfig).forEach(([configuredGlobal, configuredValue]) => {
      try {
        configOps.normalizeConfigGlobal(configuredValue);
      } catch (err) {
        throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\n${err.message}`);
      }
    });
  }
  /**
   * Validate `processor` configuration.
   * @param {string|undefined} processorName The processor name.
   * @param {string} source The name of config file.
   * @param {function(id:string): Processor} getProcessor The getter of defined processors.
   * @returns {void}
   */


  validateProcessor(processorName, source, getProcessor) {
    if (processorName && !getProcessor(processorName)) {
      throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);
    }
  }
  /**
   * Formats an array of schema validation errors.
   * @param {Array} errors An array of error messages to format.
   * @returns {string} Formatted error message
   */


  formatErrors(errors) {
    return errors.map(error => {
      if (error.keyword === "additionalProperties") {
        const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;
        return `Unexpected top-level property "${formattedPropertyPath}"`;
      }

      if (error.keyword === "type") {
        const formattedField = error.dataPath.slice(1);
        const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
        const formattedValue = JSON.stringify(error.data);
        return `Property "${formattedField}" is the wrong type (expected ${formattedExpectedType} but got \`${formattedValue}\`)`;
      }

      const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;
      return `"${field}" ${error.message}. Value: ${JSON.stringify(error.data)}`;
    }).map(message => `\t- ${message}.\n`).join("");
  }
  /**
   * Validates the top level properties of the config object.
   * @param {Object} config The config object to validate.
   * @param {string} source The name of the configuration source to report in any errors.
   * @returns {void}
   */


  validateConfigSchema(config, source = null) {
    validateSchema = validateSchema || ajv.compile(configSchema_1);

    if (!validateSchema(config)) {
      throw new Error(`ESLint configuration in ${source} is invalid:\n${this.formatErrors(validateSchema.errors)}`);
    }

    if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
      emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
    }
  }
  /**
   * Validates an entire config object.
   * @param {Object} config The config object to validate.
   * @param {string} source The name of the configuration source to report in any errors.
   * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.
   * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.
   * @returns {void}
   */


  validate(config, source, getAdditionalRule, getAdditionalEnv) {
    this.validateConfigSchema(config, source);
    this.validateRules(config.rules, source, getAdditionalRule);
    this.validateEnvironment(config.env, source, getAdditionalEnv);
    this.validateGlobals(config.globals, source);

    for (const override of config.overrides || []) {
      this.validateRules(override.rules, source, getAdditionalRule);
      this.validateEnvironment(override.env, source, getAdditionalEnv);
      this.validateGlobals(config.globals, source);
    }
  }
  /**
   * Validate config array object.
   * @param {ConfigArray} configArray The config array to validate.
   * @returns {void}
   */


  validateConfigArray(configArray) {
    const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
    const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
    const getPluginRule = Map.prototype.get.bind(configArray.pluginRules); // Validate.

    for (const element of configArray) {
      if (validated.has(element)) {
        continue;
      }

      validated.add(element);
      this.validateEnvironment(element.env, element.name, getPluginEnv);
      this.validateGlobals(element.globals, element.name);
      this.validateProcessor(element.processor, element.name, getPluginProcessor);
      this.validateRules(element.rules, element.name, getPluginRule);
    }
  }

};

var AssignmentExpression = [
	"left",
	"right"
];
var AssignmentPattern = [
	"left",
	"right"
];
var ArrayExpression = [
	"elements"
];
var ArrayPattern = [
	"elements"
];
var ArrowFunctionExpression = [
	"params",
	"body"
];
var AwaitExpression = [
	"argument"
];
var BlockStatement = [
	"body"
];
var BinaryExpression = [
	"left",
	"right"
];
var BreakStatement = [
	"label"
];
var CallExpression = [
	"callee",
	"arguments"
];
var CatchClause = [
	"param",
	"body"
];
var ChainExpression = [
	"expression"
];
var ClassBody = [
	"body"
];
var ClassDeclaration = [
	"id",
	"superClass",
	"body"
];
var ClassExpression = [
	"id",
	"superClass",
	"body"
];
var ConditionalExpression = [
	"test",
	"consequent",
	"alternate"
];
var ContinueStatement = [
	"label"
];
var DebuggerStatement = [
];
var DoWhileStatement = [
	"body",
	"test"
];
var EmptyStatement = [
];
var ExportAllDeclaration = [
	"exported",
	"source"
];
var ExportDefaultDeclaration = [
	"declaration"
];
var ExportNamedDeclaration = [
	"declaration",
	"specifiers",
	"source"
];
var ExportSpecifier = [
	"exported",
	"local"
];
var ExpressionStatement = [
	"expression"
];
var ExperimentalRestProperty = [
	"argument"
];
var ExperimentalSpreadProperty = [
	"argument"
];
var ForStatement = [
	"init",
	"test",
	"update",
	"body"
];
var ForInStatement = [
	"left",
	"right",
	"body"
];
var ForOfStatement = [
	"left",
	"right",
	"body"
];
var FunctionDeclaration = [
	"id",
	"params",
	"body"
];
var FunctionExpression = [
	"id",
	"params",
	"body"
];
var Identifier = [
];
var IfStatement = [
	"test",
	"consequent",
	"alternate"
];
var ImportDeclaration = [
	"specifiers",
	"source"
];
var ImportDefaultSpecifier = [
	"local"
];
var ImportExpression = [
	"source"
];
var ImportNamespaceSpecifier = [
	"local"
];
var ImportSpecifier = [
	"imported",
	"local"
];
var JSXAttribute = [
	"name",
	"value"
];
var JSXClosingElement = [
	"name"
];
var JSXElement = [
	"openingElement",
	"children",
	"closingElement"
];
var JSXEmptyExpression = [
];
var JSXExpressionContainer = [
	"expression"
];
var JSXIdentifier = [
];
var JSXMemberExpression = [
	"object",
	"property"
];
var JSXNamespacedName = [
	"namespace",
	"name"
];
var JSXOpeningElement = [
	"name",
	"attributes"
];
var JSXSpreadAttribute = [
	"argument"
];
var JSXText = [
];
var JSXFragment = [
	"openingFragment",
	"children",
	"closingFragment"
];
var Literal = [
];
var LabeledStatement = [
	"label",
	"body"
];
var LogicalExpression = [
	"left",
	"right"
];
var MemberExpression = [
	"object",
	"property"
];
var MetaProperty = [
	"meta",
	"property"
];
var MethodDefinition = [
	"key",
	"value"
];
var NewExpression = [
	"callee",
	"arguments"
];
var ObjectExpression = [
	"properties"
];
var ObjectPattern = [
	"properties"
];
var Program = [
	"body"
];
var Property = [
	"key",
	"value"
];
var RestElement = [
	"argument"
];
var ReturnStatement = [
	"argument"
];
var SequenceExpression = [
	"expressions"
];
var SpreadElement = [
	"argument"
];
var Super = [
];
var SwitchStatement = [
	"discriminant",
	"cases"
];
var SwitchCase = [
	"test",
	"consequent"
];
var TaggedTemplateExpression = [
	"tag",
	"quasi"
];
var TemplateElement = [
];
var TemplateLiteral = [
	"quasis",
	"expressions"
];
var ThisExpression = [
];
var ThrowStatement = [
	"argument"
];
var TryStatement = [
	"block",
	"handler",
	"finalizer"
];
var UnaryExpression = [
	"argument"
];
var UpdateExpression = [
	"argument"
];
var VariableDeclaration = [
	"declarations"
];
var VariableDeclarator = [
	"id",
	"init"
];
var WhileStatement = [
	"test",
	"body"
];
var WithStatement = [
	"object",
	"body"
];
var YieldExpression = [
	"argument"
];
var KEYS$1 = {
	AssignmentExpression: AssignmentExpression,
	AssignmentPattern: AssignmentPattern,
	ArrayExpression: ArrayExpression,
	ArrayPattern: ArrayPattern,
	ArrowFunctionExpression: ArrowFunctionExpression,
	AwaitExpression: AwaitExpression,
	BlockStatement: BlockStatement,
	BinaryExpression: BinaryExpression,
	BreakStatement: BreakStatement,
	CallExpression: CallExpression,
	CatchClause: CatchClause,
	ChainExpression: ChainExpression,
	ClassBody: ClassBody,
	ClassDeclaration: ClassDeclaration,
	ClassExpression: ClassExpression,
	ConditionalExpression: ConditionalExpression,
	ContinueStatement: ContinueStatement,
	DebuggerStatement: DebuggerStatement,
	DoWhileStatement: DoWhileStatement,
	EmptyStatement: EmptyStatement,
	ExportAllDeclaration: ExportAllDeclaration,
	ExportDefaultDeclaration: ExportDefaultDeclaration,
	ExportNamedDeclaration: ExportNamedDeclaration,
	ExportSpecifier: ExportSpecifier,
	ExpressionStatement: ExpressionStatement,
	ExperimentalRestProperty: ExperimentalRestProperty,
	ExperimentalSpreadProperty: ExperimentalSpreadProperty,
	ForStatement: ForStatement,
	ForInStatement: ForInStatement,
	ForOfStatement: ForOfStatement,
	FunctionDeclaration: FunctionDeclaration,
	FunctionExpression: FunctionExpression,
	Identifier: Identifier,
	IfStatement: IfStatement,
	ImportDeclaration: ImportDeclaration,
	ImportDefaultSpecifier: ImportDefaultSpecifier,
	ImportExpression: ImportExpression,
	ImportNamespaceSpecifier: ImportNamespaceSpecifier,
	ImportSpecifier: ImportSpecifier,
	JSXAttribute: JSXAttribute,
	JSXClosingElement: JSXClosingElement,
	JSXElement: JSXElement,
	JSXEmptyExpression: JSXEmptyExpression,
	JSXExpressionContainer: JSXExpressionContainer,
	JSXIdentifier: JSXIdentifier,
	JSXMemberExpression: JSXMemberExpression,
	JSXNamespacedName: JSXNamespacedName,
	JSXOpeningElement: JSXOpeningElement,
	JSXSpreadAttribute: JSXSpreadAttribute,
	JSXText: JSXText,
	JSXFragment: JSXFragment,
	Literal: Literal,
	LabeledStatement: LabeledStatement,
	LogicalExpression: LogicalExpression,
	MemberExpression: MemberExpression,
	MetaProperty: MetaProperty,
	MethodDefinition: MethodDefinition,
	NewExpression: NewExpression,
	ObjectExpression: ObjectExpression,
	ObjectPattern: ObjectPattern,
	Program: Program,
	Property: Property,
	RestElement: RestElement,
	ReturnStatement: ReturnStatement,
	SequenceExpression: SequenceExpression,
	SpreadElement: SpreadElement,
	Super: Super,
	SwitchStatement: SwitchStatement,
	SwitchCase: SwitchCase,
	TaggedTemplateExpression: TaggedTemplateExpression,
	TemplateElement: TemplateElement,
	TemplateLiteral: TemplateLiteral,
	ThisExpression: ThisExpression,
	ThrowStatement: ThrowStatement,
	TryStatement: TryStatement,
	UnaryExpression: UnaryExpression,
	UpdateExpression: UpdateExpression,
	VariableDeclaration: VariableDeclaration,
	VariableDeclarator: VariableDeclarator,
	WhileStatement: WhileStatement,
	WithStatement: WithStatement,
	YieldExpression: YieldExpression
};

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */

 // Types.


const NODE_TYPES = Object.freeze(Object.keys(KEYS$1)); // Freeze the keys.

for (const type of NODE_TYPES) {
  Object.freeze(KEYS$1[type]);
}

Object.freeze(KEYS$1); // List to ignore keys.

const KEY_BLACKLIST = new Set(["parent", "leadingComments", "trailingComments"]);
/**
 * Check whether a given key should be used or not.
 * @param {string} key The key to check.
 * @returns {boolean} `true` if the key should be used.
 */

function filterKey(key) {
  return !KEY_BLACKLIST.has(key) && key[0] !== "_";
} //------------------------------------------------------------------------------
// Public interfaces
//------------------------------------------------------------------------------


var lib$3 = Object.freeze({
  /**
   * Visitor keys.
   * @type {{ [type: string]: string[] | undefined }}
   */
  KEYS: KEYS$1,

  /**
   * Get visitor keys of a given node.
   * @param {Object} node The AST node to get keys.
   * @returns {string[]} Visitor keys of the node.
   */
  getKeys(node) {
    return Object.keys(node).filter(filterKey);
  },

  // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
  // eslint-disable-next-line valid-jsdoc

  /**
   * Make the union set with `KEYS` and given keys.
   * @param {Object} additionalKeys The additional keys.
   * @returns {{ [type: string]: string[] | undefined }} The union set.
   */
  unionWith(additionalKeys) {
    const retv = Object.assign({}, KEYS$1);

    for (const type of Object.keys(additionalKeys)) {
      if (retv.hasOwnProperty(type)) {
        const keys = new Set(additionalKeys[type]);

        for (const key of retv[type]) {
          keys.add(key);
        }

        retv[type] = Object.freeze(Array.from(keys));
      } else {
        retv[type] = Object.freeze(Array.from(additionalKeys[type]));
      }
    }

    return Object.freeze(retv);
  }

});

/*! @author Toru Nagashima <https://github.com/mysticatea> */
/**
 * Get the innermost scope which contains a given location.
 * @param {Scope} initialScope The initial scope to search.
 * @param {Node} node The location to search.
 * @returns {Scope} The innermost scope.
 */

function getInnermostScope(initialScope, node) {
  const location = node.range[0];
  let scope = initialScope;
  let found = false;

  do {
    found = false;

    for (const childScope of scope.childScopes) {
      const range = childScope.block.range;

      if (range[0] <= location && location < range[1]) {
        scope = childScope;
        found = true;
        break;
      }
    }
  } while (found);

  return scope;
}
/**
 * Find the variable of a given name.
 * @param {Scope} initialScope The scope to start finding.
 * @param {string|Node} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.
 * @returns {Variable|null} The found variable or null.
 */


function findVariable$4(initialScope, nameOrNode) {
  let name = "";
  let scope = initialScope;

  if (typeof nameOrNode === "string") {
    name = nameOrNode;
  } else {
    name = nameOrNode.name;
    scope = getInnermostScope(scope, nameOrNode);
  }

  while (scope != null) {
    const variable = scope.set.get(name);

    if (variable != null) {
      return variable;
    }

    scope = scope.upper;
  }

  return null;
}
/**
 * Negate the result of `this` calling.
 * @param {Token} token The token to check.
 * @returns {boolean} `true` if the result of `this(token)` is `false`.
 */


function negate0(token) {
  return !this(token); //eslint-disable-line no-invalid-this
}
/**
 * Creates the negate function of the given function.
 * @param {function(Token):boolean} f - The function to negate.
 * @returns {function(Token):boolean} Negated function.
 */


function negate$1(f) {
  return negate0.bind(f);
}
/**
 * Checks if the given token is an arrow token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an arrow token.
 */


function isArrowToken(token) {
  return token.value === "=>" && token.type === "Punctuator";
}
/**
 * Checks if the given token is a comma token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a comma token.
 */


function isCommaToken$1(token) {
  return token.value === "," && token.type === "Punctuator";
}
/**
 * Checks if the given token is a semicolon token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a semicolon token.
 */


function isSemicolonToken(token) {
  return token.value === ";" && token.type === "Punctuator";
}
/**
 * Checks if the given token is a colon token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a colon token.
 */


function isColonToken(token) {
  return token.value === ":" && token.type === "Punctuator";
}
/**
 * Checks if the given token is an opening parenthesis token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening parenthesis token.
 */


function isOpeningParenToken$1(token) {
  return token.value === "(" && token.type === "Punctuator";
}
/**
 * Checks if the given token is a closing parenthesis token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing parenthesis token.
 */


function isClosingParenToken$1(token) {
  return token.value === ")" && token.type === "Punctuator";
}
/**
 * Checks if the given token is an opening square bracket token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening square bracket token.
 */


function isOpeningBracketToken(token) {
  return token.value === "[" && token.type === "Punctuator";
}
/**
 * Checks if the given token is a closing square bracket token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing square bracket token.
 */


function isClosingBracketToken(token) {
  return token.value === "]" && token.type === "Punctuator";
}
/**
 * Checks if the given token is an opening brace token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening brace token.
 */


function isOpeningBraceToken(token) {
  return token.value === "{" && token.type === "Punctuator";
}
/**
 * Checks if the given token is a closing brace token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing brace token.
 */


function isClosingBraceToken(token) {
  return token.value === "}" && token.type === "Punctuator";
}
/**
 * Checks if the given token is a comment token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a comment token.
 */


function isCommentToken$3(token) {
  return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
}

const isNotArrowToken = negate$1(isArrowToken);
const isNotCommaToken = negate$1(isCommaToken$1);
const isNotSemicolonToken = negate$1(isSemicolonToken);
const isNotColonToken = negate$1(isColonToken);
const isNotOpeningParenToken$1 = negate$1(isOpeningParenToken$1);
const isNotClosingParenToken = negate$1(isClosingParenToken$1);
const isNotOpeningBracketToken = negate$1(isOpeningBracketToken);
const isNotClosingBracketToken = negate$1(isClosingBracketToken);
const isNotOpeningBraceToken = negate$1(isOpeningBraceToken);
const isNotClosingBraceToken = negate$1(isClosingBraceToken);
const isNotCommentToken = negate$1(isCommentToken$3);
/**
 * Get the `(` token of the given function node.
 * @param {Node} node - The function node to get.
 * @param {SourceCode} sourceCode - The source code object to get tokens.
 * @returns {Token} `(` token.
 */

function getOpeningParenOfParams(node, sourceCode) {
  return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken$1) : sourceCode.getFirstToken(node, isOpeningParenToken$1);
}
/**
 * Get the location of the given function node for reporting.
 * @param {Node} node - The function node to get.
 * @param {SourceCode} sourceCode - The source code object to get tokens.
 * @returns {string} The location of the function node for reporting.
 */


function getFunctionHeadLocation(node, sourceCode) {
  const parent = node.parent;
  let start = null;
  let end = null;

  if (node.type === "ArrowFunctionExpression") {
    const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
    start = arrowToken.loc.start;
    end = arrowToken.loc.end;
  } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
    start = parent.loc.start;
    end = getOpeningParenOfParams(node, sourceCode).loc.start;
  } else {
    start = node.loc.start;
    end = getOpeningParenOfParams(node, sourceCode).loc.start;
  }

  return {
    start: Object.assign({}, start),
    end: Object.assign({}, end)
  };
}
/* globals BigInt, globalThis, global, self, window */


const globalObject = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
const builtinNames = Object.freeze(new Set(["Array", "ArrayBuffer", "BigInt", "BigInt64Array", "BigUint64Array", "Boolean", "DataView", "Date", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "Float32Array", "Float64Array", "Function", "Infinity", "Int16Array", "Int32Array", "Int8Array", "isFinite", "isNaN", "isPrototypeOf", "JSON", "Map", "Math", "NaN", "Number", "Object", "parseFloat", "parseInt", "Promise", "Proxy", "Reflect", "RegExp", "Set", "String", "Symbol", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray", "undefined", "unescape", "WeakMap", "WeakSet"]));
const callAllowed = new Set([Array.isArray, typeof BigInt === "function" ? BigInt : undefined, Boolean, Date, Date.parse, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, escape, isFinite, isNaN, isPrototypeOf, ...Object.getOwnPropertyNames(Math).map(k => Math[k]).filter(f => typeof f === "function"), Number, Number.isFinite, Number.isNaN, Number.parseFloat, Number.parseInt, Object, Object.entries, Object.is, Object.isExtensible, Object.isFrozen, Object.isSealed, Object.keys, Object.values, parseFloat, parseInt, RegExp, String, String.fromCharCode, String.fromCodePoint, String.raw, Symbol, Symbol.for, Symbol.keyFor, unescape].filter(f => typeof f === "function"));
const callPassThrough = new Set([Object.freeze, Object.preventExtensions, Object.seal]);
/**
 * Get the property descriptor.
 * @param {object} object The object to get.
 * @param {string|number|symbol} name The property name to get.
 */

function getPropertyDescriptor(object, name) {
  let x = object;

  while ((typeof x === "object" || typeof x === "function") && x !== null) {
    const d = Object.getOwnPropertyDescriptor(x, name);

    if (d) {
      return d;
    }

    x = Object.getPrototypeOf(x);
  }

  return null;
}
/**
 * Check if a property is getter or not.
 * @param {object} object The object to check.
 * @param {string|number|symbol} name The property name to check.
 */


function isGetter(object, name) {
  const d = getPropertyDescriptor(object, name);
  return d != null && d.get != null;
}
/**
 * Get the element values of a given node list.
 * @param {Node[]} nodeList The node list to get values.
 * @param {Scope|undefined} initialScope The initial scope to find variables.
 * @returns {any[]|null} The value list if all nodes are constant. Otherwise, null.
 */


function getElementValues(nodeList, initialScope) {
  const valueList = [];

  for (let i = 0; i < nodeList.length; ++i) {
    const elementNode = nodeList[i];

    if (elementNode == null) {
      valueList.length = i + 1;
    } else if (elementNode.type === "SpreadElement") {
      const argument = getStaticValueR(elementNode.argument, initialScope);

      if (argument == null) {
        return null;
      }

      valueList.push(...argument.value);
    } else {
      const element = getStaticValueR(elementNode, initialScope);

      if (element == null) {
        return null;
      }

      valueList.push(element.value);
    }
  }

  return valueList;
}

const operations = Object.freeze({
  ArrayExpression(node, initialScope) {
    const elements = getElementValues(node.elements, initialScope);
    return elements != null ? {
      value: elements
    } : null;
  },

  AssignmentExpression(node, initialScope) {
    if (node.operator === "=") {
      return getStaticValueR(node.right, initialScope);
    }

    return null;
  },

  //eslint-disable-next-line complexity
  BinaryExpression(node, initialScope) {
    if (node.operator === "in" || node.operator === "instanceof") {
      // Not supported.
      return null;
    }

    const left = getStaticValueR(node.left, initialScope);
    const right = getStaticValueR(node.right, initialScope);

    if (left != null && right != null) {
      switch (node.operator) {
        case "==":
          return {
            value: left.value == right.value
          };
        //eslint-disable-line eqeqeq

        case "!=":
          return {
            value: left.value != right.value
          };
        //eslint-disable-line eqeqeq

        case "===":
          return {
            value: left.value === right.value
          };

        case "!==":
          return {
            value: left.value !== right.value
          };

        case "<":
          return {
            value: left.value < right.value
          };

        case "<=":
          return {
            value: left.value <= right.value
          };

        case ">":
          return {
            value: left.value > right.value
          };

        case ">=":
          return {
            value: left.value >= right.value
          };

        case "<<":
          return {
            value: left.value << right.value
          };

        case ">>":
          return {
            value: left.value >> right.value
          };

        case ">>>":
          return {
            value: left.value >>> right.value
          };

        case "+":
          return {
            value: left.value + right.value
          };

        case "-":
          return {
            value: left.value - right.value
          };

        case "*":
          return {
            value: left.value * right.value
          };

        case "/":
          return {
            value: left.value / right.value
          };

        case "%":
          return {
            value: left.value % right.value
          };

        case "**":
          return {
            value: Math.pow(left.value, right.value)
          };

        case "|":
          return {
            value: left.value | right.value
          };

        case "^":
          return {
            value: left.value ^ right.value
          };

        case "&":
          return {
            value: left.value & right.value
          };
        // no default
      }
    }

    return null;
  },

  CallExpression(node, initialScope) {
    const calleeNode = node.callee;
    const args = getElementValues(node.arguments, initialScope);

    if (args != null) {
      if (calleeNode.type === "MemberExpression") {
        const object = getStaticValueR(calleeNode.object, initialScope);

        if (object != null) {
          if (object.value == null && (object.optional || node.optional)) {
            return {
              value: undefined,
              optional: true
            };
          }

          const property = calleeNode.computed ? getStaticValueR(calleeNode.property, initialScope) : {
            value: calleeNode.property.name
          };

          if (property != null) {
            const receiver = object.value;
            const methodName = property.value;

            if (callAllowed.has(receiver[methodName])) {
              return {
                value: receiver[methodName](...args)
              };
            }

            if (callPassThrough.has(receiver[methodName])) {
              return {
                value: args[0]
              };
            }
          }
        }
      } else {
        const callee = getStaticValueR(calleeNode, initialScope);

        if (callee != null) {
          if (callee.value == null && node.optional) {
            return {
              value: undefined,
              optional: true
            };
          }

          const func = callee.value;

          if (callAllowed.has(func)) {
            return {
              value: func(...args)
            };
          }

          if (callPassThrough.has(func)) {
            return {
              value: args[0]
            };
          }
        }
      }
    }

    return null;
  },

  ConditionalExpression(node, initialScope) {
    const test = getStaticValueR(node.test, initialScope);

    if (test != null) {
      return test.value ? getStaticValueR(node.consequent, initialScope) : getStaticValueR(node.alternate, initialScope);
    }

    return null;
  },

  ExpressionStatement(node, initialScope) {
    return getStaticValueR(node.expression, initialScope);
  },

  Identifier(node, initialScope) {
    if (initialScope != null) {
      const variable = findVariable$4(initialScope, node); // Built-in globals.

      if (variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in globalObject) {
        return {
          value: globalObject[variable.name]
        };
      } // Constants.


      if (variable != null && variable.defs.length === 1) {
        const def = variable.defs[0];

        if (def.parent && def.parent.kind === "const" && // TODO(mysticatea): don't support destructuring here.
        def.node.id.type === "Identifier") {
          return getStaticValueR(def.node.init, initialScope);
        }
      }
    }

    return null;
  },

  Literal(node) {
    //istanbul ignore if : this is implementation-specific behavior.
    if ((node.regex != null || node.bigint != null) && node.value == null) {
      // It was a RegExp/BigInt literal, but Node.js didn't support it.
      return null;
    }

    return {
      value: node.value
    };
  },

  LogicalExpression(node, initialScope) {
    const left = getStaticValueR(node.left, initialScope);

    if (left != null) {
      if (node.operator === "||" && Boolean(left.value) === true || node.operator === "&&" && Boolean(left.value) === false || node.operator === "??" && left.value != null) {
        return left;
      }

      const right = getStaticValueR(node.right, initialScope);

      if (right != null) {
        return right;
      }
    }

    return null;
  },

  MemberExpression(node, initialScope) {
    const object = getStaticValueR(node.object, initialScope);

    if (object != null) {
      if (object.value == null && (object.optional || node.optional)) {
        return {
          value: undefined,
          optional: true
        };
      }

      const property = node.computed ? getStaticValueR(node.property, initialScope) : {
        value: node.property.name
      };

      if (property != null && !isGetter(object.value, property.value)) {
        return {
          value: object.value[property.value]
        };
      }
    }

    return null;
  },

  ChainExpression(node, initialScope) {
    const expression = getStaticValueR(node.expression, initialScope);

    if (expression != null) {
      return {
        value: expression.value
      };
    }

    return null;
  },

  NewExpression(node, initialScope) {
    const callee = getStaticValueR(node.callee, initialScope);
    const args = getElementValues(node.arguments, initialScope);

    if (callee != null && args != null) {
      const Func = callee.value;

      if (callAllowed.has(Func)) {
        return {
          value: new Func(...args)
        };
      }
    }

    return null;
  },

  ObjectExpression(node, initialScope) {
    const object = {};

    for (const propertyNode of node.properties) {
      if (propertyNode.type === "Property") {
        if (propertyNode.kind !== "init") {
          return null;
        }

        const key = propertyNode.computed ? getStaticValueR(propertyNode.key, initialScope) : {
          value: propertyNode.key.name
        };
        const value = getStaticValueR(propertyNode.value, initialScope);

        if (key == null || value == null) {
          return null;
        }

        object[key.value] = value.value;
      } else if (propertyNode.type === "SpreadElement" || propertyNode.type === "ExperimentalSpreadProperty") {
        const argument = getStaticValueR(propertyNode.argument, initialScope);

        if (argument == null) {
          return null;
        }

        Object.assign(object, argument.value);
      } else {
        return null;
      }
    }

    return {
      value: object
    };
  },

  SequenceExpression(node, initialScope) {
    const last = node.expressions[node.expressions.length - 1];
    return getStaticValueR(last, initialScope);
  },

  TaggedTemplateExpression(node, initialScope) {
    const tag = getStaticValueR(node.tag, initialScope);
    const expressions = getElementValues(node.quasi.expressions, initialScope);

    if (tag != null && expressions != null) {
      const func = tag.value;
      const strings = node.quasi.quasis.map(q => q.value.cooked);
      strings.raw = node.quasi.quasis.map(q => q.value.raw);

      if (func === String.raw) {
        return {
          value: func(strings, ...expressions)
        };
      }
    }

    return null;
  },

  TemplateLiteral(node, initialScope) {
    const expressions = getElementValues(node.expressions, initialScope);

    if (expressions != null) {
      let value = node.quasis[0].value.cooked;

      for (let i = 0; i < expressions.length; ++i) {
        value += expressions[i];
        value += node.quasis[i + 1].value.cooked;
      }

      return {
        value
      };
    }

    return null;
  },

  UnaryExpression(node, initialScope) {
    if (node.operator === "delete") {
      // Not supported.
      return null;
    }

    if (node.operator === "void") {
      return {
        value: undefined
      };
    }

    const arg = getStaticValueR(node.argument, initialScope);

    if (arg != null) {
      switch (node.operator) {
        case "-":
          return {
            value: -arg.value
          };

        case "+":
          return {
            value: +arg.value
          };
        //eslint-disable-line no-implicit-coercion

        case "!":
          return {
            value: !arg.value
          };

        case "~":
          return {
            value: ~arg.value
          };

        case "typeof":
          return {
            value: typeof arg.value
          };
        // no default
      }
    }

    return null;
  }

});
/**
 * Get the value of a given node if it's a static value.
 * @param {Node} node The node to get.
 * @param {Scope|undefined} initialScope The scope to start finding variable.
 * @returns {{value:any}|{value:undefined,optional?:true}|null} The static value of the node, or `null`.
 */

function getStaticValueR(node, initialScope) {
  if (node != null && Object.hasOwnProperty.call(operations, node.type)) {
    return operations[node.type](node, initialScope);
  }

  return null;
}
/**
 * Get the value of a given node if it's a static value.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If this scope was given, this tries to resolve identifier references which are in the given node as much as possible.
 * @returns {{value:any}|{value:undefined,optional?:true}|null} The static value of the node, or `null`.
 */


function getStaticValue$1(node, initialScope = null) {
  try {
    return getStaticValueR(node, initialScope);
  } catch (_error) {
    return null;
  }
}
/**
 * Get the value of a given node if it's a literal or a template literal.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is an Identifier node and this scope was given, this checks the variable of the identifier, and returns the value of it if the variable is a constant.
 * @returns {string|null} The value of the node, or `null`.
 */


function getStringIfConstant$4(node, initialScope = null) {
  // Handle the literals that the platform doesn't support natively.
  if (node && node.type === "Literal" && node.value === null) {
    if (node.regex) {
      return `/${node.regex.pattern}/${node.regex.flags}`;
    }

    if (node.bigint) {
      return node.bigint;
    }
  }

  const evaluated = getStaticValue$1(node, initialScope);
  return evaluated && String(evaluated.value);
}
/**
 * Get the property name from a MemberExpression node or a Property node.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.
 * @returns {string|null} The property name of the node.
 */


function getPropertyName$3(node, initialScope) {
  switch (node.type) {
    case "MemberExpression":
      if (node.computed) {
        return getStringIfConstant$4(node.property, initialScope);
      }

      return node.property.name;

    case "Property":
    case "MethodDefinition":
      if (node.computed) {
        return getStringIfConstant$4(node.key, initialScope);
      }

      if (node.key.type === "Literal") {
        return String(node.key.value);
      }

      return node.key.name;
    // no default
  }

  return null;
}
/**
 * Get the name and kind of the given function node.
 * @param {ASTNode} node - The function node to get.
 * @returns {string} The name and kind of the function node.
 */


function getFunctionNameWithKind(node) {
  const parent = node.parent;
  const tokens = [];

  if (parent.type === "MethodDefinition" && parent.static) {
    tokens.push("static");
  }

  if (node.async) {
    tokens.push("async");
  }

  if (node.generator) {
    tokens.push("generator");
  }

  if (node.type === "ArrowFunctionExpression") {
    tokens.push("arrow", "function");
  } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
    if (parent.kind === "constructor") {
      return "constructor";
    }

    if (parent.kind === "get") {
      tokens.push("getter");
    } else if (parent.kind === "set") {
      tokens.push("setter");
    } else {
      tokens.push("method");
    }
  } else {
    tokens.push("function");
  }

  if (node.id) {
    tokens.push(`'${node.id.name}'`);
  } else {
    const name = getPropertyName$3(parent);

    if (name) {
      tokens.push(`'${name}'`);
    }
  }

  if (node.type === "ArrowFunctionExpression") {
    if (parent.type === "VariableDeclarator" && parent.id && parent.id.type === "Identifier") {
      tokens.push(`'${parent.id.name}'`);
    }

    if (parent.type === "AssignmentExpression" && parent.left && parent.left.type === "Identifier") {
      tokens.push(`'${parent.left.name}'`);
    }
  }

  return tokens.join(" ");
}

const typeConversionBinaryOps = Object.freeze(new Set(["==", "!=", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "|", "^", "&", "in"]));
const typeConversionUnaryOps = Object.freeze(new Set(["-", "+", "!", "~"]));
/**
 * Check whether the given value is an ASTNode or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an ASTNode.
 */

function isNode(x) {
  return x !== null && typeof x === "object" && typeof x.type === "string";
}

const visitor = Object.freeze(Object.assign(Object.create(null), {
  $visit(node, options, visitorKeys) {
    const {
      type
    } = node;

    if (typeof this[type] === "function") {
      return this[type](node, options, visitorKeys);
    }

    return this.$visitChildren(node, options, visitorKeys);
  },

  $visitChildren(node, options, visitorKeys) {
    const {
      type
    } = node;

    for (const key of visitorKeys[type] || lib$3.getKeys(node)) {
      const value = node[key];

      if (Array.isArray(value)) {
        for (const element of value) {
          if (isNode(element) && this.$visit(element, options, visitorKeys)) {
            return true;
          }
        }
      } else if (isNode(value) && this.$visit(value, options, visitorKeys)) {
        return true;
      }
    }

    return false;
  },

  ArrowFunctionExpression() {
    return false;
  },

  AssignmentExpression() {
    return true;
  },

  AwaitExpression() {
    return true;
  },

  BinaryExpression(node, options, visitorKeys) {
    if (options.considerImplicitTypeConversion && typeConversionBinaryOps.has(node.operator) && (node.left.type !== "Literal" || node.right.type !== "Literal")) {
      return true;
    }

    return this.$visitChildren(node, options, visitorKeys);
  },

  CallExpression() {
    return true;
  },

  FunctionExpression() {
    return false;
  },

  ImportExpression() {
    return true;
  },

  MemberExpression(node, options, visitorKeys) {
    if (options.considerGetters) {
      return true;
    }

    if (options.considerImplicitTypeConversion && node.computed && node.property.type !== "Literal") {
      return true;
    }

    return this.$visitChildren(node, options, visitorKeys);
  },

  MethodDefinition(node, options, visitorKeys) {
    if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
      return true;
    }

    return this.$visitChildren(node, options, visitorKeys);
  },

  NewExpression() {
    return true;
  },

  Property(node, options, visitorKeys) {
    if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
      return true;
    }

    return this.$visitChildren(node, options, visitorKeys);
  },

  UnaryExpression(node, options, visitorKeys) {
    if (node.operator === "delete") {
      return true;
    }

    if (options.considerImplicitTypeConversion && typeConversionUnaryOps.has(node.operator) && node.argument.type !== "Literal") {
      return true;
    }

    return this.$visitChildren(node, options, visitorKeys);
  },

  UpdateExpression() {
    return true;
  },

  YieldExpression() {
    return true;
  }

}));
/**
 * Check whether a given node has any side effect or not.
 * @param {Node} node The node to get.
 * @param {SourceCode} sourceCode The source code object.
 * @param {object} [options] The option object.
 * @param {boolean} [options.considerGetters=false] If `true` then it considers member accesses as the node which has side effects.
 * @param {boolean} [options.considerImplicitTypeConversion=false] If `true` then it considers implicit type conversion as the node which has side effects.
 * @param {object} [options.visitorKeys=evk.KEYS] The keys to traverse nodes. Use `context.getSourceCode().visitorKeys`.
 * @returns {boolean} `true` if the node has a certain side effect.
 */

function hasSideEffect(node, sourceCode, {
  considerGetters = false,
  considerImplicitTypeConversion = false
} = {}) {
  return visitor.$visit(node, {
    considerGetters,
    considerImplicitTypeConversion
  }, sourceCode.visitorKeys || lib$3.KEYS);
}
/**
 * Get the left parenthesis of the parent node syntax if it exists.
 * E.g., `if (a) {}` then the `(`.
 * @param {Node} node The AST node to check.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {Token|null} The left parenthesis of the parent node syntax
 */


function getParentSyntaxParen(node, sourceCode) {
  const parent = node.parent;

  switch (parent.type) {
    case "CallExpression":
    case "NewExpression":
      if (parent.arguments.length === 1 && parent.arguments[0] === node) {
        return sourceCode.getTokenAfter(parent.callee, isOpeningParenToken$1);
      }

      return null;

    case "DoWhileStatement":
      if (parent.test === node) {
        return sourceCode.getTokenAfter(parent.body, isOpeningParenToken$1);
      }

      return null;

    case "IfStatement":
    case "WhileStatement":
      if (parent.test === node) {
        return sourceCode.getFirstToken(parent, 1);
      }

      return null;

    case "ImportExpression":
      if (parent.source === node) {
        return sourceCode.getFirstToken(parent, 1);
      }

      return null;

    case "SwitchStatement":
      if (parent.discriminant === node) {
        return sourceCode.getFirstToken(parent, 1);
      }

      return null;

    case "WithStatement":
      if (parent.object === node) {
        return sourceCode.getFirstToken(parent, 1);
      }

      return null;

    default:
      return null;
  }
}
/**
 * Check whether a given node is parenthesized or not.
 * @param {number} times The number of parantheses.
 * @param {Node} node The AST node to check.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {boolean} `true` if the node is parenthesized the given times.
 */

/**
 * Check whether a given node is parenthesized or not.
 * @param {Node} node The AST node to check.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {boolean} `true` if the node is parenthesized.
 */


function isParenthesized(timesOrNode, nodeOrSourceCode, optionalSourceCode) {
  let times, node, sourceCode, maybeLeftParen, maybeRightParen;

  if (typeof timesOrNode === "number") {
    times = timesOrNode | 0;
    node = nodeOrSourceCode;
    sourceCode = optionalSourceCode;

    if (!(times >= 1)) {
      throw new TypeError("'times' should be a positive integer.");
    }
  } else {
    times = 1;
    node = timesOrNode;
    sourceCode = nodeOrSourceCode;
  }

  if (node == null) {
    return false;
  }

  maybeLeftParen = maybeRightParen = node;

  do {
    maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen);
    maybeRightParen = sourceCode.getTokenAfter(maybeRightParen);
  } while (maybeLeftParen != null && maybeRightParen != null && isOpeningParenToken$1(maybeLeftParen) && isClosingParenToken$1(maybeRightParen) && // Avoid false positive such as `if (a) {}`
  maybeLeftParen !== getParentSyntaxParen(node, sourceCode) && --times > 0);

  return times === 0;
}
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */


const placeholder = /\$(?:[$&`']|[1-9][0-9]?)/gu;
/** @type {WeakMap<PatternMatcher, {pattern:RegExp,escaped:boolean}>} */

const internal = new WeakMap();
/**
 * Check whether a given character is escaped or not.
 * @param {string} str The string to check.
 * @param {number} index The location of the character to check.
 * @returns {boolean} `true` if the character is escaped.
 */

function isEscaped(str, index) {
  let escaped = false;

  for (let i = index - 1; i >= 0 && str.charCodeAt(i) === 0x5c; --i) {
    escaped = !escaped;
  }

  return escaped;
}
/**
 * Replace a given string by a given matcher.
 * @param {PatternMatcher} matcher The pattern matcher.
 * @param {string} str The string to be replaced.
 * @param {string} replacement The new substring to replace each matched part.
 * @returns {string} The replaced string.
 */


function replaceS(matcher, str, replacement) {
  const chunks = [];
  let index = 0;
  /** @type {RegExpExecArray} */

  let match = null;
  /**
   * @param {string} key The placeholder.
   * @returns {string} The replaced string.
   */

  function replacer(key) {
    switch (key) {
      case "$$":
        return "$";

      case "$&":
        return match[0];

      case "$`":
        return str.slice(0, match.index);

      case "$'":
        return str.slice(match.index + match[0].length);

      default:
        {
          const i = key.slice(1);

          if (i in match) {
            return match[i];
          }

          return key;
        }
    }
  }

  for (match of matcher.execAll(str)) {
    chunks.push(str.slice(index, match.index));
    chunks.push(replacement.replace(placeholder, replacer));
    index = match.index + match[0].length;
  }

  chunks.push(str.slice(index));
  return chunks.join("");
}
/**
 * Replace a given string by a given matcher.
 * @param {PatternMatcher} matcher The pattern matcher.
 * @param {string} str The string to be replaced.
 * @param {(...strs[])=>string} replace The function to replace each matched part.
 * @returns {string} The replaced string.
 */


function replaceF(matcher, str, replace) {
  const chunks = [];
  let index = 0;

  for (const match of matcher.execAll(str)) {
    chunks.push(str.slice(index, match.index));
    chunks.push(String(replace(...match, match.index, match.input)));
    index = match.index + match[0].length;
  }

  chunks.push(str.slice(index));
  return chunks.join("");
}
/**
 * The class to find patterns as considering escape sequences.
 */


class PatternMatcher {
  /**
   * Initialize this matcher.
   * @param {RegExp} pattern The pattern to match.
   * @param {{escaped:boolean}} options The options.
   */
  constructor(pattern, {
    escaped = false
  } = {}) {
    if (!(pattern instanceof RegExp)) {
      throw new TypeError("'pattern' should be a RegExp instance.");
    }

    if (!pattern.flags.includes("g")) {
      throw new Error("'pattern' should contains 'g' flag.");
    }

    internal.set(this, {
      pattern: new RegExp(pattern.source, pattern.flags),
      escaped: Boolean(escaped)
    });
  }
  /**
   * Find the pattern in a given string.
   * @param {string} str The string to find.
   * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
   */


  *execAll(str) {
    const {
      pattern,
      escaped
    } = internal.get(this);
    let match = null;
    let lastIndex = 0;
    pattern.lastIndex = 0;

    while ((match = pattern.exec(str)) != null) {
      if (escaped || !isEscaped(str, match.index)) {
        lastIndex = pattern.lastIndex;
        yield match;
        pattern.lastIndex = lastIndex;
      }
    }
  }
  /**
   * Check whether the pattern is found in a given string.
   * @param {string} str The string to check.
   * @returns {boolean} `true` if the pattern was found in the string.
   */


  test(str) {
    const it = this.execAll(str);
    const ret = it.next();
    return !ret.done;
  }
  /**
   * Replace a given string.
   * @param {string} str The string to be replaced.
   * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
   * @returns {string} The replaced string.
   */


  [Symbol.replace](str, replacer) {
    return typeof replacer === "function" ? replaceF(this, String(str), replacer) : replaceS(this, String(str), String(replacer));
  }

}

const IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;
const has = Function.call.bind(Object.hasOwnProperty);
const READ = Symbol("read");
const CALL$8 = Symbol("call");
const CONSTRUCT$6 = Symbol("construct");
const ESM = Symbol("esm");
const requireCall = {
  require: {
    [CALL$8]: true
  }
};
/**
 * Check whether a given variable is modified or not.
 * @param {Variable} variable The variable to check.
 * @returns {boolean} `true` if the variable is modified.
 */

function isModifiedGlobal(variable) {
  return variable == null || variable.defs.length !== 0 || variable.references.some(r => r.isWrite());
}
/**
 * Check if the value of a given node is passed through to the parent syntax as-is.
 * For example, `a` and `b` in (`a || b` and `c ? a : b`) are passed through.
 * @param {Node} node A node to check.
 * @returns {boolean} `true` if the node is passed through.
 */


function isPassThrough(node) {
  const parent = node.parent;

  switch (parent && parent.type) {
    case "ConditionalExpression":
      return parent.consequent === node || parent.alternate === node;

    case "LogicalExpression":
      return true;

    case "SequenceExpression":
      return parent.expressions[parent.expressions.length - 1] === node;

    case "ChainExpression":
      return true;

    default:
      return false;
  }
}
/**
 * The reference tracker.
 */


class ReferenceTracker$8 {
  /**
   * Initialize this tracker.
   * @param {Scope} globalScope The global scope.
   * @param {object} [options] The options.
   * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
   * @param {string[]} [options.globalObjectNames=["global","globalThis","self","window"]] The variable names for Global Object.
   */
  constructor(globalScope, {
    mode = "strict",
    globalObjectNames = ["global", "globalThis", "self", "window"]
  } = {}) {
    this.variableStack = [];
    this.globalScope = globalScope;
    this.mode = mode;
    this.globalObjectNames = globalObjectNames.slice(0);
  }
  /**
   * Iterate the references of global variables.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */


  *iterateGlobalReferences(traceMap) {
    for (const key of Object.keys(traceMap)) {
      const nextTraceMap = traceMap[key];
      const path = [key];
      const variable = this.globalScope.set.get(key);

      if (isModifiedGlobal(variable)) {
        continue;
      }

      yield* this._iterateVariableReferences(variable, path, nextTraceMap, true);
    }

    for (const key of this.globalObjectNames) {
      const path = [];
      const variable = this.globalScope.set.get(key);

      if (isModifiedGlobal(variable)) {
        continue;
      }

      yield* this._iterateVariableReferences(variable, path, traceMap, false);
    }
  }
  /**
   * Iterate the references of CommonJS modules.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */


  *iterateCjsReferences(traceMap) {
    for (const {
      node
    } of this.iterateGlobalReferences(requireCall)) {
      const key = getStringIfConstant$4(node.arguments[0]);

      if (key == null || !has(traceMap, key)) {
        continue;
      }

      const nextTraceMap = traceMap[key];
      const path = [key];

      if (nextTraceMap[READ]) {
        yield {
          node,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }

      yield* this._iteratePropertyReferences(node, path, nextTraceMap);
    }
  }
  /**
   * Iterate the references of ES modules.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */


  *iterateEsmReferences(traceMap) {
    const programNode = this.globalScope.block;

    for (const node of programNode.body) {
      if (!IMPORT_TYPE.test(node.type) || node.source == null) {
        continue;
      }

      const moduleId = node.source.value;

      if (!has(traceMap, moduleId)) {
        continue;
      }

      const nextTraceMap = traceMap[moduleId];
      const path = [moduleId];

      if (nextTraceMap[READ]) {
        yield {
          node,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }

      if (node.type === "ExportAllDeclaration") {
        for (const key of Object.keys(nextTraceMap)) {
          const exportTraceMap = nextTraceMap[key];

          if (exportTraceMap[READ]) {
            yield {
              node,
              path: path.concat(key),
              type: READ,
              info: exportTraceMap[READ]
            };
          }
        }
      } else {
        for (const specifier of node.specifiers) {
          const esm = has(nextTraceMap, ESM);

          const it = this._iterateImportReferences(specifier, path, esm ? nextTraceMap : this.mode === "legacy" ? Object.assign({
            default: nextTraceMap
          }, nextTraceMap) : {
            default: nextTraceMap
          });

          if (esm) {
            yield* it;
          } else {
            for (const report of it) {
              report.path = report.path.filter(exceptDefault);

              if (report.path.length >= 2 || report.type !== READ) {
                yield report;
              }
            }
          }
        }
      }
    }
  }
  /**
   * Iterate the references for a given variable.
   * @param {Variable} variable The variable to iterate that references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @param {boolean} shouldReport = The flag to report those references.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */


  *_iterateVariableReferences(variable, path, traceMap, shouldReport) {
    if (this.variableStack.includes(variable)) {
      return;
    }

    this.variableStack.push(variable);

    try {
      for (const reference of variable.references) {
        if (!reference.isRead()) {
          continue;
        }

        const node = reference.identifier;

        if (shouldReport && traceMap[READ]) {
          yield {
            node,
            path,
            type: READ,
            info: traceMap[READ]
          };
        }

        yield* this._iteratePropertyReferences(node, path, traceMap);
      }
    } finally {
      this.variableStack.pop();
    }
  }
  /**
   * Iterate the references for a given AST node.
   * @param rootNode The AST node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  //eslint-disable-next-line complexity


  *_iteratePropertyReferences(rootNode, path, traceMap) {
    let node = rootNode;

    while (isPassThrough(node)) {
      node = node.parent;
    }

    const parent = node.parent;

    if (parent.type === "MemberExpression") {
      if (parent.object === node) {
        const key = getPropertyName$3(parent);

        if (key == null || !has(traceMap, key)) {
          return;
        }

        path = path.concat(key); //eslint-disable-line no-param-reassign

        const nextTraceMap = traceMap[key];

        if (nextTraceMap[READ]) {
          yield {
            node: parent,
            path,
            type: READ,
            info: nextTraceMap[READ]
          };
        }

        yield* this._iteratePropertyReferences(parent, path, nextTraceMap);
      }

      return;
    }

    if (parent.type === "CallExpression") {
      if (parent.callee === node && traceMap[CALL$8]) {
        yield {
          node: parent,
          path,
          type: CALL$8,
          info: traceMap[CALL$8]
        };
      }

      return;
    }

    if (parent.type === "NewExpression") {
      if (parent.callee === node && traceMap[CONSTRUCT$6]) {
        yield {
          node: parent,
          path,
          type: CONSTRUCT$6,
          info: traceMap[CONSTRUCT$6]
        };
      }

      return;
    }

    if (parent.type === "AssignmentExpression") {
      if (parent.right === node) {
        yield* this._iterateLhsReferences(parent.left, path, traceMap);
        yield* this._iteratePropertyReferences(parent, path, traceMap);
      }

      return;
    }

    if (parent.type === "AssignmentPattern") {
      if (parent.right === node) {
        yield* this._iterateLhsReferences(parent.left, path, traceMap);
      }

      return;
    }

    if (parent.type === "VariableDeclarator") {
      if (parent.init === node) {
        yield* this._iterateLhsReferences(parent.id, path, traceMap);
      }
    }
  }
  /**
   * Iterate the references for a given Pattern node.
   * @param {Node} patternNode The Pattern node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */


  *_iterateLhsReferences(patternNode, path, traceMap) {
    if (patternNode.type === "Identifier") {
      const variable = findVariable$4(this.globalScope, patternNode);

      if (variable != null) {
        yield* this._iterateVariableReferences(variable, path, traceMap, false);
      }

      return;
    }

    if (patternNode.type === "ObjectPattern") {
      for (const property of patternNode.properties) {
        const key = getPropertyName$3(property);

        if (key == null || !has(traceMap, key)) {
          continue;
        }

        const nextPath = path.concat(key);
        const nextTraceMap = traceMap[key];

        if (nextTraceMap[READ]) {
          yield {
            node: property,
            path: nextPath,
            type: READ,
            info: nextTraceMap[READ]
          };
        }

        yield* this._iterateLhsReferences(property.value, nextPath, nextTraceMap);
      }

      return;
    }

    if (patternNode.type === "AssignmentPattern") {
      yield* this._iterateLhsReferences(patternNode.left, path, traceMap);
    }
  }
  /**
   * Iterate the references for a given ModuleSpecifier node.
   * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */


  *_iterateImportReferences(specifierNode, path, traceMap) {
    const type = specifierNode.type;

    if (type === "ImportSpecifier" || type === "ImportDefaultSpecifier") {
      const key = type === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.name;

      if (!has(traceMap, key)) {
        return;
      }

      path = path.concat(key); //eslint-disable-line no-param-reassign

      const nextTraceMap = traceMap[key];

      if (nextTraceMap[READ]) {
        yield {
          node: specifierNode,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }

      yield* this._iterateVariableReferences(findVariable$4(this.globalScope, specifierNode.local), path, nextTraceMap, false);
      return;
    }

    if (type === "ImportNamespaceSpecifier") {
      yield* this._iterateVariableReferences(findVariable$4(this.globalScope, specifierNode.local), path, traceMap, false);
      return;
    }

    if (type === "ExportSpecifier") {
      const key = specifierNode.local.name;

      if (!has(traceMap, key)) {
        return;
      }

      path = path.concat(key); //eslint-disable-line no-param-reassign

      const nextTraceMap = traceMap[key];

      if (nextTraceMap[READ]) {
        yield {
          node: specifierNode,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }
    }
  }

}

ReferenceTracker$8.READ = READ;
ReferenceTracker$8.CALL = CALL$8;
ReferenceTracker$8.CONSTRUCT = CONSTRUCT$6;
ReferenceTracker$8.ESM = ESM;
/**
 * This is a predicate function for Array#filter.
 * @param {string} name A name part.
 * @param {number} index The index of the name.
 * @returns {boolean} `false` if it's default.
 */

function exceptDefault(name, index) {
  return !(index === 1 && name === "default");
}

var index = {
  CALL: CALL$8,
  CONSTRUCT: CONSTRUCT$6,
  ESM,
  findVariable: findVariable$4,
  getFunctionHeadLocation,
  getFunctionNameWithKind,
  getInnermostScope,
  getPropertyName: getPropertyName$3,
  getStaticValue: getStaticValue$1,
  getStringIfConstant: getStringIfConstant$4,
  hasSideEffect,
  isArrowToken,
  isClosingBraceToken,
  isClosingBracketToken,
  isClosingParenToken: isClosingParenToken$1,
  isColonToken,
  isCommaToken: isCommaToken$1,
  isCommentToken: isCommentToken$3,
  isNotArrowToken,
  isNotClosingBraceToken,
  isNotClosingBracketToken,
  isNotClosingParenToken,
  isNotColonToken,
  isNotCommaToken,
  isNotCommentToken,
  isNotOpeningBraceToken,
  isNotOpeningBracketToken,
  isNotOpeningParenToken: isNotOpeningParenToken$1,
  isNotSemicolonToken,
  isOpeningBraceToken,
  isOpeningBracketToken,
  isOpeningParenToken: isOpeningParenToken$1,
  isParenthesized,
  isSemicolonToken,
  PatternMatcher,
  READ,
  ReferenceTracker: ReferenceTracker$8
};

var eslintUtils$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': index,
  CALL: CALL$8,
  CONSTRUCT: CONSTRUCT$6,
  ESM: ESM,
  PatternMatcher: PatternMatcher,
  READ: READ,
  ReferenceTracker: ReferenceTracker$8,
  findVariable: findVariable$4,
  getFunctionHeadLocation: getFunctionHeadLocation,
  getFunctionNameWithKind: getFunctionNameWithKind,
  getInnermostScope: getInnermostScope,
  getPropertyName: getPropertyName$3,
  getStaticValue: getStaticValue$1,
  getStringIfConstant: getStringIfConstant$4,
  hasSideEffect: hasSideEffect,
  isArrowToken: isArrowToken,
  isClosingBraceToken: isClosingBraceToken,
  isClosingBracketToken: isClosingBracketToken,
  isClosingParenToken: isClosingParenToken$1,
  isColonToken: isColonToken,
  isCommaToken: isCommaToken$1,
  isCommentToken: isCommentToken$3,
  isNotArrowToken: isNotArrowToken,
  isNotClosingBraceToken: isNotClosingBraceToken,
  isNotClosingBracketToken: isNotClosingBracketToken,
  isNotClosingParenToken: isNotClosingParenToken,
  isNotColonToken: isNotColonToken,
  isNotCommaToken: isNotCommaToken,
  isNotCommentToken: isNotCommentToken,
  isNotOpeningBraceToken: isNotOpeningBraceToken,
  isNotOpeningBracketToken: isNotOpeningBracketToken,
  isNotOpeningParenToken: isNotOpeningParenToken$1,
  isNotSemicolonToken: isNotSemicolonToken,
  isOpeningBraceToken: isOpeningBraceToken,
  isOpeningBracketToken: isOpeningBracketToken,
  isOpeningParenToken: isOpeningParenToken$1,
  isParenthesized: isParenthesized,
  isSemicolonToken: isSemicolonToken
});

// Generated by LiveScript 1.6.0
var apply,
    curry,
    flip,
    fix,
    over,
    memoize,
    toString$$2 = {}.toString;
apply = curry$$5(function (f, list) {
  return f.apply(null, list);
});

curry = function (f) {
  return curry$$5(f);
};

flip = curry$$5(function (f, x, y) {
  return f(y, x);
});

fix = function (f) {
  return function (g) {
    return function () {
      return f(g(g)).apply(null, arguments);
    };
  }(function (g) {
    return function () {
      return f(g(g)).apply(null, arguments);
    };
  });
};

over = curry$$5(function (f, g, x, y) {
  return f(g(x), g(y));
});

memoize = function (f) {
  var memo;
  memo = {};
  return function () {
    var args, res$, i$, to$, key, arg;
    res$ = [];

    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }

    args = res$;

    key = function () {
      var i$,
          ref$,
          len$,
          results$ = [];

      for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
        arg = ref$[i$];
        results$.push(arg + toString$$2.call(arg).slice(8, -1));
      }

      return results$;
    }().join('');

    return memo[key] = key in memo ? memo[key] : f.apply(null, args);
  };
};

var Func$1 = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over,
  memoize: memoize
};

function curry$$5(f, bound) {
  var context,
      _curry = function (args) {
    return f.length > 1 ? function () {
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
    } : f;
  };

  return _curry();
}

// Generated by LiveScript 1.6.0
var each$1,
    map$1,
    compact$1,
    filter$1,
    reject$1,
    remove$2,
    partition$1,
    find$1,
    head,
    first,
    tail,
    last$1,
    initial,
    empty$1,
    reverse$1,
    unique,
    uniqueBy,
    fold,
    foldl,
    fold1,
    foldl1,
    foldr,
    foldr1,
    unfoldr,
    concat,
    concatMap,
    flatten,
    difference,
    intersection,
    union$1,
    countBy,
    groupBy,
    andList,
    orList,
    any,
    all,
    sort,
    sortWith,
    sortBy,
    sum,
    product,
    mean,
    average,
    maximum,
    minimum,
    maximumBy,
    minimumBy,
    scan,
    scanl,
    scan1,
    scanl1,
    scanr,
    scanr1,
    slice,
    take,
    drop,
    splitAt,
    takeWhile,
    dropWhile,
    span,
    breakList,
    zip,
    zipWith,
    zipAll,
    zipAllWith,
    at,
    elemIndex,
    elemIndices,
    findIndex,
    findIndices,
    toString$$1 = {}.toString;
each$1 = curry$$4(function (f, xs) {
  var i$, len$, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }

  return xs;
});
map$1 = curry$$4(function (f, xs) {
  var i$,
      len$,
      x,
      results$ = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }

  return results$;
});

compact$1 = function (xs) {
  var i$,
      len$,
      x,
      results$ = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (x) {
      results$.push(x);
    }
  }

  return results$;
};

filter$1 = curry$$4(function (f, xs) {
  var i$,
      len$,
      x,
      results$ = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (f(x)) {
      results$.push(x);
    }
  }

  return results$;
});
reject$1 = curry$$4(function (f, xs) {
  var i$,
      len$,
      x,
      results$ = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (!f(x)) {
      results$.push(x);
    }
  }

  return results$;
});
remove$2 = curry$$4(function (el, xs) {
  var i, x$;
  i = elemIndex(el, xs);
  x$ = xs.slice();

  if (i != null) {
    x$.splice(i, 1);
  }

  return x$;
});
partition$1 = curry$$4(function (f, xs) {
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }

  return [passed, failed];
});
find$1 = curry$$4(function (f, xs) {
  var i$, len$, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (f(x)) {
      return x;
    }
  }
});

head = first = function (xs) {
  return xs[0];
};

tail = function (xs) {
  if (!xs.length) {
    return;
  }

  return xs.slice(1);
};

last$1 = function (xs) {
  return xs[xs.length - 1];
};

initial = function (xs) {
  if (!xs.length) {
    return;
  }

  return xs.slice(0, -1);
};

empty$1 = function (xs) {
  return !xs.length;
};

reverse$1 = function (xs) {
  return xs.concat().reverse();
};

unique = function (xs) {
  var result, i$, len$, x;
  result = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (!in$(x, result)) {
      result.push(x);
    }
  }

  return result;
};

uniqueBy = curry$$4(function (f, xs) {
  var seen,
      i$,
      len$,
      x,
      val,
      results$ = [];
  seen = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);

    if (in$(val, seen)) {
      continue;
    }

    seen.push(val);
    results$.push(x);
  }

  return results$;
});
fold = foldl = curry$$4(function (f, memo, xs) {
  var i$, len$, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }

  return memo;
});
fold1 = foldl1 = curry$$4(function (f, xs) {
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$$4(function (f, memo, xs) {
  var i$, x;

  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }

  return memo;
});
foldr1 = curry$$4(function (f, xs) {
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$$4(function (f, b) {
  var result, x, that;
  result = [];
  x = b;

  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }

  return result;
});

concat = function (xss) {
  return [].concat.apply([], xss);
};

concatMap = curry$$4(function (f, xs) {
  var x;
  return [].concat.apply([], function () {
    var i$,
        ref$,
        len$,
        results$ = [];

    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }

    return results$;
  }());
});

flatten = function (xs) {
  var x;
  return [].concat.apply([], function () {
    var i$,
        ref$,
        len$,
        results$ = [];

    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];

      if (toString$$1.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }

    return results$;
  }());
};

difference = function (xs) {
  var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;
  res$ = [];

  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }

  yss = res$;
  results = [];

  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];

      if (in$(x, ys)) {
        continue outer;
      }
    }

    results.push(x);
  }

  return results;
};

intersection = function (xs) {
  var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;
  res$ = [];

  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }

  yss = res$;
  results = [];

  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];

      if (!in$(x, ys)) {
        continue outer;
      }
    }

    results.push(x);
  }

  return results;
};

union$1 = function () {
  var xss, res$, i$, to$, results, len$, xs, j$, len1$, x;
  res$ = [];

  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }

  xss = res$;
  results = [];

  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];

    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];

      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }

  return results;
};

countBy = curry$$4(function (f, xs) {
  var results, i$, len$, x, key;
  results = {};

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);

    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }

  return results;
});
groupBy = curry$$4(function (f, xs) {
  var results, i$, len$, x, key;
  results = {};

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);

    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }

  return results;
});

andList = function (xs) {
  var i$, len$, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (!x) {
      return false;
    }
  }

  return true;
};

orList = function (xs) {
  var i$, len$, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (x) {
      return true;
    }
  }

  return false;
};

any = curry$$4(function (f, xs) {
  var i$, len$, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (f(x)) {
      return true;
    }
  }

  return false;
});
all = curry$$4(function (f, xs) {
  var i$, len$, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];

    if (!f(x)) {
      return false;
    }
  }

  return true;
});

sort = function (xs) {
  return xs.concat().sort(function (x, y) {
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};

sortWith = curry$$4(function (f, xs) {
  return xs.concat().sort(f);
});
sortBy = curry$$4(function (f, xs) {
  return xs.concat().sort(function (x, y) {
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});

sum = function (xs) {
  var result, i$, len$, x;
  result = 0;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }

  return result;
};

product = function (xs) {
  var result, i$, len$, x;
  result = 1;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }

  return result;
};

mean = average = function (xs) {
  var sum, i$, len$, x;
  sum = 0;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }

  return sum / xs.length;
};

maximum = function (xs) {
  var max, i$, ref$, len$, x;
  max = xs[0];

  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];

    if (x > max) {
      max = x;
    }
  }

  return max;
};

minimum = function (xs) {
  var min, i$, ref$, len$, x;
  min = xs[0];

  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];

    if (x < min) {
      min = x;
    }
  }

  return min;
};

maximumBy = curry$$4(function (f, xs) {
  var max, i$, ref$, len$, x;
  max = xs[0];

  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];

    if (f(x) > f(max)) {
      max = x;
    }
  }

  return max;
});
minimumBy = curry$$4(function (f, xs) {
  var min, i$, ref$, len$, x;
  min = xs[0];

  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];

    if (f(x) < f(min)) {
      min = x;
    }
  }

  return min;
});
scan = scanl = curry$$4(function (f, memo, xs) {
  var last, x;
  last = memo;
  return [memo].concat(function () {
    var i$,
        ref$,
        len$,
        results$ = [];

    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }

    return results$;
  }());
});
scan1 = scanl1 = curry$$4(function (f, xs) {
  if (!xs.length) {
    return;
  }

  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$$4(function (f, memo, xs) {
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$$4(function (f, xs) {
  if (!xs.length) {
    return;
  }

  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$$4(function (x, y, xs) {
  return xs.slice(x, y);
});
take = curry$$4(function (n, xs) {
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$$4(function (n, xs) {
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$$4(function (n, xs) {
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$$4(function (p, xs) {
  var len, i;
  len = xs.length;

  if (!len) {
    return xs;
  }

  i = 0;

  while (i < len && p(xs[i])) {
    i += 1;
  }

  return xs.slice(0, i);
});
dropWhile = curry$$4(function (p, xs) {
  var len, i;
  len = xs.length;

  if (!len) {
    return xs;
  }

  i = 0;

  while (i < len && p(xs[i])) {
    i += 1;
  }

  return xs.slice(i);
});
span = curry$$4(function (p, xs) {
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$$4(function (p, xs) {
  return span(compose$(p, not$), xs);
});
zip = curry$$4(function (xs, ys) {
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];

    if (i === len) {
      break;
    }

    result.push([x, ys[i]]);
  }

  return result;
});
zipWith = curry$$4(function (f, xs, ys) {
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];

    if (i === len) {
      break;
    }

    result.push(f(x, ys[i]));
  }

  return result;
});

zipAll = function () {
  var xss,
      res$,
      i$,
      to$,
      minLength,
      len$,
      xs,
      ref$,
      i,
      lresult$,
      j$,
      results$ = [];
  res$ = [];

  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }

  xss = res$;
  minLength = undefined;

  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }

  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];

    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }

    results$.push(lresult$);
  }

  return results$;
};

zipAllWith = function (f) {
  var xss,
      res$,
      i$,
      to$,
      minLength,
      len$,
      xs,
      ref$,
      i,
      results$ = [];
  res$ = [];

  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }

  xss = res$;
  minLength = undefined;

  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }

  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, fn$()));
  }

  return results$;

  function fn$() {
    var i$,
        ref$,
        len$,
        results$ = [];

    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }

    return results$;
  }
};

at = curry$$4(function (n, xs) {
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$$4(function (el, xs) {
  var i$, len$, i, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];

    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$$4(function (el, xs) {
  var i$,
      len$,
      i,
      x,
      results$ = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];

    if (x === el) {
      results$.push(i);
    }
  }

  return results$;
});
findIndex = curry$$4(function (f, xs) {
  var i$, len$, i, x;

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];

    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$$4(function (f, xs) {
  var i$,
      len$,
      i,
      x,
      results$ = [];

  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];

    if (f(x)) {
      results$.push(i);
    }
  }

  return results$;
});
var List$1 = {
  each: each$1,
  map: map$1,
  filter: filter$1,
  compact: compact$1,
  reject: reject$1,
  remove: remove$2,
  partition: partition$1,
  find: find$1,
  head: head,
  first: first,
  tail: tail,
  last: last$1,
  initial: initial,
  empty: empty$1,
  reverse: reverse$1,
  difference: difference,
  intersection: intersection,
  union: union$1,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};

function curry$$4(f, bound) {
  var context,
      _curry = function (args) {
    return f.length > 1 ? function () {
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
    } : f;
  };

  return _curry();
}

function in$(x, xs) {
  var i = -1,
      l = xs.length >>> 0;

  while (++i < l) if (x === xs[i]) return true;

  return false;
}

function compose$() {
  var functions = arguments;
  return function () {
    var i, result;
    result = functions[0].apply(this, arguments);

    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }

    return result;
  };
}

function not$(x) {
  return !x;
}

// Generated by LiveScript 1.6.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;

values = function (object) {
  var i$,
      x,
      results$ = [];

  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }

  return results$;
};

keys = function (object) {
  var x,
      results$ = [];

  for (x in object) {
    results$.push(x);
  }

  return results$;
};

pairsToObj = function (object) {
  var i$,
      len$,
      x,
      resultObj$ = {};

  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    resultObj$[x[0]] = x[1];
  }

  return resultObj$;
};

objToPairs = function (object) {
  var key,
      value,
      results$ = [];

  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }

  return results$;
};

listsToObj = curry$$3(function (keys, values) {
  var i$,
      len$,
      i,
      key,
      resultObj$ = {};

  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    resultObj$[key] = values[i];
  }

  return resultObj$;
});

objToLists = function (object) {
  var keys, values, key, value;
  keys = [];
  values = [];

  for (key in object) {
    value = object[key];
    keys.push(key);
    values.push(value);
  }

  return [keys, values];
};

empty = function (object) {
  var x;

  for (x in object) {
    return false;
  }

  return true;
};

each = curry$$3(function (f, object) {
  var i$, x;

  for (i$ in object) {
    x = object[i$];
    f(x);
  }

  return object;
});
map = curry$$3(function (f, object) {
  var k,
      x,
      resultObj$ = {};

  for (k in object) {
    x = object[k];
    resultObj$[k] = f(x);
  }

  return resultObj$;
});

compact = function (object) {
  var k,
      x,
      resultObj$ = {};

  for (k in object) {
    x = object[k];

    if (x) {
      resultObj$[k] = x;
    }
  }

  return resultObj$;
};

filter = curry$$3(function (f, object) {
  var k,
      x,
      resultObj$ = {};

  for (k in object) {
    x = object[k];

    if (f(x)) {
      resultObj$[k] = x;
    }
  }

  return resultObj$;
});
reject = curry$$3(function (f, object) {
  var k,
      x,
      resultObj$ = {};

  for (k in object) {
    x = object[k];

    if (!f(x)) {
      resultObj$[k] = x;
    }
  }

  return resultObj$;
});
partition = curry$$3(function (f, object) {
  var passed, failed, k, x;
  passed = {};
  failed = {};

  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }

  return [passed, failed];
});
find = curry$$3(function (f, object) {
  var i$, x;

  for (i$ in object) {
    x = object[i$];

    if (f(x)) {
      return x;
    }
  }
});
var Obj$1 = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};

function curry$$3(f, bound) {
  var context,
      _curry = function (args) {
    return f.length > 1 ? function () {
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
    } : f;
  };

  return _curry();
}

// Generated by LiveScript 1.6.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$$2(function (sep, str) {
  return str.split(sep);
});
join = curry$$2(function (sep, xs) {
  return xs.join(sep);
});

lines = function (str) {
  if (!str.length) {
    return [];
  }

  return str.split('\n');
};

unlines = function (it) {
  return it.join('\n');
};

words = function (str) {
  if (!str.length) {
    return [];
  }

  return str.split(/[ ]+/);
};

unwords = function (it) {
  return it.join(' ');
};

chars = function (it) {
  return it.split('');
};

unchars = function (it) {
  return it.join('');
};

reverse = function (str) {
  return str.split('').reverse().join('');
};

repeat = curry$$2(function (n, str) {
  var result, i$;
  result = '';

  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }

  return result;
});

capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

camelize = function (it) {
  return it.replace(/[-_]+(.)?/g, function (arg$, c) {
    return (c != null ? c : '').toUpperCase();
  });
};

dasherize = function (str) {
  return str.replace(/([^-A-Z])([A-Z]+)/g, function (arg$, lower, upper) {
    return lower + "-" + (upper.length > 1 ? upper : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function (arg$, upper) {
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};

var Str$1 = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};

function curry$$2(f, bound) {
  var context,
      _curry = function (args) {
    return f.length > 1 ? function () {
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
    } : f;
  };

  return _curry();
}

// Generated by LiveScript 1.6.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$$1(function (x$, y$) {
  return x$ > y$ ? x$ : y$;
});
min = curry$$1(function (x$, y$) {
  return x$ < y$ ? x$ : y$;
});

negate = function (x) {
  return -x;
};

abs = Math.abs;

signum = function (x) {
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};

quot = curry$$1(function (x, y) {
  return ~~(x / y);
});
rem = curry$$1(function (x$, y$) {
  return x$ % y$;
});
div = curry$$1(function (x, y) {
  return Math.floor(x / y);
});
mod = curry$$1(function (x$, y$) {
  var ref$;
  return (x$ % (ref$ = y$) + ref$) % ref$;
});

recip = function (it) {
  return 1 / it;
};

pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$$1(function (x$, y$) {
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$$1(function (x, y) {
  return Math.atan2(x, y);
});

truncate = function (x) {
  return ~~x;
};

round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;

isItNaN = function (x) {
  return x !== x;
};

even = function (x) {
  return x % 2 === 0;
};

odd = function (x) {
  return x % 2 !== 0;
};

gcd = curry$$1(function (x, y) {
  var z;
  x = Math.abs(x);
  y = Math.abs(y);

  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }

  return x;
});
lcm = curry$$1(function (x, y) {
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
var Num$1 = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};

function curry$$1(f, bound) {
  var context,
      _curry = function (args) {
    return f.length > 1 ? function () {
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
    } : f;
  };

  return _curry();
}

// Generated by LiveScript 1.6.0
var Func,
    List,
    Obj,
    Str,
    Num,
    id,
    isType,
    replicate,
    prelude,
    toString$ = {}.toString;
Func = Func$1;
List = List$1;
Obj = Obj$1;
Str = Str$1;
Num = Num$1;

id = function (x) {
  return x;
};

isType = curry$(function (type, x) {
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function (n, x) {
  var i$,
      results$ = [];

  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }

  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.2.1';
var lib$2 = prelude;

function curry$(f, bound) {
  var context,
      _curry = function (args) {
    return f.length > 1 ? function () {
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
    } : f;
  };

  return _curry();
}

var parseString = createCommonjsModule$1(function (module) {
// Generated by LiveScript 1.6.0
(function () {
  var reject, special, tokenRegex;
  reject = lib$2.reject;

  function consumeOp(tokens, op) {
    if (tokens[0] === op) {
      return tokens.shift();
    } else {
      throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
    }
  }

  function maybeConsumeOp(tokens, op) {
    if (tokens[0] === op) {
      return tokens.shift();
    }
  }

  function consumeList(tokens, arg$, hasDelimiters) {
    var open, close, result, untilTest;
    open = arg$[0], close = arg$[1];

    if (hasDelimiters) {
      consumeOp(tokens, open);
    }

    result = [];
    untilTest = "," + (hasDelimiters ? close : '');

    while (tokens.length && hasDelimiters && tokens[0] !== close) {
      result.push(consumeElement(tokens, untilTest));
      maybeConsumeOp(tokens, ',');
    }

    if (hasDelimiters) {
      consumeOp(tokens, close);
    }

    return result;
  }

  function consumeArray(tokens, hasDelimiters) {
    return consumeList(tokens, ['[', ']'], hasDelimiters);
  }

  function consumeTuple(tokens, hasDelimiters) {
    return consumeList(tokens, ['(', ')'], hasDelimiters);
  }

  function consumeFields(tokens, hasDelimiters) {
    var result, untilTest, key;

    if (hasDelimiters) {
      consumeOp(tokens, '{');
    }

    result = {};
    untilTest = "," + (hasDelimiters ? '}' : '');

    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {
      key = consumeValue(tokens, ':');
      consumeOp(tokens, ':');
      result[key] = consumeElement(tokens, untilTest);
      maybeConsumeOp(tokens, ',');
    }

    if (hasDelimiters) {
      consumeOp(tokens, '}');
    }

    return result;
  }

  function consumeValue(tokens, untilTest) {
    var out;
    untilTest == null && (untilTest = '');
    out = '';

    while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {
      out += tokens.shift();
    }

    return out;
  }

  function consumeElement(tokens, untilTest) {
    switch (tokens[0]) {
      case '[':
        return consumeArray(tokens, true);

      case '(':
        return consumeTuple(tokens, true);

      case '{':
        return consumeFields(tokens, true);

      default:
        return consumeValue(tokens, untilTest);
    }
  }

  function consumeTopLevel(tokens, types, options) {
    var ref$, type, structure, origTokens, result, finalResult, x$, y$;
    ref$ = types[0], type = ref$.type, structure = ref$.structure;
    origTokens = tokens.concat();

    if (!options.explicit && types.length === 1 && (!type && structure || type === 'Array' || type === 'Object')) {
      result = structure === 'array' || type === 'Array' ? consumeArray(tokens, tokens[0] === '[') : structure === 'tuple' ? consumeTuple(tokens, tokens[0] === '(') : consumeFields(tokens, tokens[0] === '{');
      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array' ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$) : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;
    } else {
      finalResult = consumeElement(tokens);
    }

    return finalResult;
  }

  special = /\[\]\(\)}{:,/.source;
  tokenRegex = RegExp('("(?:\\\\"|[^"])*")|(\'(?:\\\\\'|[^\'])*\')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\s' + special + '](?:\\s*[^\\s' + special + ']+)*)|\\s*');

  module.exports = function (types, string, options) {
    var tokens, node;
    options == null && (options = {});

    if (!options.explicit && types.length === 1 && types[0].type === 'String') {
      return string;
    }

    tokens = reject(not$, string.split(tokenRegex));
    node = consumeTopLevel(tokens, types, options);

    if (!node) {
      throw new Error("Error parsing '" + string + "'.");
    }

    return node;
  };

  function not$(x) {
    return !x;
  }
}).call(commonjsGlobal);
});

var parseType = createCommonjsModule$1(function (module) {
// Generated by LiveScript 1.6.0
(function () {
  var identifierRegex, tokenRegex;
  identifierRegex = /[\$\w]+/;

  function peek(tokens) {
    var token;
    token = tokens[0];

    if (token == null) {
      throw new Error('Unexpected end of input.');
    }

    return token;
  }

  function consumeIdent(tokens) {
    var token;
    token = peek(tokens);

    if (!identifierRegex.test(token)) {
      throw new Error("Expected text, got '" + token + "' instead.");
    }

    return tokens.shift();
  }

  function consumeOp(tokens, op) {
    var token;
    token = peek(tokens);

    if (token !== op) {
      throw new Error("Expected '" + op + "', got '" + token + "' instead.");
    }

    return tokens.shift();
  }

  function maybeConsumeOp(tokens, op) {
    var token;
    token = tokens[0];

    if (token === op) {
      return tokens.shift();
    } else {
      return null;
    }
  }

  function consumeArray(tokens) {
    var types;
    consumeOp(tokens, '[');

    if (peek(tokens) === ']') {
      throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
    }

    types = consumeTypes(tokens);
    consumeOp(tokens, ']');
    return {
      structure: 'array',
      of: types
    };
  }

  function consumeTuple(tokens) {
    var components;
    components = [];
    consumeOp(tokens, '(');

    if (peek(tokens) === ')') {
      throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
    }

    for (;;) {
      components.push(consumeTypes(tokens));
      maybeConsumeOp(tokens, ',');

      if (')' === peek(tokens)) {
        break;
      }
    }

    consumeOp(tokens, ')');
    return {
      structure: 'tuple',
      of: components
    };
  }

  function consumeFields(tokens) {
    var fields, subset, ref$, key, types;
    fields = {};
    consumeOp(tokens, '{');
    subset = false;

    for (;;) {
      if (maybeConsumeOp(tokens, '...')) {
        subset = true;
        break;
      }

      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
      fields[key] = types;
      maybeConsumeOp(tokens, ',');

      if ('}' === peek(tokens)) {
        break;
      }
    }

    consumeOp(tokens, '}');
    return {
      structure: 'fields',
      of: fields,
      subset: subset
    };
  }

  function consumeField(tokens) {
    var key, types;
    key = consumeIdent(tokens);
    consumeOp(tokens, ':');
    types = consumeTypes(tokens);
    return [key, types];
  }

  function maybeConsumeStructure(tokens) {
    switch (tokens[0]) {
      case '[':
        return consumeArray(tokens);

      case '(':
        return consumeTuple(tokens);

      case '{':
        return consumeFields(tokens);
    }
  }

  function consumeType(tokens) {
    var token, wildcard, type, structure;
    token = peek(tokens);
    wildcard = token === '*';

    if (wildcard || identifierRegex.test(token)) {
      type = wildcard ? consumeOp(tokens, '*') : consumeIdent(tokens);
      structure = maybeConsumeStructure(tokens);

      if (structure) {
        return structure.type = type, structure;
      } else {
        return {
          type: type
        };
      }
    } else {
      structure = maybeConsumeStructure(tokens);

      if (!structure) {
        throw new Error("Unexpected character: " + token);
      }

      return structure;
    }
  }

  function consumeTypes(tokens) {
    var lookahead, types, typesSoFar, typeObj, type, structure;

    if ('::' === peek(tokens)) {
      throw new Error("No comment before comment separator '::' found.");
    }

    lookahead = tokens[1];

    if (lookahead != null && lookahead === '::') {
      tokens.shift();
      tokens.shift();
    }

    types = [];
    typesSoFar = {};

    if ('Maybe' === peek(tokens)) {
      tokens.shift();
      types = [{
        type: 'Undefined'
      }, {
        type: 'Null'
      }];
      typesSoFar = {
        Undefined: true,
        Null: true
      };
    }

    for (;;) {
      typeObj = consumeType(tokens), type = typeObj.type, structure = typeObj.structure;

      if (!typesSoFar[type]) {
        types.push(typeObj);
      }

      if (structure == null) {
        typesSoFar[type] = true;
      }

      if (!maybeConsumeOp(tokens, '|')) {
        break;
      }
    }

    return types;
  }

  tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');

  module.exports = function (input) {
    var tokens, e;

    if (!input.length) {
      throw new Error('No type specified.');
    }

    tokens = input.match(tokenRegex) || [];

    if (in$('->', tokens)) {
      throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
    }

    try {
      return consumeTypes(tokens);
    } catch (e$) {
      e = e$;
      throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
    }
  };

  function in$(x, xs) {
    var i = -1,
        l = xs.length >>> 0;

    while (++i < l) if (x === xs[i]) return true;

    return false;
  }
}).call(commonjsGlobal);
});

var check = createCommonjsModule$1(function (module) {
// Generated by LiveScript 1.6.0
(function () {
  var ref$,
      any,
      all,
      isItNaN,
      types,
      defaultType,
      toString$ = {}.toString;
  ref$ = lib$2, any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
  types = {
    Number: {
      typeOf: 'Number',
      validate: function (it) {
        return !isItNaN(it);
      }
    },
    NaN: {
      typeOf: 'Number',
      validate: isItNaN
    },
    Int: {
      typeOf: 'Number',
      validate: function (it) {
        return !isItNaN(it) && it % 1 === 0;
      }
    },
    Float: {
      typeOf: 'Number',
      validate: function (it) {
        return !isItNaN(it);
      }
    },
    Date: {
      typeOf: 'Date',
      validate: function (it) {
        return !isItNaN(it.getTime());
      }
    }
  };
  defaultType = {
    array: 'Array',
    tuple: 'Array'
  };

  function checkArray(input, type, options) {
    return all(function (it) {
      return checkMultiple(it, type.of, options);
    }, input);
  }

  function checkTuple(input, type, options) {
    var i, i$, ref$, len$, types;
    i = 0;

    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];

      if (!checkMultiple(input[i], types, options)) {
        return false;
      }

      i++;
    }

    return input.length <= i;
  }

  function checkFields(input, type, options) {
    var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;
    inputKeys = {};
    numInputKeys = 0;

    for (k in input) {
      inputKeys[k] = true;
      numInputKeys++;
    }

    numOfKeys = 0;

    for (key in ref$ = type.of) {
      types = ref$[key];

      if (!checkMultiple(input[key], types, options)) {
        return false;
      }

      if (inputKeys[key]) {
        numOfKeys++;
      }
    }

    return type.subset || numInputKeys === numOfKeys;
  }

  function checkStructure(input, type, options) {
    if (!(input instanceof Object)) {
      return false;
    }

    switch (type.structure) {
      case 'fields':
        return checkFields(input, type, options);

      case 'array':
        return checkArray(input, type, options);

      case 'tuple':
        return checkTuple(input, type, options);
    }
  }

  function check(input, typeObj, options) {
    var type, structure, setting, that;
    type = typeObj.type, structure = typeObj.structure;

    if (type) {
      if (type === '*') {
        return true;
      }

      setting = options.customTypes[type] || types[type];

      if (setting) {
        return (setting.typeOf === void 8 || setting.typeOf === toString$.call(input).slice(8, -1)) && setting.validate(input);
      } else {
        return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj, options));
      }
    } else if (structure) {
      if (that = defaultType[structure]) {
        if (that !== toString$.call(input).slice(8, -1)) {
          return false;
        }
      }

      return checkStructure(input, typeObj, options);
    } else {
      throw new Error("No type defined. Input: " + input + ".");
    }
  }

  function checkMultiple(input, types, options) {
    if (toString$.call(types).slice(8, -1) !== 'Array') {
      throw new Error("Types must be in an array. Input: " + input + ".");
    }

    return any(function (it) {
      return check(input, it, options);
    }, types);
  }

  module.exports = function (parsedType, input, options) {
    options == null && (options = {});

    if (options.customTypes == null) {
      options.customTypes = {};
    }

    return checkMultiple(input, parsedType, options);
  };
}).call(commonjsGlobal);
});

var lib$1 = createCommonjsModule$1(function (module) {
// Generated by LiveScript 1.6.0
(function () {
  var VERSION, parseType$1, parsedTypeCheck, typeCheck;
  VERSION = '0.4.0';
  parseType$1 = parseType;
  parsedTypeCheck = check;

  typeCheck = function (type, input, options) {
    return parsedTypeCheck(parseType$1(type), input, options);
  };

  module.exports = {
    VERSION: VERSION,
    typeCheck: typeCheck,
    parsedTypeCheck: parsedTypeCheck,
    parseType: parseType$1
  };
}).call(commonjsGlobal);
});

var cast = createCommonjsModule$1(function (module) {
// Generated by LiveScript 1.6.0
(function () {
  var parsedTypeCheck,
      types,
      toString$ = {}.toString;
  parsedTypeCheck = lib$1.parsedTypeCheck;
  types = {
    '*': function (value, options) {
      switch (toString$.call(value).slice(8, -1)) {
        case 'Array':
          return typeCast(value, {
            type: 'Array'
          }, options);

        case 'Object':
          return typeCast(value, {
            type: 'Object'
          }, options);

        default:
          return {
            type: 'Just',
            value: typesCast(value, [{
              type: 'Undefined'
            }, {
              type: 'Null'
            }, {
              type: 'NaN'
            }, {
              type: 'Boolean'
            }, {
              type: 'Number'
            }, {
              type: 'Date'
            }, {
              type: 'RegExp'
            }, {
              type: 'Array'
            }, {
              type: 'Object'
            }, {
              type: 'String'
            }], (options.explicit = true, options))
          };
      }
    },
    Undefined: function (it) {
      if (it === 'undefined' || it === void 8) {
        return {
          type: 'Just',
          value: void 8
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Null: function (it) {
      if (it === 'null') {
        return {
          type: 'Just',
          value: null
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    NaN: function (it) {
      if (it === 'NaN') {
        return {
          type: 'Just',
          value: NaN
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Boolean: function (it) {
      if (it === 'true') {
        return {
          type: 'Just',
          value: true
        };
      } else if (it === 'false') {
        return {
          type: 'Just',
          value: false
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Number: function (it) {
      return {
        type: 'Just',
        value: +it
      };
    },
    Int: function (it) {
      return {
        type: 'Just',
        value: +it
      };
    },
    Float: function (it) {
      return {
        type: 'Just',
        value: +it
      };
    },
    Date: function (value, options) {
      var that;

      if (that = /^\#([\s\S]*)\#$/.exec(value)) {
        return {
          type: 'Just',
          value: new Date(+that[1] || that[1])
        };
      } else if (options.explicit) {
        return {
          type: 'Nothing'
        };
      } else {
        return {
          type: 'Just',
          value: new Date(+value || value)
        };
      }
    },
    RegExp: function (value, options) {
      var that;

      if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
        return {
          type: 'Just',
          value: new RegExp(that[1], that[2])
        };
      } else if (options.explicit) {
        return {
          type: 'Nothing'
        };
      } else {
        return {
          type: 'Just',
          value: new RegExp(value)
        };
      }
    },
    Array: function (value, options) {
      return castArray(value, {
        of: [{
          type: '*'
        }]
      }, options);
    },
    Object: function (value, options) {
      return castFields(value, {
        of: {}
      }, options);
    },
    String: function (it) {
      var replace, that;

      if (toString$.call(it).slice(8, -1) !== 'String') {
        return {
          type: 'Nothing'
        };
      }

      replace = function (value, quote) {
        return value.replace(/\\([^u]|u[0-9a-fA-F]{4})/g, function (all, escaped) {
          switch (escaped[0]) {
            case quote:
              return quote;

            case '\\':
              return '\\';

            case 'b':
              return '\b';

            case 'f':
              return '\f';

            case 'n':
              return '\n';

            case 'r':
              return '\r';

            case 't':
              return '\t';

            case 'u':
              return JSON.parse("\"" + all + "\"");

            default:
              return escaped;
          }
        });
      };

      if (that = it.match(/^'([\s\S]*)'$/)) {
        return {
          type: 'Just',
          value: replace(that[1], "'")
        };
      } else if (that = it.match(/^"([\s\S]*)"$/)) {
        return {
          type: 'Just',
          value: replace(that[1], '"')
        };
      } else {
        return {
          type: 'Just',
          value: it
        };
      }
    }
  };

  function castArray(node, type, options) {
    var typeOf, element;

    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      };
    }

    typeOf = type.of;
    return {
      type: 'Just',
      value: function () {
        var i$,
            ref$,
            len$,
            results$ = [];

        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
          element = ref$[i$];
          results$.push(typesCast(element, typeOf, options));
        }

        return results$;
      }()
    };
  }

  function castTuple(node, type, options) {
    var result, i, i$, ref$, len$, types, cast;

    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      };
    }

    result = [];
    i = 0;

    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];
      cast = typesCast(node[i], types, options);

      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {
        result.push(cast);
      }

      i++;
    }

    if (node.length <= i) {
      return {
        type: 'Just',
        value: result
      };
    } else {
      return {
        type: 'Nothing'
      };
    }
  }

  function castFields(node, type, options) {
    var typeOf, key, value;

    if (toString$.call(node).slice(8, -1) !== 'Object') {
      return {
        type: 'Nothing'
      };
    }

    typeOf = type.of;
    return {
      type: 'Just',
      value: function () {
        var ref$,
            resultObj$ = {};

        for (key in ref$ = node) {
          value = ref$[key];
          resultObj$[typesCast(key, [{
            type: 'String'
          }], options)] = typesCast(value, typeOf[key] || [{
            type: '*'
          }], options);
        }

        return resultObj$;
      }()
    };
  }

  function typeCast(node, typeObj, options) {
    var type, structure, castFunc, ref$;
    type = typeObj.type, structure = typeObj.structure;

    if (type) {
      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];

      if (!castFunc) {
        throw new Error("Type not defined: " + type + ".");
      }

      return castFunc(node, options, typesCast);
    } else {
      switch (structure) {
        case 'array':
          return castArray(node, typeObj, options);

        case 'tuple':
          return castTuple(node, typeObj, options);

        case 'fields':
          return castFields(node, typeObj, options);
      }
    }
  }

  function typesCast(node, types, options) {
    var i$, len$, type, ref$, valueType, value;

    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {
      type = types[i$];
      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;

      if (valueType === 'Nothing') {
        continue;
      }

      if (parsedTypeCheck([type], value, {
        customTypes: options.customTypes
      })) {
        return value;
      }
    }

    throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types) + ".");
  }

  module.exports = function (node, types, options) {
    if (!options.explicit && types.length === 1 && types[0].type === 'String') {
      return node;
    }

    return typesCast(node, types, options);
  };
}).call(commonjsGlobal);
});

var lib = createCommonjsModule$1(function (module) {
// Generated by LiveScript 1.6.0
(function () {
  var parseString$1, cast$1, parseType, VERSION, parsedTypeParse, parse;
  parseString$1 = parseString;
  cast$1 = cast;
  parseType = lib$1.parseType;
  VERSION = '0.4.1';

  parsedTypeParse = function (parsedType, string, options) {
    options == null && (options = {});
    options.explicit == null && (options.explicit = false);
    options.customTypes == null && (options.customTypes = {});
    return cast$1(parseString$1(parsedType, string, options), parsedType, options);
  };

  parse = function (type, string, options) {
    return parsedTypeParse(parseType(type), string, options);
  };

  module.exports = {
    VERSION: VERSION,
    parse: parse,
    parsedTypeParse: parsedTypeParse
  };
}).call(commonjsGlobal);
});

function e(t) {
  return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
    return typeof e;
  } : function (e) {
    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  })(t);
}

function t(e, t) {
  return function (e) {
    if (Array.isArray(e)) return e;
  }(e) || function (e, t) {
    if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e))) return;
    var r = [],
        n = !0,
        a = !1,
        o = void 0;

    try {
      for (var i, s = e[Symbol.iterator](); !(n = (i = s.next()).done) && (r.push(i.value), !t || r.length !== t); n = !0);
    } catch (e) {
      a = !0, o = e;
    } finally {
      try {
        n || null == s.return || s.return();
      } finally {
        if (a) throw o;
      }
    }

    return r;
  }(e, t) || n(e, t) || function () {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}

function r(e) {
  return function (e) {
    if (Array.isArray(e)) return a(e);
  }(e) || function (e) {
    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);
  }(e) || n(e) || function () {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}

function n(e, t) {
  if (e) {
    if ("string" == typeof e) return a(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? a(e, t) : void 0;
  }
}

function a(e, t) {
  (null == t || t > e.length) && (t = e.length);

  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];

  return n;
}

function o(e, t) {
  var r;

  if ("undefined" == typeof Symbol || null == e[Symbol.iterator]) {
    if (Array.isArray(e) || (r = n(e)) || t && e && "number" == typeof e.length) {
      r && (e = r);

      var a = 0,
          o = function () {};

      return {
        s: o,
        n: function () {
          return a >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[a++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: o
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var i,
      s = !0,
      l = !1;
  return {
    s: function () {
      r = e[Symbol.iterator]();
    },
    n: function () {
      var e = r.next();
      return s = e.done, e;
    },
    e: function (e) {
      l = !0, i = e;
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (l) throw i;
      }
    }
  };
}

function i(e, t) {
  return e(t = {
    exports: {}
  }, t.exports), t.exports;
}

var s = i(function (e, t) {
  !function e(t) {
    var r, n, a, o, i, s;

    function l(e) {
      var t,
          r,
          n = {};

      for (t in e) e.hasOwnProperty(t) && (r = e[t], n[t] = "object" == typeof r && null !== r ? l(r) : r);

      return n;
    }

    function u(e, t) {
      this.parent = e, this.key = t;
    }

    function c(e, t, r, n) {
      this.node = e, this.path = t, this.wrap = r, this.ref = n;
    }

    function f() {}

    function p(e) {
      return null != e && "object" == typeof e && "string" == typeof e.type;
    }

    function h(e, t) {
      return (e === r.ObjectExpression || e === r.ObjectPattern) && "properties" === t;
    }

    function y(e, t) {
      for (var r = e.length - 1; r >= 0; --r) if (e[r].node === t) return !0;

      return !1;
    }

    function d(e, t) {
      return new f().traverse(e, t);
    }

    function m(e, t) {
      var r;
      return r = function (e, t) {
        var r, n, a, o;

        for (n = e.length, a = 0; n;) t(e[o = a + (r = n >>> 1)]) ? n = r : (a = o + 1, n -= r + 1);

        return a;
      }(t, function (t) {
        return t.range[0] > e.range[0];
      }), e.extendedRange = [e.range[0], e.range[1]], r !== t.length && (e.extendedRange[1] = t[r].range[0]), (r -= 1) >= 0 && (e.extendedRange[0] = t[r].range[1]), e;
    }

    return r = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      Program: "Program",
      Property: "Property",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    }, a = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      ComprehensionExpression: ["blocks", "filter", "body"],
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      Program: ["body"],
      Property: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    }, n = {
      Break: o = {},
      Skip: i = {},
      Remove: s = {}
    }, u.prototype.replace = function (e) {
      this.parent[this.key] = e;
    }, u.prototype.remove = function () {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
    }, f.prototype.path = function () {
      var e, t, r, n, a;

      function o(e, t) {
        if (Array.isArray(t)) for (r = 0, n = t.length; r < n; ++r) e.push(t[r]);else e.push(t);
      }

      if (!this.__current.path) return null;

      for (a = [], e = 2, t = this.__leavelist.length; e < t; ++e) o(a, this.__leavelist[e].path);

      return o(a, this.__current.path), a;
    }, f.prototype.type = function () {
      return this.current().type || this.__current.wrap;
    }, f.prototype.parents = function () {
      var e, t, r;

      for (r = [], e = 1, t = this.__leavelist.length; e < t; ++e) r.push(this.__leavelist[e].node);

      return r;
    }, f.prototype.current = function () {
      return this.__current.node;
    }, f.prototype.__execute = function (e, t) {
      var r, n;
      return n = void 0, r = this.__current, this.__current = t, this.__state = null, e && (n = e.call(this, t.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = r, n;
    }, f.prototype.notify = function (e) {
      this.__state = e;
    }, f.prototype.skip = function () {
      this.notify(i);
    }, f.prototype.break = function () {
      this.notify(o);
    }, f.prototype.remove = function () {
      this.notify(s);
    }, f.prototype.__initialize = function (e, t) {
      this.visitor = t, this.root = e, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, "iteration" === t.fallback ? this.__fallback = Object.keys : "function" == typeof t.fallback && (this.__fallback = t.fallback), this.__keys = a, t.keys && (this.__keys = Object.assign(Object.create(this.__keys), t.keys));
    }, f.prototype.traverse = function (e, t) {
      var r, n, a, s, l, u, f, d, m, x, v, g;

      for (this.__initialize(e, t), g = {}, r = this.__worklist, n = this.__leavelist, r.push(new c(e, null, null, null)), n.push(new c(null, null, null, null)); r.length;) if ((a = r.pop()) !== g) {
        if (a.node) {
          if (u = this.__execute(t.enter, a), this.__state === o || u === o) return;
          if (r.push(g), n.push(a), this.__state === i || u === i) continue;

          if (l = (s = a.node).type || a.wrap, !(x = this.__keys[l])) {
            if (!this.__fallback) throw new Error("Unknown node type " + l + ".");
            x = this.__fallback(s);
          }

          for (d = x.length; (d -= 1) >= 0;) if (v = s[f = x[d]]) if (Array.isArray(v)) {
            for (m = v.length; (m -= 1) >= 0;) if (v[m] && !y(n, v[m])) {
              if (h(l, x[d])) a = new c(v[m], [f, m], "Property", null);else {
                if (!p(v[m])) continue;
                a = new c(v[m], [f, m], null, null);
              }
              r.push(a);
            }
          } else if (p(v)) {
            if (y(n, v)) continue;
            r.push(new c(v, f, null, null));
          }
        }
      } else if (a = n.pop(), u = this.__execute(t.leave, a), this.__state === o || u === o) return;
    }, f.prototype.replace = function (e, t) {
      var r, n, a, l, f, y, d, m, x, v, g, b, A;

      function E(e) {
        var t, n, a, o;
        if (e.ref.remove()) for (n = e.ref.key, o = e.ref.parent, t = r.length; t--;) if ((a = r[t]).ref && a.ref.parent === o) {
          if (a.ref.key < n) break;
          --a.ref.key;
        }
      }

      for (this.__initialize(e, t), g = {}, r = this.__worklist, n = this.__leavelist, y = new c(e, null, null, new u(b = {
        root: e
      }, "root")), r.push(y), n.push(y); r.length;) if ((y = r.pop()) !== g) {
        if (void 0 !== (f = this.__execute(t.enter, y)) && f !== o && f !== i && f !== s && (y.ref.replace(f), y.node = f), this.__state !== s && f !== s || (E(y), y.node = null), this.__state === o || f === o) return b.root;

        if ((a = y.node) && (r.push(g), n.push(y), this.__state !== i && f !== i)) {
          if (l = a.type || y.wrap, !(x = this.__keys[l])) {
            if (!this.__fallback) throw new Error("Unknown node type " + l + ".");
            x = this.__fallback(a);
          }

          for (d = x.length; (d -= 1) >= 0;) if (v = a[A = x[d]]) if (Array.isArray(v)) {
            for (m = v.length; (m -= 1) >= 0;) if (v[m]) {
              if (h(l, x[d])) y = new c(v[m], [A, m], "Property", new u(v, m));else {
                if (!p(v[m])) continue;
                y = new c(v[m], [A, m], null, new u(v, m));
              }
              r.push(y);
            }
          } else p(v) && r.push(new c(v, A, null, new u(a, A)));
        }
      } else if (y = n.pop(), void 0 !== (f = this.__execute(t.leave, y)) && f !== o && f !== i && f !== s && y.ref.replace(f), this.__state !== s && f !== s || E(y), this.__state === o || f === o) return b.root;

      return b.root;
    }, t.Syntax = r, t.traverse = d, t.replace = function (e, t) {
      return new f().replace(e, t);
    }, t.attachComments = function (e, t, r) {
      var a,
          o,
          i,
          s,
          u = [];
      if (!e.range) throw new Error("attachComments needs range information");

      if (!r.length) {
        if (t.length) {
          for (i = 0, o = t.length; i < o; i += 1) (a = l(t[i])).extendedRange = [0, e.range[0]], u.push(a);

          e.leadingComments = u;
        }

        return e;
      }

      for (i = 0, o = t.length; i < o; i += 1) u.push(m(l(t[i]), r));

      return s = 0, d(e, {
        enter: function (e) {
          for (var t; s < u.length && !((t = u[s]).extendedRange[1] > e.range[0]);) t.extendedRange[1] === e.range[0] ? (e.leadingComments || (e.leadingComments = []), e.leadingComments.push(t), u.splice(s, 1)) : s += 1;

          return s === u.length ? n.Break : u[s].extendedRange[0] > e.range[1] ? n.Skip : void 0;
        }
      }), s = 0, d(e, {
        leave: function (e) {
          for (var t; s < u.length && (t = u[s], !(e.range[1] < t.extendedRange[0]));) e.range[1] === t.extendedRange[0] ? (e.trailingComments || (e.trailingComments = []), e.trailingComments.push(t), u.splice(s, 1)) : s += 1;

          return s === u.length ? n.Break : u[s].extendedRange[0] > e.range[1] ? n.Skip : void 0;
        }
      }), e;
    }, t.VisitorKeys = a, t.VisitorOption = n, t.Controller = f, t.cloneEnvironment = function () {
      return e({});
    }, t;
  }(t);
}),
    l = i(function (e) {
  e.exports && (e.exports = function () {
    function e(t, r, n, a) {
      this.message = t, this.expected = r, this.found = n, this.location = a, this.name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, e);
    }

    return function (e, t) {
      function r() {
        this.constructor = e;
      }

      r.prototype = t.prototype, e.prototype = new r();
    }(e, Error), e.buildMessage = function (e, t) {
      var r = {
        literal: function (e) {
          return '"' + a(e.text) + '"';
        },
        class: function (e) {
          var t,
              r = "";

          for (t = 0; t < e.parts.length; t++) r += e.parts[t] instanceof Array ? o(e.parts[t][0]) + "-" + o(e.parts[t][1]) : o(e.parts[t]);

          return "[" + (e.inverted ? "^" : "") + r + "]";
        },
        any: function (e) {
          return "any character";
        },
        end: function (e) {
          return "end of input";
        },
        other: function (e) {
          return e.description;
        }
      };

      function n(e) {
        return e.charCodeAt(0).toString(16).toUpperCase();
      }

      function a(e) {
        return e.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (e) {
          return "\\x0" + n(e);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (e) {
          return "\\x" + n(e);
        });
      }

      function o(e) {
        return e.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (e) {
          return "\\x0" + n(e);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (e) {
          return "\\x" + n(e);
        });
      }

      return "Expected " + function (e) {
        var t,
            n,
            a,
            o = new Array(e.length);

        for (t = 0; t < e.length; t++) o[t] = (a = e[t], r[a.type](a));

        if (o.sort(), o.length > 0) {
          for (t = 1, n = 1; t < o.length; t++) o[t - 1] !== o[t] && (o[n] = o[t], n++);

          o.length = n;
        }

        switch (o.length) {
          case 1:
            return o[0];

          case 2:
            return o[0] + " or " + o[1];

          default:
            return o.slice(0, -1).join(", ") + ", or " + o[o.length - 1];
        }
      }(e) + " but " + function (e) {
        return e ? '"' + a(e) + '"' : "end of input";
      }(t) + " found.";
    }, {
      SyntaxError: e,
      parse: function (t, r) {
        r = void 0 !== r ? r : {};

        var n,
            a,
            o,
            i,
            s = {},
            l = {
          start: be
        },
            u = be,
            c = de(" ", !1),
            f = /^[^ [\],():#!=><~+.]/,
            p = me([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], !0, !1),
            h = de(">", !1),
            y = de("~", !1),
            d = de("+", !1),
            m = de(",", !1),
            x = de("!", !1),
            v = de("*", !1),
            g = de("#", !1),
            b = de("[", !1),
            A = de("]", !1),
            E = /^[><!]/,
            S = me([">", "<", "!"], !1, !1),
            _ = de("=", !1),
            w = function (e) {
          return (e || "") + "=";
        },
            C = /^[><]/,
            P = me([">", "<"], !1, !1),
            k = de(".", !1),
            D = function (e, t, r) {
          return {
            type: "attribute",
            name: e,
            operator: t,
            value: r
          };
        },
            j = de('"', !1),
            I = /^[^\\"]/,
            T = me(["\\", '"'], !0, !1),
            F = de("\\", !1),
            L = {
          type: "any"
        },
            O = function (e, t) {
          return e + t;
        },
            R = function (e) {
          return {
            type: "literal",
            value: (t = e.join(""), t.replace(/\\(.)/g, function (e, t) {
              switch (t) {
                case "b":
                  return "\b";

                case "f":
                  return "\f";

                case "n":
                  return "\n";

                case "r":
                  return "\r";

                case "t":
                  return "\t";

                case "v":
                  return "\v";

                default:
                  return t;
              }
            }))
          };
          var t;
        },
            B = de("'", !1),
            M = /^[^\\']/,
            U = me(["\\", "'"], !0, !1),
            V = /^[0-9]/,
            q = me([["0", "9"]], !1, !1),
            N = de("type(", !1),
            W = /^[^ )]/,
            K = me([" ", ")"], !0, !1),
            G = de(")", !1),
            z = /^[imsu]/,
            H = me(["i", "m", "s", "u"], !1, !1),
            Y = de("/", !1),
            $ = /^[^\/]/,
            J = me(["/"], !0, !1),
            Q = de(":not(", !1),
            X = de(":matches(", !1),
            Z = de(":has(", !1),
            ee = de(":first-child", !1),
            te = de(":last-child", !1),
            re = de(":nth-child(", !1),
            ne = de(":nth-last-child(", !1),
            ae = de(":", !1),
            oe = de("statement", !0),
            ie = de("expression", !0),
            se = de("declaration", !0),
            le = de("function", !0),
            ue = de("pattern", !0),
            ce = 0,
            fe = [{
          line: 1,
          column: 1
        }],
            pe = 0,
            he = [],
            ye = {};

        if ("startRule" in r) {
          if (!(r.startRule in l)) throw new Error("Can't start parsing from rule \"" + r.startRule + '".');
          u = l[r.startRule];
        }

        function de(e, t) {
          return {
            type: "literal",
            text: e,
            ignoreCase: t
          };
        }

        function me(e, t, r) {
          return {
            type: "class",
            parts: e,
            inverted: t,
            ignoreCase: r
          };
        }

        function xe(e) {
          var r,
              n = fe[e];
          if (n) return n;

          for (r = e - 1; !fe[r];) r--;

          for (n = {
            line: (n = fe[r]).line,
            column: n.column
          }; r < e;) 10 === t.charCodeAt(r) ? (n.line++, n.column = 1) : n.column++, r++;

          return fe[e] = n, n;
        }

        function ve(e, t) {
          var r = xe(e),
              n = xe(t);
          return {
            start: {
              offset: e,
              line: r.line,
              column: r.column
            },
            end: {
              offset: t,
              line: n.line,
              column: n.column
            }
          };
        }

        function ge(e) {
          ce < pe || (ce > pe && (pe = ce, he = []), he.push(e));
        }

        function be() {
          var e,
              t,
              r,
              n,
              a = 30 * ce + 0,
              o = ye[a];
          return o ? (ce = o.nextPos, o.result) : (e = ce, (t = Ae()) !== s && (r = _e()) !== s && Ae() !== s ? e = t = 1 === (n = r).length ? n[0] : {
            type: "matches",
            selectors: n
          } : (ce = e, e = s), e === s && (e = ce, (t = Ae()) !== s && (t = void 0), e = t), ye[a] = {
            nextPos: ce,
            result: e
          }, e);
        }

        function Ae() {
          var e,
              r,
              n = 30 * ce + 1,
              a = ye[n];
          if (a) return ce = a.nextPos, a.result;

          for (e = [], 32 === t.charCodeAt(ce) ? (r = " ", ce++) : (r = s, ge(c)); r !== s;) e.push(r), 32 === t.charCodeAt(ce) ? (r = " ", ce++) : (r = s, ge(c));

          return ye[n] = {
            nextPos: ce,
            result: e
          }, e;
        }

        function Ee() {
          var e,
              r,
              n,
              a = 30 * ce + 2,
              o = ye[a];
          if (o) return ce = o.nextPos, o.result;
          if (r = [], f.test(t.charAt(ce)) ? (n = t.charAt(ce), ce++) : (n = s, ge(p)), n !== s) for (; n !== s;) r.push(n), f.test(t.charAt(ce)) ? (n = t.charAt(ce), ce++) : (n = s, ge(p));else r = s;
          return r !== s && (r = r.join("")), e = r, ye[a] = {
            nextPos: ce,
            result: e
          }, e;
        }

        function Se() {
          var e,
              r,
              n,
              a = 30 * ce + 3,
              o = ye[a];
          return o ? (ce = o.nextPos, o.result) : (e = ce, (r = Ae()) !== s ? (62 === t.charCodeAt(ce) ? (n = ">", ce++) : (n = s, ge(h)), n !== s && Ae() !== s ? e = r = "child" : (ce = e, e = s)) : (ce = e, e = s), e === s && (e = ce, (r = Ae()) !== s ? (126 === t.charCodeAt(ce) ? (n = "~", ce++) : (n = s, ge(y)), n !== s && Ae() !== s ? e = r = "sibling" : (ce = e, e = s)) : (ce = e, e = s), e === s && (e = ce, (r = Ae()) !== s ? (43 === t.charCodeAt(ce) ? (n = "+", ce++) : (n = s, ge(d)), n !== s && Ae() !== s ? e = r = "adjacent" : (ce = e, e = s)) : (ce = e, e = s), e === s && (e = ce, 32 === t.charCodeAt(ce) ? (r = " ", ce++) : (r = s, ge(c)), r !== s && (n = Ae()) !== s ? e = r = "descendant" : (ce = e, e = s)))), ye[a] = {
            nextPos: ce,
            result: e
          }, e);
        }

        function _e() {
          var e,
              r,
              n,
              a,
              o,
              i,
              l,
              u,
              c = 30 * ce + 4,
              f = ye[c];
          if (f) return ce = f.nextPos, f.result;

          if (e = ce, (r = we()) !== s) {
            for (n = [], a = ce, (o = Ae()) !== s ? (44 === t.charCodeAt(ce) ? (i = ",", ce++) : (i = s, ge(m)), i !== s && (l = Ae()) !== s && (u = we()) !== s ? a = o = [o, i, l, u] : (ce = a, a = s)) : (ce = a, a = s); a !== s;) n.push(a), a = ce, (o = Ae()) !== s ? (44 === t.charCodeAt(ce) ? (i = ",", ce++) : (i = s, ge(m)), i !== s && (l = Ae()) !== s && (u = we()) !== s ? a = o = [o, i, l, u] : (ce = a, a = s)) : (ce = a, a = s);

            n !== s ? e = r = [r].concat(n.map(function (e) {
              return e[3];
            })) : (ce = e, e = s);
          } else ce = e, e = s;

          return ye[c] = {
            nextPos: ce,
            result: e
          }, e;
        }

        function we() {
          var e,
              t,
              r,
              n,
              a,
              o,
              i,
              l = 30 * ce + 5,
              u = ye[l];
          if (u) return ce = u.nextPos, u.result;

          if (e = ce, (t = Ce()) !== s) {
            for (r = [], n = ce, (a = Se()) !== s && (o = Ce()) !== s ? n = a = [a, o] : (ce = n, n = s); n !== s;) r.push(n), n = ce, (a = Se()) !== s && (o = Ce()) !== s ? n = a = [a, o] : (ce = n, n = s);

            r !== s ? (i = t, e = t = r.reduce(function (e, t) {
              return {
                type: t[0],
                left: e,
                right: t[1]
              };
            }, i)) : (ce = e, e = s);
          } else ce = e, e = s;

          return ye[l] = {
            nextPos: ce,
            result: e
          }, e;
        }

        function Ce() {
          var e,
              r,
              n,
              a,
              o,
              i,
              l,
              u = 30 * ce + 6,
              c = ye[u];
          if (c) return ce = c.nextPos, c.result;

          if (e = ce, 33 === t.charCodeAt(ce) ? (r = "!", ce++) : (r = s, ge(x)), r === s && (r = null), r !== s) {
            if (n = [], (a = Pe()) !== s) for (; a !== s;) n.push(a), a = Pe();else n = s;
            n !== s ? (o = r, l = 1 === (i = n).length ? i[0] : {
              type: "compound",
              selectors: i
            }, o && (l.subject = !0), e = r = l) : (ce = e, e = s);
          } else ce = e, e = s;

          return ye[u] = {
            nextPos: ce,
            result: e
          }, e;
        }

        function Pe() {
          var e,
              r = 30 * ce + 7,
              n = ye[r];
          return n ? (ce = n.nextPos, n.result) : ((e = function () {
            var e,
                r,
                n = 30 * ce + 8,
                a = ye[n];
            return a ? (ce = a.nextPos, a.result) : (42 === t.charCodeAt(ce) ? (r = "*", ce++) : (r = s, ge(v)), r !== s && (r = {
              type: "wildcard",
              value: r
            }), e = r, ye[n] = {
              nextPos: ce,
              result: e
            }, e);
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a = 30 * ce + 9,
                o = ye[a];
            return o ? (ce = o.nextPos, o.result) : (e = ce, 35 === t.charCodeAt(ce) ? (r = "#", ce++) : (r = s, ge(g)), r === s && (r = null), r !== s && (n = Ee()) !== s ? e = r = {
              type: "identifier",
              value: n
            } : (ce = e, e = s), ye[a] = {
              nextPos: ce,
              result: e
            }, e);
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a,
                o = 30 * ce + 10,
                i = ye[o];
            return i ? (ce = i.nextPos, i.result) : (e = ce, 91 === t.charCodeAt(ce) ? (r = "[", ce++) : (r = s, ge(b)), r !== s && Ae() !== s && (n = function () {
              var e,
                  r,
                  n,
                  a,
                  o = 30 * ce + 14,
                  i = ye[o];
              return i ? (ce = i.nextPos, i.result) : (e = ce, (r = ke()) !== s && Ae() !== s && (n = function () {
                var e,
                    r,
                    n,
                    a = 30 * ce + 12,
                    o = ye[a];
                return o ? (ce = o.nextPos, o.result) : (e = ce, 33 === t.charCodeAt(ce) ? (r = "!", ce++) : (r = s, ge(x)), r === s && (r = null), r !== s ? (61 === t.charCodeAt(ce) ? (n = "=", ce++) : (n = s, ge(_)), n !== s ? (r = w(r), e = r) : (ce = e, e = s)) : (ce = e, e = s), ye[a] = {
                  nextPos: ce,
                  result: e
                }, e);
              }()) !== s && Ae() !== s ? ((a = function () {
                var e,
                    r,
                    n,
                    a,
                    o,
                    i = 30 * ce + 18,
                    l = ye[i];
                if (l) return ce = l.nextPos, l.result;
                if (e = ce, "type(" === t.substr(ce, 5) ? (r = "type(", ce += 5) : (r = s, ge(N)), r !== s) {
                  if (Ae() !== s) {
                    if (n = [], W.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(K)), a !== s) for (; a !== s;) n.push(a), W.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(K));else n = s;
                    n !== s && (a = Ae()) !== s ? (41 === t.charCodeAt(ce) ? (o = ")", ce++) : (o = s, ge(G)), o !== s ? (r = {
                      type: "type",
                      value: n.join("")
                    }, e = r) : (ce = e, e = s)) : (ce = e, e = s);
                  } else ce = e, e = s;
                } else ce = e, e = s;
                return ye[i] = {
                  nextPos: ce,
                  result: e
                }, e;
              }()) === s && (a = function () {
                var e,
                    r,
                    n,
                    a,
                    o,
                    i,
                    l = 30 * ce + 20,
                    u = ye[l];
                if (u) return ce = u.nextPos, u.result;

                if (e = ce, 47 === t.charCodeAt(ce) ? (r = "/", ce++) : (r = s, ge(Y)), r !== s) {
                  if (n = [], $.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(J)), a !== s) for (; a !== s;) n.push(a), $.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(J));else n = s;
                  n !== s ? (47 === t.charCodeAt(ce) ? (a = "/", ce++) : (a = s, ge(Y)), a !== s ? ((o = function () {
                    var e,
                        r,
                        n = 30 * ce + 19,
                        a = ye[n];
                    if (a) return ce = a.nextPos, a.result;
                    if (e = [], z.test(t.charAt(ce)) ? (r = t.charAt(ce), ce++) : (r = s, ge(H)), r !== s) for (; r !== s;) e.push(r), z.test(t.charAt(ce)) ? (r = t.charAt(ce), ce++) : (r = s, ge(H));else e = s;
                    return ye[n] = {
                      nextPos: ce,
                      result: e
                    }, e;
                  }()) === s && (o = null), o !== s ? (i = o, r = {
                    type: "regexp",
                    value: new RegExp(n.join(""), i ? i.join("") : "")
                  }, e = r) : (ce = e, e = s)) : (ce = e, e = s)) : (ce = e, e = s);
                } else ce = e, e = s;

                return ye[l] = {
                  nextPos: ce,
                  result: e
                }, e;
              }()), a !== s ? (r = D(r, n, a), e = r) : (ce = e, e = s)) : (ce = e, e = s), e === s && (e = ce, (r = ke()) !== s && Ae() !== s && (n = function () {
                var e,
                    r,
                    n,
                    a = 30 * ce + 11,
                    o = ye[a];
                return o ? (ce = o.nextPos, o.result) : (e = ce, E.test(t.charAt(ce)) ? (r = t.charAt(ce), ce++) : (r = s, ge(S)), r === s && (r = null), r !== s ? (61 === t.charCodeAt(ce) ? (n = "=", ce++) : (n = s, ge(_)), n !== s ? (r = w(r), e = r) : (ce = e, e = s)) : (ce = e, e = s), e === s && (C.test(t.charAt(ce)) ? (e = t.charAt(ce), ce++) : (e = s, ge(P))), ye[a] = {
                  nextPos: ce,
                  result: e
                }, e);
              }()) !== s && Ae() !== s ? ((a = function () {
                var e,
                    r,
                    n,
                    a,
                    o,
                    i,
                    l = 30 * ce + 15,
                    u = ye[l];
                if (u) return ce = u.nextPos, u.result;

                if (e = ce, 34 === t.charCodeAt(ce) ? (r = '"', ce++) : (r = s, ge(j)), r !== s) {
                  for (n = [], I.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(T)), a === s && (a = ce, 92 === t.charCodeAt(ce) ? (o = "\\", ce++) : (o = s, ge(F)), o !== s ? (t.length > ce ? (i = t.charAt(ce), ce++) : (i = s, ge(L)), i !== s ? (o = O(o, i), a = o) : (ce = a, a = s)) : (ce = a, a = s)); a !== s;) n.push(a), I.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(T)), a === s && (a = ce, 92 === t.charCodeAt(ce) ? (o = "\\", ce++) : (o = s, ge(F)), o !== s ? (t.length > ce ? (i = t.charAt(ce), ce++) : (i = s, ge(L)), i !== s ? (o = O(o, i), a = o) : (ce = a, a = s)) : (ce = a, a = s));

                  n !== s ? (34 === t.charCodeAt(ce) ? (a = '"', ce++) : (a = s, ge(j)), a !== s ? (r = R(n), e = r) : (ce = e, e = s)) : (ce = e, e = s);
                } else ce = e, e = s;

                if (e === s) if (e = ce, 39 === t.charCodeAt(ce) ? (r = "'", ce++) : (r = s, ge(B)), r !== s) {
                  for (n = [], M.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(U)), a === s && (a = ce, 92 === t.charCodeAt(ce) ? (o = "\\", ce++) : (o = s, ge(F)), o !== s ? (t.length > ce ? (i = t.charAt(ce), ce++) : (i = s, ge(L)), i !== s ? (o = O(o, i), a = o) : (ce = a, a = s)) : (ce = a, a = s)); a !== s;) n.push(a), M.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(U)), a === s && (a = ce, 92 === t.charCodeAt(ce) ? (o = "\\", ce++) : (o = s, ge(F)), o !== s ? (t.length > ce ? (i = t.charAt(ce), ce++) : (i = s, ge(L)), i !== s ? (o = O(o, i), a = o) : (ce = a, a = s)) : (ce = a, a = s));

                  n !== s ? (39 === t.charCodeAt(ce) ? (a = "'", ce++) : (a = s, ge(B)), a !== s ? (r = R(n), e = r) : (ce = e, e = s)) : (ce = e, e = s);
                } else ce = e, e = s;
                return ye[l] = {
                  nextPos: ce,
                  result: e
                }, e;
              }()) === s && (a = function () {
                var e,
                    r,
                    n,
                    a,
                    o,
                    i,
                    l,
                    u = 30 * ce + 16,
                    c = ye[u];
                if (c) return ce = c.nextPos, c.result;

                for (e = ce, r = ce, n = [], V.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(q)); a !== s;) n.push(a), V.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(q));

                if (n !== s ? (46 === t.charCodeAt(ce) ? (a = ".", ce++) : (a = s, ge(k)), a !== s ? r = n = [n, a] : (ce = r, r = s)) : (ce = r, r = s), r === s && (r = null), r !== s) {
                  if (n = [], V.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(q)), a !== s) for (; a !== s;) n.push(a), V.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(q));else n = s;
                  n !== s ? (i = n, l = (o = r) ? [].concat.apply([], o).join("") : "", r = {
                    type: "literal",
                    value: parseFloat(l + i.join(""))
                  }, e = r) : (ce = e, e = s);
                } else ce = e, e = s;

                return ye[u] = {
                  nextPos: ce,
                  result: e
                }, e;
              }()) === s && (a = function () {
                var e,
                    t,
                    r = 30 * ce + 17,
                    n = ye[r];
                return n ? (ce = n.nextPos, n.result) : ((t = Ee()) !== s && (t = {
                  type: "literal",
                  value: t
                }), e = t, ye[r] = {
                  nextPos: ce,
                  result: e
                }, e);
              }()), a !== s ? (r = D(r, n, a), e = r) : (ce = e, e = s)) : (ce = e, e = s), e === s && (e = ce, (r = ke()) !== s && (r = {
                type: "attribute",
                name: r
              }), e = r)), ye[o] = {
                nextPos: ce,
                result: e
              }, e);
            }()) !== s && Ae() !== s ? (93 === t.charCodeAt(ce) ? (a = "]", ce++) : (a = s, ge(A)), a !== s ? e = r = n : (ce = e, e = s)) : (ce = e, e = s), ye[o] = {
              nextPos: ce,
              result: e
            }, e);
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a,
                o,
                i,
                l,
                u,
                c = 30 * ce + 21,
                f = ye[c];
            if (f) return ce = f.nextPos, f.result;
            if (e = ce, 46 === t.charCodeAt(ce) ? (r = ".", ce++) : (r = s, ge(k)), r !== s) {
              if ((n = Ee()) !== s) {
                for (a = [], o = ce, 46 === t.charCodeAt(ce) ? (i = ".", ce++) : (i = s, ge(k)), i !== s && (l = Ee()) !== s ? o = i = [i, l] : (ce = o, o = s); o !== s;) a.push(o), o = ce, 46 === t.charCodeAt(ce) ? (i = ".", ce++) : (i = s, ge(k)), i !== s && (l = Ee()) !== s ? o = i = [i, l] : (ce = o, o = s);

                a !== s ? (u = n, r = {
                  type: "field",
                  name: a.reduce(function (e, t) {
                    return e + t[0] + t[1];
                  }, u)
                }, e = r) : (ce = e, e = s);
              } else ce = e, e = s;
            } else ce = e, e = s;
            return ye[c] = {
              nextPos: ce,
              result: e
            }, e;
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a,
                o = 30 * ce + 22,
                i = ye[o];
            return i ? (ce = i.nextPos, i.result) : (e = ce, ":not(" === t.substr(ce, 5) ? (r = ":not(", ce += 5) : (r = s, ge(Q)), r !== s && Ae() !== s && (n = _e()) !== s && Ae() !== s ? (41 === t.charCodeAt(ce) ? (a = ")", ce++) : (a = s, ge(G)), a !== s ? e = r = {
              type: "not",
              selectors: n
            } : (ce = e, e = s)) : (ce = e, e = s), ye[o] = {
              nextPos: ce,
              result: e
            }, e);
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a,
                o = 30 * ce + 23,
                i = ye[o];
            return i ? (ce = i.nextPos, i.result) : (e = ce, ":matches(" === t.substr(ce, 9) ? (r = ":matches(", ce += 9) : (r = s, ge(X)), r !== s && Ae() !== s && (n = _e()) !== s && Ae() !== s ? (41 === t.charCodeAt(ce) ? (a = ")", ce++) : (a = s, ge(G)), a !== s ? e = r = {
              type: "matches",
              selectors: n
            } : (ce = e, e = s)) : (ce = e, e = s), ye[o] = {
              nextPos: ce,
              result: e
            }, e);
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a,
                o = 30 * ce + 24,
                i = ye[o];
            return i ? (ce = i.nextPos, i.result) : (e = ce, ":has(" === t.substr(ce, 5) ? (r = ":has(", ce += 5) : (r = s, ge(Z)), r !== s && Ae() !== s && (n = _e()) !== s && Ae() !== s ? (41 === t.charCodeAt(ce) ? (a = ")", ce++) : (a = s, ge(G)), a !== s ? e = r = {
              type: "has",
              selectors: n
            } : (ce = e, e = s)) : (ce = e, e = s), ye[o] = {
              nextPos: ce,
              result: e
            }, e);
          }()) === s && (e = function () {
            var e,
                r,
                n = 30 * ce + 25,
                a = ye[n];
            return a ? (ce = a.nextPos, a.result) : (":first-child" === t.substr(ce, 12) ? (r = ":first-child", ce += 12) : (r = s, ge(ee)), r !== s && (r = De(1)), e = r, ye[n] = {
              nextPos: ce,
              result: e
            }, e);
          }()) === s && (e = function () {
            var e,
                r,
                n = 30 * ce + 26,
                a = ye[n];
            return a ? (ce = a.nextPos, a.result) : (":last-child" === t.substr(ce, 11) ? (r = ":last-child", ce += 11) : (r = s, ge(te)), r !== s && (r = je(1)), e = r, ye[n] = {
              nextPos: ce,
              result: e
            }, e);
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a,
                o,
                i = 30 * ce + 27,
                l = ye[i];
            if (l) return ce = l.nextPos, l.result;
            if (e = ce, ":nth-child(" === t.substr(ce, 11) ? (r = ":nth-child(", ce += 11) : (r = s, ge(re)), r !== s) {
              if (Ae() !== s) {
                if (n = [], V.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(q)), a !== s) for (; a !== s;) n.push(a), V.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(q));else n = s;
                n !== s && (a = Ae()) !== s ? (41 === t.charCodeAt(ce) ? (o = ")", ce++) : (o = s, ge(G)), o !== s ? (r = De(parseInt(n.join(""), 10)), e = r) : (ce = e, e = s)) : (ce = e, e = s);
              } else ce = e, e = s;
            } else ce = e, e = s;
            return ye[i] = {
              nextPos: ce,
              result: e
            }, e;
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a,
                o,
                i = 30 * ce + 28,
                l = ye[i];
            if (l) return ce = l.nextPos, l.result;
            if (e = ce, ":nth-last-child(" === t.substr(ce, 16) ? (r = ":nth-last-child(", ce += 16) : (r = s, ge(ne)), r !== s) {
              if (Ae() !== s) {
                if (n = [], V.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(q)), a !== s) for (; a !== s;) n.push(a), V.test(t.charAt(ce)) ? (a = t.charAt(ce), ce++) : (a = s, ge(q));else n = s;
                n !== s && (a = Ae()) !== s ? (41 === t.charCodeAt(ce) ? (o = ")", ce++) : (o = s, ge(G)), o !== s ? (r = je(parseInt(n.join(""), 10)), e = r) : (ce = e, e = s)) : (ce = e, e = s);
              } else ce = e, e = s;
            } else ce = e, e = s;
            return ye[i] = {
              nextPos: ce,
              result: e
            }, e;
          }()) === s && (e = function () {
            var e,
                r,
                n,
                a = 30 * ce + 29,
                o = ye[a];
            return o ? (ce = o.nextPos, o.result) : (e = ce, 58 === t.charCodeAt(ce) ? (r = ":", ce++) : (r = s, ge(ae)), r !== s ? ("statement" === t.substr(ce, 9).toLowerCase() ? (n = t.substr(ce, 9), ce += 9) : (n = s, ge(oe)), n === s && ("expression" === t.substr(ce, 10).toLowerCase() ? (n = t.substr(ce, 10), ce += 10) : (n = s, ge(ie)), n === s && ("declaration" === t.substr(ce, 11).toLowerCase() ? (n = t.substr(ce, 11), ce += 11) : (n = s, ge(se)), n === s && ("function" === t.substr(ce, 8).toLowerCase() ? (n = t.substr(ce, 8), ce += 8) : (n = s, ge(le)), n === s && ("pattern" === t.substr(ce, 7).toLowerCase() ? (n = t.substr(ce, 7), ce += 7) : (n = s, ge(ue)))))), n !== s ? e = r = {
              type: "class",
              name: n
            } : (ce = e, e = s)) : (ce = e, e = s), ye[a] = {
              nextPos: ce,
              result: e
            }, e);
          }()), ye[r] = {
            nextPos: ce,
            result: e
          }, e);
        }

        function ke() {
          var e,
              r,
              n,
              a,
              o,
              i,
              l,
              u,
              c = 30 * ce + 13,
              f = ye[c];
          if (f) return ce = f.nextPos, f.result;

          if (e = ce, (r = Ee()) !== s) {
            for (n = [], a = ce, 46 === t.charCodeAt(ce) ? (o = ".", ce++) : (o = s, ge(k)), o !== s && (i = Ee()) !== s ? a = o = [o, i] : (ce = a, a = s); a !== s;) n.push(a), a = ce, 46 === t.charCodeAt(ce) ? (o = ".", ce++) : (o = s, ge(k)), o !== s && (i = Ee()) !== s ? a = o = [o, i] : (ce = a, a = s);

            n !== s ? (l = r, u = n, e = r = [].concat.apply([l], u).join("")) : (ce = e, e = s);
          } else ce = e, e = s;

          return ye[c] = {
            nextPos: ce,
            result: e
          }, e;
        }

        function De(e) {
          return {
            type: "nth-child",
            index: {
              type: "literal",
              value: e
            }
          };
        }

        function je(e) {
          return {
            type: "nth-last-child",
            index: {
              type: "literal",
              value: e
            }
          };
        }

        if ((n = u()) !== s && ce === t.length) return n;
        throw n !== s && ce < t.length && ge({
          type: "end"
        }), a = he, o = pe < t.length ? t.charAt(pe) : null, i = pe < t.length ? ve(pe, pe + 1) : ve(pe, pe), new e(e.buildMessage(a, o), a, o, i);
      }
    };
  }());
});

function u(t, r, n, a) {
  if (!r) return !0;
  if (!t) return !1;

  switch (n || (n = []), r.type) {
    case "wildcard":
      return !0;

    case "identifier":
      return r.value.toLowerCase() === t.type.toLowerCase();

    case "field":
      var i = r.name.split("."),
          l = n[i.length - 1];
      return function e(t, r, n) {
        if (0 === n.length) return t === r;
        if (null == r) return !1;
        var a = r[n[0]],
            i = n.slice(1);

        if (Array.isArray(a)) {
          var s,
              l = o(a);

          try {
            for (l.s(); !(s = l.n()).done;) {
              if (e(t, s.value, i)) return !0;
            }
          } catch (e) {
            l.e(e);
          } finally {
            l.f();
          }

          return !1;
        }

        return e(t, a, i);
      }(t, l, i);

    case "matches":
      var c,
          f = o(r.selectors);

      try {
        for (f.s(); !(c = f.n()).done;) {
          var d = c.value;
          if (u(t, d, n, a)) return !0;
        }
      } catch (e) {
        f.e(e);
      } finally {
        f.f();
      }

      return !1;

    case "compound":
      var m,
          x = o(r.selectors);

      try {
        for (x.s(); !(m = x.n()).done;) {
          var v = m.value;
          if (!u(t, v, n, a)) return !1;
        }
      } catch (e) {
        x.e(e);
      } finally {
        x.f();
      }

      return !0;

    case "not":
      var g,
          b = o(r.selectors);

      try {
        for (b.s(); !(g = b.n()).done;) {
          var A = g.value;
          if (u(t, A, n, a)) return !1;
        }
      } catch (e) {
        b.e(e);
      } finally {
        b.f();
      }

      return !0;

    case "has":
      var E = function () {
        var e,
            n = [],
            i = o(r.selectors);

        try {
          var l = function () {
            var r = e.value,
                o = [];
            s.traverse(t, {
              enter: function (e, t) {
                null != t && o.unshift(t), u(e, r, o, a) && n.push(e);
              },
              leave: function () {
                o.shift();
              },
              keys: a && a.visitorKeys,
              fallback: a && a.fallback || "iteration"
            });
          };

          for (i.s(); !(e = i.n()).done;) l();
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }

        return {
          v: 0 !== n.length
        };
      }();

      if ("object" === e(E)) return E.v;

    case "child":
      return !!u(t, r.right, n, a) && u(n[0], r.left, n.slice(1), a);

    case "descendant":
      if (u(t, r.right, n, a)) for (var S = 0, _ = n.length; S < _; ++S) if (u(n[S], r.left, n.slice(S + 1), a)) return !0;
      return !1;

    case "attribute":
      var w = function (e, t) {
        var r,
            n = o(t.split("."));

        try {
          for (n.s(); !(r = n.n()).done;) {
            var a = r.value;
            if (null == e) return e;
            e = e[a];
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }

        return e;
      }(t, r.name);

      switch (r.operator) {
        case void 0:
          return null != w;

        case "=":
          switch (r.value.type) {
            case "regexp":
              return "string" == typeof w && r.value.value.test(w);

            case "literal":
              return "".concat(r.value.value) === "".concat(w);

            case "type":
              return r.value.value === e(w);
          }

          throw new Error("Unknown selector value type: ".concat(r.value.type));

        case "!=":
          switch (r.value.type) {
            case "regexp":
              return !r.value.value.test(w);

            case "literal":
              return "".concat(r.value.value) !== "".concat(w);

            case "type":
              return r.value.value !== e(w);
          }

          throw new Error("Unknown selector value type: ".concat(r.value.type));

        case "<=":
          return w <= r.value.value;

        case "<":
          return w < r.value.value;

        case ">":
          return w > r.value.value;

        case ">=":
          return w >= r.value.value;
      }

      throw new Error("Unknown operator: ".concat(r.operator));

    case "sibling":
      return u(t, r.right, n, a) && p(t, r.left, n, "LEFT_SIDE", a) || r.left.subject && u(t, r.left, n, a) && p(t, r.right, n, "RIGHT_SIDE", a);

    case "adjacent":
      return u(t, r.right, n, a) && h(t, r.left, n, "LEFT_SIDE", a) || r.right.subject && u(t, r.left, n, a) && h(t, r.right, n, "RIGHT_SIDE", a);

    case "nth-child":
      return u(t, r.right, n, a) && y(t, n, function () {
        return r.index.value - 1;
      }, a);

    case "nth-last-child":
      return u(t, r.right, n, a) && y(t, n, function (e) {
        return e - r.index.value;
      }, a);

    case "class":
      switch (r.name.toLowerCase()) {
        case "statement":
          if ("Statement" === t.type.slice(-9)) return !0;

        case "declaration":
          return "Declaration" === t.type.slice(-11);

        case "pattern":
          if ("Pattern" === t.type.slice(-7)) return !0;

        case "expression":
          return "Expression" === t.type.slice(-10) || "Literal" === t.type.slice(-7) || "Identifier" === t.type && (0 === n.length || "MetaProperty" !== n[0].type) || "MetaProperty" === t.type;

        case "function":
          return "FunctionDeclaration" === t.type || "FunctionExpression" === t.type || "ArrowFunctionExpression" === t.type;
      }

      throw new Error("Unknown class name: ".concat(r.name));
  }

  throw new Error("Unknown selector type: ".concat(r.type));
}

function c(e, t) {
  var r = e.type;
  return t && t.visitorKeys && t.visitorKeys[r] ? t.visitorKeys[r] : s.VisitorKeys[r] ? s.VisitorKeys[r] : t && "function" == typeof t.fallback ? t.fallback(e) : Object.keys(e).filter(function (e) {
    return "type" !== e;
  });
}

function f(t) {
  return null !== t && "object" === e(t) && "string" == typeof t.type;
}

function p(e, r, n, a, i) {
  var s = t(n, 1)[0];
  if (!s) return !1;
  var l,
      p = o(c(s, i));

  try {
    for (p.s(); !(l = p.n()).done;) {
      var h = s[l.value];

      if (Array.isArray(h)) {
        var y = h.indexOf(e);
        if (y < 0) continue;
        var d = void 0,
            m = void 0;
        "LEFT_SIDE" === a ? (d = 0, m = y) : (d = y + 1, m = h.length);

        for (var x = d; x < m; ++x) if (f(h[x]) && u(h[x], r, n, i)) return !0;
      }
    }
  } catch (e) {
    p.e(e);
  } finally {
    p.f();
  }

  return !1;
}

function h(e, r, n, a, i) {
  var s = t(n, 1)[0];
  if (!s) return !1;
  var l,
      p = o(c(s, i));

  try {
    for (p.s(); !(l = p.n()).done;) {
      var h = s[l.value];

      if (Array.isArray(h)) {
        var y = h.indexOf(e);
        if (y < 0) continue;
        if ("LEFT_SIDE" === a && y > 0 && f(h[y - 1]) && u(h[y - 1], r, n, i)) return !0;
        if ("RIGHT_SIDE" === a && y < h.length - 1 && f(h[y + 1]) && u(h[y + 1], r, n, i)) return !0;
      }
    }
  } catch (e) {
    p.e(e);
  } finally {
    p.f();
  }

  return !1;
}

function y(e, r, n, a) {
  var i = t(r, 1)[0];
  if (!i) return !1;
  var s,
      l = o(c(i, a));

  try {
    for (l.s(); !(s = l.n()).done;) {
      var u = i[s.value];

      if (Array.isArray(u)) {
        var f = u.indexOf(e);
        if (f >= 0 && f === n(u.length)) return !0;
      }
    }
  } catch (e) {
    l.e(e);
  } finally {
    l.f();
  }

  return !1;
}

function d(n, a) {
  if (null == n || "object" != e(n)) return [];
  null == a && (a = n);

  for (var o = n.subject ? [a] : [], i = 0, s = function (e) {
    for (var t = [], r = Object.keys(e), n = 0; n < r.length; n++) t.push([r[n], e[r[n]]]);

    return t;
  }(n); i < s.length; i++) {
    var l = t(s[i], 2),
        u = l[0],
        c = l[1];
    o.push.apply(o, r(d(c, "left" === u ? c : a)));
  }

  return o;
}

function m(e, t, r, n) {
  if (t) {
    var a = [],
        o = d(t);
    s.traverse(e, {
      enter: function (e, i) {
        if (null != i && a.unshift(i), u(e, t, a, n)) if (o.length) for (var s = 0, l = o.length; s < l; ++s) {
          u(e, o[s], a, n) && r(e, i, a);

          for (var c = 0, f = a.length; c < f; ++c) {
            var p = a.slice(c + 1);
            u(a[c], o[s], p, n) && r(a[c], i, p);
          }
        } else r(e, i, a);
      },
      leave: function () {
        a.shift();
      },
      keys: n && n.visitorKeys,
      fallback: n && n.fallback || "iteration"
    });
  }
}

function x(e, t, r) {
  var n = [];
  return m(e, t, function (e) {
    n.push(e);
  }, r), n;
}

function v(e) {
  return l.parse(e);
}

function g(e, t, r) {
  return x(e, v(t), r);
}

g.parse = v, g.match = x, g.traverse = m, g.matches = u, g.query = g;

var esquery_esm_min = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': g
});

var eslintUtils = /*@__PURE__*/getAugmentedNamespace(eslintUtils$1);

var esquery = /*@__PURE__*/getAugmentedNamespace(esquery_esm_min);

function _interopDefaultLegacy$1(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var path__default = _interopDefaultLegacy$1(path);

var eslintScope__default = _interopDefaultLegacy$1(lib$6);

var eslintVisitorKeys__default = _interopDefaultLegacy$1(lib$5);

var espree__default$1 = _interopDefaultLegacy$1(espree_1);

var lodash__default$1 = _interopDefaultLegacy$1(lodash);

var environments__default = _interopDefaultLegacy$1(environments);

var configOps__default = _interopDefaultLegacy$1(configOps);

var configValidator__default = _interopDefaultLegacy$1(configValidator);

var eslintUtils__default$1 = _interopDefaultLegacy$1(eslintUtils);

var assert__default = _interopDefaultLegacy$1(require$$1$4);

var debug__default = _interopDefaultLegacy$1(src);

var levn__default = _interopDefaultLegacy$1(lib);

var esquery__default = _interopDefaultLegacy$1(esquery);
const _phantomChildren = {
  "@babel/highlight": "7.13.10"
};
const _requested = {
  type: "range",
  registry: true,
  raw: "eslint@^7.0.0",
  name: "eslint",
  escapedName: "eslint",
  rawSpec: "^7.0.0",
  saveSpec: null,
  fetchSpec: "^7.0.0"
};
const _requiredBy = ["#DEV:/"];
const author = {
  name: "Nicholas C. Zakas",
  email: "nicholas+npm@nczconsulting.com"
};
const bin = {
  eslint: "bin/eslint.js"
};
const bugs = {
  url: "https://github.com/eslint/eslint/issues/"
};
const dependencies$1 = {
  "@babel/code-frame": "7.12.11",
  "@eslint/eslintrc": "^0.4.0",
  ajv: "^6.10.0",
  chalk: "^4.0.0",
  "cross-spawn": "^7.0.2",
  debug: "^4.0.1",
  doctrine: "^3.0.0",
  enquirer: "^2.3.5",
  "eslint-scope": "^5.1.1",
  "eslint-utils": "^2.1.0",
  "eslint-visitor-keys": "^2.0.0",
  espree: "^7.3.1",
  esquery: "^1.4.0",
  esutils: "^2.0.2",
  "file-entry-cache": "^6.0.1",
  "functional-red-black-tree": "^1.0.1",
  "glob-parent": "^5.0.0",
  globals: "^13.6.0",
  ignore: "^4.0.6",
  "import-fresh": "^3.0.0",
  imurmurhash: "^0.1.4",
  "is-glob": "^4.0.0",
  "js-yaml": "^3.13.1",
  "json-stable-stringify-without-jsonify": "^1.0.1",
  levn: "^0.4.1",
  lodash: "^4.17.21",
  minimatch: "^3.0.4",
  "natural-compare": "^1.4.0",
  optionator: "^0.9.1",
  progress: "^2.0.0",
  regexpp: "^3.1.0",
  semver: "^7.2.1",
  "strip-ansi": "^6.0.0",
  "strip-json-comments": "^3.1.0",
  table: "^6.0.4",
  "text-table": "^0.2.0",
  "v8-compile-cache": "^2.0.3"
};
const devDependencies$1 = {
  "@babel/core": "^7.4.3",
  "@babel/preset-env": "^7.4.3",
  acorn: "^7.2.0",
  "babel-loader": "^8.0.5",
  chai: "^4.0.1",
  cheerio: "^0.22.0",
  "common-tags": "^1.8.0",
  "core-js": "^3.1.3",
  dateformat: "^3.0.3",
  ejs: "^3.0.2",
  "escape-string-regexp": "^3.0.0",
  eslint: "file:.",
  "eslint-config-eslint": "file:packages/eslint-config-eslint",
  "eslint-plugin-eslint-plugin": "^2.2.1",
  "eslint-plugin-internal-rules": "file:tools/internal-rules",
  "eslint-plugin-jsdoc": "^25.4.3",
  "eslint-plugin-node": "^11.1.0",
  "eslint-release": "^2.0.0",
  eslump: "^2.0.0",
  esprima: "^4.0.1",
  "fs-teardown": "^0.1.0",
  glob: "^7.1.6",
  jsdoc: "^3.5.5",
  karma: "^6.1.1",
  "karma-chrome-launcher": "^3.1.0",
  "karma-mocha": "^2.0.1",
  "karma-mocha-reporter": "^2.2.5",
  "karma-webpack": "^5.0.0",
  "lint-staged": "^10.1.2",
  "load-perf": "^0.2.0",
  markdownlint: "^0.19.0",
  "markdownlint-cli": "^0.22.0",
  memfs: "^3.0.1",
  mocha: "^8.3.2",
  "mocha-junit-reporter": "^2.0.0",
  "node-polyfill-webpack-plugin": "^1.0.3",
  "npm-license": "^0.3.3",
  nyc: "^15.0.1",
  proxyquire: "^2.0.1",
  puppeteer: "^7.1.0",
  recast: "^0.19.0",
  "regenerator-runtime": "^0.13.2",
  shelljs: "^0.8.2",
  sinon: "^9.0.1",
  temp: "^0.9.0",
  webpack: "^5.23.0",
  "webpack-cli": "^4.5.0",
  yorkie: "^2.0.0"
};
const engines$1 = {
  node: "^10.12.0 || >=12.0.0"
};
const files$1 = ["LICENSE", "README.md", "bin", "conf", "lib", "messages"];
const gitHooks = {
  "pre-commit": "lint-staged"
};
const keywords$1 = ["ast", "lint", "javascript", "ecmascript", "espree"];
const repository$1 = {
  type: "git",
  url: "git+https://github.com/eslint/eslint.git"
};
const scripts$1 = {
  docs: "node Makefile.js docs",
  fix: "node Makefile.js lint -- fix",
  fuzz: "node Makefile.js fuzz",
  "generate-alpharelease": "node Makefile.js generatePrerelease -- alpha",
  "generate-betarelease": "node Makefile.js generatePrerelease -- beta",
  "generate-rcrelease": "node Makefile.js generatePrerelease -- rc",
  "generate-release": "node Makefile.js generateRelease",
  gensite: "node Makefile.js gensite",
  lint: "node Makefile.js lint",
  perf: "node Makefile.js perf",
  "publish-release": "node Makefile.js publishRelease",
  test: "node Makefile.js test",
  "test:cli": "mocha",
  webpack: "node Makefile.js webpack"
};
var _package = {
  _from: "eslint@^7.0.0",
  _id: "eslint@7.24.0",
  _inBundle: false,
  _integrity: "sha512-k9gaHeHiFmGCDQ2rEfvULlSLruz6tgfA8DEn+rY9/oYPFFTlz55mM/Q/Rij1b2Y42jwZiK3lXvNTw6w6TXzcKQ==",
  _location: "/eslint",
  _phantomChildren: _phantomChildren,
  _requested: _requested,
  _requiredBy: _requiredBy,
  _resolved: "https://registry.npmjs.org/eslint/-/eslint-7.24.0.tgz",
  _shasum: "2e44fa62d93892bfdb100521f17345ba54b8513a",
  _spec: "eslint@^7.0.0",
  _where: "/home/runner/work/eslint4b/eslint4b",
  author: author,
  bin: bin,
  bugs: bugs,
  bundleDependencies: false,
  dependencies: dependencies$1,
  deprecated: false,
  description: "An AST-based pattern checker for JavaScript.",
  devDependencies: devDependencies$1,
  engines: engines$1,
  files: files$1,
  funding: "https://opencollective.com/eslint",
  gitHooks: gitHooks,
  homepage: "https://eslint.org",
  keywords: keywords$1,
  license: "MIT",
  "lint-staged": {
    "*.js": ["eslint --fix", "git add"],
    "*.md": "markdownlint"
  },
  main: "./lib/api.js",
  name: "eslint",
  repository: repository$1,
  scripts: scripts$1,
  version: "7.24.0"
};

var _package$1 = Object.freeze({
  __proto__: null,
  _from: "eslint@^7.0.0",
  _id: "eslint@7.24.0",
  _inBundle: false,
  _integrity: "sha512-k9gaHeHiFmGCDQ2rEfvULlSLruz6tgfA8DEn+rY9/oYPFFTlz55mM/Q/Rij1b2Y42jwZiK3lXvNTw6w6TXzcKQ==",
  _location: "/eslint",
  _phantomChildren: _phantomChildren,
  _requested: _requested,
  _requiredBy: _requiredBy,
  _resolved: "https://registry.npmjs.org/eslint/-/eslint-7.24.0.tgz",
  _shasum: "2e44fa62d93892bfdb100521f17345ba54b8513a",
  _spec: "eslint@^7.0.0",
  _where: "/home/runner/work/eslint4b/eslint4b",
  author: author,
  bin: bin,
  bugs: bugs,
  bundleDependencies: false,
  dependencies: dependencies$1,
  deprecated: false,
  description: "An AST-based pattern checker for JavaScript.",
  devDependencies: devDependencies$1,
  engines: engines$1,
  files: files$1,
  funding: "https://opencollective.com/eslint",
  gitHooks: gitHooks,
  homepage: "https://eslint.org",
  keywords: keywords$1,
  license: "MIT",
  main: "./lib/api.js",
  name: "eslint",
  repository: repository$1,
  scripts: scripts$1,
  version: "7.24.0",
  'default': _package
});

var cursor = class {
  constructor() {
    this.current = null;
  }

  getOneToken() {
    return this.moveNext() ? this.current : null;
  }

  getAllTokens() {
    const tokens = [];

    while (this.moveNext()) {
      tokens.push(this.current);
    }

    return tokens;
  }

  moveNext() {
    throw new Error("Not implemented.");
  }

};

function getStartLocation(token) {
  return token.range[0];
}

var search = function (tokens, location) {
  return lodash__default$1['default'].sortedIndexBy(tokens, {
    range: [location]
  }, getStartLocation);
};

var getFirstIndex = function (tokens, indexMap, startLoc) {
  if (startLoc in indexMap) {
    return indexMap[startLoc];
  }

  if (startLoc - 1 in indexMap) {
    const index = indexMap[startLoc - 1];
    const token = index >= 0 && index < tokens.length ? tokens[index] : null;

    if (token && token.range[0] >= startLoc) {
      return index;
    }

    return index + 1;
  }

  return 0;
};

var getLastIndex = function (tokens, indexMap, endLoc) {
  if (endLoc in indexMap) {
    return indexMap[endLoc] - 1;
  }

  if (endLoc - 1 in indexMap) {
    const index = indexMap[endLoc - 1];
    const token = index >= 0 && index < tokens.length ? tokens[index] : null;

    if (token && token.range[1] > endLoc) {
      return index - 1;
    }

    return index;
  }

  return tokens.length - 1;
};

var utils$1 = {
  search: search,
  getFirstIndex: getFirstIndex,
  getLastIndex: getLastIndex
};
var backwardTokenCommentCursor = class extends cursor {
  constructor(tokens, comments, indexMap, startLoc, endLoc) {
    super();
    this.tokens = tokens;
    this.comments = comments;
    this.tokenIndex = utils$1.getLastIndex(tokens, indexMap, endLoc);
    this.commentIndex = utils$1.search(comments, endLoc) - 1;
    this.border = startLoc;
  }

  moveNext() {
    const token = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null;
    const comment = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;

    if (token && (!comment || token.range[1] > comment.range[1])) {
      this.current = token;
      this.tokenIndex -= 1;
    } else if (comment) {
      this.current = comment;
      this.commentIndex -= 1;
    } else {
      this.current = null;
    }

    return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
  }

};
var backwardTokenCursor = class extends cursor {
  constructor(tokens, comments, indexMap, startLoc, endLoc) {
    super();
    this.tokens = tokens;
    this.index = utils$1.getLastIndex(tokens, indexMap, endLoc);
    this.indexEnd = utils$1.getFirstIndex(tokens, indexMap, startLoc);
  }

  moveNext() {
    if (this.index >= this.indexEnd) {
      this.current = this.tokens[this.index];
      this.index -= 1;
      return true;
    }

    return false;
  }

  getOneToken() {
    return this.index >= this.indexEnd ? this.tokens[this.index] : null;
  }

};
var decorativeCursor = class extends cursor {
  constructor(cursor) {
    super();
    this.cursor = cursor;
  }

  moveNext() {
    const retv = this.cursor.moveNext();
    this.current = this.cursor.current;
    return retv;
  }

};
var filterCursor = class extends decorativeCursor {
  constructor(cursor, predicate) {
    super(cursor);
    this.predicate = predicate;
  }

  moveNext() {
    const predicate = this.predicate;

    while (super.moveNext()) {
      if (predicate(this.current)) {
        return true;
      }
    }

    return false;
  }

};
var forwardTokenCommentCursor = class extends cursor {
  constructor(tokens, comments, indexMap, startLoc, endLoc) {
    super();
    this.tokens = tokens;
    this.comments = comments;
    this.tokenIndex = utils$1.getFirstIndex(tokens, indexMap, startLoc);
    this.commentIndex = utils$1.search(comments, startLoc);
    this.border = endLoc;
  }

  moveNext() {
    const token = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null;
    const comment = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;

    if (token && (!comment || token.range[0] < comment.range[0])) {
      this.current = token;
      this.tokenIndex += 1;
    } else if (comment) {
      this.current = comment;
      this.commentIndex += 1;
    } else {
      this.current = null;
    }

    return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
  }

};
var forwardTokenCursor = class extends cursor {
  constructor(tokens, comments, indexMap, startLoc, endLoc) {
    super();
    this.tokens = tokens;
    this.index = utils$1.getFirstIndex(tokens, indexMap, startLoc);
    this.indexEnd = utils$1.getLastIndex(tokens, indexMap, endLoc);
  }

  moveNext() {
    if (this.index <= this.indexEnd) {
      this.current = this.tokens[this.index];
      this.index += 1;
      return true;
    }

    return false;
  }

  getOneToken() {
    return this.index <= this.indexEnd ? this.tokens[this.index] : null;
  }

  getAllTokens() {
    return this.tokens.slice(this.index, this.indexEnd + 1);
  }

};
var limitCursor = class extends decorativeCursor {
  constructor(cursor, count) {
    super(cursor);
    this.count = count;
  }

  moveNext() {
    if (this.count > 0) {
      this.count -= 1;
      return super.moveNext();
    }

    return false;
  }

};
var skipCursor = class extends decorativeCursor {
  constructor(cursor, count) {
    super(cursor);
    this.count = count;
  }

  moveNext() {
    while (this.count > 0) {
      this.count -= 1;

      if (!super.moveNext()) {
        return false;
      }
    }

    return super.moveNext();
  }

};

class CursorFactory {
  constructor(TokenCursor, TokenCommentCursor) {
    this.TokenCursor = TokenCursor;
    this.TokenCommentCursor = TokenCommentCursor;
  }

  createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {
    const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;
    return new Cursor(tokens, comments, indexMap, startLoc, endLoc);
  }

  createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {
    let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);

    if (filter) {
      cursor = new filterCursor(cursor, filter);
    }

    if (skip >= 1) {
      cursor = new skipCursor(cursor, skip);
    }

    if (count >= 0) {
      cursor = new limitCursor(cursor, count);
    }

    return cursor;
  }

}

var forward = new CursorFactory(forwardTokenCursor, forwardTokenCommentCursor);
var backward = new CursorFactory(backwardTokenCursor, backwardTokenCommentCursor);
var cursors = {
  forward: forward,
  backward: backward
};
var paddedTokenCursor = class extends forwardTokenCursor {
  constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
    super(tokens, comments, indexMap, startLoc, endLoc);
    this.index = Math.max(0, this.index - beforeCount);
    this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);
  }

};
const {
  isCommentToken: isCommentToken$1
} = eslintUtils__default$1['default'];
const TOKENS = Symbol("tokens");
const COMMENTS = Symbol("comments");
const INDEX_MAP = Symbol("indexMap");

function createIndexMap(tokens, comments) {
  const map = Object.create(null);
  let tokenIndex = 0;
  let commentIndex = 0;
  let nextStart = 0;
  let range = null;

  while (tokenIndex < tokens.length || commentIndex < comments.length) {
    nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;

    while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {
      map[range[0]] = tokenIndex;
      map[range[1] - 1] = tokenIndex;
      tokenIndex += 1;
    }

    nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;

    while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {
      map[range[0]] = tokenIndex;
      map[range[1] - 1] = tokenIndex;
      commentIndex += 1;
    }
  }

  return map;
}

function createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
  let includeComments = false;
  let skip = 0;
  let filter = null;

  if (typeof opts === "number") {
    skip = opts | 0;
  } else if (typeof opts === "function") {
    filter = opts;
  } else if (opts) {
    includeComments = !!opts.includeComments;
    skip = opts.skip | 0;
    filter = opts.filter || null;
  }

  assert__default['default'](skip >= 0, "options.skip should be zero or a positive integer.");
  assert__default['default'](!filter || typeof filter === "function", "options.filter should be a function.");
  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);
}

function createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
  let includeComments = false;
  let count = 0;
  let countExists = false;
  let filter = null;

  if (typeof opts === "number") {
    count = opts | 0;
    countExists = true;
  } else if (typeof opts === "function") {
    filter = opts;
  } else if (opts) {
    includeComments = !!opts.includeComments;
    count = opts.count | 0;
    countExists = typeof opts.count === "number";
    filter = opts.filter || null;
  }

  assert__default['default'](count >= 0, "options.count should be zero or a positive integer.");
  assert__default['default'](!filter || typeof filter === "function", "options.filter should be a function.");
  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);
}

function createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
  if (typeof beforeCount === "undefined" && typeof afterCount === "undefined") {
    return new forwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);
  }

  if (typeof beforeCount === "number" || typeof beforeCount === "undefined") {
    return new paddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);
  }

  return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);
}

function getAdjacentCommentTokensFromCursor(cursor) {
  const tokens = [];
  let currentToken = cursor.getOneToken();

  while (currentToken && isCommentToken$1(currentToken)) {
    tokens.push(currentToken);
    currentToken = cursor.getOneToken();
  }

  return tokens;
}

var tokenStore = class {
  constructor(tokens, comments) {
    this[TOKENS] = tokens;
    this[COMMENTS] = comments;
    this[INDEX_MAP] = createIndexMap(tokens, comments);
  }

  getTokenByRangeStart(offset, options) {
    const includeComments = options && options.includeComments;
    const token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();

    if (token && token.range[0] === offset) {
      return token;
    }

    return null;
  }

  getFirstToken(node, options) {
    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
  }

  getLastToken(node, options) {
    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
  }

  getTokenBefore(node, options) {
    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();
  }

  getTokenAfter(node, options) {
    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();
  }

  getFirstTokenBetween(left, right, options) {
    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
  }

  getLastTokenBetween(left, right, options) {
    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
  }

  getTokenOrCommentBefore(node, skip) {
    return this.getTokenBefore(node, {
      includeComments: true,
      skip
    });
  }

  getTokenOrCommentAfter(node, skip) {
    return this.getTokenAfter(node, {
      includeComments: true,
      skip
    });
  }

  getFirstTokens(node, options) {
    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();
  }

  getLastTokens(node, options) {
    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();
  }

  getTokensBefore(node, options) {
    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();
  }

  getTokensAfter(node, options) {
    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();
  }

  getFirstTokensBetween(left, right, options) {
    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();
  }

  getLastTokensBetween(left, right, options) {
    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();
  }

  getTokens(node, beforeCount, afterCount) {
    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();
  }

  getTokensBetween(left, right, padding) {
    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();
  }

  commentsExistBetween(left, right) {
    const index = utils$1.search(this[COMMENTS], left.range[1]);
    return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];
  }

  getCommentsBefore(nodeOrToken) {
    const cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], {
      includeComments: true
    });
    return getAdjacentCommentTokensFromCursor(cursor).reverse();
  }

  getCommentsAfter(nodeOrToken) {
    const cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, {
      includeComments: true
    });
    return getAdjacentCommentTokensFromCursor(cursor);
  }

  getCommentsInside(node) {
    return this.getTokens(node, {
      includeComments: true,
      filter: isCommentToken$1
    });
  }

};
const {
  isCommentToken: isCommentToken$2
} = eslintUtils__default$1['default'];

function validate(ast) {
  if (!ast.tokens) {
    throw new Error("AST is missing the tokens array.");
  }

  if (!ast.comments) {
    throw new Error("AST is missing the comments array.");
  }

  if (!ast.loc) {
    throw new Error("AST is missing location information.");
  }

  if (!ast.range) {
    throw new Error("AST is missing range information");
  }
}

function looksLikeExport(astNode) {
  return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" || astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
}

function sortedMerge(tokens, comments) {
  const result = [];
  let tokenIndex = 0;
  let commentIndex = 0;

  while (tokenIndex < tokens.length || commentIndex < comments.length) {
    if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {
      result.push(tokens[tokenIndex++]);
    } else {
      result.push(comments[commentIndex++]);
    }
  }

  return result;
}

function nodesOrTokensOverlap(first, second) {
  return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];
}

function isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {
  if (nodesOrTokensOverlap(first, second)) {
    return false;
  }

  const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];
  const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;
  const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;
  let currentToken = firstToken;

  while (currentToken !== finalToken) {
    const nextToken = sourceCode.getTokenAfter(currentToken, {
      includeComments: true
    });

    if (currentToken.range[1] !== nextToken.range[0] || checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === "JSXText" && /\s/u.test(nextToken.value)) {
      return true;
    }

    currentToken = nextToken;
  }

  return false;
}

class SourceCode$1 extends tokenStore {
  constructor(textOrConfig, astIfNoConfig) {
    let text, ast, parserServices, scopeManager, visitorKeys;

    if (typeof textOrConfig === "string") {
      text = textOrConfig;
      ast = astIfNoConfig;
    } else if (typeof textOrConfig === "object" && textOrConfig !== null) {
      text = textOrConfig.text;
      ast = textOrConfig.ast;
      parserServices = textOrConfig.parserServices;
      scopeManager = textOrConfig.scopeManager;
      visitorKeys = textOrConfig.visitorKeys;
    }

    validate(ast);
    super(ast.tokens, ast.comments);
    this.hasBOM = text.charCodeAt(0) === 0xFEFF;
    this.text = this.hasBOM ? text.slice(1) : text;
    this.ast = ast;
    this.parserServices = parserServices || {};
    this.scopeManager = scopeManager || null;
    this.visitorKeys = visitorKeys || _commonjsHelpers11cbc178.traverser.DEFAULT_VISITOR_KEYS;
    const shebangMatched = this.text.match(_commonjsHelpers11cbc178.astUtils.shebangPattern);
    const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];

    if (hasShebang) {
      ast.comments[0].type = "Shebang";
    }

    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);
    this.lines = [];
    this.lineStartIndices = [0];

    const lineEndingPattern = _commonjsHelpers11cbc178.astUtils.createGlobalLinebreakMatcher();

    let match;

    while (match = lineEndingPattern.exec(this.text)) {
      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
      this.lineStartIndices.push(match.index + match[0].length);
    }

    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));
    this._commentCache = new WeakMap();
    Object.freeze(this);
    Object.freeze(this.lines);
  }

  static splitLines(text) {
    return text.split(_commonjsHelpers11cbc178.astUtils.createGlobalLinebreakMatcher());
  }

  getText(node, beforeCount, afterCount) {
    if (node) {
      return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));
    }

    return this.text;
  }

  getLines() {
    return this.lines;
  }

  getAllComments() {
    return this.ast.comments;
  }

  getComments(node) {
    if (this._commentCache.has(node)) {
      return this._commentCache.get(node);
    }

    const comments = {
      leading: [],
      trailing: []
    };

    if (node.type === "Program") {
      if (node.body.length === 0) {
        comments.leading = node.comments;
      }
    } else {
      if ((node.type === "BlockStatement" || node.type === "ClassBody") && node.body.length === 0 || node.type === "ObjectExpression" && node.properties.length === 0 || node.type === "ArrayExpression" && node.elements.length === 0 || node.type === "SwitchStatement" && node.cases.length === 0) {
        comments.trailing = this.getTokens(node, {
          includeComments: true,
          filter: isCommentToken$2
        });
      }

      let currentToken = this.getTokenBefore(node, {
        includeComments: true
      });

      while (currentToken && isCommentToken$2(currentToken)) {
        if (node.parent && currentToken.start < node.parent.start) {
          break;
        }

        comments.leading.push(currentToken);
        currentToken = this.getTokenBefore(currentToken, {
          includeComments: true
        });
      }

      comments.leading.reverse();
      currentToken = this.getTokenAfter(node, {
        includeComments: true
      });

      while (currentToken && isCommentToken$2(currentToken)) {
        if (node.parent && currentToken.end > node.parent.end) {
          break;
        }

        comments.trailing.push(currentToken);
        currentToken = this.getTokenAfter(currentToken, {
          includeComments: true
        });
      }
    }

    this._commentCache.set(node, comments);

    return comments;
  }

  getJSDocComment(node) {
    const findJSDocComment = astNode => {
      const tokenBefore = this.getTokenBefore(astNode, {
        includeComments: true
      });

      if (tokenBefore && isCommentToken$2(tokenBefore) && tokenBefore.type === "Block" && tokenBefore.value.charAt(0) === "*" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {
        return tokenBefore;
      }

      return null;
    };

    let parent = node.parent;

    switch (node.type) {
      case "ClassDeclaration":
      case "FunctionDeclaration":
        return findJSDocComment(looksLikeExport(parent) ? parent : node);

      case "ClassExpression":
        return findJSDocComment(parent.parent);

      case "ArrowFunctionExpression":
      case "FunctionExpression":
        if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
          while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
            parent = parent.parent;

            if (!parent) {
              break;
            }
          }

          if (parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program") {
            return findJSDocComment(parent);
          }
        }

        return findJSDocComment(node);

      default:
        return null;
    }
  }

  getNodeByRangeIndex(index) {
    let result = null;

    _commonjsHelpers11cbc178.traverser.traverse(this.ast, {
      visitorKeys: this.visitorKeys,

      enter(node) {
        if (node.range[0] <= index && index < node.range[1]) {
          result = node;
        } else {
          this.skip();
        }
      },

      leave(node) {
        if (node === result) {
          this.break();
        }
      }

    });

    return result;
  }

  isSpaceBetween(first, second) {
    return isSpaceBetween(this, first, second, false);
  }

  isSpaceBetweenTokens(first, second) {
    return isSpaceBetween(this, first, second, true);
  }

  getLocFromIndex(index) {
    if (typeof index !== "number") {
      throw new TypeError("Expected `index` to be a number.");
    }

    if (index < 0 || index > this.text.length) {
      throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);
    }

    if (index === this.text.length) {
      return {
        line: this.lines.length,
        column: this.lines[this.lines.length - 1].length
      };
    }

    const lineNumber = lodash__default$1['default'].sortedLastIndex(this.lineStartIndices, index);
    return {
      line: lineNumber,
      column: index - this.lineStartIndices[lineNumber - 1]
    };
  }

  getIndexFromLoc(loc) {
    if (typeof loc !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
      throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
    }

    if (loc.line <= 0) {
      throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);
    }

    if (loc.line > this.lineStartIndices.length) {
      throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);
    }

    const lineStartIndex = this.lineStartIndices[loc.line - 1];
    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
    const positionIndex = lineStartIndex + loc.column;

    if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {
      throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);
    }

    return positionIndex;
  }

}

var sourceCode$1 = SourceCode$1;
var sourceCode = {
  SourceCode: sourceCode$1
};
const debug$3 = debug__default['default']("eslint:code-path");

function getId(segment) {
  return segment.id + (segment.reachable ? "" : "!");
}

function nodeToString(node, label) {
  const suffix = label ? `:${label}` : "";

  switch (node.type) {
    case "Identifier":
      return `${node.type}${suffix} (${node.name})`;

    case "Literal":
      return `${node.type}${suffix} (${node.value})`;

    default:
      return `${node.type}${suffix}`;
  }
}

var debugHelpers = {
  enabled: debug$3.enabled,
  dump: debug$3,
  dumpState: !debug$3.enabled ? debug$3 : function (node, state, leaving) {
    for (let i = 0; i < state.currentSegments.length; ++i) {
      const segInternal = state.currentSegments[i].internal;

      if (leaving) {
        const last = segInternal.nodes.length - 1;

        if (last >= 0 && segInternal.nodes[last] === nodeToString(node, "enter")) {
          segInternal.nodes[last] = nodeToString(node, void 0);
        } else {
          segInternal.nodes.push(nodeToString(node, "exit"));
        }
      } else {
        segInternal.nodes.push(nodeToString(node, "enter"));
      }
    }

    debug$3([`${state.currentSegments.map(getId).join(",")})`, `${node.type}${leaving ? ":exit" : ""}`].join(" "));
  },
  dumpDot: !debug$3.enabled ? debug$3 : function (codePath) {
    let text = "\ndigraph {\nnode[shape=box,style=\"rounded,filled\",fillcolor=white];\ninitial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";

    if (codePath.returnedSegments.length > 0) {
      text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
    }

    if (codePath.thrownSegments.length > 0) {
      text += "thrown[label=\"\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
    }

    const traceMap = Object.create(null);
    const arrows = this.makeDotArrows(codePath, traceMap);

    for (const id in traceMap) {
      const segment = traceMap[id];
      text += `${id}[`;

      if (segment.reachable) {
        text += "label=\"";
      } else {
        text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
      }

      if (segment.internal.nodes.length > 0) {
        text += segment.internal.nodes.join("\\n");
      } else {
        text += "????";
      }

      text += "\"];\n";
    }

    text += `${arrows}\n`;
    text += "}";
    debug$3("DOT", text);
  },

  makeDotArrows(codePath, traceMap) {
    const stack = [[codePath.initialSegment, 0]];
    const done = traceMap || Object.create(null);
    let lastId = codePath.initialSegment.id;
    let text = `initial->${codePath.initialSegment.id}`;

    while (stack.length > 0) {
      const item = stack.pop();
      const segment = item[0];
      const index = item[1];

      if (done[segment.id] && index === 0) {
        continue;
      }

      done[segment.id] = segment;
      const nextSegment = segment.allNextSegments[index];

      if (!nextSegment) {
        continue;
      }

      if (lastId === segment.id) {
        text += `->${nextSegment.id}`;
      } else {
        text += `;\n${segment.id}->${nextSegment.id}`;
      }

      lastId = nextSegment.id;
      stack.unshift([segment, 1 + index]);
      stack.push([nextSegment, 0]);
    }

    codePath.returnedSegments.forEach(finalSegment => {
      if (lastId === finalSegment.id) {
        text += "->final";
      } else {
        text += `;\n${finalSegment.id}->final`;
      }

      lastId = null;
    });
    codePath.thrownSegments.forEach(finalSegment => {
      if (lastId === finalSegment.id) {
        text += "->thrown";
      } else {
        text += `;\n${finalSegment.id}->thrown`;
      }

      lastId = null;
    });
    return `${text};`;
  }

};

function isReachable$1$1(segment) {
  return segment.reachable;
}

class CodePathSegment {
  constructor(id, allPrevSegments, reachable) {
    this.id = id;
    this.nextSegments = [];
    this.prevSegments = allPrevSegments.filter(isReachable$1$1);
    this.allNextSegments = [];
    this.allPrevSegments = allPrevSegments;
    this.reachable = reachable;
    Object.defineProperty(this, "internal", {
      value: {
        used: false,
        loopedPrevSegments: []
      }
    });

    if (debugHelpers.enabled) {
      this.internal.nodes = [];
    }
  }

  isLoopedPrevSegment(segment) {
    return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
  }

  static newRoot(id) {
    return new CodePathSegment(id, [], true);
  }

  static newNext(id, allPrevSegments) {
    return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable$1$1));
  }

  static newUnreachable(id, allPrevSegments) {
    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);
    CodePathSegment.markUsed(segment);
    return segment;
  }

  static newDisconnected(id, allPrevSegments) {
    return new CodePathSegment(id, [], allPrevSegments.some(isReachable$1$1));
  }

  static markUsed(segment) {
    if (segment.internal.used) {
      return;
    }

    segment.internal.used = true;
    let i;

    if (segment.reachable) {
      for (i = 0; i < segment.allPrevSegments.length; ++i) {
        const prevSegment = segment.allPrevSegments[i];
        prevSegment.allNextSegments.push(segment);
        prevSegment.nextSegments.push(segment);
      }
    } else {
      for (i = 0; i < segment.allPrevSegments.length; ++i) {
        segment.allPrevSegments[i].allNextSegments.push(segment);
      }
    }
  }

  static markPrevSegmentAsLooped(segment, prevSegment) {
    segment.internal.loopedPrevSegments.push(prevSegment);
  }

  static flattenUnusedSegments(segments) {
    const done = Object.create(null);
    const retv = [];

    for (let i = 0; i < segments.length; ++i) {
      const segment = segments[i];

      if (done[segment.id]) {
        continue;
      }

      if (!segment.internal.used) {
        for (let j = 0; j < segment.allPrevSegments.length; ++j) {
          const prevSegment = segment.allPrevSegments[j];

          if (!done[prevSegment.id]) {
            done[prevSegment.id] = true;
            retv.push(prevSegment);
          }
        }
      } else {
        done[segment.id] = true;
        retv.push(segment);
      }
    }

    return retv;
  }

}

var codePathSegment = CodePathSegment;

function isReachable$4(segment) {
  return segment.reachable;
}

function makeSegments(context, begin, end, create) {
  const list = context.segmentsList;
  const normalizedBegin = begin >= 0 ? begin : list.length + begin;
  const normalizedEnd = end >= 0 ? end : list.length + end;
  const segments = [];

  for (let i = 0; i < context.count; ++i) {
    const allPrevSegments = [];

    for (let j = normalizedBegin; j <= normalizedEnd; ++j) {
      allPrevSegments.push(list[j][i]);
    }

    segments.push(create(context.idGenerator.next(), allPrevSegments));
  }

  return segments;
}

function mergeExtraSegments(context, segments) {
  let currentSegments = segments;

  while (currentSegments.length > context.count) {
    const merged = [];

    for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {
      merged.push(codePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));
    }

    currentSegments = merged;
  }

  return currentSegments;
}

class ForkContext {
  constructor(idGenerator, upper, count) {
    this.idGenerator = idGenerator;
    this.upper = upper;
    this.count = count;
    this.segmentsList = [];
  }

  get head() {
    const list = this.segmentsList;
    return list.length === 0 ? [] : list[list.length - 1];
  }

  get empty() {
    return this.segmentsList.length === 0;
  }

  get reachable() {
    const segments = this.head;
    return segments.length > 0 && segments.some(isReachable$4);
  }

  makeNext(begin, end) {
    return makeSegments(this, begin, end, codePathSegment.newNext);
  }

  makeUnreachable(begin, end) {
    return makeSegments(this, begin, end, codePathSegment.newUnreachable);
  }

  makeDisconnected(begin, end) {
    return makeSegments(this, begin, end, codePathSegment.newDisconnected);
  }

  add(segments) {
    assert__default['default'](segments.length >= this.count, `${segments.length} >= ${this.count}`);
    this.segmentsList.push(mergeExtraSegments(this, segments));
  }

  replaceHead(segments) {
    assert__default['default'](segments.length >= this.count, `${segments.length} >= ${this.count}`);
    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
  }

  addAll(context) {
    assert__default['default'](context.count === this.count);
    const source = context.segmentsList;

    for (let i = 0; i < source.length; ++i) {
      this.segmentsList.push(source[i]);
    }
  }

  clear() {
    this.segmentsList = [];
  }

  static newRoot(idGenerator) {
    const context = new ForkContext(idGenerator, null, 1);
    context.add([codePathSegment.newRoot(idGenerator.next())]);
    return context;
  }

  static newEmpty(parentContext, forkLeavingPath) {
    return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);
  }

}

var forkContext = ForkContext;

function addToReturnedOrThrown(dest, others, all, segments) {
  for (let i = 0; i < segments.length; ++i) {
    const segment = segments[i];
    dest.push(segment);

    if (others.indexOf(segment) === -1) {
      all.push(segment);
    }
  }
}

function getContinueContext(state, label) {
  if (!label) {
    return state.loopContext;
  }

  let context = state.loopContext;

  while (context) {
    if (context.label === label) {
      return context;
    }

    context = context.upper;
  }

  return null;
}

function getBreakContext(state, label) {
  let context = state.breakContext;

  while (context) {
    if (label ? context.label === label : context.breakable) {
      return context;
    }

    context = context.upper;
  }

  return null;
}

function getReturnContext(state) {
  let context = state.tryContext;

  while (context) {
    if (context.hasFinalizer && context.position !== "finally") {
      return context;
    }

    context = context.upper;
  }

  return state;
}

function getThrowContext(state) {
  let context = state.tryContext;

  while (context) {
    if (context.position === "try" || context.hasFinalizer && context.position === "catch") {
      return context;
    }

    context = context.upper;
  }

  return state;
}

function remove$1(xs, x) {
  xs.splice(xs.indexOf(x), 1);
}

function removeConnection(prevSegments, nextSegments) {
  for (let i = 0; i < prevSegments.length; ++i) {
    const prevSegment = prevSegments[i];
    const nextSegment = nextSegments[i];
    remove$1(prevSegment.nextSegments, nextSegment);
    remove$1(prevSegment.allNextSegments, nextSegment);
    remove$1(nextSegment.prevSegments, prevSegment);
    remove$1(nextSegment.allPrevSegments, prevSegment);
  }
}

function makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {
  const fromSegments = codePathSegment.flattenUnusedSegments(unflattenedFromSegments);
  const toSegments = codePathSegment.flattenUnusedSegments(unflattenedToSegments);
  const end = Math.min(fromSegments.length, toSegments.length);

  for (let i = 0; i < end; ++i) {
    const fromSegment = fromSegments[i];
    const toSegment = toSegments[i];

    if (toSegment.reachable) {
      fromSegment.nextSegments.push(toSegment);
    }

    if (fromSegment.reachable) {
      toSegment.prevSegments.push(fromSegment);
    }

    fromSegment.allNextSegments.push(toSegment);
    toSegment.allPrevSegments.push(fromSegment);

    if (toSegment.allPrevSegments.length >= 2) {
      codePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
    }

    state.notifyLooped(fromSegment, toSegment);
  }
}

function finalizeTestSegmentsOfFor(context, choiceContext, head) {
  if (!choiceContext.processed) {
    choiceContext.trueForkContext.add(head);
    choiceContext.falseForkContext.add(head);
    choiceContext.qqForkContext.add(head);
  }

  if (context.test !== true) {
    context.brokenForkContext.addAll(choiceContext.falseForkContext);
  }

  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}

class CodePathState {
  constructor(idGenerator, onLooped) {
    this.idGenerator = idGenerator;
    this.notifyLooped = onLooped;
    this.forkContext = forkContext.newRoot(idGenerator);
    this.choiceContext = null;
    this.switchContext = null;
    this.tryContext = null;
    this.loopContext = null;
    this.breakContext = null;
    this.chainContext = null;
    this.currentSegments = [];
    this.initialSegment = this.forkContext.head[0];
    const final = this.finalSegments = [];
    const returned = this.returnedForkContext = [];
    const thrown = this.thrownForkContext = [];
    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
  }

  get headSegments() {
    return this.forkContext.head;
  }

  get parentForkContext() {
    const current = this.forkContext;
    return current && current.upper;
  }

  pushForkContext(forkLeavingPath) {
    this.forkContext = forkContext.newEmpty(this.forkContext, forkLeavingPath);
    return this.forkContext;
  }

  popForkContext() {
    const lastContext = this.forkContext;
    this.forkContext = lastContext.upper;
    this.forkContext.replaceHead(lastContext.makeNext(0, -1));
    return lastContext;
  }

  forkPath() {
    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
  }

  forkBypassPath() {
    this.forkContext.add(this.parentForkContext.head);
  }

  pushChoiceContext(kind, isForkingAsResult) {
    this.choiceContext = {
      upper: this.choiceContext,
      kind,
      isForkingAsResult,
      trueForkContext: forkContext.newEmpty(this.forkContext),
      falseForkContext: forkContext.newEmpty(this.forkContext),
      qqForkContext: forkContext.newEmpty(this.forkContext),
      processed: false
    };
  }

  popChoiceContext() {
    const context = this.choiceContext;
    this.choiceContext = context.upper;
    const forkContext = this.forkContext;
    const headSegments = forkContext.head;

    switch (context.kind) {
      case "&&":
      case "||":
      case "??":
        if (!context.processed) {
          context.trueForkContext.add(headSegments);
          context.falseForkContext.add(headSegments);
          context.qqForkContext.add(headSegments);
        }

        if (context.isForkingAsResult) {
          const parentContext = this.choiceContext;
          parentContext.trueForkContext.addAll(context.trueForkContext);
          parentContext.falseForkContext.addAll(context.falseForkContext);
          parentContext.qqForkContext.addAll(context.qqForkContext);
          parentContext.processed = true;
          return context;
        }

        break;

      case "test":
        if (!context.processed) {
          context.trueForkContext.clear();
          context.trueForkContext.add(headSegments);
        } else {
          context.falseForkContext.clear();
          context.falseForkContext.add(headSegments);
        }

        break;

      case "loop":
        return context;

      default:
        throw new Error("unreachable");
    }

    const prevForkContext = context.trueForkContext;
    prevForkContext.addAll(context.falseForkContext);
    forkContext.replaceHead(prevForkContext.makeNext(0, -1));
    return context;
  }

  makeLogicalRight() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;

    if (context.processed) {
      let prevForkContext;

      switch (context.kind) {
        case "&&":
          prevForkContext = context.trueForkContext;
          break;

        case "||":
          prevForkContext = context.falseForkContext;
          break;

        case "??":
          prevForkContext = context.qqForkContext;
          break;

        default:
          throw new Error("unreachable");
      }

      forkContext.replaceHead(prevForkContext.makeNext(0, -1));
      prevForkContext.clear();
      context.processed = false;
    } else {
      switch (context.kind) {
        case "&&":
          context.falseForkContext.add(forkContext.head);
          break;

        case "||":
          context.trueForkContext.add(forkContext.head);
          break;

        case "??":
          context.trueForkContext.add(forkContext.head);
          context.falseForkContext.add(forkContext.head);
          break;

        default:
          throw new Error("unreachable");
      }

      forkContext.replaceHead(forkContext.makeNext(-1, -1));
    }
  }

  makeIfConsequent() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;

    if (!context.processed) {
      context.trueForkContext.add(forkContext.head);
      context.falseForkContext.add(forkContext.head);
      context.qqForkContext.add(forkContext.head);
    }

    context.processed = false;
    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));
  }

  makeIfAlternate() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;
    context.trueForkContext.clear();
    context.trueForkContext.add(forkContext.head);
    context.processed = true;
    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));
  }

  pushChainContext() {
    this.chainContext = {
      upper: this.chainContext,
      countChoiceContexts: 0
    };
  }

  popChainContext() {
    const context = this.chainContext;
    this.chainContext = context.upper;

    for (let i = context.countChoiceContexts; i > 0; --i) {
      this.popChoiceContext();
    }
  }

  makeOptionalNode() {
    if (this.chainContext) {
      this.chainContext.countChoiceContexts += 1;
      this.pushChoiceContext("??", false);
    }
  }

  makeOptionalRight() {
    if (this.chainContext) {
      this.makeLogicalRight();
    }
  }

  pushSwitchContext(hasCase, label) {
    this.switchContext = {
      upper: this.switchContext,
      hasCase,
      defaultSegments: null,
      defaultBodySegments: null,
      foundDefault: false,
      lastIsDefault: false,
      countForks: 0
    };
    this.pushBreakContext(true, label);
  }

  popSwitchContext() {
    const context = this.switchContext;
    this.switchContext = context.upper;
    const forkContext = this.forkContext;
    const brokenForkContext = this.popBreakContext().brokenForkContext;

    if (context.countForks === 0) {
      if (!brokenForkContext.empty) {
        brokenForkContext.add(forkContext.makeNext(-1, -1));
        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }

      return;
    }

    const lastSegments = forkContext.head;
    this.forkBypassPath();
    const lastCaseSegments = forkContext.head;
    brokenForkContext.add(lastSegments);

    if (!context.lastIsDefault) {
      if (context.defaultBodySegments) {
        removeConnection(context.defaultSegments, context.defaultBodySegments);
        makeLooped(this, lastCaseSegments, context.defaultBodySegments);
      } else {
        brokenForkContext.add(lastCaseSegments);
      }
    }

    for (let i = 0; i < context.countForks; ++i) {
      this.forkContext = this.forkContext.upper;
    }

    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
  }

  makeSwitchCaseBody(isEmpty, isDefault) {
    const context = this.switchContext;

    if (!context.hasCase) {
      return;
    }

    const parentForkContext = this.forkContext;
    const forkContext = this.pushForkContext();
    forkContext.add(parentForkContext.makeNext(0, -1));

    if (isDefault) {
      context.defaultSegments = parentForkContext.head;

      if (isEmpty) {
        context.foundDefault = true;
      } else {
        context.defaultBodySegments = forkContext.head;
      }
    } else {
      if (!isEmpty && context.foundDefault) {
        context.foundDefault = false;
        context.defaultBodySegments = forkContext.head;
      }
    }

    context.lastIsDefault = isDefault;
    context.countForks += 1;
  }

  pushTryContext(hasFinalizer) {
    this.tryContext = {
      upper: this.tryContext,
      position: "try",
      hasFinalizer,
      returnedForkContext: hasFinalizer ? forkContext.newEmpty(this.forkContext) : null,
      thrownForkContext: forkContext.newEmpty(this.forkContext),
      lastOfTryIsReachable: false,
      lastOfCatchIsReachable: false
    };
  }

  popTryContext() {
    const context = this.tryContext;
    this.tryContext = context.upper;

    if (context.position === "catch") {
      this.popForkContext();
      return;
    }

    const returned = context.returnedForkContext;
    const thrown = context.thrownForkContext;

    if (returned.empty && thrown.empty) {
      return;
    }

    const headSegments = this.forkContext.head;
    this.forkContext = this.forkContext.upper;
    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);

    if (!returned.empty) {
      getReturnContext(this).returnedForkContext.add(leavingSegments);
    }

    if (!thrown.empty) {
      getThrowContext(this).thrownForkContext.add(leavingSegments);
    }

    this.forkContext.replaceHead(normalSegments);

    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
      this.forkContext.makeUnreachable();
    }
  }

  makeCatchBlock() {
    const context = this.tryContext;
    const forkContext$1 = this.forkContext;
    const thrown = context.thrownForkContext;
    context.position = "catch";
    context.thrownForkContext = forkContext.newEmpty(forkContext$1);
    context.lastOfTryIsReachable = forkContext$1.reachable;
    thrown.add(forkContext$1.head);
    const thrownSegments = thrown.makeNext(0, -1);
    this.pushForkContext();
    this.forkBypassPath();
    this.forkContext.add(thrownSegments);
  }

  makeFinallyBlock() {
    const context = this.tryContext;
    let forkContext = this.forkContext;
    const returned = context.returnedForkContext;
    const thrown = context.thrownForkContext;
    const headOfLeavingSegments = forkContext.head;

    if (context.position === "catch") {
      this.popForkContext();
      forkContext = this.forkContext;
      context.lastOfCatchIsReachable = forkContext.reachable;
    } else {
      context.lastOfTryIsReachable = forkContext.reachable;
    }

    context.position = "finally";

    if (returned.empty && thrown.empty) {
      return;
    }

    const segments = forkContext.makeNext(-1, -1);

    for (let i = 0; i < forkContext.count; ++i) {
      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];

      for (let j = 0; j < returned.segmentsList.length; ++j) {
        prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
      }

      for (let j = 0; j < thrown.segmentsList.length; ++j) {
        prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
      }

      segments.push(codePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));
    }

    this.pushForkContext(true);
    this.forkContext.add(segments);
  }

  makeFirstThrowablePathInTryBlock() {
    const forkContext = this.forkContext;

    if (!forkContext.reachable) {
      return;
    }

    const context = getThrowContext(this);

    if (context === this || context.position !== "try" || !context.thrownForkContext.empty) {
      return;
    }

    context.thrownForkContext.add(forkContext.head);
    forkContext.replaceHead(forkContext.makeNext(-1, -1));
  }

  pushLoopContext(type, label) {
    const forkContext$1 = this.forkContext;
    const breakContext = this.pushBreakContext(true, label);

    switch (type) {
      case "WhileStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext
        };
        break;

      case "DoWhileStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          entrySegments: null,
          continueForkContext: forkContext.newEmpty(forkContext$1),
          brokenForkContext: breakContext.brokenForkContext
        };
        break;

      case "ForStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          endOfInitSegments: null,
          testSegments: null,
          endOfTestSegments: null,
          updateSegments: null,
          endOfUpdateSegments: null,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext
        };
        break;

      case "ForInStatement":
      case "ForOfStatement":
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          prevSegments: null,
          leftSegments: null,
          endOfLeftSegments: null,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext
        };
        break;

      default:
        throw new Error(`unknown type: "${type}"`);
    }
  }

  popLoopContext() {
    const context = this.loopContext;
    this.loopContext = context.upper;
    const forkContext = this.forkContext;
    const brokenForkContext = this.popBreakContext().brokenForkContext;

    switch (context.type) {
      case "WhileStatement":
      case "ForStatement":
        this.popChoiceContext();
        makeLooped(this, forkContext.head, context.continueDestSegments);
        break;

      case "DoWhileStatement":
        {
          const choiceContext = this.popChoiceContext();

          if (!choiceContext.processed) {
            choiceContext.trueForkContext.add(forkContext.head);
            choiceContext.falseForkContext.add(forkContext.head);
          }

          if (context.test !== true) {
            brokenForkContext.addAll(choiceContext.falseForkContext);
          }

          const segmentsList = choiceContext.trueForkContext.segmentsList;

          for (let i = 0; i < segmentsList.length; ++i) {
            makeLooped(this, segmentsList[i], context.entrySegments);
          }

          break;
        }

      case "ForInStatement":
      case "ForOfStatement":
        brokenForkContext.add(forkContext.head);
        makeLooped(this, forkContext.head, context.leftSegments);
        break;

      default:
        throw new Error("unreachable");
    }

    if (brokenForkContext.empty) {
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    } else {
      forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
    }
  }

  makeWhileTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const testSegments = forkContext.makeNext(0, -1);
    context.test = test;
    context.continueDestSegments = testSegments;
    forkContext.replaceHead(testSegments);
  }

  makeWhileBody() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext = this.forkContext;

    if (!choiceContext.processed) {
      choiceContext.trueForkContext.add(forkContext.head);
      choiceContext.falseForkContext.add(forkContext.head);
    }

    if (context.test !== true) {
      context.brokenForkContext.addAll(choiceContext.falseForkContext);
    }

    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
  }

  makeDoWhileBody() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const bodySegments = forkContext.makeNext(-1, -1);
    context.entrySegments = bodySegments;
    forkContext.replaceHead(bodySegments);
  }

  makeDoWhileTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    context.test = test;

    if (!context.continueForkContext.empty) {
      context.continueForkContext.add(forkContext.head);
      const testSegments = context.continueForkContext.makeNext(0, -1);
      forkContext.replaceHead(testSegments);
    }
  }

  makeForTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const endOfInitSegments = forkContext.head;
    const testSegments = forkContext.makeNext(-1, -1);
    context.test = test;
    context.endOfInitSegments = endOfInitSegments;
    context.continueDestSegments = context.testSegments = testSegments;
    forkContext.replaceHead(testSegments);
  }

  makeForUpdate() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext = this.forkContext;

    if (context.testSegments) {
      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
    } else {
      context.endOfInitSegments = forkContext.head;
    }

    const updateSegments = forkContext.makeDisconnected(-1, -1);
    context.continueDestSegments = context.updateSegments = updateSegments;
    forkContext.replaceHead(updateSegments);
  }

  makeForBody() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext$1 = this.forkContext;

    if (context.updateSegments) {
      context.endOfUpdateSegments = forkContext$1.head;

      if (context.testSegments) {
        makeLooped(this, context.endOfUpdateSegments, context.testSegments);
      }
    } else if (context.testSegments) {
      finalizeTestSegmentsOfFor(context, choiceContext, forkContext$1.head);
    } else {
      context.endOfInitSegments = forkContext$1.head;
    }

    let bodySegments = context.endOfTestSegments;

    if (!bodySegments) {
      const prevForkContext = forkContext.newEmpty(forkContext$1);
      prevForkContext.add(context.endOfInitSegments);

      if (context.endOfUpdateSegments) {
        prevForkContext.add(context.endOfUpdateSegments);
      }

      bodySegments = prevForkContext.makeNext(0, -1);
    }

    context.continueDestSegments = context.continueDestSegments || bodySegments;
    forkContext$1.replaceHead(bodySegments);
  }

  makeForInOfLeft() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const leftSegments = forkContext.makeDisconnected(-1, -1);
    context.prevSegments = forkContext.head;
    context.leftSegments = context.continueDestSegments = leftSegments;
    forkContext.replaceHead(leftSegments);
  }

  makeForInOfRight() {
    const context = this.loopContext;
    const forkContext$1 = this.forkContext;
    const temp = forkContext.newEmpty(forkContext$1);
    temp.add(context.prevSegments);
    const rightSegments = temp.makeNext(-1, -1);
    context.endOfLeftSegments = forkContext$1.head;
    forkContext$1.replaceHead(rightSegments);
  }

  makeForInOfBody() {
    const context = this.loopContext;
    const forkContext$1 = this.forkContext;
    const temp = forkContext.newEmpty(forkContext$1);
    temp.add(context.endOfLeftSegments);
    const bodySegments = temp.makeNext(-1, -1);
    makeLooped(this, forkContext$1.head, context.leftSegments);
    context.brokenForkContext.add(forkContext$1.head);
    forkContext$1.replaceHead(bodySegments);
  }

  pushBreakContext(breakable, label) {
    this.breakContext = {
      upper: this.breakContext,
      breakable,
      label,
      brokenForkContext: forkContext.newEmpty(this.forkContext)
    };
    return this.breakContext;
  }

  popBreakContext() {
    const context = this.breakContext;
    const forkContext = this.forkContext;
    this.breakContext = context.upper;

    if (!context.breakable) {
      const brokenForkContext = context.brokenForkContext;

      if (!brokenForkContext.empty) {
        brokenForkContext.add(forkContext.head);
        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }
    }

    return context;
  }

  makeBreak(label) {
    const forkContext = this.forkContext;

    if (!forkContext.reachable) {
      return;
    }

    const context = getBreakContext(this, label);

    if (context) {
      context.brokenForkContext.add(forkContext.head);
    }

    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
  }

  makeContinue(label) {
    const forkContext = this.forkContext;

    if (!forkContext.reachable) {
      return;
    }

    const context = getContinueContext(this, label);

    if (context) {
      if (context.continueDestSegments) {
        makeLooped(this, forkContext.head, context.continueDestSegments);

        if (context.type === "ForInStatement" || context.type === "ForOfStatement") {
          context.brokenForkContext.add(forkContext.head);
        }
      } else {
        context.continueForkContext.add(forkContext.head);
      }
    }

    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
  }

  makeReturn() {
    const forkContext = this.forkContext;

    if (forkContext.reachable) {
      getReturnContext(this).returnedForkContext.add(forkContext.head);
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }
  }

  makeThrow() {
    const forkContext = this.forkContext;

    if (forkContext.reachable) {
      getThrowContext(this).thrownForkContext.add(forkContext.head);
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }
  }

  makeFinal() {
    const segments = this.currentSegments;

    if (segments.length > 0 && segments[0].reachable) {
      this.returnedForkContext.add(segments);
    }
  }

}

var codePathState = CodePathState;

class IdGenerator {
  constructor(prefix) {
    this.prefix = String(prefix);
    this.n = 0;
  }

  next() {
    this.n = 1 + this.n | 0;

    if (this.n < 0) {
      this.n = 1;
    }

    return this.prefix + this.n;
  }

}

var idGenerator = IdGenerator;

class CodePath {
  constructor(id, upper, onLooped) {
    this.id = id;
    this.upper = upper;
    this.childCodePaths = [];
    Object.defineProperty(this, "internal", {
      value: new codePathState(new idGenerator(`${id}_`), onLooped)
    });

    if (upper) {
      upper.childCodePaths.push(this);
    }
  }

  static getState(codePath) {
    return codePath.internal;
  }

  get initialSegment() {
    return this.internal.initialSegment;
  }

  get finalSegments() {
    return this.internal.finalSegments;
  }

  get returnedSegments() {
    return this.internal.returnedForkContext;
  }

  get thrownSegments() {
    return this.internal.thrownForkContext;
  }

  get currentSegments() {
    return this.internal.currentSegments;
  }

  traverseSegments(options, callback) {
    let resolvedOptions;
    let resolvedCallback;

    if (typeof options === "function") {
      resolvedCallback = options;
      resolvedOptions = {};
    } else {
      resolvedOptions = options || {};
      resolvedCallback = callback;
    }

    const startSegment = resolvedOptions.first || this.internal.initialSegment;
    const lastSegment = resolvedOptions.last;
    let item = null;
    let index = 0;
    let end = 0;
    let segment = null;
    const visited = Object.create(null);
    const stack = [[startSegment, 0]];
    let skippedSegment = null;
    let broken = false;
    const controller = {
      skip() {
        if (stack.length <= 1) {
          broken = true;
        } else {
          skippedSegment = stack[stack.length - 2][0];
        }
      },

      break() {
        broken = true;
      }

    };

    function isVisited(prevSegment) {
      return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);
    }

    while (stack.length > 0) {
      item = stack[stack.length - 1];
      segment = item[0];
      index = item[1];

      if (index === 0) {
        if (visited[segment.id]) {
          stack.pop();
          continue;
        }

        if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
          stack.pop();
          continue;
        }

        if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
          skippedSegment = null;
        }

        visited[segment.id] = true;

        if (!skippedSegment) {
          resolvedCallback.call(this, segment, controller);

          if (segment === lastSegment) {
            controller.skip();
          }

          if (broken) {
            break;
          }
        }
      }

      end = segment.nextSegments.length - 1;

      if (index < end) {
        item[1] += 1;
        stack.push([segment.nextSegments[index], 0]);
      } else if (index === end) {
        item[0] = segment.nextSegments[index];
        item[1] = 0;
      } else {
        stack.pop();
      }
    }
  }

}

var codePath = CodePath;
const {
  breakableTypePattern
} = _commonjsHelpers11cbc178.astUtils;

function isCaseNode(node) {
  return Boolean(node.test);
}

function isHandledLogicalOperator(operator) {
  return operator === "&&" || operator === "||" || operator === "??";
}

function isLogicalAssignmentOperator(operator) {
  return operator === "&&=" || operator === "||=" || operator === "??=";
}

function getLabel(node) {
  if (node.parent.type === "LabeledStatement") {
    return node.parent.label.name;
  }

  return null;
}

function isForkingByTrueOrFalse(node) {
  const parent = node.parent;

  switch (parent.type) {
    case "ConditionalExpression":
    case "IfStatement":
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
      return parent.test === node;

    case "LogicalExpression":
      return isHandledLogicalOperator(parent.operator);

    case "AssignmentExpression":
      return isLogicalAssignmentOperator(parent.operator);

    default:
      return false;
  }
}

function getBooleanValueIfSimpleConstant(node) {
  if (node.type === "Literal") {
    return Boolean(node.value);
  }

  return void 0;
}

function isIdentifierReference(node) {
  const parent = node.parent;

  switch (parent.type) {
    case "LabeledStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "ArrayPattern":
    case "RestElement":
    case "ImportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "CatchClause":
      return false;

    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "ClassDeclaration":
    case "ClassExpression":
    case "VariableDeclarator":
      return parent.id !== node;

    case "Property":
    case "MethodDefinition":
      return parent.key !== node || parent.computed || parent.shorthand;

    case "AssignmentPattern":
      return parent.key !== node;

    default:
      return true;
  }
}

function forwardCurrentToHead(analyzer, node) {
  const codePath$1 = analyzer.codePath;
  const state = codePath.getState(codePath$1);
  const currentSegments = state.currentSegments;
  const headSegments = state.headSegments;
  const end = Math.max(currentSegments.length, headSegments.length);
  let i, currentSegment, headSegment;

  for (i = 0; i < end; ++i) {
    currentSegment = currentSegments[i];
    headSegment = headSegments[i];

    if (currentSegment !== headSegment && currentSegment) {
      debugHelpers.dump(`onCodePathSegmentEnd ${currentSegment.id}`);

      if (currentSegment.reachable) {
        analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
      }
    }
  }

  state.currentSegments = headSegments;

  for (i = 0; i < end; ++i) {
    currentSegment = currentSegments[i];
    headSegment = headSegments[i];

    if (currentSegment !== headSegment && headSegment) {
      debugHelpers.dump(`onCodePathSegmentStart ${headSegment.id}`);
      codePathSegment.markUsed(headSegment);

      if (headSegment.reachable) {
        analyzer.emitter.emit("onCodePathSegmentStart", headSegment, node);
      }
    }
  }
}

function leaveFromCurrentSegment(analyzer, node) {
  const state = codePath.getState(analyzer.codePath);
  const currentSegments = state.currentSegments;

  for (let i = 0; i < currentSegments.length; ++i) {
    const currentSegment = currentSegments[i];
    debugHelpers.dump(`onCodePathSegmentEnd ${currentSegment.id}`);

    if (currentSegment.reachable) {
      analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
    }
  }

  state.currentSegments = [];
}

function preprocess(analyzer, node) {
  const codePath$1 = analyzer.codePath;
  const state = codePath.getState(codePath$1);
  const parent = node.parent;

  switch (parent.type) {
    case "CallExpression":
      if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {
        state.makeOptionalRight();
      }

      break;

    case "MemberExpression":
      if (parent.optional === true && parent.property === node) {
        state.makeOptionalRight();
      }

      break;

    case "LogicalExpression":
      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {
        state.makeLogicalRight();
      }

      break;

    case "AssignmentExpression":
      if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {
        state.makeLogicalRight();
      }

      break;

    case "ConditionalExpression":
    case "IfStatement":
      if (parent.consequent === node) {
        state.makeIfConsequent();
      } else if (parent.alternate === node) {
        state.makeIfAlternate();
      }

      break;

    case "SwitchCase":
      if (parent.consequent[0] === node) {
        state.makeSwitchCaseBody(false, !parent.test);
      }

      break;

    case "TryStatement":
      if (parent.handler === node) {
        state.makeCatchBlock();
      } else if (parent.finalizer === node) {
        state.makeFinallyBlock();
      }

      break;

    case "WhileStatement":
      if (parent.test === node) {
        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
      } else {
        assert__default['default'](parent.body === node);
        state.makeWhileBody();
      }

      break;

    case "DoWhileStatement":
      if (parent.body === node) {
        state.makeDoWhileBody();
      } else {
        assert__default['default'](parent.test === node);
        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
      }

      break;

    case "ForStatement":
      if (parent.test === node) {
        state.makeForTest(getBooleanValueIfSimpleConstant(node));
      } else if (parent.update === node) {
        state.makeForUpdate();
      } else if (parent.body === node) {
        state.makeForBody();
      }

      break;

    case "ForInStatement":
    case "ForOfStatement":
      if (parent.left === node) {
        state.makeForInOfLeft();
      } else if (parent.right === node) {
        state.makeForInOfRight();
      } else {
        assert__default['default'](parent.body === node);
        state.makeForInOfBody();
      }

      break;

    case "AssignmentPattern":
      if (parent.right === node) {
        state.pushForkContext();
        state.forkBypassPath();
        state.forkPath();
      }

      break;
  }
}

function processCodePathToEnter(analyzer, node) {
  let codePath$1 = analyzer.codePath;
  let state = codePath$1 && codePath.getState(codePath$1);
  const parent = node.parent;

  switch (node.type) {
    case "Program":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      if (codePath$1) {
        forwardCurrentToHead(analyzer, node);
        debugHelpers.dumpState(node, state, false);
      }

      codePath$1 = analyzer.codePath = new codePath(analyzer.idGenerator.next(), codePath$1, analyzer.onLooped);
      state = codePath.getState(codePath$1);
      debugHelpers.dump(`onCodePathStart ${codePath$1.id}`);
      analyzer.emitter.emit("onCodePathStart", codePath$1, node);
      break;

    case "ChainExpression":
      state.pushChainContext();
      break;

    case "CallExpression":
      if (node.optional === true) {
        state.makeOptionalNode();
      }

      break;

    case "MemberExpression":
      if (node.optional === true) {
        state.makeOptionalNode();
      }

      break;

    case "LogicalExpression":
      if (isHandledLogicalOperator(node.operator)) {
        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
      }

      break;

    case "AssignmentExpression":
      if (isLogicalAssignmentOperator(node.operator)) {
        state.pushChoiceContext(node.operator.slice(0, -1), isForkingByTrueOrFalse(node));
      }

      break;

    case "ConditionalExpression":
    case "IfStatement":
      state.pushChoiceContext("test", false);
      break;

    case "SwitchStatement":
      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));
      break;

    case "TryStatement":
      state.pushTryContext(Boolean(node.finalizer));
      break;

    case "SwitchCase":
      if (parent.discriminant !== node && parent.cases[0] !== node) {
        state.forkPath();
      }

      break;

    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      state.pushLoopContext(node.type, getLabel(node));
      break;

    case "LabeledStatement":
      if (!breakableTypePattern.test(node.body.type)) {
        state.pushBreakContext(false, node.label.name);
      }

      break;
  }

  forwardCurrentToHead(analyzer, node);
  debugHelpers.dumpState(node, state, false);
}

function processCodePathToExit(analyzer, node) {
  const codePath$1 = analyzer.codePath;
  const state = codePath.getState(codePath$1);
  let dontForward = false;

  switch (node.type) {
    case "ChainExpression":
      state.popChainContext();
      break;

    case "IfStatement":
    case "ConditionalExpression":
      state.popChoiceContext();
      break;

    case "LogicalExpression":
      if (isHandledLogicalOperator(node.operator)) {
        state.popChoiceContext();
      }

      break;

    case "AssignmentExpression":
      if (isLogicalAssignmentOperator(node.operator)) {
        state.popChoiceContext();
      }

      break;

    case "SwitchStatement":
      state.popSwitchContext();
      break;

    case "SwitchCase":
      if (node.consequent.length === 0) {
        state.makeSwitchCaseBody(true, !node.test);
      }

      if (state.forkContext.reachable) {
        dontForward = true;
      }

      break;

    case "TryStatement":
      state.popTryContext();
      break;

    case "BreakStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeBreak(node.label && node.label.name);
      dontForward = true;
      break;

    case "ContinueStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeContinue(node.label && node.label.name);
      dontForward = true;
      break;

    case "ReturnStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeReturn();
      dontForward = true;
      break;

    case "ThrowStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeThrow();
      dontForward = true;
      break;

    case "Identifier":
      if (isIdentifierReference(node)) {
        state.makeFirstThrowablePathInTryBlock();
        dontForward = true;
      }

      break;

    case "CallExpression":
    case "ImportExpression":
    case "MemberExpression":
    case "NewExpression":
    case "YieldExpression":
      state.makeFirstThrowablePathInTryBlock();
      break;

    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      state.popLoopContext();
      break;

    case "AssignmentPattern":
      state.popForkContext();
      break;

    case "LabeledStatement":
      if (!breakableTypePattern.test(node.body.type)) {
        state.popBreakContext();
      }

      break;
  }

  if (!dontForward) {
    forwardCurrentToHead(analyzer, node);
  }

  debugHelpers.dumpState(node, state, true);
}

function postprocess(analyzer, node) {
  switch (node.type) {
    case "Program":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      {
        let codePath$1 = analyzer.codePath;
        codePath.getState(codePath$1).makeFinal();
        leaveFromCurrentSegment(analyzer, node);
        debugHelpers.dump(`onCodePathEnd ${codePath$1.id}`);
        analyzer.emitter.emit("onCodePathEnd", codePath$1, node);
        debugHelpers.dumpDot(codePath$1);
        codePath$1 = analyzer.codePath = analyzer.codePath.upper;

        if (codePath$1) {
          debugHelpers.dumpState(node, codePath.getState(codePath$1), true);
        }

        break;
      }

    case "CallExpression":
      if (node.optional === true && node.arguments.length === 0) {
        codePath.getState(analyzer.codePath).makeOptionalRight();
      }

      break;
  }
}

class CodePathAnalyzer {
  constructor(eventGenerator) {
    this.original = eventGenerator;
    this.emitter = eventGenerator.emitter;
    this.codePath = null;
    this.idGenerator = new idGenerator("s");
    this.currentNode = null;
    this.onLooped = this.onLooped.bind(this);
  }

  enterNode(node) {
    this.currentNode = node;

    if (node.parent) {
      preprocess(this, node);
    }

    processCodePathToEnter(this, node);
    this.original.enterNode(node);
    this.currentNode = null;
  }

  leaveNode(node) {
    this.currentNode = node;
    processCodePathToExit(this, node);
    this.original.leaveNode(node);
    postprocess(this, node);
    this.currentNode = null;
  }

  onLooped(fromSegment, toSegment) {
    if (fromSegment.reachable && toSegment.reachable) {
      debugHelpers.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);
      this.emitter.emit("onCodePathSegmentLoop", fromSegment, toSegment, this.currentNode);
    }
  }

}

var codePathAnalyzer = CodePathAnalyzer;

function compareLocations(itemA, itemB) {
  return itemA.line - itemB.line || itemA.column - itemB.column;
}

function applyDirectives(options) {
  const problems = [];
  let nextDirectiveIndex = 0;
  let currentGlobalDisableDirective = null;
  const disabledRuleMap = new Map();
  const enabledRules = new Set();
  const usedDisableDirectives = new Set();

  for (const problem of options.problems) {
    while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {
      const directive = options.directives[nextDirectiveIndex++];

      switch (directive.type) {
        case "disable":
          if (directive.ruleId === null) {
            currentGlobalDisableDirective = directive;
            disabledRuleMap.clear();
            enabledRules.clear();
          } else if (currentGlobalDisableDirective) {
            enabledRules.delete(directive.ruleId);
            disabledRuleMap.set(directive.ruleId, directive);
          } else {
            disabledRuleMap.set(directive.ruleId, directive);
          }

          break;

        case "enable":
          if (directive.ruleId === null) {
            currentGlobalDisableDirective = null;
            disabledRuleMap.clear();
          } else if (currentGlobalDisableDirective) {
            enabledRules.add(directive.ruleId);
            disabledRuleMap.delete(directive.ruleId);
          } else {
            disabledRuleMap.delete(directive.ruleId);
          }

          break;
      }
    }

    if (disabledRuleMap.has(problem.ruleId)) {
      usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));
    } else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) {
      usedDisableDirectives.add(currentGlobalDisableDirective);
    } else {
      problems.push(problem);
    }
  }

  const unusedDisableDirectives = options.directives.filter(directive => directive.type === "disable" && !usedDisableDirectives.has(directive)).map(directive => ({
    ruleId: null,
    message: directive.ruleId ? `Unused eslint-disable directive (no problems were reported from '${directive.ruleId}').` : "Unused eslint-disable directive (no problems were reported).",
    line: directive.unprocessedDirective.line,
    column: directive.unprocessedDirective.column,
    severity: options.reportUnusedDisableDirectives === "warn" ? 1 : 2,
    nodeType: null
  }));
  return {
    problems,
    unusedDisableDirectives
  };
}

var applyDisableDirectives = ({
  directives,
  problems,
  reportUnusedDisableDirectives = "off"
}) => {
  const blockDirectives = directives.filter(directive => directive.type === "disable" || directive.type === "enable").map(directive => Object.assign({}, directive, {
    unprocessedDirective: directive
  })).sort(compareLocations);
  const lineDirectives = lodash__default$1['default'].flatMap(directives, directive => {
    switch (directive.type) {
      case "disable":
      case "enable":
        return [];

      case "disable-line":
        return [{
          type: "disable",
          line: directive.line,
          column: 1,
          ruleId: directive.ruleId,
          unprocessedDirective: directive
        }, {
          type: "enable",
          line: directive.line + 1,
          column: 0,
          ruleId: directive.ruleId,
          unprocessedDirective: directive
        }];

      case "disable-next-line":
        return [{
          type: "disable",
          line: directive.line + 1,
          column: 1,
          ruleId: directive.ruleId,
          unprocessedDirective: directive
        }, {
          type: "enable",
          line: directive.line + 2,
          column: 0,
          ruleId: directive.ruleId,
          unprocessedDirective: directive
        }];

      default:
        throw new TypeError(`Unrecognized directive type '${directive.type}'`);
    }
  }).sort(compareLocations);
  const blockDirectivesResult = applyDirectives({
    problems,
    directives: blockDirectives,
    reportUnusedDisableDirectives
  });
  const lineDirectivesResult = applyDirectives({
    problems: blockDirectivesResult.problems,
    directives: lineDirectives,
    reportUnusedDisableDirectives
  });
  return reportUnusedDisableDirectives !== "off" ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;
};

const debug$2 = debug__default['default']("eslint:config-comment-parser");
var configCommentParser = class {
  parseStringConfig(string, comment) {
    debug$2("Parsing String config");
    const items = {};
    const trimmedString = string.replace(/\s*([:,])\s*/gu, "$1");
    trimmedString.split(/\s|,+/u).forEach(name => {
      if (!name) {
        return;
      }

      const [key, value = null] = name.split(":");
      items[key] = {
        value,
        comment
      };
    });
    return items;
  }

  parseJsonConfig(string, location) {
    debug$2("Parsing JSON config");
    let items = {};

    try {
      items = levn__default['default'].parse("Object", string) || {};

      if (configOps__default['default'].isEverySeverityValid(items)) {
        return {
          success: true,
          config: items
        };
      }
    } catch {
      debug$2("Levn parsing failed; falling back to manual parsing.");
    }

    items = {};
    const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, "\"$1\":").replace(/(\]|[0-9])\s+(?=")/u, "$1,");

    try {
      items = JSON.parse(`{${normalizedString}}`);
    } catch (ex) {
      debug$2("Manual parsing failed.");
      return {
        success: false,
        error: {
          ruleId: null,
          fatal: true,
          severity: 2,
          message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,
          line: location.start.line,
          column: location.start.column + 1
        }
      };
    }

    return {
      success: true,
      config: items
    };
  }

  parseListConfig(string) {
    debug$2("Parsing list config");
    const items = {};
    string.replace(/\s*,\s*/gu, ",").split(/,+/u).forEach(name => {
      const trimmedName = name.trim();

      if (trimmedName) {
        items[trimmedName] = true;
      }
    });
    return items;
  }

};

function getPossibleTypes(parsedSelector) {
  switch (parsedSelector.type) {
    case "identifier":
      return [parsedSelector.value];

    case "matches":
      {
        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);

        if (typesForComponents.every(Boolean)) {
          return lodash__default$1['default'].union(...typesForComponents);
        }

        return null;
      }

    case "compound":
      {
        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);

        if (!typesForComponents.length) {
          return null;
        }

        return lodash__default$1['default'].intersection(...typesForComponents);
      }

    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return getPossibleTypes(parsedSelector.right);

    default:
      return null;
  }
}

function countClassAttributes(parsedSelector) {
  switch (parsedSelector.type) {
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);

    case "compound":
    case "not":
    case "matches":
      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);

    case "attribute":
    case "field":
    case "nth-child":
    case "nth-last-child":
      return 1;

    default:
      return 0;
  }
}

function countIdentifiers(parsedSelector) {
  switch (parsedSelector.type) {
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);

    case "compound":
    case "not":
    case "matches":
      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);

    case "identifier":
      return 1;

    default:
      return 0;
  }
}

function compareSpecificity(selectorA, selectorB) {
  return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
}

function tryParseSelector(rawSelector) {
  try {
    return esquery__default['default'].parse(rawSelector.replace(/:exit$/u, ""));
  } catch (err) {
    if (err.location && err.location.start && typeof err.location.start.offset === "number") {
      throw new SyntaxError(`Syntax error in selector "${rawSelector}" at position ${err.location.start.offset}: ${err.message}`);
    }

    throw err;
  }
}

const parseSelector = lodash__default$1['default'].memoize(rawSelector => {
  const parsedSelector = tryParseSelector(rawSelector);
  return {
    rawSelector,
    isExit: rawSelector.endsWith(":exit"),
    parsedSelector,
    listenerTypes: getPossibleTypes(parsedSelector),
    attributeCount: countClassAttributes(parsedSelector),
    identifierCount: countIdentifiers(parsedSelector)
  };
});

class NodeEventGenerator {
  constructor(emitter, esqueryOptions) {
    this.emitter = emitter;
    this.esqueryOptions = esqueryOptions;
    this.currentAncestry = [];
    this.enterSelectorsByNodeType = new Map();
    this.exitSelectorsByNodeType = new Map();
    this.anyTypeEnterSelectors = [];
    this.anyTypeExitSelectors = [];
    emitter.eventNames().forEach(rawSelector => {
      const selector = parseSelector(rawSelector);

      if (selector.listenerTypes) {
        const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;
        selector.listenerTypes.forEach(nodeType => {
          if (!typeMap.has(nodeType)) {
            typeMap.set(nodeType, []);
          }

          typeMap.get(nodeType).push(selector);
        });
        return;
      }

      const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
      selectors.push(selector);
    });
    this.anyTypeEnterSelectors.sort(compareSpecificity);
    this.anyTypeExitSelectors.sort(compareSpecificity);
    this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
    this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
  }

  applySelector(node, selector) {
    if (esquery__default['default'].matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {
      this.emitter.emit(selector.rawSelector, node);
    }
  }

  applySelectors(node, isExit) {
    const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];
    const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
    let selectorsByTypeIndex = 0;
    let anyTypeSelectorsIndex = 0;

    while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
      if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {
        this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
      } else {
        this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
      }
    }
  }

  enterNode(node) {
    if (node.parent) {
      this.currentAncestry.unshift(node.parent);
    }

    this.applySelectors(node, false);
  }

  leaveNode(node) {
    this.applySelectors(node, true);
    this.currentAncestry.shift();
  }

}

var nodeEventGenerator = NodeEventGenerator;

function insertTextAt(index, text) {
  return {
    range: [index, index],
    text
  };
}

const ruleFixer = Object.freeze({
  insertTextAfter(nodeOrToken, text) {
    return this.insertTextAfterRange(nodeOrToken.range, text);
  },

  insertTextAfterRange(range, text) {
    return insertTextAt(range[1], text);
  },

  insertTextBefore(nodeOrToken, text) {
    return this.insertTextBeforeRange(nodeOrToken.range, text);
  },

  insertTextBeforeRange(range, text) {
    return insertTextAt(range[0], text);
  },

  replaceText(nodeOrToken, text) {
    return this.replaceTextRange(nodeOrToken.range, text);
  },

  replaceTextRange(range, text) {
    return {
      range,
      text
    };
  },

  remove(nodeOrToken) {
    return this.removeRange(nodeOrToken.range);
  },

  removeRange(range) {
    return {
      range,
      text: ""
    };
  }

});
var ruleFixer_1 = ruleFixer;

var interpolate = (text, data) => {
  if (!data) {
    return text;
  }

  return text.replace(/\{\{([^{}]+?)\}\}/gu, (fullMatch, termWithWhitespace) => {
    const term = termWithWhitespace.trim();

    if (term in data) {
      return data[term];
    }

    return fullMatch;
  });
};

function normalizeMultiArgReportCall(...args) {
  if (args.length === 1) {
    return Object.assign({}, args[0]);
  }

  if (typeof args[1] === "string") {
    return {
      node: args[0],
      message: args[1],
      data: args[2],
      fix: args[3]
    };
  }

  return {
    node: args[0],
    loc: args[1],
    message: args[2],
    data: args[3],
    fix: args[4]
  };
}

function assertValidNodeInfo(descriptor) {
  if (descriptor.node) {
    assert__default['default'](typeof descriptor.node === "object", "Node must be an object");
  } else {
    assert__default['default'](descriptor.loc, "Node must be provided when reporting error if location is not provided");
  }
}

function normalizeReportLoc(descriptor) {
  if (descriptor.loc) {
    if (descriptor.loc.start) {
      return descriptor.loc;
    }

    return {
      start: descriptor.loc,
      end: null
    };
  }

  return descriptor.node.loc;
}

function assertValidFix(fix) {
  if (fix) {
    assert__default['default'](fix.range && typeof fix.range[0] === "number" && typeof fix.range[1] === "number", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);
  }
}

function compareFixesByRange(a, b) {
  return a.range[0] - b.range[0] || a.range[1] - b.range[1];
}

function mergeFixes(fixes, sourceCode) {
  for (const fix of fixes) {
    assertValidFix(fix);
  }

  if (fixes.length === 0) {
    return null;
  }

  if (fixes.length === 1) {
    return fixes[0];
  }

  fixes.sort(compareFixesByRange);
  const originalText = sourceCode.text;
  const start = fixes[0].range[0];
  const end = fixes[fixes.length - 1].range[1];
  let text = "";
  let lastPos = Number.MIN_SAFE_INTEGER;

  for (const fix of fixes) {
    assert__default['default'](fix.range[0] >= lastPos, "Fix objects must not be overlapped in a report.");

    if (fix.range[0] >= 0) {
      text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
    }

    text += fix.text;
    lastPos = fix.range[1];
  }

  text += originalText.slice(Math.max(0, start, lastPos), end);
  return {
    range: [start, end],
    text
  };
}

function normalizeFixes(descriptor, sourceCode) {
  if (typeof descriptor.fix !== "function") {
    return null;
  }

  const fix = descriptor.fix(ruleFixer_1);

  if (fix && Symbol.iterator in fix) {
    return mergeFixes(Array.from(fix), sourceCode);
  }

  assertValidFix(fix);
  return fix;
}

function mapSuggestions(descriptor, sourceCode, messages) {
  if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {
    return [];
  }

  return descriptor.suggest.map(suggestInfo => {
    const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];
    return { ...suggestInfo,
      desc: interpolate(computedDesc, suggestInfo.data),
      fix: normalizeFixes(suggestInfo, sourceCode)
    };
  }).filter(({
    fix
  }) => fix);
}

function createProblem(options) {
  const problem = {
    ruleId: options.ruleId,
    severity: options.severity,
    message: options.message,
    line: options.loc.start.line,
    column: options.loc.start.column + 1,
    nodeType: options.node && options.node.type || null
  };

  if (options.messageId) {
    problem.messageId = options.messageId;
  }

  if (options.loc.end) {
    problem.endLine = options.loc.end.line;
    problem.endColumn = options.loc.end.column + 1;
  }

  if (options.fix) {
    problem.fix = options.fix;
  }

  if (options.suggestions && options.suggestions.length > 0) {
    problem.suggestions = options.suggestions;
  }

  return problem;
}

function validateSuggestions(suggest, messages) {
  if (suggest && Array.isArray(suggest)) {
    suggest.forEach(suggestion => {
      if (suggestion.messageId) {
        const {
          messageId
        } = suggestion;

        if (!messages) {
          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);
        }

        if (!messages[messageId]) {
          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);
        }

        if (suggestion.desc) {
          throw new TypeError("context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.");
        }
      } else if (!suggestion.desc) {
        throw new TypeError("context.report() called with a suggest option that doesn't have either a `desc` or `messageId`");
      }

      if (typeof suggestion.fix !== "function") {
        throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);
      }
    });
  }
}

var reportTranslator = function (metadata) {
  return (...args) => {
    const descriptor = normalizeMultiArgReportCall(...args);
    const messages = metadata.messageIds;
    assertValidNodeInfo(descriptor);
    let computedMessage;

    if (descriptor.messageId) {
      if (!messages) {
        throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
      }

      const id = descriptor.messageId;

      if (descriptor.message) {
        throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
      }

      if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {
        throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);
      }

      computedMessage = messages[id];
    } else if (descriptor.message) {
      computedMessage = descriptor.message;
    } else {
      throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
    }

    validateSuggestions(descriptor.suggest, messages);
    return createProblem({
      ruleId: metadata.ruleId,
      severity: metadata.severity,
      node: descriptor.node,
      message: interpolate(computedMessage, descriptor.data),
      messageId: descriptor.messageId,
      loc: normalizeReportLoc(descriptor),
      fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),
      suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)
    });
  };
};

var rulesIndex = new Map();

function normalizeRule(rule) {
  return typeof rule === "function" ? Object.assign({
    create: rule
  }, rule) : rule;
}

class Rules {
  constructor() {
    this._rules = Object.create(null);
  }

  define(ruleId, ruleModule) {
    this._rules[ruleId] = normalizeRule(ruleModule);
  }

  get(ruleId) {
    if (typeof this._rules[ruleId] === "string") {
      this.define(ruleId, null);
    }

    if (this._rules[ruleId]) {
      return this._rules[ruleId];
    }

    if (rulesIndex.has(ruleId)) {
      return rulesIndex.get(ruleId);
    }

    return null;
  }

  *[Symbol.iterator]() {
    yield* rulesIndex;

    for (const ruleId of Object.keys(this._rules)) {
      yield [ruleId, this.get(ruleId)];
    }
  }

}

var rules$1 = Rules;

var safeEmitter = () => {
  const listeners = Object.create(null);
  return Object.freeze({
    on(eventName, listener) {
      if (eventName in listeners) {
        listeners[eventName].push(listener);
      } else {
        listeners[eventName] = [listener];
      }
    },

    emit(eventName, ...args) {
      if (eventName in listeners) {
        listeners[eventName].forEach(listener => listener(...args));
      }
    },

    eventNames() {
      return Object.keys(listeners);
    }

  });
};

const debug$1 = debug__default['default']("eslint:source-code-fixer");
const BOM = "\uFEFF";

function compareMessagesByFixRange(a, b) {
  return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];
}

function compareMessagesByLocation(a, b) {
  return a.line - b.line || a.column - b.column;
}

function SourceCodeFixer() {
  Object.freeze(this);
}

SourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {
  debug$1("Applying fixes");

  if (shouldFix === false) {
    debug$1("shouldFix parameter was false, not attempting fixes");
    return {
      fixed: false,
      messages,
      output: sourceText
    };
  }

  const remainingMessages = [],
        fixes = [],
        bom = sourceText.startsWith(BOM) ? BOM : "",
        text = bom ? sourceText.slice(1) : sourceText;
  let lastPos = Number.NEGATIVE_INFINITY,
      output = bom;

  function attemptFix(problem) {
    const fix = problem.fix;
    const start = fix.range[0];
    const end = fix.range[1];

    if (lastPos >= start || start > end) {
      remainingMessages.push(problem);
      return false;
    }

    if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {
      output = "";
    }

    output += text.slice(Math.max(0, lastPos), Math.max(0, start));
    output += fix.text;
    lastPos = end;
    return true;
  }

  messages.forEach(problem => {
    if (Object.prototype.hasOwnProperty.call(problem, "fix")) {
      fixes.push(problem);
    } else {
      remainingMessages.push(problem);
    }
  });

  if (fixes.length) {
    debug$1("Found fixes to apply");
    let fixesWereApplied = false;

    for (const problem of fixes.sort(compareMessagesByFixRange)) {
      if (typeof shouldFix !== "function" || shouldFix(problem)) {
        attemptFix(problem);
        fixesWereApplied = true;
      } else {
        remainingMessages.push(problem);
      }
    }

    output += text.slice(Math.max(0, lastPos));
    return {
      fixed: fixesWereApplied,
      messages: remainingMessages.sort(compareMessagesByLocation),
      output
    };
  }

  debug$1("No fixes to apply");
  return {
    fixed: false,
    messages,
    output: bom + text
  };
};

var sourceCodeFixer = SourceCodeFixer;

const enabled = false;

function getListSize() {
  return 10;
}

var timing = function () {
  const data = Object.create(null);

  return {
    time: function (key, fn) {
      if (typeof data[key] === "undefined") {
        data[key] = 0;
      }

      return function (...args) {
        let t = browser$1$1.hrtime();
        fn(...args);
        t = browser$1$1.hrtime(t);
        data[key] += t[0] * 1e3 + t[1] / 1e6;
      };
    },
    enabled,
    getListSize
  };
}();

const rules = {
  "generator-star": ["generator-star-spacing"],
  "global-strict": ["strict"],
  "no-arrow-condition": ["no-confusing-arrow", "no-constant-condition"],
  "no-comma-dangle": ["comma-dangle"],
  "no-empty-class": ["no-empty-character-class"],
  "no-empty-label": ["no-labels"],
  "no-extra-strict": ["strict"],
  "no-reserved-keys": ["quote-props"],
  "no-space-before-semi": ["semi-spacing"],
  "no-wrap-func": ["no-extra-parens"],
  "space-after-function-name": ["space-before-function-paren"],
  "space-after-keywords": ["keyword-spacing"],
  "space-before-function-parentheses": ["space-before-function-paren"],
  "space-before-keywords": ["keyword-spacing"],
  "space-in-brackets": ["object-curly-spacing", "array-bracket-spacing", "computed-property-spacing"],
  "space-return-throw-case": ["keyword-spacing"],
  "space-unary-word-ops": ["space-unary-ops"],
  "spaced-line-comment": ["spaced-comment"]
};
var replacements = {
  rules: rules
};
var replacements$1 = Object.freeze({
  __proto__: null,
  rules: rules,
  'default': replacements
});

var pkg = _commonjsHelpers11cbc178.getCjsExportFromNamespace(_package$1);

var ruleReplacements = _commonjsHelpers11cbc178.getCjsExportFromNamespace(replacements$1);

const {
  SourceCode
} = sourceCode;
const debug = debug__default['default']("eslint:linter");
const MAX_AUTOFIX_PASSES = 10;
const DEFAULT_PARSER_NAME = "espree";
const commentParser = new configCommentParser();
const DEFAULT_ERROR_LOC = {
  start: {
    line: 1,
    column: 0
  },
  end: {
    line: 1,
    column: 1
  }
};

function addDeclaredGlobals(globalScope, configGlobals, {
  exportedVariables,
  enabledGlobals
}) {
  for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {
    const configValue = configGlobals[id] === void 0 ? void 0 : configOps__default['default'].normalizeConfigGlobal(configGlobals[id]);
    const commentValue = enabledGlobals[id] && enabledGlobals[id].value;
    const value = commentValue || configValue;
    const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;

    if (value === "off") {
      continue;
    }

    let variable = globalScope.set.get(id);

    if (!variable) {
      variable = new eslintScope__default['default'].Variable(id, globalScope);
      globalScope.variables.push(variable);
      globalScope.set.set(id, variable);
    }

    variable.eslintImplicitGlobalSetting = configValue;
    variable.eslintExplicitGlobal = sourceComments !== void 0;
    variable.eslintExplicitGlobalComments = sourceComments;
    variable.writeable = value === "writable";
  }

  Object.keys(exportedVariables).forEach(name => {
    const variable = globalScope.set.get(name);

    if (variable) {
      variable.eslintUsed = true;
    }
  });
  globalScope.through = globalScope.through.filter(reference => {
    const name = reference.identifier.name;
    const variable = globalScope.set.get(name);

    if (variable) {
      reference.resolved = variable;
      variable.references.push(reference);
      return false;
    }

    return true;
  });
}

function createMissingRuleMessage(ruleId) {
  return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(", ")}` : `Definition for rule '${ruleId}' was not found.`;
}

function createLintingProblem(options) {
  const {
    ruleId = null,
    loc = DEFAULT_ERROR_LOC,
    message = createMissingRuleMessage(options.ruleId),
    severity = 2
  } = options;
  return {
    ruleId,
    message,
    line: loc.start.line,
    column: loc.start.column + 1,
    endLine: loc.end.line,
    endColumn: loc.end.column + 1,
    severity,
    nodeType: null
  };
}

function createDisableDirectives(options) {
  const {
    type,
    loc,
    value,
    ruleMapper
  } = options;
  const ruleIds = Object.keys(commentParser.parseListConfig(value));
  const directiveRules = ruleIds.length ? ruleIds : [null];
  const result = {
    directives: [],
    directiveProblems: []
  };

  for (const ruleId of directiveRules) {
    if (ruleId === null || ruleMapper(ruleId) !== null) {
      result.directives.push({
        type,
        line: loc.start.line,
        column: loc.start.column + 1,
        ruleId
      });
    } else {
      result.directiveProblems.push(createLintingProblem({
        ruleId,
        loc
      }));
    }
  }

  return result;
}

function stripDirectiveComment(value) {
  return value.split(/\s-{2,}\s/u)[0].trim();
}

function getDirectiveComments(filename, ast, ruleMapper, warnInlineConfig) {
  const configuredRules = {};
  const enabledGlobals = Object.create(null);
  const exportedVariables = {};
  const problems = [];
  const disableDirectives = [];
  const validator = new configValidator__default['default']({
    builtInRules: rules$1
  });
  ast.comments.filter(token => token.type !== "Shebang").forEach(comment => {
    const trimmedCommentText = stripDirectiveComment(comment.value);
    const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\s|$)/u.exec(trimmedCommentText);

    if (!match) {
      return;
    }

    const directiveText = match[1];
    const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);

    if (comment.type === "Line" && !lineCommentSupported) {
      return;
    }

    if (warnInlineConfig) {
      const kind = comment.type === "Block" ? `/*${directiveText}*/` : `//${directiveText}`;
      problems.push(createLintingProblem({
        ruleId: null,
        message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,
        loc: comment.loc,
        severity: 1
      }));
      return;
    }

    if (lineCommentSupported && comment.loc.start.line !== comment.loc.end.line) {
      problems.push(createLintingProblem({
        ruleId: null,
        message: `${directiveText} comment should not span multiple lines.`,
        loc: comment.loc
      }));
      return;
    }

    const directiveValue = trimmedCommentText.slice(match.index + directiveText.length);

    switch (directiveText) {
      case "eslint-disable":
      case "eslint-enable":
      case "eslint-disable-next-line":
      case "eslint-disable-line":
        {
          const directiveType = directiveText.slice(7);
          const options = {
            type: directiveType,
            loc: comment.loc,
            value: directiveValue,
            ruleMapper
          };
          const {
            directives,
            directiveProblems
          } = createDisableDirectives(options);
          disableDirectives.push(...directives);
          problems.push(...directiveProblems);
          break;
        }

      case "exported":
        Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));
        break;

      case "globals":
      case "global":
        for (const [id, {
          value
        }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {
          let normalizedValue;

          try {
            normalizedValue = configOps__default['default'].normalizeConfigGlobal(value);
          } catch (err) {
            problems.push(createLintingProblem({
              ruleId: null,
              loc: comment.loc,
              message: err.message
            }));
            continue;
          }

          if (enabledGlobals[id]) {
            enabledGlobals[id].comments.push(comment);
            enabledGlobals[id].value = normalizedValue;
          } else {
            enabledGlobals[id] = {
              comments: [comment],
              value: normalizedValue
            };
          }
        }

        break;

      case "eslint":
        {
          const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);

          if (parseResult.success) {
            Object.keys(parseResult.config).forEach(name => {
              const rule = ruleMapper(name);
              const ruleValue = parseResult.config[name];

              if (rule === null) {
                problems.push(createLintingProblem({
                  ruleId: name,
                  loc: comment.loc
                }));
                return;
              }

              try {
                validator.validateRuleOptions(rule, name, ruleValue);
              } catch (err) {
                problems.push(createLintingProblem({
                  ruleId: name,
                  message: err.message,
                  loc: comment.loc
                }));
                return;
              }

              configuredRules[name] = ruleValue;
            });
          } else {
            problems.push(parseResult.error);
          }

          break;
        }
    }
  });
  return {
    configuredRules,
    enabledGlobals,
    exportedVariables,
    problems,
    disableDirectives
  };
}

function normalizeEcmaVersion(ecmaVersion) {
  return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;
}

const eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//gu;

function findEslintEnv(text) {
  let match, retv;
  eslintEnvPattern.lastIndex = 0;

  while ((match = eslintEnvPattern.exec(text)) !== null) {
    retv = Object.assign(retv || {}, commentParser.parseListConfig(stripDirectiveComment(match[1])));
  }

  return retv;
}

function normalizeFilename(filename) {
  const parts = filename.split(path__default['default'].sep);
  const index = parts.lastIndexOf("<text>");
  return index === -1 ? filename : parts.slice(index).join(path__default['default'].sep);
}

function normalizeVerifyOptions(providedOptions, config) {
  const disableInlineConfig = config.noInlineConfig === true;
  const ignoreInlineConfig = providedOptions.allowInlineConfig === false;
  const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig ? ` (${config.configNameOfNoInlineConfig})` : "";
  let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;

  if (typeof reportUnusedDisableDirectives === "boolean") {
    reportUnusedDisableDirectives = reportUnusedDisableDirectives ? "error" : "off";
  }

  if (typeof reportUnusedDisableDirectives !== "string") {
    reportUnusedDisableDirectives = config.reportUnusedDisableDirectives ? "warn" : "off";
  }

  return {
    filename: normalizeFilename(providedOptions.filename || "<input>"),
    allowInlineConfig: !ignoreInlineConfig,
    warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? `your config${configNameOfNoInlineConfig}` : null,
    reportUnusedDisableDirectives,
    disableFixes: Boolean(providedOptions.disableFixes)
  };
}

function resolveParserOptions(parserName, providedOptions, enabledEnvironments) {
  const parserOptionsFromEnv = enabledEnvironments.filter(env => env.parserOptions).reduce((parserOptions, env) => lodash__default$1['default'].merge(parserOptions, env.parserOptions), {});
  const mergedParserOptions = lodash__default$1['default'].merge(parserOptionsFromEnv, providedOptions || {});
  const isModule = mergedParserOptions.sourceType === "module";

  if (isModule) {
    mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, {
      globalReturn: false
    });
  }

  mergedParserOptions.ecmaVersion = normalizeEcmaVersion(mergedParserOptions.ecmaVersion);
  return mergedParserOptions;
}

function resolveGlobals(providedGlobals, enabledEnvironments) {
  return Object.assign({}, ...enabledEnvironments.filter(env => env.globals).map(env => env.globals), providedGlobals);
}

function stripUnicodeBOM(text) {
  if (text.charCodeAt(0) === 0xFEFF) {
    return text.slice(1);
  }

  return text;
}

function getRuleOptions(ruleConfig) {
  if (Array.isArray(ruleConfig)) {
    return ruleConfig.slice(1);
  }

  return [];
}

function analyzeScope(ast, parserOptions, visitorKeys) {
  const ecmaFeatures = parserOptions.ecmaFeatures || {};
  const ecmaVersion = parserOptions.ecmaVersion || 5;
  return eslintScope__default['default'].analyze(ast, {
    ignoreEval: true,
    nodejsScope: ecmaFeatures.globalReturn,
    impliedStrict: ecmaFeatures.impliedStrict,
    ecmaVersion,
    sourceType: parserOptions.sourceType || "script",
    childVisitorKeys: visitorKeys || eslintVisitorKeys__default['default'].KEYS,
    fallback: _commonjsHelpers11cbc178.traverser.getKeys
  });
}

function parse(text, parser, providedParserOptions, filePath) {
  const textToParse = stripUnicodeBOM(text).replace(_commonjsHelpers11cbc178.astUtils.shebangPattern, (match, captured) => `//${captured}`);
  const parserOptions = Object.assign({}, providedParserOptions, {
    loc: true,
    range: true,
    raw: true,
    tokens: true,
    comment: true,
    eslintVisitorKeys: true,
    eslintScopeManager: true,
    filePath
  });

  try {
    const parseResult = typeof parser.parseForESLint === "function" ? parser.parseForESLint(textToParse, parserOptions) : {
      ast: parser.parse(textToParse, parserOptions)
    };
    const ast = parseResult.ast;
    const parserServices = parseResult.services || {};
    const visitorKeys = parseResult.visitorKeys || eslintVisitorKeys__default['default'].KEYS;
    const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);
    return {
      success: true,
      sourceCode: new SourceCode({
        text,
        ast,
        parserServices,
        scopeManager,
        visitorKeys
      })
    };
  } catch (ex) {
    const message = `Parsing error: ${ex.message.replace(/^line \d+:/iu, "").trim()}`;
    debug("%s\n%s", message, ex.stack);
    return {
      success: false,
      error: {
        ruleId: null,
        fatal: true,
        severity: 2,
        message,
        line: ex.lineNumber,
        column: ex.column
      }
    };
  }
}

function getScope(scopeManager, currentNode) {
  const inner = currentNode.type !== "Program";

  for (let node = currentNode; node; node = node.parent) {
    const scope = scopeManager.acquire(node, inner);

    if (scope) {
      if (scope.type === "function-expression-name") {
        return scope.childScopes[0];
      }

      return scope;
    }
  }

  return scopeManager.scopes[0];
}

function markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {
  const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;
  const specialScope = hasGlobalReturn || parserOptions.sourceType === "module";
  const currentScope = getScope(scopeManager, currentNode);
  const initialScope = currentScope.type === "global" && specialScope ? currentScope.childScopes[0] : currentScope;

  for (let scope = initialScope; scope; scope = scope.upper) {
    const variable = scope.variables.find(scopeVar => scopeVar.name === name);

    if (variable) {
      variable.eslintUsed = true;
      return true;
    }
  }

  return false;
}

function createRuleListeners(rule, ruleContext) {
  try {
    return rule.create(ruleContext);
  } catch (ex) {
    ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;
    throw ex;
  }
}

function getAncestors(node) {
  const ancestorsStartingAtParent = [];

  for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
    ancestorsStartingAtParent.push(ancestor);
  }

  return ancestorsStartingAtParent.reverse();
}

const DEPRECATED_SOURCECODE_PASSTHROUGHS = {
  getSource: "getText",
  getSourceLines: "getLines",
  getAllComments: "getAllComments",
  getNodeByRangeIndex: "getNodeByRangeIndex",
  getComments: "getComments",
  getCommentsBefore: "getCommentsBefore",
  getCommentsAfter: "getCommentsAfter",
  getCommentsInside: "getCommentsInside",
  getJSDocComment: "getJSDocComment",
  getFirstToken: "getFirstToken",
  getFirstTokens: "getFirstTokens",
  getLastToken: "getLastToken",
  getLastTokens: "getLastTokens",
  getTokenAfter: "getTokenAfter",
  getTokenBefore: "getTokenBefore",
  getTokenByRangeStart: "getTokenByRangeStart",
  getTokens: "getTokens",
  getTokensAfter: "getTokensAfter",
  getTokensBefore: "getTokensBefore",
  getTokensBetween: "getTokensBetween"
};
const BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce((contextInfo, methodName) => Object.assign(contextInfo, {
  [methodName](...args) {
    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);
  }

}), {}));

function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename, disableFixes, cwd) {
  const emitter = safeEmitter();
  const nodeQueue = [];
  let currentNode = sourceCode.ast;

  _commonjsHelpers11cbc178.traverser.traverse(sourceCode.ast, {
    enter(node, parent) {
      node.parent = parent;
      nodeQueue.push({
        isEntering: true,
        node
      });
    },

    leave(node) {
      nodeQueue.push({
        isEntering: false,
        node
      });
    },

    visitorKeys: sourceCode.visitorKeys
  });

  const sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {
    getAncestors: () => getAncestors(currentNode),
    getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),
    getCwd: () => cwd,
    getFilename: () => filename,
    getScope: () => getScope(sourceCode.scopeManager, currentNode),
    getSourceCode: () => sourceCode,
    markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),
    parserOptions,
    parserPath: parserName,
    parserServices: sourceCode.parserServices,
    settings
  }));
  const lintingProblems = [];
  Object.keys(configuredRules).forEach(ruleId => {
    const severity = configOps__default['default'].getRuleSeverity(configuredRules[ruleId]);

    if (severity === 0) {
      return;
    }

    const rule = ruleMapper(ruleId);

    if (rule === null) {
      lintingProblems.push(createLintingProblem({
        ruleId
      }));
      return;
    }

    const messageIds = rule.meta && rule.meta.messages;
    let reportTranslator$1 = null;
    const ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {
      id: ruleId,
      options: getRuleOptions(configuredRules[ruleId]),

      report(...args) {
        if (reportTranslator$1 === null) {
          reportTranslator$1 = reportTranslator({
            ruleId,
            severity,
            sourceCode,
            messageIds,
            disableFixes
          });
        }

        const problem = reportTranslator$1(...args);

        if (problem.fix && rule.meta && !rule.meta.fixable) {
          throw new Error("Fixable rules should export a `meta.fixable` property.");
        }

        lintingProblems.push(problem);
      }

    }));
    const ruleListeners = createRuleListeners(rule, ruleContext);
    Object.keys(ruleListeners).forEach(selector => {
      emitter.on(selector, timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector]);
    });
  });
  const eventGenerator = nodeQueue[0].node.type === "Program" ? new codePathAnalyzer(new nodeEventGenerator(emitter, {
    visitorKeys: sourceCode.visitorKeys,
    fallback: _commonjsHelpers11cbc178.traverser.getKeys
  })) : new nodeEventGenerator(emitter, {
    visitorKeys: sourceCode.visitorKeys,
    fallback: _commonjsHelpers11cbc178.traverser.getKeys
  });
  nodeQueue.forEach(traversalInfo => {
    currentNode = traversalInfo.node;

    try {
      if (traversalInfo.isEntering) {
        eventGenerator.enterNode(currentNode);
      } else {
        eventGenerator.leaveNode(currentNode);
      }
    } catch (err) {
      err.currentNode = currentNode;
      throw err;
    }
  });
  return lintingProblems;
}

function ensureText(textOrSourceCode) {
  if (typeof textOrSourceCode === "object") {
    const {
      hasBOM,
      text
    } = textOrSourceCode;
    const bom = hasBOM ? "\uFEFF" : "";
    return bom + text;
  }

  return String(textOrSourceCode);
}

function getEnv(slots, envId) {
  return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || environments__default['default'].get(envId) || null;
}

function getRule(slots, ruleId) {
  return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);
}

function normalizeCwd(cwd) {
  if (cwd) {
    return cwd;
  }

  if (typeof browser$1$1 === "object") {
    return browser$1$1.cwd();
  }

  return undefined;
}

const internalSlotsMap = new WeakMap();

class Linter$1 {
  constructor({
    cwd
  } = {}) {
    internalSlotsMap.set(this, {
      cwd: normalizeCwd(cwd),
      lastConfigArray: null,
      lastSourceCode: null,
      parserMap: new Map([["espree", espree__default$1['default']]]),
      ruleMap: new rules$1()
    });
    this.version = pkg.version;
  }

  static get version() {
    return pkg.version;
  }

  _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {
    const slots = internalSlotsMap.get(this);
    const config = providedConfig || {};
    const options = normalizeVerifyOptions(providedOptions, config);
    let text;

    if (typeof textOrSourceCode === "string") {
      slots.lastSourceCode = null;
      text = textOrSourceCode;
    } else {
      slots.lastSourceCode = textOrSourceCode;
      text = textOrSourceCode.text;
    }

    let parserName = DEFAULT_PARSER_NAME;
    let parser = espree__default$1['default'];

    if (typeof config.parser === "object" && config.parser !== null) {
      parserName = config.parser.filePath;
      parser = config.parser.definition;
    } else if (typeof config.parser === "string") {
      if (!slots.parserMap.has(config.parser)) {
        return [{
          ruleId: null,
          fatal: true,
          severity: 2,
          message: `Configured parser '${config.parser}' was not found.`,
          line: 0,
          column: 0
        }];
      }

      parserName = config.parser;
      parser = slots.parserMap.get(config.parser);
    }

    const envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(text) : {};
    const resolvedEnvConfig = Object.assign({
      builtin: true
    }, config.env, envInFile);
    const enabledEnvs = Object.keys(resolvedEnvConfig).filter(envName => resolvedEnvConfig[envName]).map(envName => getEnv(slots, envName)).filter(env => env);
    const parserOptions = resolveParserOptions(parserName, config.parserOptions || {}, enabledEnvs);
    const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);
    const settings = config.settings || {};

    if (!slots.lastSourceCode) {
      const parseResult = parse(text, parser, parserOptions, options.filename);

      if (!parseResult.success) {
        return [parseResult.error];
      }

      slots.lastSourceCode = parseResult.sourceCode;
    } else {
      if (!slots.lastSourceCode.scopeManager) {
        slots.lastSourceCode = new SourceCode({
          text: slots.lastSourceCode.text,
          ast: slots.lastSourceCode.ast,
          parserServices: slots.lastSourceCode.parserServices,
          visitorKeys: slots.lastSourceCode.visitorKeys,
          scopeManager: analyzeScope(slots.lastSourceCode.ast, parserOptions)
        });
      }
    }

    const sourceCode = slots.lastSourceCode;
    const commentDirectives = options.allowInlineConfig ? getDirectiveComments(options.filename, sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig) : {
      configuredRules: {},
      enabledGlobals: {},
      exportedVariables: {},
      problems: [],
      disableDirectives: []
    };
    addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {
      exportedVariables: commentDirectives.exportedVariables,
      enabledGlobals: commentDirectives.enabledGlobals
    });
    const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);
    let lintingProblems;

    try {
      lintingProblems = runRules(sourceCode, configuredRules, ruleId => getRule(slots, ruleId), parserOptions, parserName, settings, options.filename, options.disableFixes, slots.cwd);
    } catch (err) {
      err.message += `\nOccurred while linting ${options.filename}`;
      debug("An error occurred while traversing");
      debug("Filename:", options.filename);

      if (err.currentNode) {
        const {
          line
        } = err.currentNode.loc.start;
        debug("Line:", line);
        err.message += `:${line}`;
      }

      debug("Parser Options:", parserOptions);
      debug("Parser Path:", parserName);
      debug("Settings:", settings);
      throw err;
    }

    return applyDisableDirectives({
      directives: commentDirectives.disableDirectives,
      problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),
      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
    });
  }

  verify(textOrSourceCode, config, filenameOrOptions) {
    debug("Verify");
    const options = typeof filenameOrOptions === "string" ? {
      filename: filenameOrOptions
    } : filenameOrOptions || {};

    if (config && typeof config.extractConfig === "function") {
      return this._verifyWithConfigArray(textOrSourceCode, config, options);
    }

    if (options.preprocess || options.postprocess) {
      return this._verifyWithProcessor(textOrSourceCode, config, options);
    }

    return this._verifyWithoutProcessors(textOrSourceCode, config, options);
  }

  _verifyWithConfigArray(textOrSourceCode, configArray, options) {
    debug("With ConfigArray: %s", options.filename);
    internalSlotsMap.get(this).lastConfigArray = configArray;
    const config = configArray.extractConfig(options.filename);
    const processor = config.processor && configArray.pluginProcessors.get(config.processor);

    if (processor) {
      debug("Apply the processor: %o", config.processor);
      const {
        preprocess,
        postprocess,
        supportsAutofix
      } = processor;
      const disableFixes = options.disableFixes || !supportsAutofix;
      return this._verifyWithProcessor(textOrSourceCode, config, { ...options,
        disableFixes,
        postprocess,
        preprocess
      }, configArray);
    }

    return this._verifyWithoutProcessors(textOrSourceCode, config, options);
  }

  _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {
    const filename = options.filename || "<input>";
    const filenameToExpose = normalizeFilename(filename);
    const text = ensureText(textOrSourceCode);

    const preprocess = options.preprocess || (rawText => [rawText]);

    const postprocess = options.postprocess || lodash__default$1['default'].flatten;

    const filterCodeBlock = options.filterCodeBlock || (blockFilename => blockFilename.endsWith(".js"));

    const originalExtname = path__default['default'].extname(filename);
    const messageLists = preprocess(text, filenameToExpose).map((block, i) => {
      debug("A code block was found: %o", block.filename || "(unnamed)");

      if (typeof block === "string") {
        return this._verifyWithoutProcessors(block, config, options);
      }

      const blockText = block.text;
      const blockName = path__default['default'].join(filename, `${i}_${block.filename}`);

      if (!filterCodeBlock(blockName, blockText)) {
        debug("This code block was skipped.");
        return [];
      }

      if (configForRecursive && path__default['default'].extname(blockName) !== originalExtname) {
        debug("Resolving configuration again because the file extension was changed.");
        return this._verifyWithConfigArray(blockText, configForRecursive, { ...options,
          filename: blockName
        });
      }

      return this._verifyWithoutProcessors(blockText, config, { ...options,
        filename: blockName
      });
    });
    return postprocess(messageLists, filenameToExpose);
  }

  getSourceCode() {
    return internalSlotsMap.get(this).lastSourceCode;
  }

  defineRule(ruleId, ruleModule) {
    internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);
  }

  defineRules(rulesToDefine) {
    Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {
      this.defineRule(ruleId, rulesToDefine[ruleId]);
    });
  }

  getRules() {
    const {
      lastConfigArray,
      ruleMap
    } = internalSlotsMap.get(this);
    return new Map(function* () {
      yield* ruleMap;

      if (lastConfigArray) {
        yield* lastConfigArray.pluginRules;
      }
    }());
  }

  defineParser(parserId, parserModule) {
    internalSlotsMap.get(this).parserMap.set(parserId, parserModule);
  }

  verifyAndFix(text, config, options) {
    let messages = [],
        fixedResult,
        fixed = false,
        passNumber = 0,
        currentText = text;
    const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;
    const shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;

    do {
      passNumber++;
      debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);
      messages = this.verify(currentText, config, options);
      debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);
      fixedResult = sourceCodeFixer.applyFixes(currentText, messages, shouldFix);

      if (messages.length === 1 && messages[0].fatal) {
        break;
      }

      fixed = fixed || fixedResult.fixed;
      currentText = fixedResult.output;
    } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);

    if (fixedResult.fixed) {
      fixedResult.messages = this.verify(currentText, config, options);
    }

    fixedResult.fixed = fixed;
    fixedResult.output = currentText;
    return fixedResult;
  }

}

var linter$1 = {
  Linter: Linter$1,

  getLinterInternalSlots(instance) {
    return internalSlotsMap.get(instance);
  }

};
const {
  Linter: Linter$2
} = linter$1;
var linter$2 = {
  Linter: Linter$2,
  SourceCodeFixer: sourceCodeFixer,
  interpolate
};
var linter_1 = linter$2.Linter;
var linter_1_1 = linter_1;

var indexB5dc13bc = {
	linter_1: linter_1_1
};

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var ast$1 = createCommonjsModule$1(function (module) {
(function () {

  function isExpression(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'ArrayExpression':
      case 'AssignmentExpression':
      case 'BinaryExpression':
      case 'CallExpression':
      case 'ConditionalExpression':
      case 'FunctionExpression':
      case 'Identifier':
      case 'Literal':
      case 'LogicalExpression':
      case 'MemberExpression':
      case 'NewExpression':
      case 'ObjectExpression':
      case 'SequenceExpression':
      case 'ThisExpression':
      case 'UnaryExpression':
      case 'UpdateExpression':
        return true;
    }

    return false;
  }

  function isIterationStatement(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'DoWhileStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'WhileStatement':
        return true;
    }

    return false;
  }

  function isStatement(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'BlockStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
      case 'DebuggerStatement':
      case 'DoWhileStatement':
      case 'EmptyStatement':
      case 'ExpressionStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'IfStatement':
      case 'LabeledStatement':
      case 'ReturnStatement':
      case 'SwitchStatement':
      case 'ThrowStatement':
      case 'TryStatement':
      case 'VariableDeclaration':
      case 'WhileStatement':
      case 'WithStatement':
        return true;
    }

    return false;
  }

  function isSourceElement(node) {
    return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
  }

  function trailingStatement(node) {
    switch (node.type) {
      case 'IfStatement':
        if (node.alternate != null) {
          return node.alternate;
        }

        return node.consequent;

      case 'LabeledStatement':
      case 'ForStatement':
      case 'ForInStatement':
      case 'WhileStatement':
      case 'WithStatement':
        return node.body;
    }

    return null;
  }

  function isProblematicIfStatement(node) {
    var current;

    if (node.type !== 'IfStatement') {
      return false;
    }

    if (node.alternate == null) {
      return false;
    }

    current = node.consequent;

    do {
      if (current.type === 'IfStatement') {
        if (current.alternate == null) {
          return true;
        }
      }

      current = trailingStatement(current);
    } while (current);

    return false;
  }

  module.exports = {
    isExpression: isExpression,
    isStatement: isStatement,
    isIterationStatement: isIterationStatement,
    isSourceElement: isSourceElement,
    isProblematicIfStatement: isProblematicIfStatement,
    trailingStatement: trailingStatement
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
});

/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var code = createCommonjsModule$1(function (module) {
(function () {

  var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch; // See `tools/generate-identifier-regex.js`.

  ES5Regex = {
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
  };
  ES6Regex = {
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };

  function isDecimalDigit(ch) {
    return 0x30 <= ch && ch <= 0x39; // 0..9
  }

  function isHexDigit(ch) {
    return 0x30 <= ch && ch <= 0x39 || // 0..9
    0x61 <= ch && ch <= 0x66 || // a..f
    0x41 <= ch && ch <= 0x46; // A..F
  }

  function isOctalDigit(ch) {
    return ch >= 0x30 && ch <= 0x37; // 0..7
  } // 7.2 White Space


  NON_ASCII_WHITESPACES = [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

  function isWhiteSpace(ch) {
    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
  } // 7.3 Line Terminators


  function isLineTerminator(ch) {
    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
  } // 7.6 Identifier Names and Identifiers


  function fromCodePoint(cp) {
    if (cp <= 0xFFFF) {
      return String.fromCharCode(cp);
    }

    var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
    var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
    return cu1 + cu2;
  }

  IDENTIFIER_START = new Array(0x80);

  for (ch = 0; ch < 0x80; ++ch) {
    IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
    ch >= 0x41 && ch <= 0x5A || // A..Z
    ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
  }

  IDENTIFIER_PART = new Array(0x80);

  for (ch = 0; ch < 0x80; ++ch) {
    IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
    ch >= 0x41 && ch <= 0x5A || // A..Z
    ch >= 0x30 && ch <= 0x39 || // 0..9
    ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
  }

  function isIdentifierStartES5(ch) {
    return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }

  function isIdentifierPartES5(ch) {
    return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }

  function isIdentifierStartES6(ch) {
    return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }

  function isIdentifierPartES6(ch) {
    return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }

  module.exports = {
    isDecimalDigit: isDecimalDigit,
    isHexDigit: isHexDigit,
    isOctalDigit: isOctalDigit,
    isWhiteSpace: isWhiteSpace,
    isLineTerminator: isLineTerminator,
    isIdentifierStartES5: isIdentifierStartES5,
    isIdentifierPartES5: isIdentifierPartES5,
    isIdentifierStartES6: isIdentifierStartES6,
    isIdentifierPartES6: isIdentifierPartES6
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
});

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var keyword = createCommonjsModule$1(function (module) {
(function () {

  var code$1 = code;

  function isStrictModeReservedWordES6(id) {
    switch (id) {
      case 'implements':
      case 'interface':
      case 'package':
      case 'private':
      case 'protected':
      case 'public':
      case 'static':
      case 'let':
        return true;

      default:
        return false;
    }
  }

  function isKeywordES5(id, strict) {
    // yield should not be treated as keyword under non-strict mode.
    if (!strict && id === 'yield') {
      return false;
    }

    return isKeywordES6(id, strict);
  }

  function isKeywordES6(id, strict) {
    if (strict && isStrictModeReservedWordES6(id)) {
      return true;
    }

    switch (id.length) {
      case 2:
        return id === 'if' || id === 'in' || id === 'do';

      case 3:
        return id === 'var' || id === 'for' || id === 'new' || id === 'try';

      case 4:
        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';

      case 5:
        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';

      case 6:
        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';

      case 7:
        return id === 'default' || id === 'finally' || id === 'extends';

      case 8:
        return id === 'function' || id === 'continue' || id === 'debugger';

      case 10:
        return id === 'instanceof';

      default:
        return false;
    }
  }

  function isReservedWordES5(id, strict) {
    return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
  }

  function isReservedWordES6(id, strict) {
    return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
  }

  function isRestrictedWord(id) {
    return id === 'eval' || id === 'arguments';
  }

  function isIdentifierNameES5(id) {
    var i, iz, ch;

    if (id.length === 0) {
      return false;
    }

    ch = id.charCodeAt(0);

    if (!code$1.isIdentifierStartES5(ch)) {
      return false;
    }

    for (i = 1, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);

      if (!code$1.isIdentifierPartES5(ch)) {
        return false;
      }
    }

    return true;
  }

  function decodeUtf16(lead, trail) {
    return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
  }

  function isIdentifierNameES6(id) {
    var i, iz, ch, lowCh, check;

    if (id.length === 0) {
      return false;
    }

    check = code$1.isIdentifierStartES6;

    for (i = 0, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);

      if (0xD800 <= ch && ch <= 0xDBFF) {
        ++i;

        if (i >= iz) {
          return false;
        }

        lowCh = id.charCodeAt(i);

        if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
          return false;
        }

        ch = decodeUtf16(ch, lowCh);
      }

      if (!check(ch)) {
        return false;
      }

      check = code$1.isIdentifierPartES6;
    }

    return true;
  }

  function isIdentifierES5(id, strict) {
    return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
  }

  function isIdentifierES6(id, strict) {
    return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
  }

  module.exports = {
    isKeywordES5: isKeywordES5,
    isKeywordES6: isKeywordES6,
    isReservedWordES5: isReservedWordES5,
    isReservedWordES6: isReservedWordES6,
    isRestrictedWord: isRestrictedWord,
    isIdentifierNameES5: isIdentifierNameES5,
    isIdentifierNameES6: isIdentifierNameES6,
    isIdentifierES5: isIdentifierES5,
    isIdentifierES6: isIdentifierES6
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
});

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var utils = createCommonjsModule$1(function (module, exports) {
(function () {

  exports.ast = ast$1;
  exports.code = code;
  exports.keyword = keyword;
})();
/* vim: set sw=4 ts=4 et tw=80 : */
});

var rbtree = createRBTree;
var RED = 0;
var BLACK = 1;

function RBNode(color, key, value, left, right, count) {
  this._color = color;
  this.key = key;
  this.value = value;
  this.left = left;
  this.right = right;
  this._count = count;
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
}

function RedBlackTree(compare, root) {
  this._compare = compare;
  this.root = root;
}

var proto = RedBlackTree.prototype;
Object.defineProperty(proto, "keys", {
  get: function () {
    var result = [];
    this.forEach(function (k, v) {
      result.push(k);
    });
    return result;
  }
});
Object.defineProperty(proto, "values", {
  get: function () {
    var result = [];
    this.forEach(function (k, v) {
      result.push(v);
    });
    return result;
  }
}); //Returns the number of nodes in the tree

Object.defineProperty(proto, "length", {
  get: function () {
    if (this.root) {
      return this.root._count;
    }

    return 0;
  }
}); //Insert a new item into the tree

proto.insert = function (key, value) {
  var cmp = this._compare; //Find point to insert new node at

  var n = this.root;
  var n_stack = [];
  var d_stack = [];

  while (n) {
    var d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);

    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  } //Rebuild path to leaf node


  n_stack.push(new RBNode(RED, key, value, null, null, 1));

  for (var s = n_stack.length - 2; s >= 0; --s) {
    var n = n_stack[s];

    if (d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
    }
  } //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)


  for (var s = n_stack.length - 1; s > 1; --s) {
    var p = n_stack[s - 1];
    var n = n_stack[s];

    if (p._color === BLACK || n._color === BLACK) {
      break;
    }

    var pp = n_stack[s - 2];

    if (pp.left === p) {
      if (p.left === n) {
        var y = pp.right;

        if (y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK;
          pp.right = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("LLb")
          pp._color = RED;
          pp.left = p.right;
          p._color = BLACK;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n;
          recount(pp);
          recount(p);

          if (s >= 3) {
            var ppp = n_stack[s - 3];

            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }

          break;
        }
      } else {
        var y = pp.right;

        if (y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK;
          pp.right = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("LRb")
          p.right = n.left;
          pp._color = RED;
          pp.left = n.right;
          n._color = BLACK;
          n.left = p;
          n.right = pp;
          n_stack[s - 2] = n;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n);

          if (s >= 3) {
            var ppp = n_stack[s - 3];

            if (ppp.left === pp) {
              ppp.left = n;
            } else {
              ppp.right = n;
            }
          }

          break;
        }
      }
    } else {
      if (p.right === n) {
        var y = pp.left;

        if (y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK;
          pp.left = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("RRb")
          pp._color = RED;
          pp.right = p.left;
          p._color = BLACK;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n;
          recount(pp);
          recount(p);

          if (s >= 3) {
            var ppp = n_stack[s - 3];

            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }

          break;
        }
      } else {
        var y = pp.left;

        if (y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK;
          pp.left = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("RLb")
          p.left = n.right;
          pp._color = RED;
          pp.right = n.left;
          n._color = BLACK;
          n.right = p;
          n.left = pp;
          n_stack[s - 2] = n;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n);

          if (s >= 3) {
            var ppp = n_stack[s - 3];

            if (ppp.right === pp) {
              ppp.right = n;
            } else {
              ppp.left = n;
            }
          }

          break;
        }
      }
    }
  } //Return new tree


  n_stack[0]._color = BLACK;
  return new RedBlackTree(cmp, n_stack[0]);
}; //Visit all nodes inorder


function doVisitFull(visit, node) {
  if (node.left) {
    var v = doVisitFull(visit, node.left);

    if (v) {
      return v;
    }
  }

  var v = visit(node.key, node.value);

  if (v) {
    return v;
  }

  if (node.right) {
    return doVisitFull(visit, node.right);
  }
} //Visit half nodes in order


function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key);

  if (l <= 0) {
    if (node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left);

      if (v) {
        return v;
      }
    }

    var v = visit(node.key, node.value);

    if (v) {
      return v;
    }
  }

  if (node.right) {
    return doVisitHalf(lo, compare, visit, node.right);
  }
} //Visit all nodes within a range


function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key);
  var h = compare(hi, node.key);
  var v;

  if (l <= 0) {
    if (node.left) {
      v = doVisit(lo, hi, compare, visit, node.left);

      if (v) {
        return v;
      }
    }

    if (h > 0) {
      v = visit(node.key, node.value);

      if (v) {
        return v;
      }
    }
  }

  if (h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right);
  }
}

proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if (!this.root) {
    return;
  }

  switch (arguments.length) {
    case 1:
      return doVisitFull(visit, this.root);

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root);

    case 3:
      if (this._compare(lo, hi) >= 0) {
        return;
      }

      return doVisit(lo, hi, this._compare, visit, this.root);
  }
}; //First item in list


Object.defineProperty(proto, "begin", {
  get: function () {
    var stack = [];
    var n = this.root;

    while (n) {
      stack.push(n);
      n = n.left;
    }

    return new RedBlackTreeIterator(this, stack);
  }
}); //Last item in list

Object.defineProperty(proto, "end", {
  get: function () {
    var stack = [];
    var n = this.root;

    while (n) {
      stack.push(n);
      n = n.right;
    }

    return new RedBlackTreeIterator(this, stack);
  }
}); //Find the ith item in the tree

proto.at = function (idx) {
  if (idx < 0) {
    return new RedBlackTreeIterator(this, []);
  }

  var n = this.root;
  var stack = [];

  while (true) {
    stack.push(n);

    if (n.left) {
      if (idx < n.left._count) {
        n = n.left;
        continue;
      }

      idx -= n.left._count;
    }

    if (!idx) {
      return new RedBlackTreeIterator(this, stack);
    }

    idx -= 1;

    if (n.right) {
      if (idx >= n.right._count) {
        break;
      }

      n = n.right;
    } else {
      break;
    }
  }

  return new RedBlackTreeIterator(this, []);
};

proto.ge = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;

  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);

    if (d <= 0) {
      last_ptr = stack.length;
    }

    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }

  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.gt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;

  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);

    if (d < 0) {
      last_ptr = stack.length;
    }

    if (d < 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }

  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.lt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;

  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);

    if (d > 0) {
      last_ptr = stack.length;
    }

    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }

  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.le = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;

  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);

    if (d >= 0) {
      last_ptr = stack.length;
    }

    if (d < 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }

  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
}; //Finds the item with key if it exists


proto.find = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];

  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);

    if (d === 0) {
      return new RedBlackTreeIterator(this, stack);
    }

    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }

  return new RedBlackTreeIterator(this, []);
}; //Removes item with key from tree


proto.remove = function (key) {
  var iter = this.find(key);

  if (iter) {
    return iter.remove();
  }

  return this;
}; //Returns the item at `key`


proto.get = function (key) {
  var cmp = this._compare;
  var n = this.root;

  while (n) {
    var d = cmp(key, n.key);

    if (d === 0) {
      return n.value;
    }

    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }

  return;
}; //Iterator for red black tree


function RedBlackTreeIterator(tree, stack) {
  this.tree = tree;
  this._stack = stack;
}

var iproto = RedBlackTreeIterator.prototype; //Test if iterator is valid

Object.defineProperty(iproto, "valid", {
  get: function () {
    return this._stack.length > 0;
  }
}); //Node of the iterator

Object.defineProperty(iproto, "node", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1];
    }

    return null;
  },
  enumerable: true
}); //Makes a copy of an iterator

iproto.clone = function () {
  return new RedBlackTreeIterator(this.tree, this._stack.slice());
}; //Swaps two nodes


function swapNode(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n._color = v._color;
  n._count = v._count;
} //Fix up a double black node in a tree


function fixDoubleBlack(stack) {
  var n, p, s, z;

  for (var i = stack.length - 1; i >= 0; --i) {
    n = stack[i];

    if (i === 0) {
      n._color = BLACK;
      return;
    } //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)


    p = stack[i - 1];

    if (p.left === n) {
      //console.log("left child")
      s = p.right;

      if (s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s);
        z = s.right = cloneNode(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s._color = p._color;
        n._color = BLACK;
        p._color = BLACK;
        z._color = BLACK;
        recount(p);
        recount(s);

        if (i > 1) {
          var pp = stack[i - 2];

          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }

        stack[i - 1] = s;
        return;
      } else if (s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s);
        z = s.left = cloneNode(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z._color = p._color;
        p._color = BLACK;
        s._color = BLACK;
        n._color = BLACK;
        recount(p);
        recount(s);
        recount(z);

        if (i > 1) {
          var pp = stack[i - 2];

          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }

        stack[i - 1] = z;
        return;
      }

      if (s._color === BLACK) {
        if (p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK;
          p.right = repaint(RED, s);
          return;
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s);
          continue;
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s);
        p.right = s.left;
        s.left = p;
        s._color = p._color;
        p._color = RED;
        recount(p);
        recount(s);

        if (i > 1) {
          var pp = stack[i - 2];

          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }

        stack[i - 1] = s;
        stack[i] = p;

        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }

        i = i + 2;
      }
    } else {
      //console.log("right child")
      s = p.left;

      if (s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s);
        z = s.left = cloneNode(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s._color = p._color;
        n._color = BLACK;
        p._color = BLACK;
        z._color = BLACK;
        recount(p);
        recount(s);

        if (i > 1) {
          var pp = stack[i - 2];

          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }

        stack[i - 1] = s;
        return;
      } else if (s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s);
        z = s.right = cloneNode(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z._color = p._color;
        p._color = BLACK;
        s._color = BLACK;
        n._color = BLACK;
        recount(p);
        recount(s);
        recount(z);

        if (i > 1) {
          var pp = stack[i - 2];

          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }

        stack[i - 1] = z;
        return;
      }

      if (s._color === BLACK) {
        if (p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK;
          p.left = repaint(RED, s);
          return;
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s);
          continue;
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s);
        p.left = s.right;
        s.right = p;
        s._color = p._color;
        p._color = RED;
        recount(p);
        recount(s);

        if (i > 1) {
          var pp = stack[i - 2];

          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }

        stack[i - 1] = s;
        stack[i] = p;

        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }

        i = i + 2;
      }
    }
  }
} //Removes item at iterator from tree


iproto.remove = function () {
  var stack = this._stack;

  if (stack.length === 0) {
    return this.tree;
  } //First copy path to node


  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);

  for (var i = stack.length - 2; i >= 0; --i) {
    var n = stack[i];

    if (n.left === stack[i + 1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }
  } //Get node


  n = cstack[cstack.length - 1]; //console.log("start remove: ", n.value)
  //If not leaf, then swap with previous node

  if (n.left && n.right) {
    //console.log("moving to leaf")
    //First walk to previous leaf
    var split = cstack.length;
    n = n.left;

    while (n.right) {
      cstack.push(n);
      n = n.right;
    } //Copy path to leaf


    var v = cstack[split - 1];
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
    cstack[split - 1].key = n.key;
    cstack[split - 1].value = n.value; //Fix up stack

    for (var i = cstack.length - 2; i >= split; --i) {
      n = cstack[i];
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }

    cstack[split - 1].left = cstack[split];
  } //console.log("stack=", cstack.map(function(v) { return v.value }))
  //Remove leaf node


  n = cstack[cstack.length - 1];

  if (n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length - 2];

    if (p.left === n) {
      p.left = null;
    } else if (p.right === n) {
      p.right = null;
    }

    cstack.pop();

    for (var i = 0; i < cstack.length; ++i) {
      cstack[i]._count--;
    }

    return new RedBlackTree(this.tree._compare, cstack[0]);
  } else {
    if (n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if (n.left) {
        swapNode(n, n.left);
      } else if (n.right) {
        swapNode(n, n.right);
      } //Child must be red, so repaint it black to balance color


      n._color = BLACK;

      for (var i = 0; i < cstack.length - 1; ++i) {
        cstack[i]._count--;
      }

      return new RedBlackTree(this.tree._compare, cstack[0]);
    } else if (cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null);
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for (var i = 0; i < cstack.length; ++i) {
        cstack[i]._count--;
      }

      var parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack); //Fix up links

      if (parent.left === n) {
        parent.left = null;
      } else {
        parent.right = null;
      }
    }
  }

  return new RedBlackTree(this.tree._compare, cstack[0]);
}; //Returns key


Object.defineProperty(iproto, "key", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1].key;
    }

    return;
  },
  enumerable: true
}); //Returns value

Object.defineProperty(iproto, "value", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1].value;
    }

    return;
  },
  enumerable: true
}); //Returns the position of this iterator in the sorted list

Object.defineProperty(iproto, "index", {
  get: function () {
    var idx = 0;
    var stack = this._stack;

    if (stack.length === 0) {
      var r = this.tree.root;

      if (r) {
        return r._count;
      }

      return 0;
    } else if (stack[stack.length - 1].left) {
      idx = stack[stack.length - 1].left._count;
    }

    for (var s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;

        if (stack[s].left) {
          idx += stack[s].left._count;
        }
      }
    }

    return idx;
  },
  enumerable: true
}); //Advances iterator to next element in list

iproto.next = function () {
  var stack = this._stack;

  if (stack.length === 0) {
    return;
  }

  var n = stack[stack.length - 1];

  if (n.right) {
    n = n.right;

    while (n) {
      stack.push(n);
      n = n.left;
    }
  } else {
    stack.pop();

    while (stack.length > 0 && stack[stack.length - 1].right === n) {
      n = stack[stack.length - 1];
      stack.pop();
    }
  }
}; //Checks if iterator is at end of tree


Object.defineProperty(iproto, "hasNext", {
  get: function () {
    var stack = this._stack;

    if (stack.length === 0) {
      return false;
    }

    if (stack[stack.length - 1].right) {
      return true;
    }

    for (var s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }

    return false;
  }
}); //Update value

iproto.update = function (value) {
  var stack = this._stack;

  if (stack.length === 0) {
    throw new Error("Can't update empty node!");
  }

  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);

  for (var i = stack.length - 2; i >= 0; --i) {
    n = stack[i];

    if (n.left === stack[i + 1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }
  }

  return new RedBlackTree(this.tree._compare, cstack[0]);
}; //Moves iterator backward one element


iproto.prev = function () {
  var stack = this._stack;

  if (stack.length === 0) {
    return;
  }

  var n = stack[stack.length - 1];

  if (n.left) {
    n = n.left;

    while (n) {
      stack.push(n);
      n = n.right;
    }
  } else {
    stack.pop();

    while (stack.length > 0 && stack[stack.length - 1].left === n) {
      n = stack[stack.length - 1];
      stack.pop();
    }
  }
}; //Checks if iterator is at start of tree


Object.defineProperty(iproto, "hasPrev", {
  get: function () {
    var stack = this._stack;

    if (stack.length === 0) {
      return false;
    }

    if (stack[stack.length - 1].left) {
      return true;
    }

    for (var s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }

    return false;
  }
}); //Default comparison function

function defaultCompare(a, b) {
  if (a < b) {
    return -1;
  }

  if (a > b) {
    return 1;
  }

  return 0;
} //Build a tree


function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null);
}

/*! @author Toru Nagashima <https://github.com/mysticatea> */
var ast = /*#__PURE__*/Object.freeze({});
let largeIdStartRanges = undefined;
let largeIdContinueRanges = undefined;

function isIdStart(cp) {
  if (cp < 0x41) return false;
  if (cp < 0x5b) return true;
  if (cp < 0x61) return false;
  if (cp < 0x7b) return true;
  return isLargeIdStart(cp);
}

function isIdContinue(cp) {
  if (cp < 0x30) return false;
  if (cp < 0x3a) return true;
  if (cp < 0x41) return false;
  if (cp < 0x5b) return true;
  if (cp === 0x5f) return true;
  if (cp < 0x61) return false;
  if (cp < 0x7b) return true;
  return isLargeIdStart(cp) || isLargeIdContinue(cp);
}

function isLargeIdStart(cp) {
  return isInRange$2(cp, largeIdStartRanges || (largeIdStartRanges = initLargeIdStartRanges()));
}

function isLargeIdContinue(cp) {
  return isInRange$2(cp, largeIdContinueRanges || (largeIdContinueRanges = initLargeIdContinueRanges()));
}

function initLargeIdStartRanges() {
  return restoreRanges("170 0 11 0 5 0 6 22 2 30 2 457 5 11 15 4 8 0 2 0 130 4 2 1 3 3 2 0 7 0 2 2 2 0 2 19 2 82 2 138 9 165 2 37 3 0 7 40 72 26 5 3 46 42 36 1 2 98 2 0 16 1 8 1 11 2 3 0 17 0 2 29 30 88 12 0 25 32 10 1 5 0 6 21 5 0 10 0 4 0 24 24 8 10 54 20 2 17 61 53 4 0 19 0 8 9 16 15 5 7 3 1 3 21 2 6 2 0 4 3 4 0 17 0 14 1 2 2 15 1 11 0 9 5 5 1 3 21 2 6 2 1 2 1 2 1 32 3 2 0 20 2 17 8 2 2 2 21 2 6 2 1 2 4 4 0 19 0 16 1 24 0 12 7 3 1 3 21 2 6 2 1 2 4 4 0 31 1 2 2 16 0 18 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 11 23 0 53 7 2 2 2 22 2 15 4 0 27 2 6 1 31 0 5 7 2 2 2 22 2 9 2 4 4 0 33 0 2 1 16 1 18 8 2 2 2 40 3 0 17 0 6 2 9 2 25 5 6 17 4 23 2 8 2 0 3 6 59 47 2 1 13 6 59 1 2 0 2 4 2 23 2 0 2 9 2 1 10 0 3 4 2 0 22 3 33 0 64 7 2 35 28 4 116 42 21 0 17 5 5 3 4 0 4 1 8 2 5 12 13 0 18 37 2 0 6 0 3 42 2 332 2 3 3 6 2 0 2 3 3 40 2 3 3 32 2 3 3 6 2 0 2 3 3 14 2 56 2 3 3 66 38 15 17 85 3 5 4 619 3 16 2 25 6 74 4 10 8 12 2 3 15 17 15 17 15 12 2 2 16 51 36 0 5 0 68 88 8 40 2 0 6 69 11 30 50 29 3 4 12 43 5 25 55 22 10 52 83 0 94 46 18 6 56 29 14 1 11 43 27 35 42 2 11 35 3 8 8 42 3 2 42 3 2 5 2 1 4 0 6 191 65 277 3 5 3 37 3 5 3 7 2 0 2 0 2 0 2 30 3 52 2 6 2 0 4 2 2 6 4 3 3 5 5 12 6 2 2 6 117 0 14 0 17 12 102 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 15 3 3 6 4 5 0 18 40 2680 46 2 46 2 132 7 3 4 1 13 37 2 0 6 0 3 55 8 0 17 22 10 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 551 2 26 8 8 4 3 4 5 85 5 4 2 89 2 3 6 42 2 93 18 31 49 15 513 6591 65 20988 4 1164 68 45 3 268 4 15 11 1 21 46 17 30 3 79 40 8 3 102 3 52 3 8 43 12 2 2 2 3 2 22 30 51 15 49 63 5 4 0 2 1 12 27 11 22 26 28 8 46 29 0 17 4 2 9 11 4 2 40 24 2 2 7 21 22 4 0 4 49 2 0 4 1 3 4 3 0 2 0 25 2 3 10 8 2 13 5 3 5 3 5 10 6 2 6 2 42 2 13 7 114 30 11171 13 22 5 48 8453 365 3 105 39 6 13 4 6 0 2 9 2 12 2 4 2 0 2 1 2 1 2 107 34 362 19 63 3 53 41 11 117 4 2 134 37 25 7 25 12 88 4 5 3 5 3 5 3 2 36 11 2 25 2 18 2 1 2 14 3 13 35 122 70 52 268 28 4 48 48 31 14 29 6 37 11 29 3 35 5 7 2 4 43 157 19 35 5 35 5 39 9 51 157 310 10 21 11 7 153 5 3 0 2 43 2 1 4 0 3 22 11 22 10 30 66 18 2 1 11 21 11 25 71 55 7 1 65 0 16 3 2 2 2 28 43 28 4 28 36 7 2 27 28 53 11 21 11 18 14 17 111 72 56 50 14 50 14 35 349 41 7 1 79 28 11 0 9 21 107 20 28 22 13 52 76 44 33 24 27 35 30 0 3 0 9 34 4 0 13 47 15 3 22 0 2 0 36 17 2 24 85 6 2 0 2 3 2 14 2 9 8 46 39 7 3 1 3 21 2 6 2 1 2 4 4 0 19 0 13 4 159 52 19 3 21 2 31 47 21 1 2 0 185 46 42 3 37 47 21 0 60 42 14 0 72 26 230 43 117 63 32 7 3 0 3 7 2 1 2 23 16 0 2 0 95 7 3 38 17 0 2 0 29 0 11 39 8 0 22 0 12 45 20 0 35 56 264 8 2 36 18 0 50 29 113 6 2 1 2 37 22 0 26 5 2 1 2 31 15 0 328 18 190 0 80 921 103 110 18 195 2749 1070 4050 582 8634 568 8 30 114 29 19 47 17 3 32 20 6 18 689 63 129 74 6 0 67 12 65 1 2 0 29 6135 9 1237 43 8 8952 286 50 2 18 3 9 395 2309 106 6 12 4 8 8 9 5991 84 2 70 2 1 3 0 3 1 3 3 2 11 2 0 2 6 2 64 2 3 3 7 2 6 2 27 2 3 2 4 2 0 4 6 2 339 3 24 2 24 2 30 2 24 2 30 2 24 2 30 2 24 2 30 2 24 2 7 2357 44 11 6 17 0 370 43 1301 196 60 67 8 0 1205 3 2 26 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 16 6 2 2 4 2 16 4421 42717 35 4148 12 221 3 5761 15 7472 3104 541 1507 4938");
}

function initLargeIdContinueRanges() {
  return restoreRanges("183 0 585 111 24 0 252 4 266 44 2 0 2 1 2 1 2 0 73 10 49 30 7 0 102 6 3 5 3 1 2 3 3 9 24 0 31 26 92 10 16 9 34 8 10 0 25 3 2 8 2 2 2 4 44 2 120 14 2 32 55 2 2 17 2 6 11 1 3 9 18 2 57 0 2 6 3 1 3 2 10 0 11 1 3 9 15 0 3 2 57 0 2 4 5 1 3 2 4 0 21 11 4 0 12 2 57 0 2 7 2 2 2 2 21 1 3 9 11 5 2 2 57 0 2 6 3 1 3 2 8 2 11 1 3 9 19 0 60 4 4 2 2 3 10 0 15 9 17 4 58 6 2 2 2 3 8 1 12 1 3 9 18 2 57 0 2 6 2 2 2 3 8 1 12 1 3 9 17 3 56 1 2 6 2 2 2 3 10 0 11 1 3 9 18 2 71 0 5 5 2 0 2 7 7 9 3 1 62 0 3 6 13 7 2 9 88 0 3 8 12 5 3 9 63 1 7 9 12 0 2 0 2 0 5 1 50 19 2 1 6 10 2 35 10 0 101 19 2 9 13 3 5 2 2 2 3 6 4 3 14 11 2 14 704 2 10 8 929 2 30 2 30 1 31 1 65 31 10 0 3 9 34 2 3 9 144 0 119 11 5 11 11 9 129 10 61 4 58 9 2 28 3 10 7 9 23 13 2 1 64 4 48 16 12 9 18 8 13 2 31 12 3 9 45 13 49 19 9 9 7 9 119 2 2 20 5 0 7 0 3 2 199 57 2 4 576 1 20 0 124 12 5 0 4 11 3071 2 142 0 97 31 555 5 106 1 30086 9 70 0 5 9 33 1 81 1 273 0 4 0 5 0 24 4 5 0 84 1 51 17 11 9 7 17 14 10 29 7 26 12 45 3 48 13 16 9 12 0 11 9 48 13 13 0 9 1 3 9 34 2 51 0 2 2 3 1 6 1 2 0 42 4 6 1 237 7 2 1 3 9 20261 0 738 15 17 15 4 1 25 2 193 9 38 0 702 0 227 0 150 4 294 9 1368 2 2 1 6 3 41 2 5 0 166 1 574 3 9 9 370 1 154 10 176 2 54 14 32 9 16 3 46 10 54 9 7 2 37 13 2 9 6 1 45 0 13 2 49 13 9 3 2 11 83 11 7 0 161 11 6 9 7 3 56 1 2 6 3 1 3 2 10 0 11 1 3 6 4 4 193 17 10 9 5 0 82 19 13 9 214 6 3 8 28 1 83 16 16 9 82 12 9 9 84 14 5 9 243 14 166 9 71 5 2 1 3 3 2 0 2 1 13 9 120 6 3 6 4 0 29 9 41 6 2 3 9 0 10 10 47 15 406 7 2 7 17 9 57 21 2 13 123 5 4 0 2 1 2 6 2 0 9 9 49 4 2 1 2 4 9 9 330 3 19306 9 135 4 60 6 26 9 1014 0 2 54 8 3 82 0 12 1 19628 1 5319 4 4 5 9 7 3 6 31 3 149 2 1418 49 513 54 5 49 9 0 15 0 23 4 2 14 1361 6 2 16 3 6 2 1 2 4 262 6 10 9 419 13 1495 6 110 6 6 9 4759 9 787719 239");
}

function isInRange$2(cp, ranges) {
  let l = 0,
      r = ranges.length / 2 | 0,
      i = 0,
      min = 0,
      max = 0;

  while (l < r) {
    i = (l + r) / 2 | 0;
    min = ranges[2 * i];
    max = ranges[2 * i + 1];

    if (cp < min) {
      r = i;
    } else if (cp > max) {
      l = i + 1;
    } else {
      return true;
    }
  }

  return false;
}

function restoreRanges(data) {
  let last = 0;
  return data.split(" ").map(s => last += parseInt(s, 10) | 0);
}

class DataSet {
  constructor(raw2018, raw2019, raw2020) {
    this._raw2018 = raw2018;
    this._raw2019 = raw2019;
    this._raw2020 = raw2020;
  }

  get es2018() {
    return this._set2018 || (this._set2018 = new Set(this._raw2018.split(" ")));
  }

  get es2019() {
    return this._set2019 || (this._set2019 = new Set(this._raw2019.split(" ")));
  }

  get es2020() {
    return this._set2020 || (this._set2020 = new Set(this._raw2020.split(" ")));
  }

}

const gcNameSet = new Set(["General_Category", "gc"]);
const scNameSet = new Set(["Script", "Script_Extensions", "sc", "scx"]);
const gcValueSets = new DataSet("C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct", "", "");
const scValueSets = new DataSet("Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy", "Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo", "Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho");
const binPropertySets = new DataSet("AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space", "Extended_Pictographic", "");

function isValidUnicodeProperty(version, name, value) {
  if (gcNameSet.has(name)) {
    return version >= 2018 && gcValueSets.es2018.has(value);
  }

  if (scNameSet.has(name)) {
    return version >= 2018 && scValueSets.es2018.has(value) || version >= 2019 && scValueSets.es2019.has(value) || version >= 2020 && scValueSets.es2020.has(value);
  }

  return false;
}

function isValidLoneUnicodeProperty(version, value) {
  return version >= 2018 && binPropertySets.es2018.has(value) || version >= 2019 && binPropertySets.es2019.has(value);
}

const Backspace = 0x08;
const CharacterTabulation = 0x09;
const LineFeed = 0x0a;
const LineTabulation = 0x0b;
const FormFeed = 0x0c;
const CarriageReturn = 0x0d;
const ExclamationMark = 0x21;
const DollarSign = 0x24;
const LeftParenthesis = 0x28;
const RightParenthesis = 0x29;
const Asterisk = 0x2a;
const PlusSign = 0x2b;
const Comma = 0x2c;
const HyphenMinus = 0x2d;
const FullStop = 0x2e;
const Solidus = 0x2f;
const DigitZero = 0x30;
const DigitOne = 0x31;
const DigitSeven = 0x37;
const DigitNine = 0x39;
const Colon = 0x3a;
const LessThanSign = 0x3c;
const EqualsSign = 0x3d;
const GreaterThanSign = 0x3e;
const QuestionMark = 0x3f;
const LatinCapitalLetterA = 0x41;
const LatinCapitalLetterB = 0x42;
const LatinCapitalLetterD = 0x44;
const LatinCapitalLetterF = 0x46;
const LatinCapitalLetterP = 0x50;
const LatinCapitalLetterS = 0x53;
const LatinCapitalLetterW = 0x57;
const LatinCapitalLetterZ = 0x5a;
const LowLine = 0x5f;
const LatinSmallLetterA = 0x61;
const LatinSmallLetterB = 0x62;
const LatinSmallLetterC = 0x63;
const LatinSmallLetterD = 0x64;
const LatinSmallLetterF = 0x66;
const LatinSmallLetterG = 0x67;
const LatinSmallLetterI = 0x69;
const LatinSmallLetterK = 0x6b;
const LatinSmallLetterM = 0x6d;
const LatinSmallLetterN = 0x6e;
const LatinSmallLetterP = 0x70;
const LatinSmallLetterR = 0x72;
const LatinSmallLetterS = 0x73;
const LatinSmallLetterT = 0x74;
const LatinSmallLetterU = 0x75;
const LatinSmallLetterV = 0x76;
const LatinSmallLetterW = 0x77;
const LatinSmallLetterX = 0x78;
const LatinSmallLetterY = 0x79;
const LatinSmallLetterZ = 0x7a;
const LeftSquareBracket = 0x5b;
const ReverseSolidus = 0x5c;
const RightSquareBracket = 0x5d;
const CircumflexAccent = 0x5e;
const LeftCurlyBracket = 0x7b;
const VerticalLine = 0x7c;
const RightCurlyBracket = 0x7d;
const ZeroWidthNonJoiner = 0x200c;
const ZeroWidthJoiner = 0x200d;
const LineSeparator = 0x2028;
const ParagraphSeparator = 0x2029;
const MinCodePoint = 0x00;
const MaxCodePoint = 0x10ffff;

function isLatinLetter(code) {
  return code >= LatinCapitalLetterA && code <= LatinCapitalLetterZ || code >= LatinSmallLetterA && code <= LatinSmallLetterZ;
}

function isDecimalDigit(code) {
  return code >= DigitZero && code <= DigitNine;
}

function isOctalDigit(code) {
  return code >= DigitZero && code <= DigitSeven;
}

function isHexDigit(code) {
  return code >= DigitZero && code <= DigitNine || code >= LatinCapitalLetterA && code <= LatinCapitalLetterF || code >= LatinSmallLetterA && code <= LatinSmallLetterF;
}

function isLineTerminator(code) {
  return code === LineFeed || code === CarriageReturn || code === LineSeparator || code === ParagraphSeparator;
}

function isValidUnicode(code) {
  return code >= MinCodePoint && code <= MaxCodePoint;
}

function digitToInt(code) {
  if (code >= LatinSmallLetterA && code <= LatinSmallLetterF) {
    return code - LatinSmallLetterA + 10;
  }

  if (code >= LatinCapitalLetterA && code <= LatinCapitalLetterF) {
    return code - LatinCapitalLetterA + 10;
  }

  return code - DigitZero;
}

function isLeadSurrogate(code) {
  return code >= 0xd800 && code <= 0xdbff;
}

function isTrailSurrogate(code) {
  return code >= 0xdc00 && code <= 0xdfff;
}

function combineSurrogatePair(lead, trail) {
  return (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000;
}

const legacyImpl = {
  at(s, end, i) {
    return i < end ? s.charCodeAt(i) : -1;
  },

  width(c) {
    return 1;
  }

};
const unicodeImpl = {
  at(s, end, i) {
    return i < end ? s.codePointAt(i) : -1;
  },

  width(c) {
    return c > 0xffff ? 2 : 1;
  }

};

class Reader {
  constructor() {
    this._impl = legacyImpl;
    this._s = "";
    this._i = 0;
    this._end = 0;
    this._cp1 = -1;
    this._w1 = 1;
    this._cp2 = -1;
    this._w2 = 1;
    this._cp3 = -1;
    this._w3 = 1;
    this._cp4 = -1;
  }

  get source() {
    return this._s;
  }

  get index() {
    return this._i;
  }

  get currentCodePoint() {
    return this._cp1;
  }

  get nextCodePoint() {
    return this._cp2;
  }

  get nextCodePoint2() {
    return this._cp3;
  }

  get nextCodePoint3() {
    return this._cp4;
  }

  reset(source, start, end, uFlag) {
    this._impl = uFlag ? unicodeImpl : legacyImpl;
    this._s = source;
    this._end = end;
    this.rewind(start);
  }

  rewind(index) {
    const impl = this._impl;
    this._i = index;
    this._cp1 = impl.at(this._s, this._end, index);
    this._w1 = impl.width(this._cp1);
    this._cp2 = impl.at(this._s, this._end, index + this._w1);
    this._w2 = impl.width(this._cp2);
    this._cp3 = impl.at(this._s, this._end, index + this._w1 + this._w2);
    this._w3 = impl.width(this._cp3);
    this._cp4 = impl.at(this._s, this._end, index + this._w1 + this._w2 + this._w3);
  }

  advance() {
    if (this._cp1 !== -1) {
      const impl = this._impl;
      this._i += this._w1;
      this._cp1 = this._cp2;
      this._w1 = this._w2;
      this._cp2 = this._cp3;
      this._w2 = impl.width(this._cp2);
      this._cp3 = this._cp4;
      this._w3 = impl.width(this._cp3);
      this._cp4 = impl.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);
    }
  }

  eat(cp) {
    if (this._cp1 === cp) {
      this.advance();
      return true;
    }

    return false;
  }

  eat2(cp1, cp2) {
    if (this._cp1 === cp1 && this._cp2 === cp2) {
      this.advance();
      this.advance();
      return true;
    }

    return false;
  }

  eat3(cp1, cp2, cp3) {
    if (this._cp1 === cp1 && this._cp2 === cp2 && this._cp3 === cp3) {
      this.advance();
      this.advance();
      this.advance();
      return true;
    }

    return false;
  }

}

class RegExpSyntaxError extends SyntaxError {
  constructor(source, uFlag, index, message) {
    if (source) {
      if (!source.startsWith("/")) {
        source = `/${source}/${uFlag ? "u" : ""}`;
      }

      source = `: ${source}`;
    }

    super(`Invalid regular expression${source}: ${message}`);
    this.index = index;
  }

}

function isSyntaxCharacter(cp) {
  return cp === CircumflexAccent || cp === DollarSign || cp === ReverseSolidus || cp === FullStop || cp === Asterisk || cp === PlusSign || cp === QuestionMark || cp === LeftParenthesis || cp === RightParenthesis || cp === LeftSquareBracket || cp === RightSquareBracket || cp === LeftCurlyBracket || cp === RightCurlyBracket || cp === VerticalLine;
}

function isRegExpIdentifierStart(cp) {
  return isIdStart(cp) || cp === DollarSign || cp === LowLine;
}

function isRegExpIdentifierPart(cp) {
  return isIdContinue(cp) || cp === DollarSign || cp === LowLine || cp === ZeroWidthNonJoiner || cp === ZeroWidthJoiner;
}

function isUnicodePropertyNameCharacter(cp) {
  return isLatinLetter(cp) || cp === LowLine;
}

function isUnicodePropertyValueCharacter(cp) {
  return isUnicodePropertyNameCharacter(cp) || isDecimalDigit(cp);
}

class RegExpValidator$2 {
  constructor(options) {
    this._reader = new Reader();
    this._uFlag = false;
    this._nFlag = false;
    this._lastIntValue = 0;
    this._lastMinValue = 0;
    this._lastMaxValue = 0;
    this._lastStrValue = "";
    this._lastKeyValue = "";
    this._lastValValue = "";
    this._lastAssertionIsQuantifiable = false;
    this._numCapturingParens = 0;
    this._groupNames = new Set();
    this._backreferenceNames = new Set();
    this._options = options || {};
  }

  validateLiteral(source, start = 0, end = source.length) {
    this._uFlag = this._nFlag = false;
    this.reset(source, start, end);
    this.onLiteralEnter(start);

    if (this.eat(Solidus) && this.eatRegExpBody() && this.eat(Solidus)) {
      const flagStart = this.index;
      const uFlag = source.includes("u", flagStart);
      this.validateFlags(source, flagStart, end);
      this.validatePattern(source, start + 1, flagStart - 1, uFlag);
    } else if (start >= end) {
      this.raise("Empty");
    } else {
      const c = String.fromCodePoint(this.currentCodePoint);
      this.raise(`Unexpected character '${c}'`);
    }

    this.onLiteralLeave(start, end);
  }

  validateFlags(source, start = 0, end = source.length) {
    const existingFlags = new Set();
    let global = false;
    let ignoreCase = false;
    let multiline = false;
    let sticky = false;
    let unicode = false;
    let dotAll = false;

    for (let i = start; i < end; ++i) {
      const flag = source.charCodeAt(i);

      if (existingFlags.has(flag)) {
        this.raise(`Duplicated flag '${source[i]}'`);
      }

      existingFlags.add(flag);

      if (flag === LatinSmallLetterG) {
        global = true;
      } else if (flag === LatinSmallLetterI) {
        ignoreCase = true;
      } else if (flag === LatinSmallLetterM) {
        multiline = true;
      } else if (flag === LatinSmallLetterU && this.ecmaVersion >= 2015) {
        unicode = true;
      } else if (flag === LatinSmallLetterY && this.ecmaVersion >= 2015) {
        sticky = true;
      } else if (flag === LatinSmallLetterS && this.ecmaVersion >= 2018) {
        dotAll = true;
      } else {
        this.raise(`Invalid flag '${source[i]}'`);
      }
    }

    this.onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll);
  }

  validatePattern(source, start = 0, end = source.length, uFlag = false) {
    this._uFlag = uFlag && this.ecmaVersion >= 2015;
    this._nFlag = uFlag && this.ecmaVersion >= 2018;
    this.reset(source, start, end);
    this.consumePattern();

    if (!this._nFlag && this.ecmaVersion >= 2018 && this._groupNames.size > 0) {
      this._nFlag = true;
      this.rewind(start);
      this.consumePattern();
    }
  }

  get strict() {
    return Boolean(this._options.strict || this._uFlag);
  }

  get ecmaVersion() {
    return this._options.ecmaVersion || 2020;
  }

  onLiteralEnter(start) {
    if (this._options.onLiteralEnter) {
      this._options.onLiteralEnter(start);
    }
  }

  onLiteralLeave(start, end) {
    if (this._options.onLiteralLeave) {
      this._options.onLiteralLeave(start, end);
    }
  }

  onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll) {
    if (this._options.onFlags) {
      this._options.onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll);
    }
  }

  onPatternEnter(start) {
    if (this._options.onPatternEnter) {
      this._options.onPatternEnter(start);
    }
  }

  onPatternLeave(start, end) {
    if (this._options.onPatternLeave) {
      this._options.onPatternLeave(start, end);
    }
  }

  onDisjunctionEnter(start) {
    if (this._options.onDisjunctionEnter) {
      this._options.onDisjunctionEnter(start);
    }
  }

  onDisjunctionLeave(start, end) {
    if (this._options.onDisjunctionLeave) {
      this._options.onDisjunctionLeave(start, end);
    }
  }

  onAlternativeEnter(start, index) {
    if (this._options.onAlternativeEnter) {
      this._options.onAlternativeEnter(start, index);
    }
  }

  onAlternativeLeave(start, end, index) {
    if (this._options.onAlternativeLeave) {
      this._options.onAlternativeLeave(start, end, index);
    }
  }

  onGroupEnter(start) {
    if (this._options.onGroupEnter) {
      this._options.onGroupEnter(start);
    }
  }

  onGroupLeave(start, end) {
    if (this._options.onGroupLeave) {
      this._options.onGroupLeave(start, end);
    }
  }

  onCapturingGroupEnter(start, name) {
    if (this._options.onCapturingGroupEnter) {
      this._options.onCapturingGroupEnter(start, name);
    }
  }

  onCapturingGroupLeave(start, end, name) {
    if (this._options.onCapturingGroupLeave) {
      this._options.onCapturingGroupLeave(start, end, name);
    }
  }

  onQuantifier(start, end, min, max, greedy) {
    if (this._options.onQuantifier) {
      this._options.onQuantifier(start, end, min, max, greedy);
    }
  }

  onLookaroundAssertionEnter(start, kind, negate) {
    if (this._options.onLookaroundAssertionEnter) {
      this._options.onLookaroundAssertionEnter(start, kind, negate);
    }
  }

  onLookaroundAssertionLeave(start, end, kind, negate) {
    if (this._options.onLookaroundAssertionLeave) {
      this._options.onLookaroundAssertionLeave(start, end, kind, negate);
    }
  }

  onEdgeAssertion(start, end, kind) {
    if (this._options.onEdgeAssertion) {
      this._options.onEdgeAssertion(start, end, kind);
    }
  }

  onWordBoundaryAssertion(start, end, kind, negate) {
    if (this._options.onWordBoundaryAssertion) {
      this._options.onWordBoundaryAssertion(start, end, kind, negate);
    }
  }

  onAnyCharacterSet(start, end, kind) {
    if (this._options.onAnyCharacterSet) {
      this._options.onAnyCharacterSet(start, end, kind);
    }
  }

  onEscapeCharacterSet(start, end, kind, negate) {
    if (this._options.onEscapeCharacterSet) {
      this._options.onEscapeCharacterSet(start, end, kind, negate);
    }
  }

  onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {
    if (this._options.onUnicodePropertyCharacterSet) {
      this._options.onUnicodePropertyCharacterSet(start, end, kind, key, value, negate);
    }
  }

  onCharacter(start, end, value) {
    if (this._options.onCharacter) {
      this._options.onCharacter(start, end, value);
    }
  }

  onBackreference(start, end, ref) {
    if (this._options.onBackreference) {
      this._options.onBackreference(start, end, ref);
    }
  }

  onCharacterClassEnter(start, negate) {
    if (this._options.onCharacterClassEnter) {
      this._options.onCharacterClassEnter(start, negate);
    }
  }

  onCharacterClassLeave(start, end, negate) {
    if (this._options.onCharacterClassLeave) {
      this._options.onCharacterClassLeave(start, end, negate);
    }
  }

  onCharacterClassRange(start, end, min, max) {
    if (this._options.onCharacterClassRange) {
      this._options.onCharacterClassRange(start, end, min, max);
    }
  }

  get source() {
    return this._reader.source;
  }

  get index() {
    return this._reader.index;
  }

  get currentCodePoint() {
    return this._reader.currentCodePoint;
  }

  get nextCodePoint() {
    return this._reader.nextCodePoint;
  }

  get nextCodePoint2() {
    return this._reader.nextCodePoint2;
  }

  get nextCodePoint3() {
    return this._reader.nextCodePoint3;
  }

  reset(source, start, end) {
    this._reader.reset(source, start, end, this._uFlag);
  }

  rewind(index) {
    this._reader.rewind(index);
  }

  advance() {
    this._reader.advance();
  }

  eat(cp) {
    return this._reader.eat(cp);
  }

  eat2(cp1, cp2) {
    return this._reader.eat2(cp1, cp2);
  }

  eat3(cp1, cp2, cp3) {
    return this._reader.eat3(cp1, cp2, cp3);
  }

  raise(message) {
    throw new RegExpSyntaxError(this.source, this._uFlag, this.index, message);
  }

  eatRegExpBody() {
    const start = this.index;
    let inClass = false;
    let escaped = false;

    for (;;) {
      const cp = this.currentCodePoint;

      if (cp === -1 || isLineTerminator(cp)) {
        const kind = inClass ? "character class" : "regular expression";
        this.raise(`Unterminated ${kind}`);
      }

      if (escaped) {
        escaped = false;
      } else if (cp === ReverseSolidus) {
        escaped = true;
      } else if (cp === LeftSquareBracket) {
        inClass = true;
      } else if (cp === RightSquareBracket) {
        inClass = false;
      } else if (cp === Solidus && !inClass || cp === Asterisk && this.index === start) {
        break;
      }

      this.advance();
    }

    return this.index !== start;
  }

  consumePattern() {
    const start = this.index;
    this._numCapturingParens = this.countCapturingParens();

    this._groupNames.clear();

    this._backreferenceNames.clear();

    this.onPatternEnter(start);
    this.consumeDisjunction();
    const cp = this.currentCodePoint;

    if (this.currentCodePoint !== -1) {
      if (cp === RightParenthesis) {
        this.raise("Unmatched ')'");
      }

      if (cp === ReverseSolidus) {
        this.raise("\\ at end of pattern");
      }

      if (cp === RightSquareBracket || cp === RightCurlyBracket) {
        this.raise("Lone quantifier brackets");
      }

      const c = String.fromCodePoint(cp);
      this.raise(`Unexpected character '${c}'`);
    }

    for (const name of this._backreferenceNames) {
      if (!this._groupNames.has(name)) {
        this.raise("Invalid named capture referenced");
      }
    }

    this.onPatternLeave(start, this.index);
  }

  countCapturingParens() {
    const start = this.index;
    let inClass = false;
    let escaped = false;
    let count = 0;
    let cp = 0;

    while ((cp = this.currentCodePoint) !== -1) {
      if (escaped) {
        escaped = false;
      } else if (cp === ReverseSolidus) {
        escaped = true;
      } else if (cp === LeftSquareBracket) {
        inClass = true;
      } else if (cp === RightSquareBracket) {
        inClass = false;
      } else if (cp === LeftParenthesis && !inClass && (this.nextCodePoint !== QuestionMark || this.nextCodePoint2 === LessThanSign && this.nextCodePoint3 !== EqualsSign && this.nextCodePoint3 !== ExclamationMark)) {
        count += 1;
      }

      this.advance();
    }

    this.rewind(start);
    return count;
  }

  consumeDisjunction() {
    const start = this.index;
    let i = 0;
    this.onDisjunctionEnter(start);

    do {
      this.consumeAlternative(i++);
    } while (this.eat(VerticalLine));

    if (this.consumeQuantifier(true)) {
      this.raise("Nothing to repeat");
    }

    if (this.eat(LeftCurlyBracket)) {
      this.raise("Lone quantifier brackets");
    }

    this.onDisjunctionLeave(start, this.index);
  }

  consumeAlternative(i) {
    const start = this.index;
    this.onAlternativeEnter(start, i);

    while (this.currentCodePoint !== -1 && this.consumeTerm()) {}

    this.onAlternativeLeave(start, this.index, i);
  }

  consumeTerm() {
    if (this._uFlag || this.strict) {
      return this.consumeAssertion() || this.consumeAtom() && this.consumeOptionalQuantifier();
    }

    return this.consumeAssertion() && (!this._lastAssertionIsQuantifiable || this.consumeOptionalQuantifier()) || this.consumeExtendedAtom() && this.consumeOptionalQuantifier();
  }

  consumeOptionalQuantifier() {
    this.consumeQuantifier();
    return true;
  }

  consumeAssertion() {
    const start = this.index;
    this._lastAssertionIsQuantifiable = false;

    if (this.eat(CircumflexAccent)) {
      this.onEdgeAssertion(start, this.index, "start");
      return true;
    }

    if (this.eat(DollarSign)) {
      this.onEdgeAssertion(start, this.index, "end");
      return true;
    }

    if (this.eat2(ReverseSolidus, LatinCapitalLetterB)) {
      this.onWordBoundaryAssertion(start, this.index, "word", true);
      return true;
    }

    if (this.eat2(ReverseSolidus, LatinSmallLetterB)) {
      this.onWordBoundaryAssertion(start, this.index, "word", false);
      return true;
    }

    if (this.eat2(LeftParenthesis, QuestionMark)) {
      const lookbehind = this.ecmaVersion >= 2018 && this.eat(LessThanSign);
      let negate = false;

      if (this.eat(EqualsSign) || (negate = this.eat(ExclamationMark))) {
        const kind = lookbehind ? "lookbehind" : "lookahead";
        this.onLookaroundAssertionEnter(start, kind, negate);
        this.consumeDisjunction();

        if (!this.eat(RightParenthesis)) {
          this.raise("Unterminated group");
        }

        this._lastAssertionIsQuantifiable = !lookbehind && !this.strict;
        this.onLookaroundAssertionLeave(start, this.index, kind, negate);
        return true;
      }

      this.rewind(start);
    }

    return false;
  }

  consumeQuantifier(noConsume = false) {
    const start = this.index;
    let min = 0;
    let max = 0;
    let greedy = false;

    if (this.eat(Asterisk)) {
      min = 0;
      max = Number.POSITIVE_INFINITY;
    } else if (this.eat(PlusSign)) {
      min = 1;
      max = Number.POSITIVE_INFINITY;
    } else if (this.eat(QuestionMark)) {
      min = 0;
      max = 1;
    } else if (this.eatBracedQuantifier(noConsume)) {
      min = this._lastMinValue;
      max = this._lastMaxValue;
    } else {
      return false;
    }

    greedy = !this.eat(QuestionMark);

    if (!noConsume) {
      this.onQuantifier(start, this.index, min, max, greedy);
    }

    return true;
  }

  eatBracedQuantifier(noError) {
    const start = this.index;

    if (this.eat(LeftCurlyBracket)) {
      this._lastMinValue = 0;
      this._lastMaxValue = Number.POSITIVE_INFINITY;

      if (this.eatDecimalDigits()) {
        this._lastMinValue = this._lastMaxValue = this._lastIntValue;

        if (this.eat(Comma)) {
          this._lastMaxValue = this.eatDecimalDigits() ? this._lastIntValue : Number.POSITIVE_INFINITY;
        }

        if (this.eat(RightCurlyBracket)) {
          if (!noError && this._lastMaxValue < this._lastMinValue) {
            this.raise("numbers out of order in {} quantifier");
          }

          return true;
        }
      }

      if (!noError && (this._uFlag || this.strict)) {
        this.raise("Incomplete quantifier");
      }

      this.rewind(start);
    }

    return false;
  }

  consumeAtom() {
    return this.consumePatternCharacter() || this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup();
  }

  consumeDot() {
    if (this.eat(FullStop)) {
      this.onAnyCharacterSet(this.index - 1, this.index, "any");
      return true;
    }

    return false;
  }

  consumeReverseSolidusAtomEscape() {
    const start = this.index;

    if (this.eat(ReverseSolidus)) {
      if (this.consumeAtomEscape()) {
        return true;
      }

      this.rewind(start);
    }

    return false;
  }

  consumeUncapturingGroup() {
    const start = this.index;

    if (this.eat3(LeftParenthesis, QuestionMark, Colon)) {
      this.onGroupEnter(start);
      this.consumeDisjunction();

      if (!this.eat(RightParenthesis)) {
        this.raise("Unterminated group");
      }

      this.onGroupLeave(start, this.index);
      return true;
    }

    return false;
  }

  consumeCapturingGroup() {
    const start = this.index;

    if (this.eat(LeftParenthesis)) {
      let name = null;

      if (this.ecmaVersion >= 2018) {
        if (this.consumeGroupSpecifier()) {
          name = this._lastStrValue;
        }
      } else if (this.currentCodePoint === QuestionMark) {
        this.raise("Invalid group");
      }

      this.onCapturingGroupEnter(start, name);
      this.consumeDisjunction();

      if (!this.eat(RightParenthesis)) {
        this.raise("Unterminated group");
      }

      this.onCapturingGroupLeave(start, this.index, name);
      return true;
    }

    return false;
  }

  consumeExtendedAtom() {
    return this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeReverseSolidusFollowedByC() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup() || this.consumeInvalidBracedQuantifier() || this.consumeExtendedPatternCharacter();
  }

  consumeReverseSolidusFollowedByC() {
    const start = this.index;

    if (this.currentCodePoint === ReverseSolidus && this.nextCodePoint === LatinSmallLetterC) {
      this._lastIntValue = this.currentCodePoint;
      this.advance();
      this.onCharacter(start, this.index, ReverseSolidus);
      return true;
    }

    return false;
  }

  consumeInvalidBracedQuantifier() {
    if (this.eatBracedQuantifier(true)) {
      this.raise("Nothing to repeat");
    }

    return false;
  }

  consumePatternCharacter() {
    const start = this.index;
    const cp = this.currentCodePoint;

    if (cp !== -1 && !isSyntaxCharacter(cp)) {
      this.advance();
      this.onCharacter(start, this.index, cp);
      return true;
    }

    return false;
  }

  consumeExtendedPatternCharacter() {
    const start = this.index;
    const cp = this.currentCodePoint;

    if (cp !== -1 && cp !== CircumflexAccent && cp !== DollarSign && cp !== ReverseSolidus && cp !== FullStop && cp !== Asterisk && cp !== PlusSign && cp !== QuestionMark && cp !== LeftParenthesis && cp !== RightParenthesis && cp !== LeftSquareBracket && cp !== VerticalLine) {
      this.advance();
      this.onCharacter(start, this.index, cp);
      return true;
    }

    return false;
  }

  consumeGroupSpecifier() {
    if (this.eat(QuestionMark)) {
      if (this.eatGroupName()) {
        if (!this._groupNames.has(this._lastStrValue)) {
          this._groupNames.add(this._lastStrValue);

          return true;
        }

        this.raise("Duplicate capture group name");
      }

      this.raise("Invalid group");
    }

    return false;
  }

  consumeAtomEscape() {
    if (this.consumeBackreference() || this.consumeCharacterClassEscape() || this.consumeCharacterEscape() || this._nFlag && this.consumeKGroupName()) {
      return true;
    }

    if (this.strict || this._uFlag) {
      this.raise("Invalid escape");
    }

    return false;
  }

  consumeBackreference() {
    const start = this.index;

    if (this.eatDecimalEscape()) {
      const n = this._lastIntValue;

      if (n <= this._numCapturingParens) {
        this.onBackreference(start - 1, this.index, n);
        return true;
      }

      if (this.strict || this._uFlag) {
        this.raise("Invalid escape");
      }

      this.rewind(start);
    }

    return false;
  }

  consumeCharacterClassEscape() {
    const start = this.index;

    if (this.eat(LatinSmallLetterD)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "digit", false);
      return true;
    }

    if (this.eat(LatinCapitalLetterD)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "digit", true);
      return true;
    }

    if (this.eat(LatinSmallLetterS)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "space", false);
      return true;
    }

    if (this.eat(LatinCapitalLetterS)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "space", true);
      return true;
    }

    if (this.eat(LatinSmallLetterW)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "word", false);
      return true;
    }

    if (this.eat(LatinCapitalLetterW)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "word", true);
      return true;
    }

    let negate = false;

    if (this._uFlag && this.ecmaVersion >= 2018 && (this.eat(LatinSmallLetterP) || (negate = this.eat(LatinCapitalLetterP)))) {
      this._lastIntValue = -1;

      if (this.eat(LeftCurlyBracket) && this.eatUnicodePropertyValueExpression() && this.eat(RightCurlyBracket)) {
        this.onUnicodePropertyCharacterSet(start - 1, this.index, "property", this._lastKeyValue, this._lastValValue || null, negate);
        return true;
      }

      this.raise("Invalid property name");
    }

    return false;
  }

  consumeCharacterEscape() {
    const start = this.index;

    if (this.eatControlEscape() || this.eatCControlLetter() || this.eatZero() || this.eatHexEscapeSequence() || this.eatRegExpUnicodeEscapeSequence() || !this.strict && !this._uFlag && this.eatLegacyOctalEscapeSequence() || this.eatIdentityEscape()) {
      this.onCharacter(start - 1, this.index, this._lastIntValue);
      return true;
    }

    return false;
  }

  consumeKGroupName() {
    const start = this.index;

    if (this.eat(LatinSmallLetterK)) {
      if (this.eatGroupName()) {
        const groupName = this._lastStrValue;

        this._backreferenceNames.add(groupName);

        this.onBackreference(start - 1, this.index, groupName);
        return true;
      }

      this.raise("Invalid named reference");
    }

    return false;
  }

  consumeCharacterClass() {
    const start = this.index;

    if (this.eat(LeftSquareBracket)) {
      const negate = this.eat(CircumflexAccent);
      this.onCharacterClassEnter(start, negate);
      this.consumeClassRanges();

      if (!this.eat(RightSquareBracket)) {
        this.raise("Unterminated character class");
      }

      this.onCharacterClassLeave(start, this.index, negate);
      return true;
    }

    return false;
  }

  consumeClassRanges() {
    const strict = this.strict || this._uFlag;

    for (;;) {
      const rangeStart = this.index;

      if (!this.consumeClassAtom()) {
        break;
      }

      const min = this._lastIntValue;

      if (!this.eat(HyphenMinus)) {
        continue;
      }

      this.onCharacter(this.index - 1, this.index, HyphenMinus);

      if (!this.consumeClassAtom()) {
        break;
      }

      const max = this._lastIntValue;

      if (min === -1 || max === -1) {
        if (strict) {
          this.raise("Invalid character class");
        }

        continue;
      }

      if (min > max) {
        this.raise("Range out of order in character class");
      }

      this.onCharacterClassRange(rangeStart, this.index, min, max);
    }
  }

  consumeClassAtom() {
    const start = this.index;
    const cp = this.currentCodePoint;

    if (cp !== -1 && cp !== ReverseSolidus && cp !== RightSquareBracket) {
      this.advance();
      this._lastIntValue = cp;
      this.onCharacter(start, this.index, this._lastIntValue);
      return true;
    }

    if (this.eat(ReverseSolidus)) {
      if (this.consumeClassEscape()) {
        return true;
      }

      if (!this.strict && this.currentCodePoint === LatinSmallLetterC) {
        this._lastIntValue = ReverseSolidus;
        this.onCharacter(start, this.index, this._lastIntValue);
        return true;
      }

      if (this.strict || this._uFlag) {
        this.raise("Invalid escape");
      }

      this.rewind(start);
    }

    return false;
  }

  consumeClassEscape() {
    const start = this.index;

    if (this.eat(LatinSmallLetterB)) {
      this._lastIntValue = Backspace;
      this.onCharacter(start - 1, this.index, this._lastIntValue);
      return true;
    }

    if (this._uFlag && this.eat(HyphenMinus)) {
      this._lastIntValue = HyphenMinus;
      this.onCharacter(start - 1, this.index, this._lastIntValue);
      return true;
    }

    let cp = 0;

    if (!this.strict && !this._uFlag && this.currentCodePoint === LatinSmallLetterC && (isDecimalDigit(cp = this.nextCodePoint) || cp === LowLine)) {
      this.advance();
      this.advance();
      this._lastIntValue = cp % 0x20;
      this.onCharacter(start - 1, this.index, this._lastIntValue);
      return true;
    }

    return this.consumeCharacterClassEscape() || this.consumeCharacterEscape();
  }

  eatGroupName() {
    if (this.eat(LessThanSign)) {
      if (this.eatRegExpIdentifierName() && this.eat(GreaterThanSign)) {
        return true;
      }

      this.raise("Invalid capture group name");
    }

    return false;
  }

  eatRegExpIdentifierName() {
    if (this.eatRegExpIdentifierStart()) {
      this._lastStrValue = String.fromCodePoint(this._lastIntValue);

      while (this.eatRegExpIdentifierPart()) {
        this._lastStrValue += String.fromCodePoint(this._lastIntValue);
      }

      return true;
    }

    return false;
  }

  eatRegExpIdentifierStart() {
    const start = this.index;
    const forceUFlag = !this._uFlag && this.ecmaVersion >= 2020;
    let cp = this.currentCodePoint;
    this.advance();

    if (cp === ReverseSolidus && this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {
      cp = this._lastIntValue;
    } else if (forceUFlag && isLeadSurrogate(cp) && isTrailSurrogate(this.currentCodePoint)) {
      cp = combineSurrogatePair(cp, this.currentCodePoint);
      this.advance();
    }

    if (isRegExpIdentifierStart(cp)) {
      this._lastIntValue = cp;
      return true;
    }

    if (this.index !== start) {
      this.rewind(start);
    }

    return false;
  }

  eatRegExpIdentifierPart() {
    const start = this.index;
    const forceUFlag = !this._uFlag && this.ecmaVersion >= 2020;
    let cp = this.currentCodePoint;
    this.advance();

    if (cp === ReverseSolidus && this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {
      cp = this._lastIntValue;
    } else if (forceUFlag && isLeadSurrogate(cp) && isTrailSurrogate(this.currentCodePoint)) {
      cp = combineSurrogatePair(cp, this.currentCodePoint);
      this.advance();
    }

    if (isRegExpIdentifierPart(cp)) {
      this._lastIntValue = cp;
      return true;
    }

    if (this.index !== start) {
      this.rewind(start);
    }

    return false;
  }

  eatCControlLetter() {
    const start = this.index;

    if (this.eat(LatinSmallLetterC)) {
      if (this.eatControlLetter()) {
        return true;
      }

      this.rewind(start);
    }

    return false;
  }

  eatZero() {
    if (this.currentCodePoint === DigitZero && !isDecimalDigit(this.nextCodePoint)) {
      this._lastIntValue = 0;
      this.advance();
      return true;
    }

    return false;
  }

  eatControlEscape() {
    if (this.eat(LatinSmallLetterF)) {
      this._lastIntValue = FormFeed;
      return true;
    }

    if (this.eat(LatinSmallLetterN)) {
      this._lastIntValue = LineFeed;
      return true;
    }

    if (this.eat(LatinSmallLetterR)) {
      this._lastIntValue = CarriageReturn;
      return true;
    }

    if (this.eat(LatinSmallLetterT)) {
      this._lastIntValue = CharacterTabulation;
      return true;
    }

    if (this.eat(LatinSmallLetterV)) {
      this._lastIntValue = LineTabulation;
      return true;
    }

    return false;
  }

  eatControlLetter() {
    const cp = this.currentCodePoint;

    if (isLatinLetter(cp)) {
      this.advance();
      this._lastIntValue = cp % 0x20;
      return true;
    }

    return false;
  }

  eatRegExpUnicodeEscapeSequence(forceUFlag = false) {
    const start = this.index;
    const uFlag = forceUFlag || this._uFlag;

    if (this.eat(LatinSmallLetterU)) {
      if (uFlag && this.eatRegExpUnicodeSurrogatePairEscape() || this.eatFixedHexDigits(4) || uFlag && this.eatRegExpUnicodeCodePointEscape()) {
        return true;
      }

      if (this.strict || uFlag) {
        this.raise("Invalid unicode escape");
      }

      this.rewind(start);
    }

    return false;
  }

  eatRegExpUnicodeSurrogatePairEscape() {
    const start = this.index;

    if (this.eatFixedHexDigits(4)) {
      const lead = this._lastIntValue;

      if (isLeadSurrogate(lead) && this.eat(ReverseSolidus) && this.eat(LatinSmallLetterU) && this.eatFixedHexDigits(4)) {
        const trail = this._lastIntValue;

        if (isTrailSurrogate(trail)) {
          this._lastIntValue = combineSurrogatePair(lead, trail);
          return true;
        }
      }

      this.rewind(start);
    }

    return false;
  }

  eatRegExpUnicodeCodePointEscape() {
    const start = this.index;

    if (this.eat(LeftCurlyBracket) && this.eatHexDigits() && this.eat(RightCurlyBracket) && isValidUnicode(this._lastIntValue)) {
      return true;
    }

    this.rewind(start);
    return false;
  }

  eatIdentityEscape() {
    const cp = this.currentCodePoint;

    if (this.isValidIdentityEscape(cp)) {
      this._lastIntValue = cp;
      this.advance();
      return true;
    }

    return false;
  }

  isValidIdentityEscape(cp) {
    if (cp === -1) {
      return false;
    }

    if (this._uFlag) {
      return isSyntaxCharacter(cp) || cp === Solidus;
    }

    if (this.strict) {
      return !isIdContinue(cp);
    }

    if (this._nFlag) {
      return !(cp === LatinSmallLetterC || cp === LatinSmallLetterK);
    }

    return cp !== LatinSmallLetterC;
  }

  eatDecimalEscape() {
    this._lastIntValue = 0;
    let cp = this.currentCodePoint;

    if (cp >= DigitOne && cp <= DigitNine) {
      do {
        this._lastIntValue = 10 * this._lastIntValue + (cp - DigitZero);
        this.advance();
      } while ((cp = this.currentCodePoint) >= DigitZero && cp <= DigitNine);

      return true;
    }

    return false;
  }

  eatUnicodePropertyValueExpression() {
    const start = this.index;

    if (this.eatUnicodePropertyName() && this.eat(EqualsSign)) {
      this._lastKeyValue = this._lastStrValue;

      if (this.eatUnicodePropertyValue()) {
        this._lastValValue = this._lastStrValue;

        if (isValidUnicodeProperty(this.ecmaVersion, this._lastKeyValue, this._lastValValue)) {
          return true;
        }

        this.raise("Invalid property name");
      }
    }

    this.rewind(start);

    if (this.eatLoneUnicodePropertyNameOrValue()) {
      const nameOrValue = this._lastStrValue;

      if (isValidUnicodeProperty(this.ecmaVersion, "General_Category", nameOrValue)) {
        this._lastKeyValue = "General_Category";
        this._lastValValue = nameOrValue;
        return true;
      }

      if (isValidLoneUnicodeProperty(this.ecmaVersion, nameOrValue)) {
        this._lastKeyValue = nameOrValue;
        this._lastValValue = "";
        return true;
      }

      this.raise("Invalid property name");
    }

    return false;
  }

  eatUnicodePropertyName() {
    this._lastStrValue = "";

    while (isUnicodePropertyNameCharacter(this.currentCodePoint)) {
      this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
      this.advance();
    }

    return this._lastStrValue !== "";
  }

  eatUnicodePropertyValue() {
    this._lastStrValue = "";

    while (isUnicodePropertyValueCharacter(this.currentCodePoint)) {
      this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
      this.advance();
    }

    return this._lastStrValue !== "";
  }

  eatLoneUnicodePropertyNameOrValue() {
    return this.eatUnicodePropertyValue();
  }

  eatHexEscapeSequence() {
    const start = this.index;

    if (this.eat(LatinSmallLetterX)) {
      if (this.eatFixedHexDigits(2)) {
        return true;
      }

      if (this._uFlag || this.strict) {
        this.raise("Invalid escape");
      }

      this.rewind(start);
    }

    return false;
  }

  eatDecimalDigits() {
    const start = this.index;
    this._lastIntValue = 0;

    while (isDecimalDigit(this.currentCodePoint)) {
      this._lastIntValue = 10 * this._lastIntValue + digitToInt(this.currentCodePoint);
      this.advance();
    }

    return this.index !== start;
  }

  eatHexDigits() {
    const start = this.index;
    this._lastIntValue = 0;

    while (isHexDigit(this.currentCodePoint)) {
      this._lastIntValue = 16 * this._lastIntValue + digitToInt(this.currentCodePoint);
      this.advance();
    }

    return this.index !== start;
  }

  eatLegacyOctalEscapeSequence() {
    if (this.eatOctalDigit()) {
      const n1 = this._lastIntValue;

      if (this.eatOctalDigit()) {
        const n2 = this._lastIntValue;

        if (n1 <= 3 && this.eatOctalDigit()) {
          this._lastIntValue = n1 * 64 + n2 * 8 + this._lastIntValue;
        } else {
          this._lastIntValue = n1 * 8 + n2;
        }
      } else {
        this._lastIntValue = n1;
      }

      return true;
    }

    return false;
  }

  eatOctalDigit() {
    const cp = this.currentCodePoint;

    if (isOctalDigit(cp)) {
      this.advance();
      this._lastIntValue = cp - DigitZero;
      return true;
    }

    this._lastIntValue = 0;
    return false;
  }

  eatFixedHexDigits(length) {
    const start = this.index;
    this._lastIntValue = 0;

    for (let i = 0; i < length; ++i) {
      const cp = this.currentCodePoint;

      if (!isHexDigit(cp)) {
        this.rewind(start);
        return false;
      }

      this._lastIntValue = 16 * this._lastIntValue + digitToInt(cp);
      this.advance();
    }

    return true;
  }

}

const DummyPattern = {};
const DummyFlags = {};
const DummyCapturingGroup = {};

class RegExpParserState {
  constructor(options) {
    this._node = DummyPattern;
    this._flags = DummyFlags;
    this._backreferences = [];
    this._capturingGroups = [];
    this.source = "";
    this.strict = Boolean(options && options.strict);
    this.ecmaVersion = options && options.ecmaVersion || 2020;
  }

  get pattern() {
    if (this._node.type !== "Pattern") {
      throw new Error("UnknownError");
    }

    return this._node;
  }

  get flags() {
    if (this._flags.type !== "Flags") {
      throw new Error("UnknownError");
    }

    return this._flags;
  }

  onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll) {
    this._flags = {
      type: "Flags",
      parent: null,
      start,
      end,
      raw: this.source.slice(start, end),
      global,
      ignoreCase,
      multiline,
      unicode,
      sticky,
      dotAll
    };
  }

  onPatternEnter(start) {
    this._node = {
      type: "Pattern",
      parent: null,
      start,
      end: start,
      raw: "",
      alternatives: []
    };
    this._backreferences.length = 0;
    this._capturingGroups.length = 0;
  }

  onPatternLeave(start, end) {
    this._node.end = end;
    this._node.raw = this.source.slice(start, end);

    for (const reference of this._backreferences) {
      const ref = reference.ref;
      const group = typeof ref === "number" ? this._capturingGroups[ref - 1] : this._capturingGroups.find(g => g.name === ref);
      reference.resolved = group;
      group.references.push(reference);
    }
  }

  onAlternativeEnter(start) {
    const parent = this._node;

    if (parent.type !== "Assertion" && parent.type !== "CapturingGroup" && parent.type !== "Group" && parent.type !== "Pattern") {
      throw new Error("UnknownError");
    }

    this._node = {
      type: "Alternative",
      parent,
      start,
      end: start,
      raw: "",
      elements: []
    };
    parent.alternatives.push(this._node);
  }

  onAlternativeLeave(start, end) {
    const node = this._node;

    if (node.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }

  onGroupEnter(start) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    this._node = {
      type: "Group",
      parent,
      start,
      end: start,
      raw: "",
      alternatives: []
    };
    parent.elements.push(this._node);
  }

  onGroupLeave(start, end) {
    const node = this._node;

    if (node.type !== "Group" || node.parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }

  onCapturingGroupEnter(start, name) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    this._node = {
      type: "CapturingGroup",
      parent,
      start,
      end: start,
      raw: "",
      name,
      alternatives: [],
      references: []
    };
    parent.elements.push(this._node);

    this._capturingGroups.push(this._node);
  }

  onCapturingGroupLeave(start, end) {
    const node = this._node;

    if (node.type !== "CapturingGroup" || node.parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }

  onQuantifier(start, end, min, max, greedy) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    const element = parent.elements.pop();

    if (element == null || element.type === "Quantifier" || element.type === "Assertion" && element.kind !== "lookahead") {
      throw new Error("UnknownError");
    }

    const node = {
      type: "Quantifier",
      parent,
      start: element.start,
      end,
      raw: this.source.slice(element.start, end),
      min,
      max,
      greedy,
      element
    };
    parent.elements.push(node);
    element.parent = node;
  }

  onLookaroundAssertionEnter(start, kind, negate) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    const node = this._node = {
      type: "Assertion",
      parent,
      start,
      end: start,
      raw: "",
      kind,
      negate,
      alternatives: []
    };
    parent.elements.push(node);
  }

  onLookaroundAssertionLeave(start, end) {
    const node = this._node;

    if (node.type !== "Assertion" || node.parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }

  onEdgeAssertion(start, end, kind) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    parent.elements.push({
      type: "Assertion",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind
    });
  }

  onWordBoundaryAssertion(start, end, kind, negate) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    parent.elements.push({
      type: "Assertion",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind,
      negate
    });
  }

  onAnyCharacterSet(start, end, kind) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    parent.elements.push({
      type: "CharacterSet",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind
    });
  }

  onEscapeCharacterSet(start, end, kind, negate) {
    const parent = this._node;

    if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
      throw new Error("UnknownError");
    }

    parent.elements.push({
      type: "CharacterSet",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind,
      negate
    });
  }

  onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {
    const parent = this._node;

    if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
      throw new Error("UnknownError");
    }

    parent.elements.push({
      type: "CharacterSet",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind,
      key,
      value,
      negate
    });
  }

  onCharacter(start, end, value) {
    const parent = this._node;

    if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
      throw new Error("UnknownError");
    }

    parent.elements.push({
      type: "Character",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      value
    });
  }

  onBackreference(start, end, ref) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    const node = {
      type: "Backreference",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      ref,
      resolved: DummyCapturingGroup
    };
    parent.elements.push(node);

    this._backreferences.push(node);
  }

  onCharacterClassEnter(start, negate) {
    const parent = this._node;

    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    this._node = {
      type: "CharacterClass",
      parent,
      start,
      end: start,
      raw: "",
      negate,
      elements: []
    };
    parent.elements.push(this._node);
  }

  onCharacterClassLeave(start, end) {
    const node = this._node;

    if (node.type !== "CharacterClass" || node.parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }

    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }

  onCharacterClassRange(start, end) {
    const parent = this._node;

    if (parent.type !== "CharacterClass") {
      throw new Error("UnknownError");
    }

    const elements = parent.elements;
    const max = elements.pop();
    const hyphen = elements.pop();
    const min = elements.pop();

    if (!min || !max || !hyphen || min.type !== "Character" || max.type !== "Character" || hyphen.type !== "Character" || hyphen.value !== HyphenMinus) {
      throw new Error("UnknownError");
    }

    const node = {
      type: "CharacterClassRange",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      min,
      max
    };
    min.parent = node;
    max.parent = node;
    elements.push(node);
  }

}

class RegExpParser$2 {
  constructor(options) {
    this._state = new RegExpParserState(options);
    this._validator = new RegExpValidator$2(this._state);
  }

  parseLiteral(source, start = 0, end = source.length) {
    this._state.source = source;

    this._validator.validateLiteral(source, start, end);

    const pattern = this._state.pattern;
    const flags = this._state.flags;
    const literal = {
      type: "RegExpLiteral",
      parent: null,
      start,
      end,
      raw: source,
      pattern,
      flags
    };
    pattern.parent = literal;
    flags.parent = literal;
    return literal;
  }

  parseFlags(source, start = 0, end = source.length) {
    this._state.source = source;

    this._validator.validateFlags(source, start, end);

    return this._state.flags;
  }

  parsePattern(source, start = 0, end = source.length, uFlag = false) {
    this._state.source = source;

    this._validator.validatePattern(source, start, end, uFlag);

    return this._state.pattern;
  }

}

class RegExpVisitor {
  constructor(handlers) {
    this._handlers = handlers;
  }

  visit(node) {
    switch (node.type) {
      case "Alternative":
        this.visitAlternative(node);
        break;

      case "Assertion":
        this.visitAssertion(node);
        break;

      case "Backreference":
        this.visitBackreference(node);
        break;

      case "CapturingGroup":
        this.visitCapturingGroup(node);
        break;

      case "Character":
        this.visitCharacter(node);
        break;

      case "CharacterClass":
        this.visitCharacterClass(node);
        break;

      case "CharacterClassRange":
        this.visitCharacterClassRange(node);
        break;

      case "CharacterSet":
        this.visitCharacterSet(node);
        break;

      case "Flags":
        this.visitFlags(node);
        break;

      case "Group":
        this.visitGroup(node);
        break;

      case "Pattern":
        this.visitPattern(node);
        break;

      case "Quantifier":
        this.visitQuantifier(node);
        break;

      case "RegExpLiteral":
        this.visitRegExpLiteral(node);
        break;

      default:
        throw new Error(`Unknown type: ${node.type}`);
    }
  }

  visitAlternative(node) {
    if (this._handlers.onAlternativeEnter) {
      this._handlers.onAlternativeEnter(node);
    }

    node.elements.forEach(this.visit, this);

    if (this._handlers.onAlternativeLeave) {
      this._handlers.onAlternativeLeave(node);
    }
  }

  visitAssertion(node) {
    if (this._handlers.onAssertionEnter) {
      this._handlers.onAssertionEnter(node);
    }

    if (node.kind === "lookahead" || node.kind === "lookbehind") {
      node.alternatives.forEach(this.visit, this);
    }

    if (this._handlers.onAssertionLeave) {
      this._handlers.onAssertionLeave(node);
    }
  }

  visitBackreference(node) {
    if (this._handlers.onBackreferenceEnter) {
      this._handlers.onBackreferenceEnter(node);
    }

    if (this._handlers.onBackreferenceLeave) {
      this._handlers.onBackreferenceLeave(node);
    }
  }

  visitCapturingGroup(node) {
    if (this._handlers.onCapturingGroupEnter) {
      this._handlers.onCapturingGroupEnter(node);
    }

    node.alternatives.forEach(this.visit, this);

    if (this._handlers.onCapturingGroupLeave) {
      this._handlers.onCapturingGroupLeave(node);
    }
  }

  visitCharacter(node) {
    if (this._handlers.onCharacterEnter) {
      this._handlers.onCharacterEnter(node);
    }

    if (this._handlers.onCharacterLeave) {
      this._handlers.onCharacterLeave(node);
    }
  }

  visitCharacterClass(node) {
    if (this._handlers.onCharacterClassEnter) {
      this._handlers.onCharacterClassEnter(node);
    }

    node.elements.forEach(this.visit, this);

    if (this._handlers.onCharacterClassLeave) {
      this._handlers.onCharacterClassLeave(node);
    }
  }

  visitCharacterClassRange(node) {
    if (this._handlers.onCharacterClassRangeEnter) {
      this._handlers.onCharacterClassRangeEnter(node);
    }

    this.visitCharacter(node.min);
    this.visitCharacter(node.max);

    if (this._handlers.onCharacterClassRangeLeave) {
      this._handlers.onCharacterClassRangeLeave(node);
    }
  }

  visitCharacterSet(node) {
    if (this._handlers.onCharacterSetEnter) {
      this._handlers.onCharacterSetEnter(node);
    }

    if (this._handlers.onCharacterSetLeave) {
      this._handlers.onCharacterSetLeave(node);
    }
  }

  visitFlags(node) {
    if (this._handlers.onFlagsEnter) {
      this._handlers.onFlagsEnter(node);
    }

    if (this._handlers.onFlagsLeave) {
      this._handlers.onFlagsLeave(node);
    }
  }

  visitGroup(node) {
    if (this._handlers.onGroupEnter) {
      this._handlers.onGroupEnter(node);
    }

    node.alternatives.forEach(this.visit, this);

    if (this._handlers.onGroupLeave) {
      this._handlers.onGroupLeave(node);
    }
  }

  visitPattern(node) {
    if (this._handlers.onPatternEnter) {
      this._handlers.onPatternEnter(node);
    }

    node.alternatives.forEach(this.visit, this);

    if (this._handlers.onPatternLeave) {
      this._handlers.onPatternLeave(node);
    }
  }

  visitQuantifier(node) {
    if (this._handlers.onQuantifierEnter) {
      this._handlers.onQuantifierEnter(node);
    }

    this.visit(node.element);

    if (this._handlers.onQuantifierLeave) {
      this._handlers.onQuantifierLeave(node);
    }
  }

  visitRegExpLiteral(node) {
    if (this._handlers.onRegExpLiteralEnter) {
      this._handlers.onRegExpLiteralEnter(node);
    }

    this.visitPattern(node.pattern);
    this.visitFlags(node.flags);

    if (this._handlers.onRegExpLiteralLeave) {
      this._handlers.onRegExpLiteralLeave(node);
    }
  }

}

function parseRegExpLiteral(source, options) {
  return new RegExpParser$2(options).parseLiteral(String(source));
}

function validateRegExpLiteral(source, options) {
  return new RegExpValidator$2(options).validateLiteral(source);
}

function visitRegExpAST$2(node, handlers) {
  new RegExpVisitor(handlers).visit(node);
}

var regexpp$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AST: ast,
  RegExpParser: RegExpParser$2,
  RegExpValidator: RegExpValidator$2,
  parseRegExpLiteral: parseRegExpLiteral,
  validateRegExpLiteral: validateRegExpLiteral,
  visitRegExpAST: visitRegExpAST$2
});

var builtin = {
	AggregateError: false,
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	FinalizationRegistry: false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	WeakRef: false,
	"WeakSet": false
};
var es5 = {
	"Array": false,
	"Boolean": false,
	constructor: false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	propertyIsEnumerable: false,
	"RangeError": false,
	"ReferenceError": false,
	"RegExp": false,
	"String": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false
};
var es2015 = {
	"Array": false,
	"ArrayBuffer": false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es2017 = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es2020 = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es2021 = {
	AggregateError: false,
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	FinalizationRegistry: false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	WeakRef: false,
	"WeakSet": false
};
var browser = {
	AbortController: false,
	AbortSignal: false,
	addEventListener: false,
	alert: false,
	AnalyserNode: false,
	Animation: false,
	AnimationEffectReadOnly: false,
	AnimationEffectTiming: false,
	AnimationEffectTimingReadOnly: false,
	AnimationEvent: false,
	AnimationPlaybackEvent: false,
	AnimationTimeline: false,
	applicationCache: false,
	ApplicationCache: false,
	ApplicationCacheErrorEvent: false,
	atob: false,
	Attr: false,
	Audio: false,
	AudioBuffer: false,
	AudioBufferSourceNode: false,
	AudioContext: false,
	AudioDestinationNode: false,
	AudioListener: false,
	AudioNode: false,
	AudioParam: false,
	AudioProcessingEvent: false,
	AudioScheduledSourceNode: false,
	"AudioWorkletGlobalScope ": false,
	AudioWorkletNode: false,
	AudioWorkletProcessor: false,
	BarProp: false,
	BaseAudioContext: false,
	BatteryManager: false,
	BeforeUnloadEvent: false,
	BiquadFilterNode: false,
	Blob: false,
	BlobEvent: false,
	blur: false,
	BroadcastChannel: false,
	btoa: false,
	BudgetService: false,
	ByteLengthQueuingStrategy: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	cancelAnimationFrame: false,
	cancelIdleCallback: false,
	CanvasCaptureMediaStreamTrack: false,
	CanvasGradient: false,
	CanvasPattern: false,
	CanvasRenderingContext2D: false,
	ChannelMergerNode: false,
	ChannelSplitterNode: false,
	CharacterData: false,
	clearInterval: false,
	clearTimeout: false,
	clientInformation: false,
	ClipboardEvent: false,
	close: false,
	closed: false,
	CloseEvent: false,
	Comment: false,
	CompositionEvent: false,
	confirm: false,
	console: false,
	ConstantSourceNode: false,
	ConvolverNode: false,
	CountQueuingStrategy: false,
	createImageBitmap: false,
	Credential: false,
	CredentialsContainer: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CSS: false,
	CSSConditionRule: false,
	CSSFontFaceRule: false,
	CSSGroupingRule: false,
	CSSImportRule: false,
	CSSKeyframeRule: false,
	CSSKeyframesRule: false,
	CSSMediaRule: false,
	CSSNamespaceRule: false,
	CSSPageRule: false,
	CSSRule: false,
	CSSRuleList: false,
	CSSStyleDeclaration: false,
	CSSStyleRule: false,
	CSSStyleSheet: false,
	CSSSupportsRule: false,
	CustomElementRegistry: false,
	customElements: false,
	CustomEvent: false,
	DataTransfer: false,
	DataTransferItem: false,
	DataTransferItemList: false,
	defaultstatus: false,
	defaultStatus: false,
	DelayNode: false,
	DeviceMotionEvent: false,
	DeviceOrientationEvent: false,
	devicePixelRatio: false,
	dispatchEvent: false,
	document: false,
	Document: false,
	DocumentFragment: false,
	DocumentType: false,
	DOMError: false,
	DOMException: false,
	DOMImplementation: false,
	DOMMatrix: false,
	DOMMatrixReadOnly: false,
	DOMParser: false,
	DOMPoint: false,
	DOMPointReadOnly: false,
	DOMQuad: false,
	DOMRect: false,
	DOMRectReadOnly: false,
	DOMStringList: false,
	DOMStringMap: false,
	DOMTokenList: false,
	DragEvent: false,
	DynamicsCompressorNode: false,
	Element: false,
	ErrorEvent: false,
	event: false,
	Event: false,
	EventSource: false,
	EventTarget: false,
	external: false,
	fetch: false,
	File: false,
	FileList: false,
	FileReader: false,
	find: false,
	focus: false,
	FocusEvent: false,
	FontFace: false,
	FontFaceSetLoadEvent: false,
	FormData: false,
	frameElement: false,
	frames: false,
	GainNode: false,
	Gamepad: false,
	GamepadButton: false,
	GamepadEvent: false,
	getComputedStyle: false,
	getSelection: false,
	HashChangeEvent: false,
	Headers: false,
	history: false,
	History: false,
	HTMLAllCollection: false,
	HTMLAnchorElement: false,
	HTMLAreaElement: false,
	HTMLAudioElement: false,
	HTMLBaseElement: false,
	HTMLBodyElement: false,
	HTMLBRElement: false,
	HTMLButtonElement: false,
	HTMLCanvasElement: false,
	HTMLCollection: false,
	HTMLContentElement: false,
	HTMLDataElement: false,
	HTMLDataListElement: false,
	HTMLDetailsElement: false,
	HTMLDialogElement: false,
	HTMLDirectoryElement: false,
	HTMLDivElement: false,
	HTMLDListElement: false,
	HTMLDocument: false,
	HTMLElement: false,
	HTMLEmbedElement: false,
	HTMLFieldSetElement: false,
	HTMLFontElement: false,
	HTMLFormControlsCollection: false,
	HTMLFormElement: false,
	HTMLFrameElement: false,
	HTMLFrameSetElement: false,
	HTMLHeadElement: false,
	HTMLHeadingElement: false,
	HTMLHRElement: false,
	HTMLHtmlElement: false,
	HTMLIFrameElement: false,
	HTMLImageElement: false,
	HTMLInputElement: false,
	HTMLLabelElement: false,
	HTMLLegendElement: false,
	HTMLLIElement: false,
	HTMLLinkElement: false,
	HTMLMapElement: false,
	HTMLMarqueeElement: false,
	HTMLMediaElement: false,
	HTMLMenuElement: false,
	HTMLMetaElement: false,
	HTMLMeterElement: false,
	HTMLModElement: false,
	HTMLObjectElement: false,
	HTMLOListElement: false,
	HTMLOptGroupElement: false,
	HTMLOptionElement: false,
	HTMLOptionsCollection: false,
	HTMLOutputElement: false,
	HTMLParagraphElement: false,
	HTMLParamElement: false,
	HTMLPictureElement: false,
	HTMLPreElement: false,
	HTMLProgressElement: false,
	HTMLQuoteElement: false,
	HTMLScriptElement: false,
	HTMLSelectElement: false,
	HTMLShadowElement: false,
	HTMLSlotElement: false,
	HTMLSourceElement: false,
	HTMLSpanElement: false,
	HTMLStyleElement: false,
	HTMLTableCaptionElement: false,
	HTMLTableCellElement: false,
	HTMLTableColElement: false,
	HTMLTableElement: false,
	HTMLTableRowElement: false,
	HTMLTableSectionElement: false,
	HTMLTemplateElement: false,
	HTMLTextAreaElement: false,
	HTMLTimeElement: false,
	HTMLTitleElement: false,
	HTMLTrackElement: false,
	HTMLUListElement: false,
	HTMLUnknownElement: false,
	HTMLVideoElement: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	IdleDeadline: false,
	IIRFilterNode: false,
	Image: false,
	ImageBitmap: false,
	ImageBitmapRenderingContext: false,
	ImageCapture: false,
	ImageData: false,
	indexedDB: false,
	innerHeight: false,
	innerWidth: false,
	InputEvent: false,
	IntersectionObserver: false,
	IntersectionObserverEntry: false,
	"Intl": false,
	isSecureContext: false,
	KeyboardEvent: false,
	KeyframeEffect: false,
	KeyframeEffectReadOnly: false,
	length: false,
	localStorage: false,
	location: true,
	Location: false,
	locationbar: false,
	matchMedia: false,
	MediaDeviceInfo: false,
	MediaDevices: false,
	MediaElementAudioSourceNode: false,
	MediaEncryptedEvent: false,
	MediaError: false,
	MediaKeyMessageEvent: false,
	MediaKeySession: false,
	MediaKeyStatusMap: false,
	MediaKeySystemAccess: false,
	MediaList: false,
	MediaQueryList: false,
	MediaQueryListEvent: false,
	MediaRecorder: false,
	MediaSettingsRange: false,
	MediaSource: false,
	MediaStream: false,
	MediaStreamAudioDestinationNode: false,
	MediaStreamAudioSourceNode: false,
	MediaStreamEvent: false,
	MediaStreamTrack: false,
	MediaStreamTrackEvent: false,
	menubar: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	MIDIAccess: false,
	MIDIConnectionEvent: false,
	MIDIInput: false,
	MIDIInputMap: false,
	MIDIMessageEvent: false,
	MIDIOutput: false,
	MIDIOutputMap: false,
	MIDIPort: false,
	MimeType: false,
	MimeTypeArray: false,
	MouseEvent: false,
	moveBy: false,
	moveTo: false,
	MutationEvent: false,
	MutationObserver: false,
	MutationRecord: false,
	name: false,
	NamedNodeMap: false,
	NavigationPreloadManager: false,
	navigator: false,
	Navigator: false,
	NetworkInformation: false,
	Node: false,
	NodeFilter: false,
	NodeIterator: false,
	NodeList: false,
	Notification: false,
	OfflineAudioCompletionEvent: false,
	OfflineAudioContext: false,
	offscreenBuffering: false,
	OffscreenCanvas: true,
	OffscreenCanvasRenderingContext2D: false,
	onabort: true,
	onafterprint: true,
	onanimationend: true,
	onanimationiteration: true,
	onanimationstart: true,
	onappinstalled: true,
	onauxclick: true,
	onbeforeinstallprompt: true,
	onbeforeprint: true,
	onbeforeunload: true,
	onblur: true,
	oncancel: true,
	oncanplay: true,
	oncanplaythrough: true,
	onchange: true,
	onclick: true,
	onclose: true,
	oncontextmenu: true,
	oncuechange: true,
	ondblclick: true,
	ondevicemotion: true,
	ondeviceorientation: true,
	ondeviceorientationabsolute: true,
	ondrag: true,
	ondragend: true,
	ondragenter: true,
	ondragleave: true,
	ondragover: true,
	ondragstart: true,
	ondrop: true,
	ondurationchange: true,
	onemptied: true,
	onended: true,
	onerror: true,
	onfocus: true,
	ongotpointercapture: true,
	onhashchange: true,
	oninput: true,
	oninvalid: true,
	onkeydown: true,
	onkeypress: true,
	onkeyup: true,
	onlanguagechange: true,
	onload: true,
	onloadeddata: true,
	onloadedmetadata: true,
	onloadstart: true,
	onlostpointercapture: true,
	onmessage: true,
	onmessageerror: true,
	onmousedown: true,
	onmouseenter: true,
	onmouseleave: true,
	onmousemove: true,
	onmouseout: true,
	onmouseover: true,
	onmouseup: true,
	onmousewheel: true,
	onoffline: true,
	ononline: true,
	onpagehide: true,
	onpageshow: true,
	onpause: true,
	onplay: true,
	onplaying: true,
	onpointercancel: true,
	onpointerdown: true,
	onpointerenter: true,
	onpointerleave: true,
	onpointermove: true,
	onpointerout: true,
	onpointerover: true,
	onpointerup: true,
	onpopstate: true,
	onprogress: true,
	onratechange: true,
	onrejectionhandled: true,
	onreset: true,
	onresize: true,
	onscroll: true,
	onsearch: true,
	onseeked: true,
	onseeking: true,
	onselect: true,
	onstalled: true,
	onstorage: true,
	onsubmit: true,
	onsuspend: true,
	ontimeupdate: true,
	ontoggle: true,
	ontransitionend: true,
	onunhandledrejection: true,
	onunload: true,
	onvolumechange: true,
	onwaiting: true,
	onwheel: true,
	open: false,
	openDatabase: false,
	opener: false,
	Option: false,
	origin: false,
	OscillatorNode: false,
	outerHeight: false,
	outerWidth: false,
	OverconstrainedError: false,
	PageTransitionEvent: false,
	pageXOffset: false,
	pageYOffset: false,
	PannerNode: false,
	parent: false,
	Path2D: false,
	PaymentAddress: false,
	PaymentRequest: false,
	PaymentRequestUpdateEvent: false,
	PaymentResponse: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceLongTaskTiming: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceNavigationTiming: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformancePaintTiming: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	PeriodicWave: false,
	Permissions: false,
	PermissionStatus: false,
	personalbar: false,
	PhotoCapabilities: false,
	Plugin: false,
	PluginArray: false,
	PointerEvent: false,
	PopStateEvent: false,
	postMessage: false,
	Presentation: false,
	PresentationAvailability: false,
	PresentationConnection: false,
	PresentationConnectionAvailableEvent: false,
	PresentationConnectionCloseEvent: false,
	PresentationConnectionList: false,
	PresentationReceiver: false,
	PresentationRequest: false,
	print: false,
	ProcessingInstruction: false,
	ProgressEvent: false,
	PromiseRejectionEvent: false,
	prompt: false,
	PushManager: false,
	PushSubscription: false,
	PushSubscriptionOptions: false,
	queueMicrotask: false,
	RadioNodeList: false,
	Range: false,
	ReadableStream: false,
	registerProcessor: false,
	RemotePlayback: false,
	removeEventListener: false,
	Request: false,
	requestAnimationFrame: false,
	requestIdleCallback: false,
	resizeBy: false,
	ResizeObserver: false,
	ResizeObserverEntry: false,
	resizeTo: false,
	Response: false,
	RTCCertificate: false,
	RTCDataChannel: false,
	RTCDataChannelEvent: false,
	RTCDtlsTransport: false,
	RTCIceCandidate: false,
	RTCIceGatherer: false,
	RTCIceTransport: false,
	RTCPeerConnection: false,
	RTCPeerConnectionIceEvent: false,
	RTCRtpContributingSource: false,
	RTCRtpReceiver: false,
	RTCRtpSender: false,
	RTCSctpTransport: false,
	RTCSessionDescription: false,
	RTCStatsReport: false,
	RTCTrackEvent: false,
	screen: false,
	Screen: false,
	screenLeft: false,
	ScreenOrientation: false,
	screenTop: false,
	screenX: false,
	screenY: false,
	ScriptProcessorNode: false,
	scroll: false,
	scrollbars: false,
	scrollBy: false,
	scrollTo: false,
	scrollX: false,
	scrollY: false,
	SecurityPolicyViolationEvent: false,
	Selection: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerRegistration: false,
	sessionStorage: false,
	setInterval: false,
	setTimeout: false,
	ShadowRoot: false,
	SharedWorker: false,
	SourceBuffer: false,
	SourceBufferList: false,
	speechSynthesis: false,
	SpeechSynthesisEvent: false,
	SpeechSynthesisUtterance: false,
	StaticRange: false,
	status: false,
	statusbar: false,
	StereoPannerNode: false,
	stop: false,
	Storage: false,
	StorageEvent: false,
	StorageManager: false,
	styleMedia: false,
	StyleSheet: false,
	StyleSheetList: false,
	SubtleCrypto: false,
	SVGAElement: false,
	SVGAngle: false,
	SVGAnimatedAngle: false,
	SVGAnimatedBoolean: false,
	SVGAnimatedEnumeration: false,
	SVGAnimatedInteger: false,
	SVGAnimatedLength: false,
	SVGAnimatedLengthList: false,
	SVGAnimatedNumber: false,
	SVGAnimatedNumberList: false,
	SVGAnimatedPreserveAspectRatio: false,
	SVGAnimatedRect: false,
	SVGAnimatedString: false,
	SVGAnimatedTransformList: false,
	SVGAnimateElement: false,
	SVGAnimateMotionElement: false,
	SVGAnimateTransformElement: false,
	SVGAnimationElement: false,
	SVGCircleElement: false,
	SVGClipPathElement: false,
	SVGComponentTransferFunctionElement: false,
	SVGDefsElement: false,
	SVGDescElement: false,
	SVGDiscardElement: false,
	SVGElement: false,
	SVGEllipseElement: false,
	SVGFEBlendElement: false,
	SVGFEColorMatrixElement: false,
	SVGFEComponentTransferElement: false,
	SVGFECompositeElement: false,
	SVGFEConvolveMatrixElement: false,
	SVGFEDiffuseLightingElement: false,
	SVGFEDisplacementMapElement: false,
	SVGFEDistantLightElement: false,
	SVGFEDropShadowElement: false,
	SVGFEFloodElement: false,
	SVGFEFuncAElement: false,
	SVGFEFuncBElement: false,
	SVGFEFuncGElement: false,
	SVGFEFuncRElement: false,
	SVGFEGaussianBlurElement: false,
	SVGFEImageElement: false,
	SVGFEMergeElement: false,
	SVGFEMergeNodeElement: false,
	SVGFEMorphologyElement: false,
	SVGFEOffsetElement: false,
	SVGFEPointLightElement: false,
	SVGFESpecularLightingElement: false,
	SVGFESpotLightElement: false,
	SVGFETileElement: false,
	SVGFETurbulenceElement: false,
	SVGFilterElement: false,
	SVGForeignObjectElement: false,
	SVGGElement: false,
	SVGGeometryElement: false,
	SVGGradientElement: false,
	SVGGraphicsElement: false,
	SVGImageElement: false,
	SVGLength: false,
	SVGLengthList: false,
	SVGLinearGradientElement: false,
	SVGLineElement: false,
	SVGMarkerElement: false,
	SVGMaskElement: false,
	SVGMatrix: false,
	SVGMetadataElement: false,
	SVGMPathElement: false,
	SVGNumber: false,
	SVGNumberList: false,
	SVGPathElement: false,
	SVGPatternElement: false,
	SVGPoint: false,
	SVGPointList: false,
	SVGPolygonElement: false,
	SVGPolylineElement: false,
	SVGPreserveAspectRatio: false,
	SVGRadialGradientElement: false,
	SVGRect: false,
	SVGRectElement: false,
	SVGScriptElement: false,
	SVGSetElement: false,
	SVGStopElement: false,
	SVGStringList: false,
	SVGStyleElement: false,
	SVGSVGElement: false,
	SVGSwitchElement: false,
	SVGSymbolElement: false,
	SVGTextContentElement: false,
	SVGTextElement: false,
	SVGTextPathElement: false,
	SVGTextPositioningElement: false,
	SVGTitleElement: false,
	SVGTransform: false,
	SVGTransformList: false,
	SVGTSpanElement: false,
	SVGUnitTypes: false,
	SVGUseElement: false,
	SVGViewElement: false,
	TaskAttributionTiming: false,
	Text: false,
	TextDecoder: false,
	TextEncoder: false,
	TextEvent: false,
	TextMetrics: false,
	TextTrack: false,
	TextTrackCue: false,
	TextTrackCueList: false,
	TextTrackList: false,
	TimeRanges: false,
	toolbar: false,
	top: false,
	Touch: false,
	TouchEvent: false,
	TouchList: false,
	TrackEvent: false,
	TransitionEvent: false,
	TreeWalker: false,
	UIEvent: false,
	URL: false,
	URLSearchParams: false,
	ValidityState: false,
	visualViewport: false,
	VisualViewport: false,
	VTTCue: false,
	WaveShaperNode: false,
	WebAssembly: false,
	WebGL2RenderingContext: false,
	WebGLActiveInfo: false,
	WebGLBuffer: false,
	WebGLContextEvent: false,
	WebGLFramebuffer: false,
	WebGLProgram: false,
	WebGLQuery: false,
	WebGLRenderbuffer: false,
	WebGLRenderingContext: false,
	WebGLSampler: false,
	WebGLShader: false,
	WebGLShaderPrecisionFormat: false,
	WebGLSync: false,
	WebGLTexture: false,
	WebGLTransformFeedback: false,
	WebGLUniformLocation: false,
	WebGLVertexArrayObject: false,
	WebSocket: false,
	WheelEvent: false,
	window: false,
	Window: false,
	Worker: false,
	WritableStream: false,
	XMLDocument: false,
	XMLHttpRequest: false,
	XMLHttpRequestEventTarget: false,
	XMLHttpRequestUpload: false,
	XMLSerializer: false,
	XPathEvaluator: false,
	XPathExpression: false,
	XPathResult: false,
	XSLTProcessor: false
};
var worker = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	clearInterval: false,
	clearTimeout: false,
	close: true,
	console: false,
	fetch: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: true,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onlanguagechange: true,
	onmessage: true,
	onoffline: true,
	ononline: true,
	onrejectionhandled: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	queueMicrotask: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: true,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false,
	WebSocket: false,
	Worker: false,
	WorkerGlobalScope: false,
	XMLHttpRequest: false
};
var node = {
	__dirname: false,
	__filename: false,
	AbortController: false,
	Buffer: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	console: false,
	exports: true,
	global: false,
	"Intl": false,
	module: false,
	process: false,
	queueMicrotask: false,
	require: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false
};
var nodeBuiltin = {
	AbortController: false,
	Buffer: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	console: false,
	global: false,
	"Intl": false,
	process: false,
	queueMicrotask: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false
};
var commonjs = {
	exports: true,
	global: false,
	module: false,
	require: false
};
var amd = {
	define: false,
	require: false
};
var mocha = {
	after: false,
	afterEach: false,
	before: false,
	beforeEach: false,
	context: false,
	describe: false,
	it: false,
	mocha: false,
	run: false,
	setup: false,
	specify: false,
	suite: false,
	suiteSetup: false,
	suiteTeardown: false,
	teardown: false,
	test: false,
	xcontext: false,
	xdescribe: false,
	xit: false,
	xspecify: false
};
var jasmine = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	expectAsync: false,
	fail: false,
	fdescribe: false,
	fit: false,
	it: false,
	jasmine: false,
	pending: false,
	runs: false,
	spyOn: false,
	spyOnAllFunctions: false,
	spyOnProperty: false,
	waits: false,
	waitsFor: false,
	xdescribe: false,
	xit: false
};
var jest = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	fdescribe: false,
	fit: false,
	it: false,
	jest: false,
	pit: false,
	require: false,
	test: false,
	xdescribe: false,
	xit: false,
	xtest: false
};
var qunit = {
	asyncTest: false,
	deepEqual: false,
	equal: false,
	expect: false,
	module: false,
	notDeepEqual: false,
	notEqual: false,
	notOk: false,
	notPropEqual: false,
	notStrictEqual: false,
	ok: false,
	propEqual: false,
	QUnit: false,
	raises: false,
	start: false,
	stop: false,
	strictEqual: false,
	test: false,
	throws: false
};
var phantomjs = {
	console: true,
	exports: true,
	phantom: true,
	require: true,
	WebPage: true
};
var couch = {
	emit: false,
	exports: false,
	getRow: false,
	log: false,
	module: false,
	provides: false,
	require: false,
	respond: false,
	send: false,
	start: false,
	sum: false
};
var rhino = {
	defineClass: false,
	deserialize: false,
	gc: false,
	help: false,
	importClass: false,
	importPackage: false,
	java: false,
	load: false,
	loadClass: false,
	Packages: false,
	print: false,
	quit: false,
	readFile: false,
	readUrl: false,
	runCommand: false,
	seal: false,
	serialize: false,
	spawn: false,
	sync: false,
	toint32: false,
	version: false
};
var nashorn = {
	__DIR__: false,
	__FILE__: false,
	__LINE__: false,
	com: false,
	edu: false,
	exit: false,
	java: false,
	Java: false,
	javafx: false,
	JavaImporter: false,
	javax: false,
	JSAdapter: false,
	load: false,
	loadWithNewGlobal: false,
	org: false,
	Packages: false,
	print: false,
	quit: false
};
var wsh = {
	ActiveXObject: false,
	CollectGarbage: false,
	Debug: false,
	Enumerator: false,
	GetObject: false,
	RuntimeObject: false,
	ScriptEngine: false,
	ScriptEngineBuildVersion: false,
	ScriptEngineMajorVersion: false,
	ScriptEngineMinorVersion: false,
	VBArray: false,
	WScript: false,
	WSH: false
};
var jquery = {
	$: false,
	jQuery: false
};
var yui = {
	YAHOO: false,
	YAHOO_config: false,
	YUI: false,
	YUI_config: false
};
var shelljs = {
	cat: false,
	cd: false,
	chmod: false,
	config: false,
	cp: false,
	dirs: false,
	echo: false,
	env: false,
	error: false,
	exec: false,
	exit: false,
	find: false,
	grep: false,
	ln: false,
	ls: false,
	mkdir: false,
	mv: false,
	popd: false,
	pushd: false,
	pwd: false,
	rm: false,
	sed: false,
	set: false,
	target: false,
	tempdir: false,
	test: false,
	touch: false,
	which: false
};
var prototypejs = {
	$: false,
	$$: false,
	$A: false,
	$break: false,
	$continue: false,
	$F: false,
	$H: false,
	$R: false,
	$w: false,
	Abstract: false,
	Ajax: false,
	Autocompleter: false,
	Builder: false,
	Class: false,
	Control: false,
	Draggable: false,
	Draggables: false,
	Droppables: false,
	Effect: false,
	Element: false,
	Enumerable: false,
	Event: false,
	Field: false,
	Form: false,
	Hash: false,
	Insertion: false,
	ObjectRange: false,
	PeriodicalExecuter: false,
	Position: false,
	Prototype: false,
	Scriptaculous: false,
	Selector: false,
	Sortable: false,
	SortableObserver: false,
	Sound: false,
	Template: false,
	Toggle: false,
	Try: false
};
var meteor = {
	$: false,
	Accounts: false,
	AccountsClient: false,
	AccountsCommon: false,
	AccountsServer: false,
	App: false,
	Assets: false,
	Blaze: false,
	check: false,
	Cordova: false,
	DDP: false,
	DDPRateLimiter: false,
	DDPServer: false,
	Deps: false,
	EJSON: false,
	Email: false,
	HTTP: false,
	Log: false,
	Match: false,
	Meteor: false,
	Mongo: false,
	MongoInternals: false,
	Npm: false,
	Package: false,
	Plugin: false,
	process: false,
	Random: false,
	ReactiveDict: false,
	ReactiveVar: false,
	Router: false,
	ServiceConfiguration: false,
	Session: false,
	share: false,
	Spacebars: false,
	Template: false,
	Tinytest: false,
	Tracker: false,
	UI: false,
	Utils: false,
	WebApp: false,
	WebAppInternals: false
};
var mongo = {
	_isWindows: false,
	_rand: false,
	BulkWriteResult: false,
	cat: false,
	cd: false,
	connect: false,
	db: false,
	getHostName: false,
	getMemInfo: false,
	hostname: false,
	ISODate: false,
	listFiles: false,
	load: false,
	ls: false,
	md5sumFile: false,
	mkdir: false,
	Mongo: false,
	NumberInt: false,
	NumberLong: false,
	ObjectId: false,
	PlanCache: false,
	print: false,
	printjson: false,
	pwd: false,
	quit: false,
	removeFile: false,
	rs: false,
	sh: false,
	UUID: false,
	version: false,
	WriteResult: false
};
var applescript = {
	$: false,
	Application: false,
	Automation: false,
	console: false,
	delay: false,
	Library: false,
	ObjC: false,
	ObjectSpecifier: false,
	Path: false,
	Progress: false,
	Ref: false
};
var serviceworker = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	clearInterval: false,
	clearTimeout: false,
	Client: false,
	clients: false,
	Clients: false,
	close: true,
	console: false,
	ExtendableEvent: false,
	ExtendableMessageEvent: false,
	fetch: false,
	FetchEvent: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: false,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onfetch: true,
	oninstall: true,
	onlanguagechange: true,
	onmessage: true,
	onmessageerror: true,
	onnotificationclick: true,
	onnotificationclose: true,
	onoffline: true,
	ononline: true,
	onpush: true,
	onpushsubscriptionchange: true,
	onrejectionhandled: true,
	onsync: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	queueMicrotask: false,
	registration: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerGlobalScope: false,
	ServiceWorkerMessageEvent: false,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	skipWaiting: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false,
	WebSocket: false,
	WindowClient: false,
	Worker: false,
	WorkerGlobalScope: false,
	XMLHttpRequest: false
};
var atomtest = {
	advanceClock: false,
	atom: false,
	fakeClearInterval: false,
	fakeClearTimeout: false,
	fakeSetInterval: false,
	fakeSetTimeout: false,
	resetTimeouts: false,
	waitsForPromise: false
};
var embertest = {
	andThen: false,
	click: false,
	currentPath: false,
	currentRouteName: false,
	currentURL: false,
	fillIn: false,
	find: false,
	findAll: false,
	findWithAssert: false,
	keyEvent: false,
	pauseTest: false,
	resumeTest: false,
	triggerEvent: false,
	visit: false,
	wait: false
};
var protractor = {
	$: false,
	$$: false,
	browser: false,
	by: false,
	By: false,
	DartObject: false,
	element: false,
	protractor: false
};
var webextensions = {
	browser: false,
	chrome: false,
	opr: false
};
var greasemonkey = {
	cloneInto: false,
	createObjectIn: false,
	exportFunction: false,
	GM: false,
	GM_addStyle: false,
	GM_addValueChangeListener: false,
	GM_deleteValue: false,
	GM_download: false,
	GM_getResourceText: false,
	GM_getResourceURL: false,
	GM_getTab: false,
	GM_getTabs: false,
	GM_getValue: false,
	GM_info: false,
	GM_listValues: false,
	GM_log: false,
	GM_notification: false,
	GM_openInTab: false,
	GM_registerMenuCommand: false,
	GM_removeValueChangeListener: false,
	GM_saveTab: false,
	GM_setClipboard: false,
	GM_setValue: false,
	GM_unregisterMenuCommand: false,
	GM_xmlhttpRequest: false,
	unsafeWindow: false
};
var devtools = {
	$: false,
	$_: false,
	$$: false,
	$0: false,
	$1: false,
	$2: false,
	$3: false,
	$4: false,
	$x: false,
	chrome: false,
	clear: false,
	copy: false,
	debug: false,
	dir: false,
	dirxml: false,
	getEventListeners: false,
	inspect: false,
	keys: false,
	monitor: false,
	monitorEvents: false,
	profile: false,
	profileEnd: false,
	queryObjects: false,
	table: false,
	undebug: false,
	unmonitor: false,
	unmonitorEvents: false,
	values: false
};
var require$$0$1 = {
	builtin: builtin,
	es5: es5,
	es2015: es2015,
	es2017: es2017,
	es2020: es2020,
	es2021: es2021,
	browser: browser,
	worker: worker,
	node: node,
	nodeBuiltin: nodeBuiltin,
	commonjs: commonjs,
	amd: amd,
	mocha: mocha,
	jasmine: jasmine,
	jest: jest,
	qunit: qunit,
	phantomjs: phantomjs,
	couch: couch,
	rhino: rhino,
	nashorn: nashorn,
	wsh: wsh,
	jquery: jquery,
	yui: yui,
	shelljs: shelljs,
	prototypejs: prototypejs,
	meteor: meteor,
	mongo: mongo,
	applescript: applescript,
	serviceworker: serviceworker,
	atomtest: atomtest,
	embertest: embertest,
	protractor: protractor,
	"shared-node-browser": {
	clearInterval: false,
	clearTimeout: false,
	console: false,
	setInterval: false,
	setTimeout: false,
	URL: false,
	URLSearchParams: false
},
	webextensions: webextensions,
	greasemonkey: greasemonkey,
	devtools: devtools
};

var globals = require$$0$1;

// A simple implementation of make-array
function make_array(subject) {
  return Array.isArray(subject) ? subject : [subject];
}

const REGEX_BLANK_LINE = /^\s+$/;
const REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const REGEX_LEADING_EXCAPED_HASH = /^\\#/;
const SLASH = '/';
const KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')
/* istanbul ignore next */
: 'node-ignore';

const define = (object, key, value) => Object.defineProperty(object, key, {
  value
});

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g; // Sanitize the range of a regular expression
// The cases are complicated, see test cases for details

const sanitizeRange = range => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but
//   fatal for JavaScript regular expression, so eliminate it.
: ''); // > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`
// '`foo/`' should not continue with the '`..`'


const DEFAULT_REPLACER_PREFIX = [// > Trailing spaces are ignored unless they are quoted with backslash ("\")
[// (a\ ) -> (a )
// (a  ) -> (a)
// (a \ ) -> (a  )
/\\?\s+$/, match => match.indexOf('\\') === 0 ? ' ' : ''], // replace (\ ) with ' '
[/\\\s/g, () => ' '], // Escape metacharacters
// which is written down by users but means special for regular expressions.
// > There are 12 characters with special meanings:
// > - the backslash \,
// > - the caret ^,
// > - the dollar sign $,
// > - the period or dot .,
// > - the vertical bar or pipe symbol |,
// > - the question mark ?,
// > - the asterisk or star *,
// > - the plus sign +,
// > - the opening parenthesis (,
// > - the closing parenthesis ),
// > - and the opening square bracket [,
// > - the opening curly brace {,
// > These special characters are often called "metacharacters".
[/[\\^$.|*+(){]/g, match => `\\${match}`], [// > [abc] matches any character inside the brackets
// >    (in this case a, b, or c);
/\[([^\]/]*)($|\])/g, (match, p1, p2) => p2 === ']' ? `[${sanitizeRange(p1)}]` : `\\${match}`], [// > a question mark (?) matches a single character
/(?!\\)\?/g, () => '[^/]'], // leading slash
[// > A leading slash matches the beginning of the pathname.
// > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
// A leading slash matches the beginning of the pathname
/^\//, () => '^'], // replace special metacharacter slash after the leading slash
[/\//g, () => '\\/'], [// > A leading "**" followed by a slash means match in all directories.
// > For example, "**/foo" matches file or directory "foo" anywhere,
// > the same as pattern "foo".
// > "**/foo/bar" matches file or directory "bar" anywhere that is directly
// >   under directory "foo".
// Notice that the '*'s have been replaced as '\\*'
/^\^*\\\*\\\*\\\//, // '**/foo' <-> 'foo'
() => '^(?:.*\\/)?']];
const DEFAULT_REPLACER_SUFFIX = [// starting
[// there will be no leading '/'
//   (which has been replaced by section "leading slash")
// If starts with '**', adding a '^' to the regular expression also works
/^(?=[^^])/, function startingReplacer() {
  return !/\/(?!$)/.test(this) // > If the pattern does not contain a slash /,
  // >   Git treats it as a shell glob pattern
  // Actually, if there is only a trailing slash,
  //   git also treats it as a shell glob pattern
  ? '(?:^|\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for
  // >   consumption by fnmatch(3)
  : '^';
}], // two globstars
[// Use lookahead assertions so that we could match more than one `'/**'`
/\\\/\\\*\\\*(?=\\\/|$)/g, // Zero, one or several directories
// should not use '*', or it will be replaced by the next replacer
// Check if it is not the last `'/**'`
(match, index, str) => index + 6 < str.length // case: /**/
// > A slash followed by two consecutive asterisks then a slash matches
// >   zero or more directories.
// > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
// '/**/'
? '(?:\\/[^\\/]+)*' // case: /**
// > A trailing `"/**"` matches everything inside.
// #21: everything inside but it should not include the current folder
: '\\/.+'], // intermediate wildcards
[// Never replace escaped '*'
// ignore rule '\*' will match the path '*'
// 'abc.*/' -> go
// 'abc.*'  -> skip this rule
/(^|[^\\]+)\\\*(?=.+)/g, // '*.js' matches '.js'
// '*.js' doesn't match 'abc'
(match, p1) => `${p1}[^\\/]*`], // trailing wildcard
[/(\^|\\\/)?\\\*$/, (match, p1) => {
  const prefix = p1 // '\^':
  // '/*' does not match ''
  // '/*' does not match everything
  // '\\\/':
  // 'abc/*' does not match 'abc/'
  ? `${p1}[^/]+` // 'a*' matches 'a'
  // 'a*' matches 'aa'
  : '[^/]*';
  return `${prefix}(?=$|\\/$)`;
}], [// unescape
/\\\\\\/g, () => '\\']];
const POSITIVE_REPLACERS = [...DEFAULT_REPLACER_PREFIX, // 'f'
// matches
// - /f(end)
// - /f/
// - (start)f(end)
// - (start)f/
// doesn't match
// - oof
// - foo
// pseudo:
// -> (^|/)f(/|$)
// ending
[// 'js' will not match 'js.'
// 'ab' will not match 'abc'
/(?:[^*/])$/, // 'js*' will not match 'a.js'
// 'js/' will not match 'a.js'
// 'js' will match 'a.js' and 'a.js/'
match => `${match}(?=$|\\/)`], ...DEFAULT_REPLACER_SUFFIX];
const NEGATIVE_REPLACERS = [...DEFAULT_REPLACER_PREFIX, // #24, #38
// The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)
// A negative pattern without a trailing wildcard should not
// re-include the things inside that directory.
// eg:
// ['node_modules/*', '!node_modules']
// should ignore `node_modules/a.js`
[/(?:[^*])$/, match => `${match}(?=$|\\/$)`], ...DEFAULT_REPLACER_SUFFIX]; // A simple cache, because an ignore rule only has only one certain meaning

const cache = Object.create(null); // @param {pattern}

const make_regex = (pattern, negative, ignorecase) => {
  const r = cache[pattern];

  if (r) {
    return r;
  }

  const replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;
  const source = replacers.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
  return cache[pattern] = ignorecase ? new RegExp(source, 'i') : new RegExp(source);
}; // > A blank line matches no files, so it can serve as a separator for readability.


const checkPattern = pattern => pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern) // > A line starting with # serves as a comment.
&& pattern.indexOf('#') !== 0;

const createRule = (pattern, ignorecase) => {
  const origin = pattern;
  let negative = false; // > An optional prefix "!" which negates the pattern;

  if (pattern.indexOf('!') === 0) {
    negative = true;
    pattern = pattern.substr(1);
  }

  pattern = pattern // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!') // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_LEADING_EXCAPED_HASH, '#');
  const regex = make_regex(pattern, negative, ignorecase);
  return {
    origin,
    pattern,
    negative,
    regex
  };
};

class IgnoreBase {
  constructor({
    ignorecase = true
  } = {}) {
    this._rules = [];
    this._ignorecase = ignorecase;
    define(this, KEY_IGNORE, true);

    this._initCache();
  }

  _initCache() {
    this._cache = Object.create(null);
  } // @param {Array.<string>|string|Ignore} pattern


  add(pattern) {
    this._added = false;

    if (typeof pattern === 'string') {
      pattern = pattern.split(/\r?\n/g);
    }

    make_array(pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,
    // making the behavior changed.

    if (this._added) {
      this._initCache();
    }

    return this;
  } // legacy


  addPattern(pattern) {
    return this.add(pattern);
  }

  _addPattern(pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules);
      this._added = true;
      return;
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignorecase);
      this._added = true;

      this._rules.push(rule);
    }
  }

  filter(paths) {
    return make_array(paths).filter(path => this._filter(path));
  }

  createFilter() {
    return path => this._filter(path);
  }

  ignores(path) {
    return !this._filter(path);
  } // @returns `Boolean` true if the `path` is NOT ignored


  _filter(path, slices) {
    if (!path) {
      return false;
    }

    if (path in this._cache) {
      return this._cache[path];
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH);
    }

    slices.pop();
    return this._cache[path] = slices.length // > It is not possible to re-include a file if a parent directory of
    // >   that file is excluded.
    // If the path contains a parent directory, check the parent first
    ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path) // Or only test the path
    : this._test(path);
  } // @returns {Boolean} true if a file is NOT ignored


  _test(path) {
    // Explicitly define variable type by setting matched to `0`
    let matched = 0;

    this._rules.forEach(rule => {
      // if matched = true, then we only test negative rules
      // if matched = false, then we test non-negative rules
      if (!(matched ^ rule.negative)) {
        matched = rule.negative ^ rule.regex.test(path);
      }
    });

    return !matched;
  }

} // Windows
// --------------------------------------------------------------

/* istanbul ignore if  */


if ( // Detect `process` so that it can run in browsers.
typeof browser$1$1 !== 'undefined' && (browser$1$1.env && browser$1$1.env.IGNORE_TEST_WIN32 || browser$1$1.platform === 'win32')) {
  const filter = IgnoreBase.prototype._filter;
  /* eslint no-control-regex: "off" */

  const make_posix = str => /^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, '/');

  IgnoreBase.prototype._filter = function filterWin32(path, slices) {
    path = make_posix(path);
    return filter.call(this, path, slices);
  };
}

var ignore = options => new IgnoreBase(options);

/*
 * @version    1.4.0
 * @date       2015-10-26
 * @stability  3 - Stable
 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
 * @license    MIT License
 */

var naturalCompare_1 = createCommonjsModule$1(function (module) {
var naturalCompare = function (a, b) {
  var i,
      codeA,
      codeB = 1,
      posA = 0,
      posB = 0,
      alphabet = String.alphabet;

  function getCode(str, pos, code) {
    if (code) {
      for (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;

      return +str.slice(pos - 1, i);
    }

    code = alphabet && alphabet.indexOf(str.charAt(pos));
    return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 // -
    : code < 48 ? code - 1 : code < 58 ? code + 18 // 0-9
    : code < 65 ? code - 11 : code < 91 ? code + 11 // A-Z
    : code < 97 ? code - 37 : code < 123 ? code + 5 // a-z
    : code - 63;
  }

  if ((a += "") != (b += "")) for (; codeB;) {
    codeA = getCode(a, posA++);
    codeB = getCode(b, posB++);

    if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
      codeA = getCode(a, posA, posA);
      codeB = getCode(b, posB, posA = i);
      posB = i;
    }

    if (codeA != codeB) return codeA < codeB ? -1 : 1;
  }
  return 0;
};

try {
  module.exports = naturalCompare;
} catch (e) {
  String.naturalCompare = naturalCompare;
}
});

var name = "doctrine";
var description = "JSDoc parser";
var homepage = "https://github.com/eslint/doctrine";
var main = "lib/doctrine.js";
var version = "3.0.0";
var engines = {
	node: ">=6.0.0"
};
var directories = {
	lib: "./lib"
};
var files = [
	"lib"
];
var maintainers = [
	{
		name: "Nicholas C. Zakas",
		email: "nicholas+npm@nczconsulting.com",
		web: "https://www.nczonline.net"
	},
	{
		name: "Yusuke Suzuki",
		email: "utatane.tea@gmail.com",
		web: "https://github.com/Constellation"
	}
];
var repository = "eslint/doctrine";
var devDependencies = {
	coveralls: "^3.0.1",
	dateformat: "^1.0.11",
	eslint: "^1.10.3",
	"eslint-release": "^1.0.0",
	linefix: "^0.1.1",
	mocha: "^3.4.2",
	"npm-license": "^0.3.1",
	nyc: "^10.3.2",
	semver: "^5.0.3",
	shelljs: "^0.5.3",
	"shelljs-nodecli": "^0.1.1",
	should: "^5.0.1"
};
var license = "Apache-2.0";
var scripts = {
	pretest: "npm run lint",
	test: "nyc mocha",
	coveralls: "nyc report --reporter=text-lcov | coveralls",
	lint: "eslint lib/",
	"generate-release": "eslint-generate-release",
	"generate-alpharelease": "eslint-generate-prerelease alpha",
	"generate-betarelease": "eslint-generate-prerelease beta",
	"generate-rcrelease": "eslint-generate-prerelease rc",
	"publish-release": "eslint-publish-release"
};
var dependencies = {
	esutils: "^2.0.2"
};
var require$$0 = {
	name: name,
	description: description,
	homepage: homepage,
	main: main,
	version: version,
	engines: engines,
	directories: directories,
	files: files,
	maintainers: maintainers,
	repository: repository,
	devDependencies: devDependencies,
	license: license,
	scripts: scripts,
	dependencies: dependencies
};

/*
 * @fileoverview Utilities for Doctrine
 * @author Yusuke Suzuki <utatane.tea@gmail.com>
 */

var utility = createCommonjsModule$1(function (module, exports) {
(function () {

  var VERSION;
  VERSION = require$$0.version;
  exports.VERSION = VERSION;

  function DoctrineError(message) {
    this.name = 'DoctrineError';
    this.message = message;
  }

  DoctrineError.prototype = function () {
    var Middle = function () {};

    Middle.prototype = Error.prototype;
    return new Middle();
  }();

  DoctrineError.prototype.constructor = DoctrineError;
  exports.DoctrineError = DoctrineError;

  function throwError(message) {
    throw new DoctrineError(message);
  }

  exports.throwError = throwError;
  exports.assert = require$$1$4;
})();
/* vim: set sw=4 ts=4 et tw=80 : */
});

/*
 * @fileoverview Type expression parser.
 * @author Yusuke Suzuki <utatane.tea@gmail.com>
 * @author Dan Tao <daniel.tao@gmail.com>
 * @author Andrew Eisenberg <andrew@eisenberg.as>
 */

var typed = createCommonjsModule$1(function (module, exports) {
// "typed", the Type Expression Parser for doctrine.
(function () {

  var Syntax, Token, source, length, index, previous, token, value, esutils, utility$1, rangeOffset, addRange;
  esutils = utils;
  utility$1 = utility;
  Syntax = {
    NullableLiteral: 'NullableLiteral',
    AllLiteral: 'AllLiteral',
    NullLiteral: 'NullLiteral',
    UndefinedLiteral: 'UndefinedLiteral',
    VoidLiteral: 'VoidLiteral',
    UnionType: 'UnionType',
    ArrayType: 'ArrayType',
    RecordType: 'RecordType',
    FieldType: 'FieldType',
    FunctionType: 'FunctionType',
    ParameterType: 'ParameterType',
    RestType: 'RestType',
    NonNullableType: 'NonNullableType',
    OptionalType: 'OptionalType',
    NullableType: 'NullableType',
    NameExpression: 'NameExpression',
    TypeApplication: 'TypeApplication',
    StringLiteralType: 'StringLiteralType',
    NumericLiteralType: 'NumericLiteralType',
    BooleanLiteralType: 'BooleanLiteralType'
  };
  Token = {
    ILLEGAL: 0,
    // ILLEGAL
    DOT_LT: 1,
    // .<
    REST: 2,
    // ...
    LT: 3,
    // <
    GT: 4,
    // >
    LPAREN: 5,
    // (
    RPAREN: 6,
    // )
    LBRACE: 7,
    // {
    RBRACE: 8,
    // }
    LBRACK: 9,
    // [
    RBRACK: 10,
    // ]
    COMMA: 11,
    // ,
    COLON: 12,
    // :
    STAR: 13,
    // *
    PIPE: 14,
    // |
    QUESTION: 15,
    // ?
    BANG: 16,
    // !
    EQUAL: 17,
    // =
    NAME: 18,
    // name token
    STRING: 19,
    // string
    NUMBER: 20,
    // number
    EOF: 21
  };

  function isTypeName(ch) {
    return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
  }

  function Context(previous, index, token, value) {
    this._previous = previous;
    this._index = index;
    this._token = token;
    this._value = value;
  }

  Context.prototype.restore = function () {
    previous = this._previous;
    index = this._index;
    token = this._token;
    value = this._value;
  };

  Context.save = function () {
    return new Context(previous, index, token, value);
  };

  function maybeAddRange(node, range) {
    if (addRange) {
      node.range = [range[0] + rangeOffset, range[1] + rangeOffset];
    }

    return node;
  }

  function advance() {
    var ch = source.charAt(index);
    index += 1;
    return ch;
  }

  function scanHexEscape(prefix) {
    var i,
        len,
        ch,
        code = 0;
    len = prefix === 'u' ? 4 : 2;

    for (i = 0; i < len; ++i) {
      if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
        ch = advance();
        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
      } else {
        return '';
      }
    }

    return String.fromCharCode(code);
  }

  function scanString() {
    var str = '',
        quote,
        ch,
        code,
        unescaped,
        restore; //TODO review removal octal = false

    quote = source.charAt(index);
    ++index;

    while (index < length) {
      ch = advance();

      if (ch === quote) {
        quote = '';
        break;
      } else if (ch === '\\') {
        ch = advance();

        if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
          switch (ch) {
            case 'n':
              str += '\n';
              break;

            case 'r':
              str += '\r';
              break;

            case 't':
              str += '\t';
              break;

            case 'u':
            case 'x':
              restore = index;
              unescaped = scanHexEscape(ch);

              if (unescaped) {
                str += unescaped;
              } else {
                index = restore;
                str += ch;
              }

              break;

            case 'b':
              str += '\b';
              break;

            case 'f':
              str += '\f';
              break;

            case 'v':
              str += '\v';
              break;

            default:
              if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
                code = '01234567'.indexOf(ch); // \0 is not octal escape sequence
                // Deprecating unused code. TODO review removal
                //if (code !== 0) {
                //    octal = true;
                //}

                if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                  //TODO Review Removal octal = true;
                  code = code * 8 + '01234567'.indexOf(advance()); // 3 digits are only allowed when string starts
                  // with 0, 1, 2, 3

                  if ('0123'.indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                    code = code * 8 + '01234567'.indexOf(advance());
                  }
                }

                str += String.fromCharCode(code);
              } else {
                str += ch;
              }

              break;
          }
        } else {
          if (ch === '\r' && source.charCodeAt(index) === 0x0A
          /* '\n' */
          ) {
              ++index;
            }
        }
      } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
        break;
      } else {
        str += ch;
      }
    }

    if (quote !== '') {
      utility$1.throwError('unexpected quote');
    }

    value = str;
    return Token.STRING;
  }

  function scanNumber() {
    var number, ch;
    number = '';
    ch = source.charCodeAt(index);

    if (ch !== 0x2E
    /* '.' */
    ) {
        number = advance();
        ch = source.charCodeAt(index);

        if (number === '0') {
          if (ch === 0x78
          /* 'x' */
          || ch === 0x58
          /* 'X' */
          ) {
              number += advance();

              while (index < length) {
                ch = source.charCodeAt(index);

                if (!esutils.code.isHexDigit(ch)) {
                  break;
                }

                number += advance();
              }

              if (number.length <= 2) {
                // only 0x
                utility$1.throwError('unexpected token');
              }

              if (index < length) {
                ch = source.charCodeAt(index);

                if (esutils.code.isIdentifierStartES5(ch)) {
                  utility$1.throwError('unexpected token');
                }
              }

              value = parseInt(number, 16);
              return Token.NUMBER;
            }

          if (esutils.code.isOctalDigit(ch)) {
            number += advance();

            while (index < length) {
              ch = source.charCodeAt(index);

              if (!esutils.code.isOctalDigit(ch)) {
                break;
              }

              number += advance();
            }

            if (index < length) {
              ch = source.charCodeAt(index);

              if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
                utility$1.throwError('unexpected token');
              }
            }

            value = parseInt(number, 8);
            return Token.NUMBER;
          }

          if (esutils.code.isDecimalDigit(ch)) {
            utility$1.throwError('unexpected token');
          }
        }

        while (index < length) {
          ch = source.charCodeAt(index);

          if (!esutils.code.isDecimalDigit(ch)) {
            break;
          }

          number += advance();
        }
      }

    if (ch === 0x2E
    /* '.' */
    ) {
        number += advance();

        while (index < length) {
          ch = source.charCodeAt(index);

          if (!esutils.code.isDecimalDigit(ch)) {
            break;
          }

          number += advance();
        }
      }

    if (ch === 0x65
    /* 'e' */
    || ch === 0x45
    /* 'E' */
    ) {
        number += advance();
        ch = source.charCodeAt(index);

        if (ch === 0x2B
        /* '+' */
        || ch === 0x2D
        /* '-' */
        ) {
            number += advance();
          }

        ch = source.charCodeAt(index);

        if (esutils.code.isDecimalDigit(ch)) {
          number += advance();

          while (index < length) {
            ch = source.charCodeAt(index);

            if (!esutils.code.isDecimalDigit(ch)) {
              break;
            }

            number += advance();
          }
        } else {
          utility$1.throwError('unexpected token');
        }
      }

    if (index < length) {
      ch = source.charCodeAt(index);

      if (esutils.code.isIdentifierStartES5(ch)) {
        utility$1.throwError('unexpected token');
      }
    }

    value = parseFloat(number);
    return Token.NUMBER;
  }

  function scanTypeName() {
    var ch, ch2;
    value = advance();

    while (index < length && isTypeName(source.charCodeAt(index))) {
      ch = source.charCodeAt(index);

      if (ch === 0x2E
      /* '.' */
      ) {
          if (index + 1 >= length) {
            return Token.ILLEGAL;
          }

          ch2 = source.charCodeAt(index + 1);

          if (ch2 === 0x3C
          /* '<' */
          ) {
              break;
            }
        }

      value += advance();
    }

    return Token.NAME;
  }

  function next() {
    var ch;
    previous = index;

    while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
      advance();
    }

    if (index >= length) {
      token = Token.EOF;
      return token;
    }

    ch = source.charCodeAt(index);

    switch (ch) {
      case 0x27:
      /* ''' */

      case 0x22:
        /* '"' */
        token = scanString();
        return token;

      case 0x3A:
        /* ':' */
        advance();
        token = Token.COLON;
        return token;

      case 0x2C:
        /* ',' */
        advance();
        token = Token.COMMA;
        return token;

      case 0x28:
        /* '(' */
        advance();
        token = Token.LPAREN;
        return token;

      case 0x29:
        /* ')' */
        advance();
        token = Token.RPAREN;
        return token;

      case 0x5B:
        /* '[' */
        advance();
        token = Token.LBRACK;
        return token;

      case 0x5D:
        /* ']' */
        advance();
        token = Token.RBRACK;
        return token;

      case 0x7B:
        /* '{' */
        advance();
        token = Token.LBRACE;
        return token;

      case 0x7D:
        /* '}' */
        advance();
        token = Token.RBRACE;
        return token;

      case 0x2E:
        /* '.' */
        if (index + 1 < length) {
          ch = source.charCodeAt(index + 1);

          if (ch === 0x3C
          /* '<' */
          ) {
              advance(); // '.'

              advance(); // '<'

              token = Token.DOT_LT;
              return token;
            }

          if (ch === 0x2E
          /* '.' */
          && index + 2 < length && source.charCodeAt(index + 2) === 0x2E
          /* '.' */
          ) {
              advance(); // '.'

              advance(); // '.'

              advance(); // '.'

              token = Token.REST;
              return token;
            }

          if (esutils.code.isDecimalDigit(ch)) {
            token = scanNumber();
            return token;
          }
        }

        token = Token.ILLEGAL;
        return token;

      case 0x3C:
        /* '<' */
        advance();
        token = Token.LT;
        return token;

      case 0x3E:
        /* '>' */
        advance();
        token = Token.GT;
        return token;

      case 0x2A:
        /* '*' */
        advance();
        token = Token.STAR;
        return token;

      case 0x7C:
        /* '|' */
        advance();
        token = Token.PIPE;
        return token;

      case 0x3F:
        /* '?' */
        advance();
        token = Token.QUESTION;
        return token;

      case 0x21:
        /* '!' */
        advance();
        token = Token.BANG;
        return token;

      case 0x3D:
        /* '=' */
        advance();
        token = Token.EQUAL;
        return token;

      case 0x2D:
        /* '-' */
        token = scanNumber();
        return token;

      default:
        if (esutils.code.isDecimalDigit(ch)) {
          token = scanNumber();
          return token;
        } // type string permits following case,
        //
        // namespace.module.MyClass
        //
        // this reduced 1 token TK_NAME


        utility$1.assert(isTypeName(ch));
        token = scanTypeName();
        return token;
    }
  }

  function consume(target, text) {
    utility$1.assert(token === target, text || 'consumed token not matched');
    next();
  }

  function expect(target, message) {
    if (token !== target) {
      utility$1.throwError(message || 'unexpected token');
    }

    next();
  } // UnionType := '(' TypeUnionList ')'
  //
  // TypeUnionList :=
  //     <<empty>>
  //   | NonemptyTypeUnionList
  //
  // NonemptyTypeUnionList :=
  //     TypeExpression
  //   | TypeExpression '|' NonemptyTypeUnionList


  function parseUnionType() {
    var elements,
        startIndex = index - 1;
    consume(Token.LPAREN, 'UnionType should start with (');
    elements = [];

    if (token !== Token.RPAREN) {
      while (true) {
        elements.push(parseTypeExpression());

        if (token === Token.RPAREN) {
          break;
        }

        expect(Token.PIPE);
      }
    }

    consume(Token.RPAREN, 'UnionType should end with )');
    return maybeAddRange({
      type: Syntax.UnionType,
      elements: elements
    }, [startIndex, previous]);
  } // ArrayType := '[' ElementTypeList ']'
  //
  // ElementTypeList :=
  //     <<empty>>
  //  | TypeExpression
  //  | '...' TypeExpression
  //  | TypeExpression ',' ElementTypeList


  function parseArrayType() {
    var elements,
        startIndex = index - 1,
        restStartIndex;
    consume(Token.LBRACK, 'ArrayType should start with [');
    elements = [];

    while (token !== Token.RBRACK) {
      if (token === Token.REST) {
        restStartIndex = index - 3;
        consume(Token.REST);
        elements.push(maybeAddRange({
          type: Syntax.RestType,
          expression: parseTypeExpression()
        }, [restStartIndex, previous]));
        break;
      } else {
        elements.push(parseTypeExpression());
      }

      if (token !== Token.RBRACK) {
        expect(Token.COMMA);
      }
    }

    expect(Token.RBRACK);
    return maybeAddRange({
      type: Syntax.ArrayType,
      elements: elements
    }, [startIndex, previous]);
  }

  function parseFieldName() {
    var v = value;

    if (token === Token.NAME || token === Token.STRING) {
      next();
      return v;
    }

    if (token === Token.NUMBER) {
      consume(Token.NUMBER);
      return String(v);
    }

    utility$1.throwError('unexpected token');
  } // FieldType :=
  //     FieldName
  //   | FieldName ':' TypeExpression
  //
  // FieldName :=
  //     NameExpression
  //   | StringLiteral
  //   | NumberLiteral
  //   | ReservedIdentifier


  function parseFieldType() {
    var key,
        rangeStart = previous;
    key = parseFieldName();

    if (token === Token.COLON) {
      consume(Token.COLON);
      return maybeAddRange({
        type: Syntax.FieldType,
        key: key,
        value: parseTypeExpression()
      }, [rangeStart, previous]);
    }

    return maybeAddRange({
      type: Syntax.FieldType,
      key: key,
      value: null
    }, [rangeStart, previous]);
  } // RecordType := '{' FieldTypeList '}'
  //
  // FieldTypeList :=
  //     <<empty>>
  //   | FieldType
  //   | FieldType ',' FieldTypeList


  function parseRecordType() {
    var fields,
        rangeStart = index - 1,
        rangeEnd;
    consume(Token.LBRACE, 'RecordType should start with {');
    fields = [];

    if (token === Token.COMMA) {
      consume(Token.COMMA);
    } else {
      while (token !== Token.RBRACE) {
        fields.push(parseFieldType());

        if (token !== Token.RBRACE) {
          expect(Token.COMMA);
        }
      }
    }

    rangeEnd = index;
    expect(Token.RBRACE);
    return maybeAddRange({
      type: Syntax.RecordType,
      fields: fields
    }, [rangeStart, rangeEnd]);
  } // NameExpression :=
  //    Identifier
  //  | TagIdentifier ':' Identifier
  //
  // Tag identifier is one of "module", "external" or "event"
  // Identifier is the same as Token.NAME, including any dots, something like
  // namespace.module.MyClass


  function parseNameExpression() {
    var name = value,
        rangeStart = index - name.length;
    expect(Token.NAME);

    if (token === Token.COLON && (name === 'module' || name === 'external' || name === 'event')) {
      consume(Token.COLON);
      name += ':' + value;
      expect(Token.NAME);
    }

    return maybeAddRange({
      type: Syntax.NameExpression,
      name: name
    }, [rangeStart, previous]);
  } // TypeExpressionList :=
  //     TopLevelTypeExpression
  //   | TopLevelTypeExpression ',' TypeExpressionList


  function parseTypeExpressionList() {
    var elements = [];
    elements.push(parseTop());

    while (token === Token.COMMA) {
      consume(Token.COMMA);
      elements.push(parseTop());
    }

    return elements;
  } // TypeName :=
  //     NameExpression
  //   | NameExpression TypeApplication
  //
  // TypeApplication :=
  //     '.<' TypeExpressionList '>'
  //   | '<' TypeExpressionList '>'   // this is extension of doctrine


  function parseTypeName() {
    var expr,
        applications,
        startIndex = index - value.length;
    expr = parseNameExpression();

    if (token === Token.DOT_LT || token === Token.LT) {
      next();
      applications = parseTypeExpressionList();
      expect(Token.GT);
      return maybeAddRange({
        type: Syntax.TypeApplication,
        expression: expr,
        applications: applications
      }, [startIndex, previous]);
    }

    return expr;
  } // ResultType :=
  //     <<empty>>
  //   | ':' void
  //   | ':' TypeExpression
  //
  // BNF is above
  // but, we remove <<empty>> pattern, so token is always TypeToken::COLON


  function parseResultType() {
    consume(Token.COLON, 'ResultType should start with :');

    if (token === Token.NAME && value === 'void') {
      consume(Token.NAME);
      return {
        type: Syntax.VoidLiteral
      };
    }

    return parseTypeExpression();
  } // ParametersType :=
  //     RestParameterType
  //   | NonRestParametersType
  //   | NonRestParametersType ',' RestParameterType
  //
  // RestParameterType :=
  //     '...'
  //     '...' Identifier
  //
  // NonRestParametersType :=
  //     ParameterType ',' NonRestParametersType
  //   | ParameterType
  //   | OptionalParametersType
  //
  // OptionalParametersType :=
  //     OptionalParameterType
  //   | OptionalParameterType, OptionalParametersType
  //
  // OptionalParameterType := ParameterType=
  //
  // ParameterType := TypeExpression | Identifier ':' TypeExpression
  //
  // Identifier is "new" or "this"


  function parseParametersType() {
    var params = [],
        optionalSequence = false,
        expr,
        rest = false,
        startIndex,
        restStartIndex = index - 3,
        nameStartIndex;

    while (token !== Token.RPAREN) {
      if (token === Token.REST) {
        // RestParameterType
        consume(Token.REST);
        rest = true;
      }

      startIndex = previous;
      expr = parseTypeExpression();

      if (expr.type === Syntax.NameExpression && token === Token.COLON) {
        nameStartIndex = previous - expr.name.length; // Identifier ':' TypeExpression

        consume(Token.COLON);
        expr = maybeAddRange({
          type: Syntax.ParameterType,
          name: expr.name,
          expression: parseTypeExpression()
        }, [nameStartIndex, previous]);
      }

      if (token === Token.EQUAL) {
        consume(Token.EQUAL);
        expr = maybeAddRange({
          type: Syntax.OptionalType,
          expression: expr
        }, [startIndex, previous]);
        optionalSequence = true;
      } else {
        if (optionalSequence) {
          utility$1.throwError('unexpected token');
        }
      }

      if (rest) {
        expr = maybeAddRange({
          type: Syntax.RestType,
          expression: expr
        }, [restStartIndex, previous]);
      }

      params.push(expr);

      if (token !== Token.RPAREN) {
        expect(Token.COMMA);
      }
    }

    return params;
  } // FunctionType := 'function' FunctionSignatureType
  //
  // FunctionSignatureType :=
  //   | TypeParameters '(' ')' ResultType
  //   | TypeParameters '(' ParametersType ')' ResultType
  //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType
  //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType


  function parseFunctionType() {
    var isNew,
        thisBinding,
        params,
        result,
        fnType,
        startIndex = index - value.length;
    utility$1.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
    consume(Token.NAME); // Google Closure Compiler is not implementing TypeParameters.
    // So we do not. if we don't get '(', we see it as error.

    expect(Token.LPAREN);
    isNew = false;
    params = [];
    thisBinding = null;

    if (token !== Token.RPAREN) {
      // ParametersType or 'this'
      if (token === Token.NAME && (value === 'this' || value === 'new')) {
        // 'this' or 'new'
        // 'new' is Closure Compiler extension
        isNew = value === 'new';
        consume(Token.NAME);
        expect(Token.COLON);
        thisBinding = parseTypeName();

        if (token === Token.COMMA) {
          consume(Token.COMMA);
          params = parseParametersType();
        }
      } else {
        params = parseParametersType();
      }
    }

    expect(Token.RPAREN);
    result = null;

    if (token === Token.COLON) {
      result = parseResultType();
    }

    fnType = maybeAddRange({
      type: Syntax.FunctionType,
      params: params,
      result: result
    }, [startIndex, previous]);

    if (thisBinding) {
      // avoid adding null 'new' and 'this' properties
      fnType['this'] = thisBinding;

      if (isNew) {
        fnType['new'] = true;
      }
    }

    return fnType;
  } // BasicTypeExpression :=
  //     '*'
  //   | 'null'
  //   | 'undefined'
  //   | TypeName
  //   | FunctionType
  //   | UnionType
  //   | RecordType
  //   | ArrayType


  function parseBasicTypeExpression() {
    var context, startIndex;

    switch (token) {
      case Token.STAR:
        consume(Token.STAR);
        return maybeAddRange({
          type: Syntax.AllLiteral
        }, [previous - 1, previous]);

      case Token.LPAREN:
        return parseUnionType();

      case Token.LBRACK:
        return parseArrayType();

      case Token.LBRACE:
        return parseRecordType();

      case Token.NAME:
        startIndex = index - value.length;

        if (value === 'null') {
          consume(Token.NAME);
          return maybeAddRange({
            type: Syntax.NullLiteral
          }, [startIndex, previous]);
        }

        if (value === 'undefined') {
          consume(Token.NAME);
          return maybeAddRange({
            type: Syntax.UndefinedLiteral
          }, [startIndex, previous]);
        }

        if (value === 'true' || value === 'false') {
          consume(Token.NAME);
          return maybeAddRange({
            type: Syntax.BooleanLiteralType,
            value: value === 'true'
          }, [startIndex, previous]);
        }

        context = Context.save();

        if (value === 'function') {
          try {
            return parseFunctionType();
          } catch (e) {
            context.restore();
          }
        }

        return parseTypeName();

      case Token.STRING:
        next();
        return maybeAddRange({
          type: Syntax.StringLiteralType,
          value: value
        }, [previous - value.length - 2, previous]);

      case Token.NUMBER:
        next();
        return maybeAddRange({
          type: Syntax.NumericLiteralType,
          value: value
        }, [previous - String(value).length, previous]);

      default:
        utility$1.throwError('unexpected token');
    }
  } // TypeExpression :=
  //     BasicTypeExpression
  //   | '?' BasicTypeExpression
  //   | '!' BasicTypeExpression
  //   | BasicTypeExpression '?'
  //   | BasicTypeExpression '!'
  //   | '?'
  //   | BasicTypeExpression '[]'


  function parseTypeExpression() {
    var expr, rangeStart;

    if (token === Token.QUESTION) {
      rangeStart = index - 1;
      consume(Token.QUESTION);

      if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {
        return maybeAddRange({
          type: Syntax.NullableLiteral
        }, [rangeStart, previous]);
      }

      return maybeAddRange({
        type: Syntax.NullableType,
        expression: parseBasicTypeExpression(),
        prefix: true
      }, [rangeStart, previous]);
    } else if (token === Token.BANG) {
      rangeStart = index - 1;
      consume(Token.BANG);
      return maybeAddRange({
        type: Syntax.NonNullableType,
        expression: parseBasicTypeExpression(),
        prefix: true
      }, [rangeStart, previous]);
    } else {
      rangeStart = previous;
    }

    expr = parseBasicTypeExpression();

    if (token === Token.BANG) {
      consume(Token.BANG);
      return maybeAddRange({
        type: Syntax.NonNullableType,
        expression: expr,
        prefix: false
      }, [rangeStart, previous]);
    }

    if (token === Token.QUESTION) {
      consume(Token.QUESTION);
      return maybeAddRange({
        type: Syntax.NullableType,
        expression: expr,
        prefix: false
      }, [rangeStart, previous]);
    }

    if (token === Token.LBRACK) {
      consume(Token.LBRACK);
      expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
      return maybeAddRange({
        type: Syntax.TypeApplication,
        expression: maybeAddRange({
          type: Syntax.NameExpression,
          name: 'Array'
        }, [rangeStart, previous]),
        applications: [expr]
      }, [rangeStart, previous]);
    }

    return expr;
  } // TopLevelTypeExpression :=
  //      TypeExpression
  //    | TypeUnionList
  //
  // This rule is Google Closure Compiler extension, not ES4
  // like,
  //   { number | string }
  // If strict to ES4, we should write it as
  //   { (number|string) }


  function parseTop() {
    var expr, elements;
    expr = parseTypeExpression();

    if (token !== Token.PIPE) {
      return expr;
    }

    elements = [expr];
    consume(Token.PIPE);

    while (true) {
      elements.push(parseTypeExpression());

      if (token !== Token.PIPE) {
        break;
      }

      consume(Token.PIPE);
    }

    return maybeAddRange({
      type: Syntax.UnionType,
      elements: elements
    }, [0, index]);
  }

  function parseTopParamType() {
    var expr;

    if (token === Token.REST) {
      consume(Token.REST);
      return maybeAddRange({
        type: Syntax.RestType,
        expression: parseTop()
      }, [0, index]);
    }

    expr = parseTop();

    if (token === Token.EQUAL) {
      consume(Token.EQUAL);
      return maybeAddRange({
        type: Syntax.OptionalType,
        expression: expr
      }, [0, index]);
    }

    return expr;
  }

  function parseType(src, opt) {
    var expr;
    source = src;
    length = source.length;
    index = 0;
    previous = 0;
    addRange = opt && opt.range;
    rangeOffset = opt && opt.startIndex || 0;
    next();
    expr = parseTop();

    if (opt && opt.midstream) {
      return {
        expression: expr,
        index: previous
      };
    }

    if (token !== Token.EOF) {
      utility$1.throwError('not reach to EOF');
    }

    return expr;
  }

  function parseParamType(src, opt) {
    var expr;
    source = src;
    length = source.length;
    index = 0;
    previous = 0;
    addRange = opt && opt.range;
    rangeOffset = opt && opt.startIndex || 0;
    next();
    expr = parseTopParamType();

    if (opt && opt.midstream) {
      return {
        expression: expr,
        index: previous
      };
    }

    if (token !== Token.EOF) {
      utility$1.throwError('not reach to EOF');
    }

    return expr;
  }

  function stringifyImpl(node, compact, topLevel) {
    var result, i, iz;

    switch (node.type) {
      case Syntax.NullableLiteral:
        result = '?';
        break;

      case Syntax.AllLiteral:
        result = '*';
        break;

      case Syntax.NullLiteral:
        result = 'null';
        break;

      case Syntax.UndefinedLiteral:
        result = 'undefined';
        break;

      case Syntax.VoidLiteral:
        result = 'void';
        break;

      case Syntax.UnionType:
        if (!topLevel) {
          result = '(';
        } else {
          result = '';
        }

        for (i = 0, iz = node.elements.length; i < iz; ++i) {
          result += stringifyImpl(node.elements[i], compact);

          if (i + 1 !== iz) {
            result += compact ? '|' : ' | ';
          }
        }

        if (!topLevel) {
          result += ')';
        }

        break;

      case Syntax.ArrayType:
        result = '[';

        for (i = 0, iz = node.elements.length; i < iz; ++i) {
          result += stringifyImpl(node.elements[i], compact);

          if (i + 1 !== iz) {
            result += compact ? ',' : ', ';
          }
        }

        result += ']';
        break;

      case Syntax.RecordType:
        result = '{';

        for (i = 0, iz = node.fields.length; i < iz; ++i) {
          result += stringifyImpl(node.fields[i], compact);

          if (i + 1 !== iz) {
            result += compact ? ',' : ', ';
          }
        }

        result += '}';
        break;

      case Syntax.FieldType:
        if (node.value) {
          result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
        } else {
          result = node.key;
        }

        break;

      case Syntax.FunctionType:
        result = compact ? 'function(' : 'function (';

        if (node['this']) {
          if (node['new']) {
            result += compact ? 'new:' : 'new: ';
          } else {
            result += compact ? 'this:' : 'this: ';
          }

          result += stringifyImpl(node['this'], compact);

          if (node.params.length !== 0) {
            result += compact ? ',' : ', ';
          }
        }

        for (i = 0, iz = node.params.length; i < iz; ++i) {
          result += stringifyImpl(node.params[i], compact);

          if (i + 1 !== iz) {
            result += compact ? ',' : ', ';
          }
        }

        result += ')';

        if (node.result) {
          result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
        }

        break;

      case Syntax.ParameterType:
        result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
        break;

      case Syntax.RestType:
        result = '...';

        if (node.expression) {
          result += stringifyImpl(node.expression, compact);
        }

        break;

      case Syntax.NonNullableType:
        if (node.prefix) {
          result = '!' + stringifyImpl(node.expression, compact);
        } else {
          result = stringifyImpl(node.expression, compact) + '!';
        }

        break;

      case Syntax.OptionalType:
        result = stringifyImpl(node.expression, compact) + '=';
        break;

      case Syntax.NullableType:
        if (node.prefix) {
          result = '?' + stringifyImpl(node.expression, compact);
        } else {
          result = stringifyImpl(node.expression, compact) + '?';
        }

        break;

      case Syntax.NameExpression:
        result = node.name;
        break;

      case Syntax.TypeApplication:
        result = stringifyImpl(node.expression, compact) + '.<';

        for (i = 0, iz = node.applications.length; i < iz; ++i) {
          result += stringifyImpl(node.applications[i], compact);

          if (i + 1 !== iz) {
            result += compact ? ',' : ', ';
          }
        }

        result += '>';
        break;

      case Syntax.StringLiteralType:
        result = '"' + node.value + '"';
        break;

      case Syntax.NumericLiteralType:
        result = String(node.value);
        break;

      case Syntax.BooleanLiteralType:
        result = String(node.value);
        break;

      default:
        utility$1.throwError('Unknown type ' + node.type);
    }

    return result;
  }

  function stringify(node, options) {
    if (options == null) {
      options = {};
    }

    return stringifyImpl(node, options.compact, options.topLevel);
  }

  exports.parseType = parseType;
  exports.parseParamType = parseParamType;
  exports.stringify = stringify;
  exports.Syntax = Syntax;
})();
/* vim: set sw=4 ts=4 et tw=80 : */
});

/*
 * @fileoverview Main Doctrine object
 * @author Yusuke Suzuki <utatane.tea@gmail.com>
 * @author Dan Tao <daniel.tao@gmail.com>
 * @author Andrew Eisenberg <andrew@eisenberg.as>
 */

var doctrine = createCommonjsModule$1(function (module, exports) {
(function () {

  var typed$1, utility$1, jsdoc, esutils, hasOwnProperty;
  esutils = utils;
  typed$1 = typed;
  utility$1 = utility;

  function sliceSource(source, index, last) {
    return source.slice(index, last);
  }

  hasOwnProperty = function () {
    var func = Object.prototype.hasOwnProperty;
    return function hasOwnProperty(obj, name) {
      return func.call(obj, name);
    };
  }();

  function shallowCopy(obj) {
    var ret = {},
        key;

    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        ret[key] = obj[key];
      }
    }

    return ret;
  }

  function isASCIIAlphanumeric(ch) {
    return ch >= 0x61
    /* 'a' */
    && ch <= 0x7A
    /* 'z' */
    || ch >= 0x41
    /* 'A' */
    && ch <= 0x5A
    /* 'Z' */
    || ch >= 0x30
    /* '0' */
    && ch <= 0x39
    /* '9' */
    ;
  }

  function isParamTitle(title) {
    return title === 'param' || title === 'argument' || title === 'arg';
  }

  function isReturnTitle(title) {
    return title === 'return' || title === 'returns';
  }

  function isProperty(title) {
    return title === 'property' || title === 'prop';
  }

  function isNameParameterRequired(title) {
    return isParamTitle(title) || isProperty(title) || title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
  }

  function isAllowedName(title) {
    return isNameParameterRequired(title) || title === 'const' || title === 'constant';
  }

  function isAllowedNested(title) {
    return isProperty(title) || isParamTitle(title);
  }

  function isAllowedOptional(title) {
    return isProperty(title) || isParamTitle(title);
  }

  function isTypeParameterRequired(title) {
    return isParamTitle(title) || isReturnTitle(title) || title === 'define' || title === 'enum' || title === 'implements' || title === 'this' || title === 'type' || title === 'typedef' || isProperty(title);
  } // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required
  // This would require changes to 'parseType'


  function isAllowedType(title) {
    return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' || title === 'namespace' || title === 'member' || title === 'var' || title === 'module' || title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' || title === 'public' || title === 'private' || title === 'protected';
  } // A regex character class that contains all whitespace except linebreak characters (\r, \n, \u2028, \u2029)


  var WHITESPACE = '[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]';
  var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\*' + WHITESPACE + '?)?)(.+|[\r\n\u2028\u2029])';

  function unwrapComment(doc) {
    // JSDoc comment is following form
    //   /**
    //    * .......
    //    */
    return doc. // remove /**
    replace(/^\/\*\*?/, ''). // remove */
    replace(/\*\/$/, ''). // remove ' * ' at the beginning of a line
    replace(new RegExp(STAR_MATCHER, 'g'), '$2'). // remove trailing whitespace
    replace(/\s*$/, '');
  }
  /**
   * Converts an index in an "unwrapped" JSDoc comment to the corresponding index in the original "wrapped" version
   * @param {string} originalSource The original wrapped comment
   * @param {number} unwrappedIndex The index of a character in the unwrapped string
   * @returns {number} The index of the corresponding character in the original wrapped string
   */


  function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {
    var replacedSource = originalSource.replace(/^\/\*\*?/, '');
    var numSkippedChars = 0;
    var matcher = new RegExp(STAR_MATCHER, 'g');
    var match;

    while (match = matcher.exec(replacedSource)) {
      numSkippedChars += match[1].length;

      if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {
        return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;
      }
    }

    return originalSource.replace(/\*\/$/, '').replace(/\s*$/, '').length;
  } // JSDoc Tag Parser


  (function (exports) {
    var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;

    function advance() {
      var ch = source.charCodeAt(index);
      index += 1;

      if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D
      /* '\r' */
      && source.charCodeAt(index) === 0x0A
      /* '\n' */
      )) {
        lineNumber += 1;
      }

      return String.fromCharCode(ch);
    }

    function scanTitle() {
      var title = ''; // waste '@'

      advance();

      while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
        title += advance();
      }

      return title;
    }

    function seekContent() {
      var ch,
          waiting,
          last = index;
      waiting = false;

      while (last < length) {
        ch = source.charCodeAt(last);

        if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D
        /* '\r' */
        && source.charCodeAt(last + 1) === 0x0A
        /* '\n' */
        )) {
          waiting = true;
        } else if (waiting) {
          if (ch === 0x40
          /* '@' */
          ) {
              break;
            }

          if (!esutils.code.isWhiteSpace(ch)) {
            waiting = false;
          }
        }

        last += 1;
      }

      return last;
    } // type expression may have nest brace, such as,
    // { { ok: string } }
    //
    // therefore, scanning type expression with balancing braces.


    function parseType(title, last, addRange) {
      var ch,
          brace,
          type,
          startIndex,
          direct = false; // search '{'

      while (index < last) {
        ch = source.charCodeAt(index);

        if (esutils.code.isWhiteSpace(ch)) {
          advance();
        } else if (ch === 0x7B
        /* '{' */
        ) {
            advance();
            break;
          } else {
          // this is direct pattern
          direct = true;
          break;
        }
      }

      if (direct) {
        return null;
      } // type expression { is found


      brace = 1;
      type = '';

      while (index < last) {
        ch = source.charCodeAt(index);

        if (esutils.code.isLineTerminator(ch)) {
          advance();
        } else {
          if (ch === 0x7D
          /* '}' */
          ) {
              brace -= 1;

              if (brace === 0) {
                advance();
                break;
              }
            } else if (ch === 0x7B
          /* '{' */
          ) {
              brace += 1;
            }

          if (type === '') {
            startIndex = index;
          }

          type += advance();
        }
      }

      if (brace !== 0) {
        // braces is not balanced
        return utility$1.throwError('Braces are not balanced');
      }

      if (isAllowedOptional(title)) {
        return typed$1.parseParamType(type, {
          startIndex: convertIndex(startIndex),
          range: addRange
        });
      }

      return typed$1.parseType(type, {
        startIndex: convertIndex(startIndex),
        range: addRange
      });
    }

    function scanIdentifier(last) {
      var identifier;

      if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {
        return null;
      }

      identifier = advance();

      while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
        identifier += advance();
      }

      return identifier;
    }

    function skipWhiteSpace(last) {
      while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
        advance();
      }
    }

    function parseName(last, allowBrackets, allowNestedParams) {
      var name = '',
          useBrackets,
          insideString;
      skipWhiteSpace(last);

      if (index >= last) {
        return null;
      }

      if (source.charCodeAt(index) === 0x5B
      /* '[' */
      ) {
          if (allowBrackets) {
            useBrackets = true;
            name = advance();
          } else {
            return null;
          }
        }

      name += scanIdentifier(last);

      if (allowNestedParams) {
        if (source.charCodeAt(index) === 0x3A
        /* ':' */
        && (name === 'module' || name === 'external' || name === 'event')) {
          name += advance();
          name += scanIdentifier(last);
        }

        if (source.charCodeAt(index) === 0x5B
        /* '[' */
        && source.charCodeAt(index + 1) === 0x5D
        /* ']' */
        ) {
            name += advance();
            name += advance();
          }

        while (source.charCodeAt(index) === 0x2E
        /* '.' */
        || source.charCodeAt(index) === 0x2F
        /* '/' */
        || source.charCodeAt(index) === 0x23
        /* '#' */
        || source.charCodeAt(index) === 0x2D
        /* '-' */
        || source.charCodeAt(index) === 0x7E
        /* '~' */
        ) {
          name += advance();
          name += scanIdentifier(last);
        }
      }

      if (useBrackets) {
        skipWhiteSpace(last); // do we have a default value for this?

        if (source.charCodeAt(index) === 0x3D
        /* '=' */
        ) {
            // consume the '='' symbol
            name += advance();
            skipWhiteSpace(last);
            var ch;
            var bracketDepth = 1; // scan in the default value

            while (index < last) {
              ch = source.charCodeAt(index);

              if (esutils.code.isWhiteSpace(ch)) {
                if (!insideString) {
                  skipWhiteSpace(last);
                  ch = source.charCodeAt(index);
                }
              }

              if (ch === 0x27
              /* ''' */
              ) {
                  if (!insideString) {
                    insideString = '\'';
                  } else {
                    if (insideString === '\'') {
                      insideString = '';
                    }
                  }
                }

              if (ch === 0x22
              /* '"' */
              ) {
                  if (!insideString) {
                    insideString = '"';
                  } else {
                    if (insideString === '"') {
                      insideString = '';
                    }
                  }
                }

              if (ch === 0x5B
              /* '[' */
              ) {
                  bracketDepth++;
                } else if (ch === 0x5D
              /* ']' */
              && --bracketDepth === 0) {
                break;
              }

              name += advance();
            }
          }

        skipWhiteSpace(last);

        if (index >= last || source.charCodeAt(index) !== 0x5D
        /* ']' */
        ) {
            // we never found a closing ']'
            return null;
          } // collect the last ']'


        name += advance();
      }

      return name;
    }

    function skipToTag() {
      while (index < length && source.charCodeAt(index) !== 0x40
      /* '@' */
      ) {
        advance();
      }

      if (index >= length) {
        return false;
      }

      utility$1.assert(source.charCodeAt(index) === 0x40
      /* '@' */
      );
      return true;
    }

    function convertIndex(rangeIndex) {
      if (source === originalSource) {
        return rangeIndex;
      }

      return convertUnwrappedCommentIndex(originalSource, rangeIndex);
    }

    function TagParser(options, title) {
      this._options = options;
      this._title = title.toLowerCase();
      this._tag = {
        title: title,
        description: null
      };

      if (this._options.lineNumbers) {
        this._tag.lineNumber = lineNumber;
      }

      this._first = index - title.length - 1;
      this._last = 0; // space to save special information for title parsers.

      this._extra = {};
    } // addError(err, ...)


    TagParser.prototype.addError = function addError(errorText) {
      var args = Array.prototype.slice.call(arguments, 1),
          msg = errorText.replace(/%(\d)/g, function (whole, index) {
        utility$1.assert(index < args.length, 'Message reference must be in range');
        return args[index];
      });

      if (!this._tag.errors) {
        this._tag.errors = [];
      }

      if (strict) {
        utility$1.throwError(msg);
      }

      this._tag.errors.push(msg);

      return recoverable;
    };

    TagParser.prototype.parseType = function () {
      // type required titles
      if (isTypeParameterRequired(this._title)) {
        try {
          this._tag.type = parseType(this._title, this._last, this._options.range);

          if (!this._tag.type) {
            if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
              if (!this.addError('Missing or invalid tag type')) {
                return false;
              }
            }
          }
        } catch (error) {
          this._tag.type = null;

          if (!this.addError(error.message)) {
            return false;
          }
        }
      } else if (isAllowedType(this._title)) {
        // optional types
        try {
          this._tag.type = parseType(this._title, this._last, this._options.range);
        } catch (e) {//For optional types, lets drop the thrown error when we hit the end of the file
        }
      }

      return true;
    };

    TagParser.prototype._parseNamePath = function (optional) {
      var name;
      name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);

      if (!name) {
        if (!optional) {
          if (!this.addError('Missing or invalid tag name')) {
            return false;
          }
        }
      }

      this._tag.name = name;
      return true;
    };

    TagParser.prototype.parseNamePath = function () {
      return this._parseNamePath(false);
    };

    TagParser.prototype.parseNamePathOptional = function () {
      return this._parseNamePath(true);
    };

    TagParser.prototype.parseName = function () {
      var assign, name; // param, property requires name

      if (isAllowedName(this._title)) {
        this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));

        if (!this._tag.name) {
          if (!isNameParameterRequired(this._title)) {
            return true;
          } // it's possible the name has already been parsed but interpreted as a type
          // it's also possible this is a sloppy declaration, in which case it will be
          // fixed at the end


          if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
            this._extra.name = this._tag.type;
            this._tag.name = this._tag.type.name;
            this._tag.type = null;
          } else {
            if (!this.addError('Missing or invalid tag name')) {
              return false;
            }
          }
        } else {
          name = this._tag.name;

          if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
            // extract the default value if there is one
            // example: @param {string} [somebody=John Doe] description
            assign = name.substring(1, name.length - 1).split('=');

            if (assign.length > 1) {
              this._tag['default'] = assign.slice(1).join('=');
            }

            this._tag.name = assign[0]; // convert to an optional type

            if (this._tag.type && this._tag.type.type !== 'OptionalType') {
              this._tag.type = {
                type: 'OptionalType',
                expression: this._tag.type
              };
            }
          }
        }
      }

      return true;
    };

    TagParser.prototype.parseDescription = function parseDescription() {
      var description = sliceSource(source, index, this._last).trim();

      if (description) {
        if (/^-\s+/.test(description)) {
          description = description.substring(2);
        }

        this._tag.description = description;
      }

      return true;
    };

    TagParser.prototype.parseCaption = function parseDescription() {
      var description = sliceSource(source, index, this._last).trim();
      var captionStartTag = '<caption>';
      var captionEndTag = '</caption>';
      var captionStart = description.indexOf(captionStartTag);
      var captionEnd = description.indexOf(captionEndTag);

      if (captionStart >= 0 && captionEnd >= 0) {
        this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();
        this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();
      } else {
        this._tag.description = description;
      }

      return true;
    };

    TagParser.prototype.parseKind = function parseKind() {
      var kind, kinds;
      kinds = {
        'class': true,
        'constant': true,
        'event': true,
        'external': true,
        'file': true,
        'function': true,
        'member': true,
        'mixin': true,
        'module': true,
        'namespace': true,
        'typedef': true
      };
      kind = sliceSource(source, index, this._last).trim();
      this._tag.kind = kind;

      if (!hasOwnProperty(kinds, kind)) {
        if (!this.addError('Invalid kind name \'%0\'', kind)) {
          return false;
        }
      }

      return true;
    };

    TagParser.prototype.parseAccess = function parseAccess() {
      var access;
      access = sliceSource(source, index, this._last).trim();
      this._tag.access = access;

      if (access !== 'private' && access !== 'protected' && access !== 'public') {
        if (!this.addError('Invalid access name \'%0\'', access)) {
          return false;
        }
      }

      return true;
    };

    TagParser.prototype.parseThis = function parseThis() {
      // this name may be a name expression (e.g. {foo.bar}),
      // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)
      var value = sliceSource(source, index, this._last).trim();

      if (value && value.charAt(0) === '{') {
        var gotType = this.parseType();

        if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {
          this._tag.name = this._tag.type.name;
          return true;
        } else {
          return this.addError('Invalid name for this');
        }
      } else {
        return this.parseNamePath();
      }
    };

    TagParser.prototype.parseVariation = function parseVariation() {
      var variation, text;
      text = sliceSource(source, index, this._last).trim();
      variation = parseFloat(text, 10);
      this._tag.variation = variation;

      if (isNaN(variation)) {
        if (!this.addError('Invalid variation \'%0\'', text)) {
          return false;
        }
      }

      return true;
    };

    TagParser.prototype.ensureEnd = function () {
      var shouldBeEmpty = sliceSource(source, index, this._last).trim();

      if (shouldBeEmpty) {
        if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
          return false;
        }
      }

      return true;
    };

    TagParser.prototype.epilogue = function epilogue() {
      var description;
      description = this._tag.description; // un-fix potentially sloppy declaration

      if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
        this._tag.type = this._extra.name;

        if (!this._tag.name) {
          this._tag.name = undefined;
        }

        if (!sloppy) {
          if (!this.addError('Missing or invalid tag name')) {
            return false;
          }
        }
      }

      return true;
    };

    Rules = {
      // http://usejsdoc.org/tags-access.html
      'access': ['parseAccess'],
      // http://usejsdoc.org/tags-alias.html
      'alias': ['parseNamePath', 'ensureEnd'],
      // http://usejsdoc.org/tags-augments.html
      'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-constructor.html
      'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-constructor.html
      'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-extends.html
      'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-example.html
      'example': ['parseCaption'],
      // http://usejsdoc.org/tags-deprecated.html
      'deprecated': ['parseDescription'],
      // http://usejsdoc.org/tags-global.html
      'global': ['ensureEnd'],
      // http://usejsdoc.org/tags-inner.html
      'inner': ['ensureEnd'],
      // http://usejsdoc.org/tags-instance.html
      'instance': ['ensureEnd'],
      // http://usejsdoc.org/tags-kind.html
      'kind': ['parseKind'],
      // http://usejsdoc.org/tags-mixes.html
      'mixes': ['parseNamePath', 'ensureEnd'],
      // http://usejsdoc.org/tags-mixin.html
      'mixin': ['parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-member.html
      'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-method.html
      'method': ['parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-module.html
      'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-method.html
      'func': ['parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-method.html
      'function': ['parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-member.html
      'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-name.html
      'name': ['parseNamePath', 'ensureEnd'],
      // http://usejsdoc.org/tags-namespace.html
      'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-private.html
      'private': ['parseType', 'parseDescription'],
      // http://usejsdoc.org/tags-protected.html
      'protected': ['parseType', 'parseDescription'],
      // http://usejsdoc.org/tags-public.html
      'public': ['parseType', 'parseDescription'],
      // http://usejsdoc.org/tags-readonly.html
      'readonly': ['ensureEnd'],
      // http://usejsdoc.org/tags-requires.html
      'requires': ['parseNamePath', 'ensureEnd'],
      // http://usejsdoc.org/tags-since.html
      'since': ['parseDescription'],
      // http://usejsdoc.org/tags-static.html
      'static': ['ensureEnd'],
      // http://usejsdoc.org/tags-summary.html
      'summary': ['parseDescription'],
      // http://usejsdoc.org/tags-this.html
      'this': ['parseThis', 'ensureEnd'],
      // http://usejsdoc.org/tags-todo.html
      'todo': ['parseDescription'],
      // http://usejsdoc.org/tags-typedef.html
      'typedef': ['parseType', 'parseNamePathOptional'],
      // http://usejsdoc.org/tags-variation.html
      'variation': ['parseVariation'],
      // http://usejsdoc.org/tags-version.html
      'version': ['parseDescription']
    };

    TagParser.prototype.parse = function parse() {
      var i, iz, sequences, method; // empty title

      if (!this._title) {
        if (!this.addError('Missing or invalid title')) {
          return null;
        }
      } // Seek to content last index.


      this._last = seekContent(this._title);

      if (this._options.range) {
        this._tag.range = [this._first, source.slice(0, this._last).replace(/\s*$/, '').length].map(convertIndex);
      }

      if (hasOwnProperty(Rules, this._title)) {
        sequences = Rules[this._title];
      } else {
        // default sequences
        sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
      }

      for (i = 0, iz = sequences.length; i < iz; ++i) {
        method = sequences[i];

        if (!this[method]()) {
          return null;
        }
      }

      return this._tag;
    };

    function parseTag(options) {
      var title, parser, tag; // skip to tag

      if (!skipToTag()) {
        return null;
      } // scan title


      title = scanTitle(); // construct tag parser

      parser = new TagParser(options, title);
      tag = parser.parse(); // Seek global index to end of this tag.

      while (index < parser._last) {
        advance();
      }

      return tag;
    } //
    // Parse JSDoc
    //


    function scanJSDocDescription(preserveWhitespace) {
      var description = '',
          ch,
          atAllowed;
      atAllowed = true;

      while (index < length) {
        ch = source.charCodeAt(index);

        if (atAllowed && ch === 0x40
        /* '@' */
        ) {
            break;
          }

        if (esutils.code.isLineTerminator(ch)) {
          atAllowed = true;
        } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
          atAllowed = false;
        }

        description += advance();
      }

      return preserveWhitespace ? description : description.trim();
    }

    function parse(comment, options) {
      var tags = [],
          tag,
          description,
          interestingTags,
          i,
          iz;

      if (options === undefined) {
        options = {};
      }

      if (typeof options.unwrap === 'boolean' && options.unwrap) {
        source = unwrapComment(comment);
      } else {
        source = comment;
      }

      originalSource = comment; // array of relevant tags

      if (options.tags) {
        if (Array.isArray(options.tags)) {
          interestingTags = {};

          for (i = 0, iz = options.tags.length; i < iz; i++) {
            if (typeof options.tags[i] === 'string') {
              interestingTags[options.tags[i]] = true;
            } else {
              utility$1.throwError('Invalid "tags" parameter: ' + options.tags);
            }
          }
        } else {
          utility$1.throwError('Invalid "tags" parameter: ' + options.tags);
        }
      }

      length = source.length;
      index = 0;
      lineNumber = 0;
      recoverable = options.recoverable;
      sloppy = options.sloppy;
      strict = options.strict;
      description = scanJSDocDescription(options.preserveWhitespace);

      while (true) {
        tag = parseTag(options);

        if (!tag) {
          break;
        }

        if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
          tags.push(tag);
        }
      }

      return {
        description: description,
        tags: tags
      };
    }

    exports.parse = parse;
  })(jsdoc = {});

  exports.version = utility$1.VERSION;
  exports.parse = jsdoc.parse;
  exports.parseType = typed$1.parseType;
  exports.parseParamType = typed$1.parseParamType;
  exports.unwrapComment = unwrapComment;
  exports.Syntax = shallowCopy(typed$1.Syntax);
  exports.Error = utility$1.DoctrineError;
  exports.type = {
    Syntax: exports.Syntax,
    parseType: typed$1.parseType,
    parseParamType: typed$1.parseParamType,
    stringify: typed$1.stringify
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
});

var regexpp = /*@__PURE__*/getAugmentedNamespace(regexpp$1);

function _interopDefaultLegacy(e){return e&&typeof e==='object'&&'default'in e?e:{'default':e};}var esutils__default=_interopDefaultLegacy(utils);var espree__default=_interopDefaultLegacy(espree_1);var lodash__default=_interopDefaultLegacy(lodash);var functionalRedBlackTree__default=_interopDefaultLegacy(rbtree);var regexpp__default=_interopDefaultLegacy(regexpp);var globals__default=_interopDefaultLegacy(globals);var eslintUtils__default=_interopDefaultLegacy(eslintUtils);var ignore__default=_interopDefaultLegacy(ignore);var naturalCompare__default=_interopDefaultLegacy(naturalCompare_1);var doctrine__default=_interopDefaultLegacy(doctrine);var astUtils=_commonjsHelpers11cbc178.createCommonjsModule(function(module){const{breakableTypePattern,createGlobalLinebreakMatcher,lineBreakPattern,shebangPattern}=_commonjsHelpers11cbc178.astUtils;const anyFunctionPattern=/^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;const thisTagPattern=/^[\s*]*@this/mu;const LINEBREAKS=new Set(["\r\n","\r","\n","\u2028","\u2029"]);const STATEMENT_LIST_PARENTS=new Set(["Program","BlockStatement","SwitchCase"]);const DECIMAL_INTEGER_PATTERN=/^(?:0|0[0-7]*[89]\d*|[1-9](?:_?\d)*)$/u;const LOGICAL_ASSIGNMENT_OPERATORS=new Set(["&&=","||=","??="]);function isModifyingReference(reference,index,references){const identifier=reference.identifier;const modifyingDifferentIdentifier=index===0||references[index-1].identifier!==identifier;return identifier&&reference.init===false&&reference.isWrite()&&modifyingDifferentIdentifier;}function startsWithUpperCase(s){return s[0]!==s[0].toLocaleLowerCase();}function isES5Constructor(node){return node.id&&startsWithUpperCase(node.id.name);}function getUpperFunction(node){for(let currentNode=node;currentNode;currentNode=currentNode.parent){if(anyFunctionPattern.test(currentNode.type)){return currentNode;}}return null;}function isFunction(node){return Boolean(node&&anyFunctionPattern.test(node.type));}function isLoop(node){return Boolean(node&&/^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u.test(node.type));}function isNullLiteral(node){return node.type==="Literal"&&node.value===null&&!node.regex&&!node.bigint;}function isNullOrUndefined(node){return isNullLiteral(node)||node.type==="Identifier"&&node.name==="undefined"||node.type==="UnaryExpression"&&node.operator==="void";}function isCallee(node){return node.parent.type==="CallExpression"&&node.parent.callee===node;}function getStaticStringValue(node){switch(node.type){case"Literal":if(node.value===null){if(isNullLiteral(node)){return String(node.value);}if(node.regex){return `/${node.regex.pattern}/${node.regex.flags}`;}if(node.bigint){return node.bigint;}}else {return String(node.value);}break;case"TemplateLiteral":if(node.expressions.length===0&&node.quasis.length===1){return node.quasis[0].value.cooked;}break;}return null;}function getStaticPropertyName(node){let prop;switch(node&&node.type){case"ChainExpression":return getStaticPropertyName(node.expression);case"Property":case"MethodDefinition":prop=node.key;break;case"MemberExpression":prop=node.property;break;}if(prop){if(prop.type==="Identifier"&&!node.computed){return prop.name;}return getStaticStringValue(prop);}return null;}function skipChainExpression(node){return node&&node.type==="ChainExpression"?node.expression:node;}function checkText(actual,expected){return typeof expected==="string"?actual===expected:expected.test(actual);}function isSpecificId(node,name){return node.type==="Identifier"&&checkText(node.name,name);}function isSpecificMemberAccess(node,objectName,propertyName){const checkNode=skipChainExpression(node);if(checkNode.type!=="MemberExpression"){return false;}if(objectName&&!isSpecificId(checkNode.object,objectName)){return false;}if(propertyName){const actualPropertyName=getStaticPropertyName(checkNode);if(typeof actualPropertyName!=="string"||!checkText(actualPropertyName,propertyName)){return false;}}return true;}function equalLiteralValue(left,right){if(left.regex||right.regex){return Boolean(left.regex&&right.regex&&left.regex.pattern===right.regex.pattern&&left.regex.flags===right.regex.flags);}if(left.bigint||right.bigint){return left.bigint===right.bigint;}return left.value===right.value;}function isSameReference(left,right,disableStaticComputedKey=false){if(left.type!==right.type){if(left.type==="ChainExpression"){return isSameReference(left.expression,right,disableStaticComputedKey);}if(right.type==="ChainExpression"){return isSameReference(left,right.expression,disableStaticComputedKey);}return false;}switch(left.type){case"Super":case"ThisExpression":return true;case"Identifier":return left.name===right.name;case"Literal":return equalLiteralValue(left,right);case"ChainExpression":return isSameReference(left.expression,right.expression,disableStaticComputedKey);case"MemberExpression":{if(!disableStaticComputedKey){const nameA=getStaticPropertyName(left);if(nameA!==null){return isSameReference(left.object,right.object,disableStaticComputedKey)&&nameA===getStaticPropertyName(right);}}return left.computed===right.computed&&isSameReference(left.object,right.object,disableStaticComputedKey)&&isSameReference(left.property,right.property,disableStaticComputedKey);}default:return false;}}function isReflectApply(node){return isSpecificMemberAccess(node,"Reflect","apply");}function isArrayFromMethod(node){return isSpecificMemberAccess(node,/Array$/u,"from");}function isMethodWhichHasThisArg(node){return isSpecificMemberAccess(node,null,/^(?:every|filter|find|findIndex|forEach|map|some)$/u);}function negate(f){return token=>!f(token);}function hasJSDocThisTag(node,sourceCode){const jsdocComment=sourceCode.getJSDocComment(node);if(jsdocComment&&thisTagPattern.test(jsdocComment.value)){return true;}return sourceCode.getCommentsBefore(node).some(comment=>thisTagPattern.test(comment.value));}function isArrowToken(token){return token.value==="=>"&&token.type==="Punctuator";}function isCommaToken(token){return token.value===","&&token.type==="Punctuator";}function isDotToken(token){return token.value==="."&&token.type==="Punctuator";}function isQuestionDotToken(token){return token.value==="?."&&token.type==="Punctuator";}function isSemicolonToken(token){return token.value===";"&&token.type==="Punctuator";}function isColonToken(token){return token.value===":"&&token.type==="Punctuator";}function isOpeningParenToken(token){return token.value==="("&&token.type==="Punctuator";}function isClosingParenToken(token){return token.value===")"&&token.type==="Punctuator";}function isOpeningBracketToken(token){return token.value==="["&&token.type==="Punctuator";}function isClosingBracketToken(token){return token.value==="]"&&token.type==="Punctuator";}function isOpeningBraceToken(token){return token.value==="{"&&token.type==="Punctuator";}function isClosingBraceToken(token){return token.value==="}"&&token.type==="Punctuator";}function getOpeningParenOfParams(node,sourceCode){return node.id?sourceCode.getTokenAfter(node.id,isOpeningParenToken):sourceCode.getFirstToken(node,isOpeningParenToken);}function isLogicalExpression(node){return node.type==="LogicalExpression"&&(node.operator==="&&"||node.operator==="||");}function isCoalesceExpression(node){return node.type==="LogicalExpression"&&node.operator==="??";}module.exports={COMMENTS_IGNORE_PATTERN:/^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u,LINEBREAKS,LINEBREAK_MATCHER:lineBreakPattern,SHEBANG_MATCHER:shebangPattern,STATEMENT_LIST_PARENTS,isTokenOnSameLine(left,right){return left.loc.end.line===right.loc.start.line;},isNullOrUndefined,isCallee,isES5Constructor,getUpperFunction,isFunction,isLoop,isInLoop:function(node){for(let currentNode=node;currentNode&&!isFunction(currentNode);currentNode=currentNode.parent){if(isLoop(currentNode)){return true;}}return false;},isArrayFromMethod,isParenthesised:function(sourceCode,node){const previousToken=sourceCode.getTokenBefore(node),nextToken=sourceCode.getTokenAfter(node);return Boolean(previousToken&&nextToken)&&previousToken.value==="("&&previousToken.range[1]<=node.range[0]&&nextToken.value===")"&&nextToken.range[0]>=node.range[1];},createGlobalLinebreakMatcher,equalTokens:function(left,right,sourceCode){const tokensL=sourceCode.getTokens(left);const tokensR=sourceCode.getTokens(right);if(tokensL.length!==tokensR.length){return false;}for(let i=0;i<tokensL.length;++i){if(tokensL[i].type!==tokensR[i].type||tokensL[i].value!==tokensR[i].value){return false;}}return true;},isArrowToken,isClosingBraceToken,isClosingBracketToken,isClosingParenToken,isColonToken,isCommaToken,isCommentToken:function(token){return token.type==="Line"||token.type==="Block"||token.type==="Shebang";},isDotToken,isQuestionDotToken,isKeywordToken:function(token){return token.type==="Keyword";},isNotClosingBraceToken:negate(isClosingBraceToken),isNotClosingBracketToken:negate(isClosingBracketToken),isNotClosingParenToken:negate(isClosingParenToken),isNotColonToken:negate(isColonToken),isNotCommaToken:negate(isCommaToken),isNotDotToken:negate(isDotToken),isNotQuestionDotToken:negate(isQuestionDotToken),isNotOpeningBraceToken:negate(isOpeningBraceToken),isNotOpeningBracketToken:negate(isOpeningBracketToken),isNotOpeningParenToken:negate(isOpeningParenToken),isNotSemicolonToken:negate(isSemicolonToken),isOpeningBraceToken,isOpeningBracketToken,isOpeningParenToken,isSemicolonToken,isStringLiteral(node){return node.type==="Literal"&&typeof node.value==="string"||node.type==="TemplateLiteral";},isBreakableStatement(node){return breakableTypePattern.test(node.type);},getModifyingReferences(references){return references.filter(isModifyingReference);},isSurroundedBy(val,character){return val[0]===character&&val[val.length-1]===character;},isDirectiveComment(node){const comment=node.value.trim();return node.type==="Line"&&comment.indexOf("eslint-")===0||node.type==="Block"&&(comment.indexOf("global ")===0||comment.indexOf("eslint ")===0||comment.indexOf("eslint-")===0);},getTrailingStatement:esutils__default['default'].ast.trailingStatement,getVariableByName(initScope,name){let scope=initScope;while(scope){const variable=scope.set.get(name);if(variable){return variable;}scope=scope.upper;}return null;},isDefaultThisBinding(node,sourceCode,{capIsConstructor=true}={}){if(capIsConstructor&&isES5Constructor(node)||hasJSDocThisTag(node,sourceCode)){return false;}const isAnonymous=node.id===null;let currentNode=node;while(currentNode){const parent=currentNode.parent;switch(parent.type){case"LogicalExpression":case"ConditionalExpression":case"ChainExpression":currentNode=parent;break;case"ReturnStatement":{const func=getUpperFunction(parent);if(func===null||!isCallee(func)){return true;}currentNode=func.parent;break;}case"ArrowFunctionExpression":if(currentNode!==parent.body||!isCallee(parent)){return true;}currentNode=parent.parent;break;case"Property":case"MethodDefinition":return parent.value!==currentNode;case"AssignmentExpression":case"AssignmentPattern":if(parent.left.type==="MemberExpression"){return false;}if(capIsConstructor&&isAnonymous&&parent.left.type==="Identifier"&&startsWithUpperCase(parent.left.name)){return false;}return true;case"VariableDeclarator":return !(capIsConstructor&&isAnonymous&&parent.init===currentNode&&parent.id.type==="Identifier"&&startsWithUpperCase(parent.id.name));case"MemberExpression":if(parent.object===currentNode&&isSpecificMemberAccess(parent,null,/^(?:bind|call|apply)$/u)){const maybeCalleeNode=parent.parent.type==="ChainExpression"?parent.parent:parent;return !(isCallee(maybeCalleeNode)&&maybeCalleeNode.parent.arguments.length>=1&&!isNullOrUndefined(maybeCalleeNode.parent.arguments[0]));}return true;case"CallExpression":if(isReflectApply(parent.callee)){return parent.arguments.length!==3||parent.arguments[0]!==currentNode||isNullOrUndefined(parent.arguments[1]);}if(isArrayFromMethod(parent.callee)){return parent.arguments.length!==3||parent.arguments[1]!==currentNode||isNullOrUndefined(parent.arguments[2]);}if(isMethodWhichHasThisArg(parent.callee)){return parent.arguments.length!==2||parent.arguments[0]!==currentNode||isNullOrUndefined(parent.arguments[1]);}return true;default:return true;}}return true;},getPrecedence(node){switch(node.type){case"SequenceExpression":return 0;case"AssignmentExpression":case"ArrowFunctionExpression":case"YieldExpression":return 1;case"ConditionalExpression":return 3;case"LogicalExpression":switch(node.operator){case"||":case"??":return 4;case"&&":return 5;}case"BinaryExpression":switch(node.operator){case"|":return 6;case"^":return 7;case"&":return 8;case"==":case"!=":case"===":case"!==":return 9;case"<":case"<=":case">":case">=":case"in":case"instanceof":return 10;case"<<":case">>":case">>>":return 11;case"+":case"-":return 12;case"*":case"/":case"%":return 13;case"**":return 15;}case"UnaryExpression":case"AwaitExpression":return 16;case"UpdateExpression":return 17;case"CallExpression":case"ChainExpression":case"ImportExpression":return 18;case"NewExpression":return 19;default:return 20;}},isEmptyBlock(node){return Boolean(node&&node.type==="BlockStatement"&&node.body.length===0);},isEmptyFunction(node){return isFunction(node)&&module.exports.isEmptyBlock(node.body);},getDirectivePrologue(node){const directives=[];if(node.type==="Program"||node.type==="FunctionDeclaration"||node.type==="FunctionExpression"||node.type==="ArrowFunctionExpression"&&node.body.type==="BlockStatement"){const statements=node.type==="Program"?node.body:node.body.body;for(const statement of statements){if(statement.type==="ExpressionStatement"&&statement.expression.type==="Literal"){directives.push(statement);}else {break;}}}return directives;},isDecimalInteger(node){return node.type==="Literal"&&typeof node.value==="number"&&DECIMAL_INTEGER_PATTERN.test(node.raw);},isDecimalIntegerNumericToken(token){return token.type==="Numeric"&&DECIMAL_INTEGER_PATTERN.test(token.value);},getFunctionNameWithKind(node){const parent=node.parent;const tokens=[];if(parent.type==="MethodDefinition"&&parent.static){tokens.push("static");}if(node.async){tokens.push("async");}if(node.generator){tokens.push("generator");}if(node.type==="ArrowFunctionExpression"){tokens.push("arrow","function");}else if(parent.type==="Property"||parent.type==="MethodDefinition"){if(parent.kind==="constructor"){return "constructor";}if(parent.kind==="get"){tokens.push("getter");}else if(parent.kind==="set"){tokens.push("setter");}else {tokens.push("method");}}else {tokens.push("function");}if(node.id){tokens.push(`'${node.id.name}'`);}else {const name=getStaticPropertyName(parent);if(name!==null){tokens.push(`'${name}'`);}}return tokens.join(" ");},getFunctionHeadLoc(node,sourceCode){const parent=node.parent;let start=null;let end=null;if(node.type==="ArrowFunctionExpression"){const arrowToken=sourceCode.getTokenBefore(node.body,isArrowToken);start=arrowToken.loc.start;end=arrowToken.loc.end;}else if(parent.type==="Property"||parent.type==="MethodDefinition"){start=parent.loc.start;end=getOpeningParenOfParams(node,sourceCode).loc.start;}else {start=node.loc.start;end=getOpeningParenOfParams(node,sourceCode).loc.start;}return {start:Object.assign({},start),end:Object.assign({},end)};},getNextLocation(sourceCode,{line,column}){if(column<sourceCode.lines[line-1].length){return {line,column:column+1};}if(line<sourceCode.lines.length){return {line:line+1,column:0};}return null;},getParenthesisedText(sourceCode,node){let leftToken=sourceCode.getFirstToken(node);let rightToken=sourceCode.getLastToken(node);while(sourceCode.getTokenBefore(leftToken)&&sourceCode.getTokenBefore(leftToken).type==="Punctuator"&&sourceCode.getTokenBefore(leftToken).value==="("&&sourceCode.getTokenAfter(rightToken)&&sourceCode.getTokenAfter(rightToken).type==="Punctuator"&&sourceCode.getTokenAfter(rightToken).value===")"){leftToken=sourceCode.getTokenBefore(leftToken);rightToken=sourceCode.getTokenAfter(rightToken);}return sourceCode.getText().slice(leftToken.range[0],rightToken.range[1]);},couldBeError(node){switch(node.type){case"Identifier":case"CallExpression":case"NewExpression":case"MemberExpression":case"TaggedTemplateExpression":case"YieldExpression":case"AwaitExpression":case"ChainExpression":return true;case"AssignmentExpression":if(["=","&&="].includes(node.operator)){return module.exports.couldBeError(node.right);}if(["||=","??="].includes(node.operator)){return module.exports.couldBeError(node.left)||module.exports.couldBeError(node.right);}return false;case"SequenceExpression":{const exprs=node.expressions;return exprs.length!==0&&module.exports.couldBeError(exprs[exprs.length-1]);}case"LogicalExpression":if(node.operator==="&&"){return module.exports.couldBeError(node.right);}return module.exports.couldBeError(node.left)||module.exports.couldBeError(node.right);case"ConditionalExpression":return module.exports.couldBeError(node.consequent)||module.exports.couldBeError(node.alternate);default:return false;}},isNumericLiteral(node){return node.type==="Literal"&&(typeof node.value==="number"||Boolean(node.bigint));},canTokensBeAdjacent(leftValue,rightValue){const espreeOptions={ecmaVersion:espree__default['default'].latestEcmaVersion,comment:true,range:true};let leftToken;if(typeof leftValue==="string"){let tokens;try{tokens=espree__default['default'].tokenize(leftValue,espreeOptions);}catch{return false;}const comments=tokens.comments;leftToken=tokens[tokens.length-1];if(comments.length){const lastComment=comments[comments.length-1];if(lastComment.range[0]>leftToken.range[0]){leftToken=lastComment;}}}else {leftToken=leftValue;}if(leftToken.type==="Shebang"){return false;}let rightToken;if(typeof rightValue==="string"){let tokens;try{tokens=espree__default['default'].tokenize(rightValue,espreeOptions);}catch{return false;}const comments=tokens.comments;rightToken=tokens[0];if(comments.length){const firstComment=comments[0];if(firstComment.range[0]<rightToken.range[0]){rightToken=firstComment;}}}else {rightToken=rightValue;}if(leftToken.type==="Punctuator"||rightToken.type==="Punctuator"){if(leftToken.type==="Punctuator"&&rightToken.type==="Punctuator"){const PLUS_TOKENS=new Set(["+","++"]);const MINUS_TOKENS=new Set(["-","--"]);return !(PLUS_TOKENS.has(leftToken.value)&&PLUS_TOKENS.has(rightToken.value)||MINUS_TOKENS.has(leftToken.value)&&MINUS_TOKENS.has(rightToken.value));}if(leftToken.type==="Punctuator"&&leftToken.value==="/"){return !["Block","Line","RegularExpression"].includes(rightToken.type);}return true;}if(leftToken.type==="String"||rightToken.type==="String"||leftToken.type==="Template"||rightToken.type==="Template"){return true;}if(leftToken.type!=="Numeric"&&rightToken.type==="Numeric"&&rightToken.value.startsWith(".")){return true;}if(leftToken.type==="Block"||rightToken.type==="Block"||rightToken.type==="Line"){return true;}return false;},getNameLocationInGlobalDirectiveComment(sourceCode,comment,name){const namePattern=new RegExp(`[\\s,]${lodash__default['default'].escapeRegExp(name)}(?:$|[\\s,:])`,"gu");namePattern.lastIndex=comment.value.indexOf("global")+6;const match=namePattern.exec(comment.value);const start=sourceCode.getLocFromIndex(comment.range[0]+2+(match?match.index+1:0));const end={line:start.line,column:start.column+(match?name.length:1)};return {start,end};},hasOctalOrNonOctalDecimalEscapeSequence(rawString){return /^(?:[^\\]|\\.)*\\(?:[1-9]|0[0-9])/su.test(rawString);},isLogicalExpression,isCoalesceExpression,isMixedLogicalAndCoalesceExpressions:function(left,right){return isLogicalExpression(left)&&isCoalesceExpression(right)||isCoalesceExpression(left)&&isLogicalExpression(right);},isNullLiteral,getStaticStringValue,getStaticPropertyName,skipChainExpression,isSpecificId,isSpecificMemberAccess,equalLiteralValue,isSameReference,isLogicalAssignmentOperator:function(operator){return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);}};});astUtils.COMMENTS_IGNORE_PATTERN;astUtils.LINEBREAKS;astUtils.LINEBREAK_MATCHER;astUtils.SHEBANG_MATCHER;astUtils.STATEMENT_LIST_PARENTS;astUtils.isTokenOnSameLine;astUtils.isNullOrUndefined;astUtils.isCallee;astUtils.isES5Constructor;astUtils.getUpperFunction;astUtils.isFunction;astUtils.isLoop;astUtils.isInLoop;astUtils.isArrayFromMethod;astUtils.isParenthesised;astUtils.createGlobalLinebreakMatcher;astUtils.equalTokens;astUtils.isArrowToken;astUtils.isClosingBraceToken;astUtils.isClosingBracketToken;astUtils.isClosingParenToken;astUtils.isColonToken;astUtils.isCommaToken;astUtils.isCommentToken;astUtils.isDotToken;astUtils.isQuestionDotToken;astUtils.isKeywordToken;astUtils.isNotClosingBraceToken;astUtils.isNotClosingBracketToken;astUtils.isNotClosingParenToken;astUtils.isNotColonToken;astUtils.isNotCommaToken;astUtils.isNotDotToken;astUtils.isNotQuestionDotToken;astUtils.isNotOpeningBraceToken;astUtils.isNotOpeningBracketToken;astUtils.isNotOpeningParenToken;astUtils.isNotSemicolonToken;astUtils.isOpeningBraceToken;astUtils.isOpeningBracketToken;astUtils.isOpeningParenToken;astUtils.isSemicolonToken;astUtils.isStringLiteral;astUtils.isBreakableStatement;astUtils.getModifyingReferences;astUtils.isSurroundedBy;astUtils.isDirectiveComment;astUtils.getTrailingStatement;astUtils.getVariableByName;astUtils.isDefaultThisBinding;astUtils.getPrecedence;astUtils.isEmptyBlock;astUtils.isEmptyFunction;astUtils.getDirectivePrologue;astUtils.isDecimalInteger;astUtils.isDecimalIntegerNumericToken;astUtils.getFunctionNameWithKind;astUtils.getFunctionHeadLoc;astUtils.getNextLocation;astUtils.getParenthesisedText;astUtils.couldBeError;astUtils.isNumericLiteral;astUtils.canTokensBeAdjacent;astUtils.getNameLocationInGlobalDirectiveComment;astUtils.hasOctalOrNonOctalDecimalEscapeSequence;astUtils.isLogicalExpression;astUtils.isCoalesceExpression;astUtils.isMixedLogicalAndCoalesceExpressions;astUtils.isNullLiteral;astUtils.getStaticStringValue;astUtils.getStaticPropertyName;astUtils.skipChainExpression;astUtils.isSpecificId;astUtils.isSpecificMemberAccess;astUtils.equalLiteralValue;astUtils.isSameReference;astUtils.isLogicalAssignmentOperator;function areEqualTokenLists$1(left,right){if(left.length!==right.length){return false;}for(let i=0;i<left.length;i++){const leftToken=left[i],rightToken=right[i];if(leftToken.type!==rightToken.type||leftToken.value!==rightToken.value){return false;}}return true;}function areEqualKeys$1(left,right){if(typeof left==="string"&&typeof right==="string"){return left===right;}if(Array.isArray(left)&&Array.isArray(right)){return areEqualTokenLists$1(left,right);}return false;}function isAccessorKind$1(node){return node.kind==="get"||node.kind==="set";}function isArgumentOfMethodCall(node,index,object,property){const parent=node.parent;return parent.type==="CallExpression"&&astUtils.isSpecificMemberAccess(parent.callee,object,property)&&parent.arguments[index]===node;}function isPropertyDescriptor$1(node){if(isArgumentOfMethodCall(node,2,"Object","defineProperty")||isArgumentOfMethodCall(node,2,"Reflect","defineProperty")){return true;}const grandparent=node.parent.parent;return grandparent.type==="ObjectExpression"&&(isArgumentOfMethodCall(grandparent,1,"Object","create")||isArgumentOfMethodCall(grandparent,1,"Object","defineProperties"));}var accessorPairs={meta:{type:"suggestion",docs:{description:"enforce getter and setter pairs in objects and classes",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/accessor-pairs"},schema:[{type:"object",properties:{getWithoutSet:{type:"boolean",default:false},setWithoutGet:{type:"boolean",default:true},enforceForClassMembers:{type:"boolean",default:true}},additionalProperties:false}],messages:{missingGetterInPropertyDescriptor:"Getter is not present in property descriptor.",missingSetterInPropertyDescriptor:"Setter is not present in property descriptor.",missingGetterInObjectLiteral:"Getter is not present for {{ name }}.",missingSetterInObjectLiteral:"Setter is not present for {{ name }}.",missingGetterInClass:"Getter is not present for class {{ name }}.",missingSetterInClass:"Setter is not present for class {{ name }}."}},create(context){const config=context.options[0]||{};const checkGetWithoutSet=config.getWithoutSet===true;const checkSetWithoutGet=config.setWithoutGet!==false;const enforceForClassMembers=config.enforceForClassMembers!==false;const sourceCode=context.getSourceCode();function report(node,messageKind){if(node.type==="Property"){context.report({node,messageId:`${messageKind}InObjectLiteral`,loc:astUtils.getFunctionHeadLoc(node.value,sourceCode),data:{name:astUtils.getFunctionNameWithKind(node.value)}});}else if(node.type==="MethodDefinition"){context.report({node,messageId:`${messageKind}InClass`,loc:astUtils.getFunctionHeadLoc(node.value,sourceCode),data:{name:astUtils.getFunctionNameWithKind(node.value)}});}else {context.report({node,messageId:`${messageKind}InPropertyDescriptor`});}}function reportList(nodes,messageKind){for(const node of nodes){report(node,messageKind);}}function createAccessorData(node){const name=astUtils.getStaticPropertyName(node);const key=name!==null?name:sourceCode.getTokens(node.key);return {key,getters:node.kind==="get"?[node]:[],setters:node.kind==="set"?[node]:[]};}function mergeAccessorData(accessors,accessorData){const equalKeyElement=accessors.find(a=>areEqualKeys$1(a.key,accessorData.key));if(equalKeyElement){equalKeyElement.getters.push(...accessorData.getters);equalKeyElement.setters.push(...accessorData.setters);}else {accessors.push(accessorData);}return accessors;}function checkList(nodes){const accessors=nodes.filter(isAccessorKind$1).map(createAccessorData).reduce(mergeAccessorData,[]);for(const{getters,setters}of accessors){if(checkSetWithoutGet&&setters.length&&!getters.length){reportList(setters,"missingGetter");}if(checkGetWithoutSet&&getters.length&&!setters.length){reportList(getters,"missingSetter");}}}function checkObjectLiteral(node){checkList(node.properties.filter(p=>p.type==="Property"));}function checkPropertyDescriptor(node){const namesToCheck=node.properties.filter(p=>p.type==="Property"&&p.kind==="init"&&!p.computed).map(({key})=>key.name);const hasGetter=namesToCheck.includes("get");const hasSetter=namesToCheck.includes("set");if(checkSetWithoutGet&&hasSetter&&!hasGetter){report(node,"missingGetter");}if(checkGetWithoutSet&&hasGetter&&!hasSetter){report(node,"missingSetter");}}function checkObjectExpression(node){checkObjectLiteral(node);if(isPropertyDescriptor$1(node)){checkPropertyDescriptor(node);}}function checkClassBody(node){const methodDefinitions=node.body.filter(m=>m.type==="MethodDefinition");checkList(methodDefinitions.filter(m=>m.static));checkList(methodDefinitions.filter(m=>!m.static));}const listeners={};if(checkSetWithoutGet||checkGetWithoutSet){listeners.ObjectExpression=checkObjectExpression;if(enforceForClassMembers){listeners.ClassBody=checkClassBody;}}return listeners;}};var arrayBracketNewline={meta:{type:"layout",docs:{description:"enforce linebreaks after opening and before closing array brackets",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/array-bracket-newline"},fixable:"whitespace",schema:[{oneOf:[{enum:["always","never","consistent"]},{type:"object",properties:{multiline:{type:"boolean"},minItems:{type:["integer","null"],minimum:0}},additionalProperties:false}]}],messages:{unexpectedOpeningLinebreak:"There should be no linebreak after '['.",unexpectedClosingLinebreak:"There should be no linebreak before ']'.",missingOpeningLinebreak:"A linebreak is required after '['.",missingClosingLinebreak:"A linebreak is required before ']'."}},create(context){const sourceCode=context.getSourceCode();function normalizeOptionValue(option){let consistent=false;let multiline=false;let minItems=0;if(option){if(option==="consistent"){consistent=true;minItems=Number.POSITIVE_INFINITY;}else if(option==="always"||option.minItems===0){minItems=0;}else if(option==="never"){minItems=Number.POSITIVE_INFINITY;}else {multiline=Boolean(option.multiline);minItems=option.minItems||Number.POSITIVE_INFINITY;}}else {consistent=false;multiline=true;minItems=Number.POSITIVE_INFINITY;}return {consistent,multiline,minItems};}function normalizeOptions(options){const value=normalizeOptionValue(options);return {ArrayExpression:value,ArrayPattern:value};}function reportNoBeginningLinebreak(node,token){context.report({node,loc:token.loc,messageId:"unexpectedOpeningLinebreak",fix(fixer){const nextToken=sourceCode.getTokenAfter(token,{includeComments:true});if(astUtils.isCommentToken(nextToken)){return null;}return fixer.removeRange([token.range[1],nextToken.range[0]]);}});}function reportNoEndingLinebreak(node,token){context.report({node,loc:token.loc,messageId:"unexpectedClosingLinebreak",fix(fixer){const previousToken=sourceCode.getTokenBefore(token,{includeComments:true});if(astUtils.isCommentToken(previousToken)){return null;}return fixer.removeRange([previousToken.range[1],token.range[0]]);}});}function reportRequiredBeginningLinebreak(node,token){context.report({node,loc:token.loc,messageId:"missingOpeningLinebreak",fix(fixer){return fixer.insertTextAfter(token,"\n");}});}function reportRequiredEndingLinebreak(node,token){context.report({node,loc:token.loc,messageId:"missingClosingLinebreak",fix(fixer){return fixer.insertTextBefore(token,"\n");}});}function check(node){const elements=node.elements;const normalizedOptions=normalizeOptions(context.options[0]);const options=normalizedOptions[node.type];const openBracket=sourceCode.getFirstToken(node);const closeBracket=sourceCode.getLastToken(node);const firstIncComment=sourceCode.getTokenAfter(openBracket,{includeComments:true});const lastIncComment=sourceCode.getTokenBefore(closeBracket,{includeComments:true});const first=sourceCode.getTokenAfter(openBracket);const last=sourceCode.getTokenBefore(closeBracket);const needsLinebreaks=elements.length>=options.minItems||options.multiline&&elements.length>0&&firstIncComment.loc.start.line!==lastIncComment.loc.end.line||elements.length===0&&firstIncComment.type==="Block"&&firstIncComment.loc.start.line!==lastIncComment.loc.end.line&&firstIncComment===lastIncComment||options.consistent&&openBracket.loc.end.line!==first.loc.start.line;if(needsLinebreaks){if(astUtils.isTokenOnSameLine(openBracket,first)){reportRequiredBeginningLinebreak(node,openBracket);}if(astUtils.isTokenOnSameLine(last,closeBracket)){reportRequiredEndingLinebreak(node,closeBracket);}}else {if(!astUtils.isTokenOnSameLine(openBracket,first)){reportNoBeginningLinebreak(node,openBracket);}if(!astUtils.isTokenOnSameLine(last,closeBracket)){reportNoEndingLinebreak(node,closeBracket);}}}return {ArrayPattern:check,ArrayExpression:check};}};var arrayBracketSpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing inside array brackets",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/array-bracket-spacing"},fixable:"whitespace",schema:[{enum:["always","never"]},{type:"object",properties:{singleValue:{type:"boolean"},objectsInArrays:{type:"boolean"},arraysInArrays:{type:"boolean"}},additionalProperties:false}],messages:{unexpectedSpaceAfter:"There should be no space after '{{tokenValue}}'.",unexpectedSpaceBefore:"There should be no space before '{{tokenValue}}'.",missingSpaceAfter:"A space is required after '{{tokenValue}}'.",missingSpaceBefore:"A space is required before '{{tokenValue}}'."}},create(context){const spaced=context.options[0]==="always",sourceCode=context.getSourceCode();function isOptionSet(option){return context.options[1]?context.options[1][option]===!spaced:false;}const options={spaced,singleElementException:isOptionSet("singleValue"),objectsInArraysException:isOptionSet("objectsInArrays"),arraysInArraysException:isOptionSet("arraysInArrays")};function reportNoBeginningSpace(node,token){const nextToken=sourceCode.getTokenAfter(token);context.report({node,loc:{start:token.loc.end,end:nextToken.loc.start},messageId:"unexpectedSpaceAfter",data:{tokenValue:token.value},fix(fixer){return fixer.removeRange([token.range[1],nextToken.range[0]]);}});}function reportNoEndingSpace(node,token){const previousToken=sourceCode.getTokenBefore(token);context.report({node,loc:{start:previousToken.loc.end,end:token.loc.start},messageId:"unexpectedSpaceBefore",data:{tokenValue:token.value},fix(fixer){return fixer.removeRange([previousToken.range[1],token.range[0]]);}});}function reportRequiredBeginningSpace(node,token){context.report({node,loc:token.loc,messageId:"missingSpaceAfter",data:{tokenValue:token.value},fix(fixer){return fixer.insertTextAfter(token," ");}});}function reportRequiredEndingSpace(node,token){context.report({node,loc:token.loc,messageId:"missingSpaceBefore",data:{tokenValue:token.value},fix(fixer){return fixer.insertTextBefore(token," ");}});}function isObjectType(node){return node&&(node.type==="ObjectExpression"||node.type==="ObjectPattern");}function isArrayType(node){return node&&(node.type==="ArrayExpression"||node.type==="ArrayPattern");}function validateArraySpacing(node){if(options.spaced&&node.elements.length===0){return;}const first=sourceCode.getFirstToken(node),second=sourceCode.getFirstToken(node,1),last=node.typeAnnotation?sourceCode.getTokenBefore(node.typeAnnotation):sourceCode.getLastToken(node),penultimate=sourceCode.getTokenBefore(last),firstElement=node.elements[0],lastElement=node.elements[node.elements.length-1];const openingBracketMustBeSpaced=options.objectsInArraysException&&isObjectType(firstElement)||options.arraysInArraysException&&isArrayType(firstElement)||options.singleElementException&&node.elements.length===1?!options.spaced:options.spaced;const closingBracketMustBeSpaced=options.objectsInArraysException&&isObjectType(lastElement)||options.arraysInArraysException&&isArrayType(lastElement)||options.singleElementException&&node.elements.length===1?!options.spaced:options.spaced;if(astUtils.isTokenOnSameLine(first,second)){if(openingBracketMustBeSpaced&&!sourceCode.isSpaceBetweenTokens(first,second)){reportRequiredBeginningSpace(node,first);}if(!openingBracketMustBeSpaced&&sourceCode.isSpaceBetweenTokens(first,second)){reportNoBeginningSpace(node,first);}}if(first!==penultimate&&astUtils.isTokenOnSameLine(penultimate,last)){if(closingBracketMustBeSpaced&&!sourceCode.isSpaceBetweenTokens(penultimate,last)){reportRequiredEndingSpace(node,last);}if(!closingBracketMustBeSpaced&&sourceCode.isSpaceBetweenTokens(penultimate,last)){reportNoEndingSpace(node,last);}}}return {ArrayPattern:validateArraySpacing,ArrayExpression:validateArraySpacing};}};const TARGET_NODE_TYPE$2=/^(?:Arrow)?FunctionExpression$/u;const TARGET_METHODS=/^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;function isReachable$3(segment){return segment.reachable;}function isTargetMethod(node){return astUtils.isSpecificMemberAccess(node,null,TARGET_METHODS);}function fullMethodName(arrayMethodName){if(["from","of","isArray"].includes(arrayMethodName)){return "Array.".concat(arrayMethodName);}return "Array.prototype.".concat(arrayMethodName);}function getArrayMethodName(node){let currentNode=node;while(currentNode){const parent=currentNode.parent;switch(parent.type){case"LogicalExpression":case"ConditionalExpression":case"ChainExpression":currentNode=parent;break;case"ReturnStatement":{const func=astUtils.getUpperFunction(parent);if(func===null||!astUtils.isCallee(func)){return null;}currentNode=func.parent;break;}case"CallExpression":if(astUtils.isArrayFromMethod(parent.callee)){if(parent.arguments.length>=2&&parent.arguments[1]===currentNode){return "from";}}if(isTargetMethod(parent.callee)){if(parent.arguments.length>=1&&parent.arguments[0]===currentNode){return astUtils.getStaticPropertyName(parent.callee);}}return null;default:return null;}}return null;}var arrayCallbackReturn={meta:{type:"problem",docs:{description:"enforce `return` statements in callbacks of array methods",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/array-callback-return"},schema:[{type:"object",properties:{allowImplicit:{type:"boolean",default:false},checkForEach:{type:"boolean",default:false}},additionalProperties:false}],messages:{expectedAtEnd:"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.",expectedInside:"{{arrayMethodName}}() expects a return value from {{name}}.",expectedReturnValue:"{{arrayMethodName}}() expects a return value from {{name}}.",expectedNoReturnValue:"{{arrayMethodName}}() expects no useless return value from {{name}}."}},create(context){const options=context.options[0]||{allowImplicit:false,checkForEach:false};const sourceCode=context.getSourceCode();let funcInfo={arrayMethodName:null,upper:null,codePath:null,hasReturn:false,shouldCheck:false,node:null};function checkLastSegment(node){if(!funcInfo.shouldCheck){return;}let messageId=null;if(funcInfo.arrayMethodName==="forEach"){if(options.checkForEach&&node.type==="ArrowFunctionExpression"&&node.expression){messageId="expectedNoReturnValue";}}else {if(node.body.type==="BlockStatement"&&funcInfo.codePath.currentSegments.some(isReachable$3)){messageId=funcInfo.hasReturn?"expectedAtEnd":"expectedInside";}}if(messageId){const name=astUtils.getFunctionNameWithKind(node);context.report({node,loc:astUtils.getFunctionHeadLoc(node,sourceCode),messageId,data:{name,arrayMethodName:fullMethodName(funcInfo.arrayMethodName)}});}}return {onCodePathStart(codePath,node){let methodName=null;if(TARGET_NODE_TYPE$2.test(node.type)){methodName=getArrayMethodName(node);}funcInfo={arrayMethodName:methodName,upper:funcInfo,codePath,hasReturn:false,shouldCheck:methodName&&!node.async&&!node.generator,node};},onCodePathEnd(){funcInfo=funcInfo.upper;},ReturnStatement(node){if(!funcInfo.shouldCheck){return;}funcInfo.hasReturn=true;let messageId=null;if(funcInfo.arrayMethodName==="forEach"){if(options.checkForEach&&node.argument){messageId="expectedNoReturnValue";}}else {if(!options.allowImplicit&&!node.argument){messageId="expectedReturnValue";}}if(messageId){context.report({node,messageId,data:{name:astUtils.getFunctionNameWithKind(funcInfo.node),arrayMethodName:fullMethodName(funcInfo.arrayMethodName)}});}},"FunctionExpression:exit":checkLastSegment,"ArrowFunctionExpression:exit":checkLastSegment};}};var arrayElementNewline={meta:{type:"layout",docs:{description:"enforce line breaks after each array element",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/array-element-newline"},fixable:"whitespace",schema:{definitions:{basicConfig:{oneOf:[{enum:["always","never","consistent"]},{type:"object",properties:{multiline:{type:"boolean"},minItems:{type:["integer","null"],minimum:0}},additionalProperties:false}]}},items:[{oneOf:[{$ref:"#/definitions/basicConfig"},{type:"object",properties:{ArrayExpression:{$ref:"#/definitions/basicConfig"},ArrayPattern:{$ref:"#/definitions/basicConfig"}},additionalProperties:false,minProperties:1}]}]},messages:{unexpectedLineBreak:"There should be no linebreak here.",missingLineBreak:"There should be a linebreak after this element."}},create(context){const sourceCode=context.getSourceCode();function normalizeOptionValue(providedOption){let consistent=false;let multiline=false;let minItems;const option=providedOption||"always";if(!option||option==="always"||option.minItems===0){minItems=0;}else if(option==="never"){minItems=Number.POSITIVE_INFINITY;}else if(option==="consistent"){consistent=true;minItems=Number.POSITIVE_INFINITY;}else {multiline=Boolean(option.multiline);minItems=option.minItems||Number.POSITIVE_INFINITY;}return {consistent,multiline,minItems};}function normalizeOptions(options){if(options&&(options.ArrayExpression||options.ArrayPattern)){let expressionOptions,patternOptions;if(options.ArrayExpression){expressionOptions=normalizeOptionValue(options.ArrayExpression);}if(options.ArrayPattern){patternOptions=normalizeOptionValue(options.ArrayPattern);}return {ArrayExpression:expressionOptions,ArrayPattern:patternOptions};}const value=normalizeOptionValue(options);return {ArrayExpression:value,ArrayPattern:value};}function reportNoLineBreak(token){const tokenBefore=sourceCode.getTokenBefore(token,{includeComments:true});context.report({loc:{start:tokenBefore.loc.end,end:token.loc.start},messageId:"unexpectedLineBreak",fix(fixer){if(astUtils.isCommentToken(tokenBefore)){return null;}if(!astUtils.isTokenOnSameLine(tokenBefore,token)){return fixer.replaceTextRange([tokenBefore.range[1],token.range[0]]," ");}const twoTokensBefore=sourceCode.getTokenBefore(tokenBefore,{includeComments:true});if(astUtils.isCommentToken(twoTokensBefore)){return null;}return fixer.replaceTextRange([twoTokensBefore.range[1],tokenBefore.range[0]],"");}});}function reportRequiredLineBreak(token){const tokenBefore=sourceCode.getTokenBefore(token,{includeComments:true});context.report({loc:{start:tokenBefore.loc.end,end:token.loc.start},messageId:"missingLineBreak",fix(fixer){return fixer.replaceTextRange([tokenBefore.range[1],token.range[0]],"\n");}});}function check(node){const elements=node.elements;const normalizedOptions=normalizeOptions(context.options[0]);const options=normalizedOptions[node.type];if(!options){return;}let elementBreak=false;if(options.multiline){elementBreak=elements.filter(element=>element!==null).some(element=>element.loc.start.line!==element.loc.end.line);}const linebreaksCount=node.elements.map((element,i)=>{const previousElement=elements[i-1];if(i===0||element===null||previousElement===null){return false;}const commaToken=sourceCode.getFirstTokenBetween(previousElement,element,astUtils.isCommaToken);const lastTokenOfPreviousElement=sourceCode.getTokenBefore(commaToken);const firstTokenOfCurrentElement=sourceCode.getTokenAfter(commaToken);return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement,firstTokenOfCurrentElement);}).filter(isBreak=>isBreak===true).length;const needsLinebreaks=elements.length>=options.minItems||options.multiline&&elementBreak||options.consistent&&linebreaksCount>0&&linebreaksCount<node.elements.length;elements.forEach((element,i)=>{const previousElement=elements[i-1];if(i===0||element===null||previousElement===null){return;}const commaToken=sourceCode.getFirstTokenBetween(previousElement,element,astUtils.isCommaToken);const lastTokenOfPreviousElement=sourceCode.getTokenBefore(commaToken);const firstTokenOfCurrentElement=sourceCode.getTokenAfter(commaToken);if(needsLinebreaks){if(astUtils.isTokenOnSameLine(lastTokenOfPreviousElement,firstTokenOfCurrentElement)){reportRequiredLineBreak(firstTokenOfCurrentElement);}}else {if(!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement,firstTokenOfCurrentElement)){reportNoLineBreak(firstTokenOfCurrentElement);}}});}return {ArrayPattern:check,ArrayExpression:check};}};var arrowBodyStyle={meta:{type:"suggestion",docs:{description:"require braces around arrow function bodies",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/arrow-body-style"},schema:{anyOf:[{type:"array",items:[{enum:["always","never"]}],minItems:0,maxItems:1},{type:"array",items:[{enum:["as-needed"]},{type:"object",properties:{requireReturnForObjectLiteral:{type:"boolean"}},additionalProperties:false}],minItems:0,maxItems:2}]},fixable:"code",messages:{unexpectedOtherBlock:"Unexpected block statement surrounding arrow body.",unexpectedEmptyBlock:"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",unexpectedObjectBlock:"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",unexpectedSingleBlock:"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",expectedBlock:"Expected block statement surrounding arrow body."}},create(context){const options=context.options;const always=options[0]==="always";const asNeeded=!options[0]||options[0]==="as-needed";const never=options[0]==="never";const requireReturnForObjectLiteral=options[1]&&options[1].requireReturnForObjectLiteral;const sourceCode=context.getSourceCode();let funcInfo=null;function hasASIProblem(token){return token&&token.type==="Punctuator"&&/^[([/`+-]/u.test(token.value);}function findClosingParen(token){let node=sourceCode.getNodeByRangeIndex(token.range[0]);while(!astUtils.isParenthesised(sourceCode,node)){node=node.parent;}return sourceCode.getTokenAfter(node);}function isInsideForLoopInitializer(node){if(node&&node.parent){if(node.parent.type==="ForStatement"&&node.parent.init===node){return true;}return isInsideForLoopInitializer(node.parent);}return false;}function validate(node){const arrowBody=node.body;if(arrowBody.type==="BlockStatement"){const blockBody=arrowBody.body;if(blockBody.length!==1&&!never){return;}if(asNeeded&&requireReturnForObjectLiteral&&blockBody[0].type==="ReturnStatement"&&blockBody[0].argument&&blockBody[0].argument.type==="ObjectExpression"){return;}if(never||asNeeded&&blockBody[0].type==="ReturnStatement"){let messageId;if(blockBody.length===0){messageId="unexpectedEmptyBlock";}else if(blockBody.length>1){messageId="unexpectedOtherBlock";}else if(blockBody[0].argument===null){messageId="unexpectedSingleBlock";}else if(astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0],{skip:1}))){messageId="unexpectedObjectBlock";}else {messageId="unexpectedSingleBlock";}context.report({node,loc:arrowBody.loc,messageId,fix(fixer){const fixes=[];if(blockBody.length!==1||blockBody[0].type!=="ReturnStatement"||!blockBody[0].argument||hasASIProblem(sourceCode.getTokenAfter(arrowBody))){return fixes;}const openingBrace=sourceCode.getFirstToken(arrowBody);const closingBrace=sourceCode.getLastToken(arrowBody);const firstValueToken=sourceCode.getFirstToken(blockBody[0],1);const lastValueToken=sourceCode.getLastToken(blockBody[0]);const commentsExist=sourceCode.commentsExistBetween(openingBrace,firstValueToken)||sourceCode.commentsExistBetween(lastValueToken,closingBrace);if(commentsExist){fixes.push(fixer.remove(openingBrace),fixer.remove(closingBrace),fixer.remove(sourceCode.getTokenAfter(openingBrace)));}else {fixes.push(fixer.removeRange([openingBrace.range[0],firstValueToken.range[0]]),fixer.removeRange([lastValueToken.range[1],closingBrace.range[1]]));}if(astUtils.isOpeningBraceToken(firstValueToken)||blockBody[0].argument.type==="SequenceExpression"||funcInfo.hasInOperator&&isInsideForLoopInitializer(node)){if(!astUtils.isParenthesised(sourceCode,blockBody[0].argument)){fixes.push(fixer.insertTextBefore(firstValueToken,"("),fixer.insertTextAfter(lastValueToken,")"));}}if(astUtils.isSemicolonToken(lastValueToken)){fixes.push(fixer.remove(lastValueToken));}return fixes;}});}}else {if(always||asNeeded&&requireReturnForObjectLiteral&&arrowBody.type==="ObjectExpression"){context.report({node,loc:arrowBody.loc,messageId:"expectedBlock",fix(fixer){const fixes=[];const arrowToken=sourceCode.getTokenBefore(arrowBody,astUtils.isArrowToken);const[firstTokenAfterArrow,secondTokenAfterArrow]=sourceCode.getTokensAfter(arrowToken,{count:2});const lastToken=sourceCode.getLastToken(node);const isParenthesisedObjectLiteral=astUtils.isOpeningParenToken(firstTokenAfterArrow)&&astUtils.isOpeningBraceToken(secondTokenAfterArrow);if(isParenthesisedObjectLiteral){const openingParenToken=firstTokenAfterArrow;const openingBraceToken=secondTokenAfterArrow;if(astUtils.isTokenOnSameLine(openingParenToken,openingBraceToken)){fixes.push(fixer.replaceText(openingParenToken,"{return "));}else {fixes.push(fixer.replaceText(openingParenToken,"{"),fixer.insertTextBefore(openingBraceToken,"return "));}fixes.push(fixer.remove(findClosingParen(openingBraceToken)));fixes.push(fixer.insertTextAfter(lastToken,"}"));}else {fixes.push(fixer.insertTextBefore(firstTokenAfterArrow,"{return "));fixes.push(fixer.insertTextAfter(lastToken,"}"));}return fixes;}});}}}return {"BinaryExpression[operator='in']"(){let info=funcInfo;while(info){info.hasInOperator=true;info=info.upper;}},ArrowFunctionExpression(){funcInfo={upper:funcInfo,hasInOperator:false};},"ArrowFunctionExpression:exit"(node){validate(node);funcInfo=funcInfo.upper;}};}};function hasBlockBody(node){return node.body.type==="BlockStatement";}var arrowParens={meta:{type:"layout",docs:{description:"require parentheses around arrow function arguments",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/arrow-parens"},fixable:"code",schema:[{enum:["always","as-needed"]},{type:"object",properties:{requireForBlockBody:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpectedParens:"Unexpected parentheses around single function argument.",expectedParens:"Expected parentheses around arrow function argument.",unexpectedParensInline:"Unexpected parentheses around single function argument having a body with no curly braces.",expectedParensBlock:"Expected parentheses around arrow function argument having a body with curly braces."}},create(context){const asNeeded=context.options[0]==="as-needed";const requireForBlockBody=asNeeded&&context.options[1]&&context.options[1].requireForBlockBody===true;const sourceCode=context.getSourceCode();function findOpeningParenOfParams(node){const tokenBeforeParams=sourceCode.getTokenBefore(node.params[0]);if(tokenBeforeParams&&astUtils.isOpeningParenToken(tokenBeforeParams)&&node.range[0]<=tokenBeforeParams.range[0]){return tokenBeforeParams;}return null;}function getClosingParenOfParams(node){return sourceCode.getTokenAfter(node.params[0],astUtils.isClosingParenToken);}function hasCommentsInParensOfParams(node,openingParen){return sourceCode.commentsExistBetween(openingParen,getClosingParenOfParams(node));}function hasUnexpectedTokensBeforeOpeningParen(node,openingParen){const expectedCount=node.async?1:0;return sourceCode.getFirstToken(node,{skip:expectedCount})!==openingParen;}return {"ArrowFunctionExpression[params.length=1]"(node){const shouldHaveParens=!asNeeded||requireForBlockBody&&hasBlockBody(node);const openingParen=findOpeningParenOfParams(node);const hasParens=openingParen!==null;const[param]=node.params;if(shouldHaveParens&&!hasParens){context.report({node,messageId:requireForBlockBody?"expectedParensBlock":"expectedParens",loc:param.loc,*fix(fixer){yield fixer.insertTextBefore(param,"(");yield fixer.insertTextAfter(param,")");}});}if(!shouldHaveParens&&hasParens&&param.type==="Identifier"&&!param.typeAnnotation&&!node.returnType&&!hasCommentsInParensOfParams(node,openingParen)&&!hasUnexpectedTokensBeforeOpeningParen(node,openingParen)){context.report({node,messageId:requireForBlockBody?"unexpectedParensInline":"unexpectedParens",loc:param.loc,*fix(fixer){const tokenBeforeOpeningParen=sourceCode.getTokenBefore(openingParen);const closingParen=getClosingParenOfParams(node);if(tokenBeforeOpeningParen&&tokenBeforeOpeningParen.range[1]===openingParen.range[0]&&!astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen,sourceCode.getFirstToken(param))){yield fixer.insertTextBefore(openingParen," ");}yield fixer.removeRange([openingParen.range[0],param.range[0]]);yield fixer.removeRange([param.range[1],closingParen.range[1]]);}});}}};}};var arrowSpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing before and after the arrow in arrow functions",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/arrow-spacing"},fixable:"whitespace",schema:[{type:"object",properties:{before:{type:"boolean",default:true},after:{type:"boolean",default:true}},additionalProperties:false}],messages:{expectedBefore:"Missing space before =>.",unexpectedBefore:"Unexpected space before =>.",expectedAfter:"Missing space after =>.",unexpectedAfter:"Unexpected space after =>."}},create(context){const rule=Object.assign({},context.options[0]);rule.before=rule.before!==false;rule.after=rule.after!==false;const sourceCode=context.getSourceCode();function getTokens(node){const arrow=sourceCode.getTokenBefore(node.body,astUtils.isArrowToken);return {before:sourceCode.getTokenBefore(arrow),arrow,after:sourceCode.getTokenAfter(arrow)};}function countSpaces(tokens){const before=tokens.arrow.range[0]-tokens.before.range[1];const after=tokens.after.range[0]-tokens.arrow.range[1];return {before,after};}return {ArrowFunctionExpression:function(node){const tokens=getTokens(node);const countSpace=countSpaces(tokens);if(rule.before){if(countSpace.before===0){context.report({node:tokens.before,messageId:"expectedBefore",fix(fixer){return fixer.insertTextBefore(tokens.arrow," ");}});}}else {if(countSpace.before>0){context.report({node:tokens.before,messageId:"unexpectedBefore",fix(fixer){return fixer.removeRange([tokens.before.range[1],tokens.arrow.range[0]]);}});}}if(rule.after){if(countSpace.after===0){context.report({node:tokens.after,messageId:"expectedAfter",fix(fixer){return fixer.insertTextAfter(tokens.arrow," ");}});}}else {if(countSpace.after>0){context.report({node:tokens.after,messageId:"unexpectedAfter",fix(fixer){return fixer.removeRange([tokens.arrow.range[1],tokens.after.range[0]]);}});}}}};}};var blockScopedVar={meta:{type:"suggestion",docs:{description:"enforce the use of variables within the scope they are defined",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/block-scoped-var"},schema:[],messages:{outOfScope:"'{{name}}' used outside of binding context."}},create(context){let stack=[];function enterScope(node){stack.push(node.range);}function exitScope(){stack.pop();}function report(reference){const identifier=reference.identifier;context.report({node:identifier,messageId:"outOfScope",data:{name:identifier.name}});}function checkForVariables(node){if(node.kind!=="var"){return;}const scopeRange=stack[stack.length-1];function isOutsideOfScope(reference){const idRange=reference.identifier.range;return idRange[0]<scopeRange[0]||idRange[1]>scopeRange[1];}const variables=context.getDeclaredVariables(node);for(let i=0;i<variables.length;++i){variables[i].references.filter(isOutsideOfScope).forEach(report);}}return {Program(node){stack=[node.range];},BlockStatement:enterScope,"BlockStatement:exit":exitScope,ForStatement:enterScope,"ForStatement:exit":exitScope,ForInStatement:enterScope,"ForInStatement:exit":exitScope,ForOfStatement:enterScope,"ForOfStatement:exit":exitScope,SwitchStatement:enterScope,"SwitchStatement:exit":exitScope,CatchClause:enterScope,"CatchClause:exit":exitScope,VariableDeclaration:checkForVariables};}};var blockSpacing={meta:{type:"layout",docs:{description:"disallow or enforce spaces inside of blocks after opening block and before closing block",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/block-spacing"},fixable:"whitespace",schema:[{enum:["always","never"]}],messages:{missing:"Requires a space {{location}} '{{token}}'.",extra:"Unexpected space(s) {{location}} '{{token}}'."}},create(context){const always=context.options[0]!=="never",messageId=always?"missing":"extra",sourceCode=context.getSourceCode();function getOpenBrace(node){if(node.type==="SwitchStatement"){if(node.cases.length>0){return sourceCode.getTokenBefore(node.cases[0]);}return sourceCode.getLastToken(node,1);}return sourceCode.getFirstToken(node);}function isValid(left,right){return !astUtils.isTokenOnSameLine(left,right)||sourceCode.isSpaceBetweenTokens(left,right)===always;}function checkSpacingInsideBraces(node){const openBrace=getOpenBrace(node);const closeBrace=sourceCode.getLastToken(node);const firstToken=sourceCode.getTokenAfter(openBrace,{includeComments:true});const lastToken=sourceCode.getTokenBefore(closeBrace,{includeComments:true});if(openBrace.type!=="Punctuator"||openBrace.value!=="{"||closeBrace.type!=="Punctuator"||closeBrace.value!=="}"||firstToken===closeBrace){return;}if(!always&&firstToken.type==="Line"){return;}if(!isValid(openBrace,firstToken)){let loc=openBrace.loc;if(messageId==="extra"){loc={start:openBrace.loc.end,end:firstToken.loc.start};}context.report({node,loc,messageId,data:{location:"after",token:openBrace.value},fix(fixer){if(always){return fixer.insertTextBefore(firstToken," ");}return fixer.removeRange([openBrace.range[1],firstToken.range[0]]);}});}if(!isValid(lastToken,closeBrace)){let loc=closeBrace.loc;if(messageId==="extra"){loc={start:lastToken.loc.end,end:closeBrace.loc.start};}context.report({node,loc,messageId,data:{location:"before",token:closeBrace.value},fix(fixer){if(always){return fixer.insertTextAfter(lastToken," ");}return fixer.removeRange([lastToken.range[1],closeBrace.range[0]]);}});}}return {BlockStatement:checkSpacingInsideBraces,SwitchStatement:checkSpacingInsideBraces};}};var braceStyle={meta:{type:"layout",docs:{description:"enforce consistent brace style for blocks",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/brace-style"},schema:[{enum:["1tbs","stroustrup","allman"]},{type:"object",properties:{allowSingleLine:{type:"boolean",default:false}},additionalProperties:false}],fixable:"whitespace",messages:{nextLineOpen:"Opening curly brace does not appear on the same line as controlling statement.",sameLineOpen:"Opening curly brace appears on the same line as controlling statement.",blockSameLine:"Statement inside of curly braces should be on next line.",nextLineClose:"Closing curly brace does not appear on the same line as the subsequent block.",singleLineClose:"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",sameLineClose:"Closing curly brace appears on the same line as the subsequent block."}},create(context){const style=context.options[0]||"1tbs",params=context.options[1]||{},sourceCode=context.getSourceCode();function removeNewlineBetween(firstToken,secondToken){const textRange=[firstToken.range[1],secondToken.range[0]];const textBetween=sourceCode.text.slice(textRange[0],textRange[1]);if(textBetween.trim()){return null;}return fixer=>fixer.replaceTextRange(textRange," ");}function validateCurlyPair(openingCurly,closingCurly){const tokenBeforeOpeningCurly=sourceCode.getTokenBefore(openingCurly);const tokenAfterOpeningCurly=sourceCode.getTokenAfter(openingCurly);const tokenBeforeClosingCurly=sourceCode.getTokenBefore(closingCurly);const singleLineException=params.allowSingleLine&&astUtils.isTokenOnSameLine(openingCurly,closingCurly);if(style!=="allman"&&!astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly,openingCurly)){context.report({node:openingCurly,messageId:"nextLineOpen",fix:removeNewlineBetween(tokenBeforeOpeningCurly,openingCurly)});}if(style==="allman"&&astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly,openingCurly)&&!singleLineException){context.report({node:openingCurly,messageId:"sameLineOpen",fix:fixer=>fixer.insertTextBefore(openingCurly,"\n")});}if(astUtils.isTokenOnSameLine(openingCurly,tokenAfterOpeningCurly)&&tokenAfterOpeningCurly!==closingCurly&&!singleLineException){context.report({node:openingCurly,messageId:"blockSameLine",fix:fixer=>fixer.insertTextAfter(openingCurly,"\n")});}if(tokenBeforeClosingCurly!==openingCurly&&!singleLineException&&astUtils.isTokenOnSameLine(tokenBeforeClosingCurly,closingCurly)){context.report({node:closingCurly,messageId:"singleLineClose",fix:fixer=>fixer.insertTextBefore(closingCurly,"\n")});}}function validateCurlyBeforeKeyword(curlyToken){const keywordToken=sourceCode.getTokenAfter(curlyToken);if(style==="1tbs"&&!astUtils.isTokenOnSameLine(curlyToken,keywordToken)){context.report({node:curlyToken,messageId:"nextLineClose",fix:removeNewlineBetween(curlyToken,keywordToken)});}if(style!=="1tbs"&&astUtils.isTokenOnSameLine(curlyToken,keywordToken)){context.report({node:curlyToken,messageId:"sameLineClose",fix:fixer=>fixer.insertTextAfter(curlyToken,"\n")});}}return {BlockStatement(node){if(!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)){validateCurlyPair(sourceCode.getFirstToken(node),sourceCode.getLastToken(node));}},ClassBody(node){validateCurlyPair(sourceCode.getFirstToken(node),sourceCode.getLastToken(node));},SwitchStatement(node){const closingCurly=sourceCode.getLastToken(node);const openingCurly=sourceCode.getTokenBefore(node.cases.length?node.cases[0]:closingCurly);validateCurlyPair(openingCurly,closingCurly);},IfStatement(node){if(node.consequent.type==="BlockStatement"&&node.alternate){validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));}},TryStatement(node){validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));if(node.handler&&node.finalizer){validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));}}};}};var callbackReturn={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"require `return` statements after callbacks",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/callback-return"},schema:[{type:"array",items:{type:"string"}}],messages:{missingReturn:"Expected return with your callback function."}},create(context){const callbacks=context.options[0]||["callback","cb","next"],sourceCode=context.getSourceCode();function findClosestParentOfType(node,types){if(!node.parent){return null;}if(types.indexOf(node.parent.type)===-1){return findClosestParentOfType(node.parent,types);}return node.parent;}function containsOnlyIdentifiers(node){if(node.type==="Identifier"){return true;}if(node.type==="MemberExpression"){if(node.object.type==="Identifier"){return true;}if(node.object.type==="MemberExpression"){return containsOnlyIdentifiers(node.object);}}return false;}function isCallback(node){return containsOnlyIdentifiers(node.callee)&&callbacks.indexOf(sourceCode.getText(node.callee))>-1;}function isCallbackExpression(node,parentNode){if(!parentNode||parentNode.type!=="ExpressionStatement"){return false;}if(parentNode.expression===node){return true;}if(parentNode.expression.type==="BinaryExpression"||parentNode.expression.type==="LogicalExpression"){if(parentNode.expression.right===node){return true;}}return false;}return {CallExpression(node){if(!isCallback(node)){return;}const closestBlock=findClosestParentOfType(node,["BlockStatement","ReturnStatement","ArrowFunctionExpression"])||{};if(closestBlock.type==="ReturnStatement"){return;}if(closestBlock.type==="ArrowFunctionExpression"){return;}if(closestBlock.type==="BlockStatement"){const lastItem=closestBlock.body[closestBlock.body.length-1];if(isCallbackExpression(node,lastItem)){const parentType=closestBlock.parent.type;if(parentType==="FunctionExpression"||parentType==="FunctionDeclaration"||parentType==="ArrowFunctionExpression"){return;}}if(lastItem.type==="ReturnStatement"){if(isCallbackExpression(node,closestBlock.body[closestBlock.body.length-2])){return;}}}if(findClosestParentOfType(node,["FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"])){context.report({node,messageId:"missingReturn"});}}};}};var camelcase={meta:{type:"suggestion",docs:{description:"enforce camelcase naming convention",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/camelcase"},schema:[{type:"object",properties:{ignoreDestructuring:{type:"boolean",default:false},ignoreImports:{type:"boolean",default:false},ignoreGlobals:{type:"boolean",default:false},properties:{enum:["always","never"]},allow:{type:"array",items:[{type:"string"}],minItems:0,uniqueItems:true}},additionalProperties:false}],messages:{notCamelCase:"Identifier '{{name}}' is not in camel case."}},create(context){const options=context.options[0]||{};let properties=options.properties||"";const ignoreDestructuring=options.ignoreDestructuring;const ignoreImports=options.ignoreImports;const ignoreGlobals=options.ignoreGlobals;const allow=options.allow||[];let globalScope;if(properties!=="always"&&properties!=="never"){properties="always";}const reported=[];const ALLOWED_PARENT_TYPES=new Set(["CallExpression","NewExpression"]);function isUnderscored(name){return name.includes("_")&&name!==name.toUpperCase();}function isAllowed(name){return allow.some(entry=>name===entry||name.match(new RegExp(entry,"u")));}function isInsideObjectPattern(node){let current=node;while(current){const parent=current.parent;if(parent&&parent.type==="Property"&&parent.computed&&parent.key===current){return false;}if(current.type==="ObjectPattern"){return true;}current=parent;}return false;}function isAssignmentTargetPropertyInDestructuring(node){if(node.parent.type==="MemberExpression"&&node.parent.property===node&&!node.parent.computed){const effectiveParent=node.parent.parent;return effectiveParent.type==="Property"&&effectiveParent.value===node.parent&&effectiveParent.parent.type==="ObjectPattern"||effectiveParent.type==="ArrayPattern"||effectiveParent.type==="RestElement"||effectiveParent.type==="AssignmentPattern"&&effectiveParent.left===node.parent;}return false;}function isReferenceToGlobalVariable(node){const variable=globalScope.set.get(node.name);return variable&&variable.defs.length===0&&variable.references.some(ref=>ref.identifier===node);}function isPropertyNameInObjectLiteral(node){const parent=node.parent;return parent.type==="Property"&&parent.parent.type==="ObjectExpression"&&!parent.computed&&parent.key===node;}function report(node){if(!reported.includes(node)){reported.push(node);context.report({node,messageId:"notCamelCase",data:{name:node.name}});}}return {Program(){globalScope=context.getScope();},Identifier(node){const name=node.name,nameIsUnderscored=isUnderscored(name.replace(/^_+|_+$/gu,"")),effectiveParent=node.parent.type==="MemberExpression"?node.parent.parent:node.parent;if(isAllowed(name)){return;}if(ignoreGlobals&&isReferenceToGlobalVariable(node)&&!isPropertyNameInObjectLiteral(node)){return;}if(node.parent.type==="MemberExpression"){if(properties==="never"){return;}if(node.parent.object.type==="Identifier"&&node.parent.object.name===node.name&&nameIsUnderscored){report(node);}else if(effectiveParent.type==="AssignmentExpression"&&nameIsUnderscored&&(effectiveParent.right.type!=="MemberExpression"||effectiveParent.left.type==="MemberExpression"&&effectiveParent.left.property.name===node.name)){report(node);}else if(isAssignmentTargetPropertyInDestructuring(node)&&nameIsUnderscored){report(node);}}else if(node.parent.type==="Property"||node.parent.type==="AssignmentPattern"){if(node.parent.parent&&node.parent.parent.type==="ObjectPattern"){if(node.parent.shorthand&&node.parent.value.left&&nameIsUnderscored){report(node);}const assignmentKeyEqualsValue=node.parent.key.name===node.parent.value.name;if(nameIsUnderscored&&node.parent.computed){report(node);}if(node.parent.key===node&&node.parent.value!==node){return;}const valueIsUnderscored=node.parent.value.name&&nameIsUnderscored;if(valueIsUnderscored&&!(assignmentKeyEqualsValue&&ignoreDestructuring)){report(node);}}if(properties==="never"||ignoreDestructuring&&isInsideObjectPattern(node)){return;}if(nameIsUnderscored&&!ALLOWED_PARENT_TYPES.has(effectiveParent.type)&&!(node.parent.right===node)){report(node);}}else if(["ImportSpecifier","ImportNamespaceSpecifier","ImportDefaultSpecifier"].includes(node.parent.type)){if(node.parent.type==="ImportSpecifier"&&ignoreImports){return;}if(node.parent.local&&node.parent.local.name===node.name&&nameIsUnderscored){report(node);}}else if(nameIsUnderscored&&!ALLOWED_PARENT_TYPES.has(effectiveParent.type)){report(node);}}};}};/**
 * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
 * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
 * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
 * @author Kevin Partington
 * @license MIT License (from JSCS). See below.
 */var letters=/[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/u;const DEFAULT_IGNORE_PATTERN=astUtils.COMMENTS_IGNORE_PATTERN,WHITESPACE=/\s/gu,MAYBE_URL=/^\s*[^:/?#\s]+:\/\/[^?#]/u;const SCHEMA_BODY={type:"object",properties:{ignorePattern:{type:"string"},ignoreInlineComments:{type:"boolean"},ignoreConsecutiveComments:{type:"boolean"}},additionalProperties:false};const DEFAULTS={ignorePattern:"",ignoreInlineComments:false,ignoreConsecutiveComments:false};function getNormalizedOptions(rawOptions,which){return Object.assign({},DEFAULTS,rawOptions[which]||rawOptions);}function getAllNormalizedOptions(rawOptions={}){return {Line:getNormalizedOptions(rawOptions,"line"),Block:getNormalizedOptions(rawOptions,"block")};}function createRegExpForIgnorePatterns(normalizedOptions){Object.keys(normalizedOptions).forEach(key=>{const ignorePatternStr=normalizedOptions[key].ignorePattern;if(ignorePatternStr){const regExp=RegExp(`^\\s*(?:${ignorePatternStr})`,"u");normalizedOptions[key].ignorePatternRegExp=regExp;}});}var capitalizedComments={meta:{type:"suggestion",docs:{description:"enforce or disallow capitalization of the first letter of a comment",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/capitalized-comments"},fixable:"code",schema:[{enum:["always","never"]},{oneOf:[SCHEMA_BODY,{type:"object",properties:{line:SCHEMA_BODY,block:SCHEMA_BODY},additionalProperties:false}]}],messages:{unexpectedLowercaseComment:"Comments should not begin with a lowercase character.",unexpectedUppercaseComment:"Comments should not begin with an uppercase character."}},create(context){const capitalize=context.options[0]||"always",normalizedOptions=getAllNormalizedOptions(context.options[1]),sourceCode=context.getSourceCode();createRegExpForIgnorePatterns(normalizedOptions);function isInlineComment(comment){const previousToken=sourceCode.getTokenBefore(comment,{includeComments:true}),nextToken=sourceCode.getTokenAfter(comment,{includeComments:true});return Boolean(previousToken&&nextToken&&comment.loc.start.line===previousToken.loc.end.line&&comment.loc.end.line===nextToken.loc.start.line);}function isConsecutiveComment(comment){const previousTokenOrComment=sourceCode.getTokenBefore(comment,{includeComments:true});return Boolean(previousTokenOrComment&&["Block","Line"].indexOf(previousTokenOrComment.type)!==-1);}function isCommentValid(comment,options){if(DEFAULT_IGNORE_PATTERN.test(comment.value)){return true;}const commentWithoutAsterisks=comment.value.replace(/\*/gu,"");if(options.ignorePatternRegExp&&options.ignorePatternRegExp.test(commentWithoutAsterisks)){return true;}if(options.ignoreInlineComments&&isInlineComment(comment)){return true;}if(options.ignoreConsecutiveComments&&isConsecutiveComment(comment)){return true;}if(MAYBE_URL.test(commentWithoutAsterisks)){return true;}const commentWordCharsOnly=commentWithoutAsterisks.replace(WHITESPACE,"");if(commentWordCharsOnly.length===0){return true;}const firstWordChar=commentWordCharsOnly[0];if(!letters.test(firstWordChar)){return true;}const isUppercase=firstWordChar!==firstWordChar.toLocaleLowerCase(),isLowercase=firstWordChar!==firstWordChar.toLocaleUpperCase();if(capitalize==="always"&&isLowercase){return false;}if(capitalize==="never"&&isUppercase){return false;}return true;}function processComment(comment){const options=normalizedOptions[comment.type],commentValid=isCommentValid(comment,options);if(!commentValid){const messageId=capitalize==="always"?"unexpectedLowercaseComment":"unexpectedUppercaseComment";context.report({node:null,loc:comment.loc,messageId,fix(fixer){const match=comment.value.match(letters);return fixer.replaceTextRange([comment.range[0]+match.index+2,comment.range[0]+match.index+3],capitalize==="always"?match[0].toLocaleUpperCase():match[0].toLocaleLowerCase());}});}}return {Program(){const comments=sourceCode.getAllComments();comments.filter(token=>token.type!=="Shebang").forEach(processComment);}};}};var classMethodsUseThis={meta:{type:"suggestion",docs:{description:"enforce that class methods utilize `this`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/class-methods-use-this"},schema:[{type:"object",properties:{exceptMethods:{type:"array",items:{type:"string"}}},additionalProperties:false}],messages:{missingThis:"Expected 'this' to be used by class {{name}}."}},create(context){const config=Object.assign({},context.options[0]);const exceptMethods=new Set(config.exceptMethods||[]);const stack=[];function enterFunction(){stack.push(false);}function isInstanceMethod(node){return !node.static&&node.kind!=="constructor"&&node.type==="MethodDefinition";}function isIncludedInstanceMethod(node){return isInstanceMethod(node)&&(node.computed||!exceptMethods.has(node.key.name));}function exitFunction(node){const methodUsesThis=stack.pop();if(isIncludedInstanceMethod(node.parent)&&!methodUsesThis){context.report({node,messageId:"missingThis",data:{name:astUtils.getFunctionNameWithKind(node)}});}}function markThisUsed(){if(stack.length){stack[stack.length-1]=true;}}return {FunctionDeclaration:enterFunction,"FunctionDeclaration:exit":exitFunction,FunctionExpression:enterFunction,"FunctionExpression:exit":exitFunction,ThisExpression:markThisUsed,Super:markThisUsed};}};const DEFAULT_OPTIONS$1=Object.freeze({arrays:"never",objects:"never",imports:"never",exports:"never",functions:"never"});function isTrailingCommaAllowed(lastItem){return !(lastItem.type==="RestElement"||lastItem.type==="RestProperty"||lastItem.type==="ExperimentalRestProperty");}function normalizeOptions$2(optionValue,ecmaVersion){if(typeof optionValue==="string"){return {arrays:optionValue,objects:optionValue,imports:optionValue,exports:optionValue,functions:!ecmaVersion||ecmaVersion<8?"ignore":optionValue};}if(typeof optionValue==="object"&&optionValue!==null){return {arrays:optionValue.arrays||DEFAULT_OPTIONS$1.arrays,objects:optionValue.objects||DEFAULT_OPTIONS$1.objects,imports:optionValue.imports||DEFAULT_OPTIONS$1.imports,exports:optionValue.exports||DEFAULT_OPTIONS$1.exports,functions:optionValue.functions||DEFAULT_OPTIONS$1.functions};}return DEFAULT_OPTIONS$1;}var commaDangle={meta:{type:"layout",docs:{description:"require or disallow trailing commas",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/comma-dangle"},fixable:"code",schema:{definitions:{value:{enum:["always-multiline","always","never","only-multiline"]},valueWithIgnore:{enum:["always-multiline","always","ignore","never","only-multiline"]}},type:"array",items:[{oneOf:[{$ref:"#/definitions/value"},{type:"object",properties:{arrays:{$ref:"#/definitions/valueWithIgnore"},objects:{$ref:"#/definitions/valueWithIgnore"},imports:{$ref:"#/definitions/valueWithIgnore"},exports:{$ref:"#/definitions/valueWithIgnore"},functions:{$ref:"#/definitions/valueWithIgnore"}},additionalProperties:false}]}]},messages:{unexpected:"Unexpected trailing comma.",missing:"Missing trailing comma."}},create(context){const options=normalizeOptions$2(context.options[0],context.parserOptions.ecmaVersion);const sourceCode=context.getSourceCode();function getLastItem(node){switch(node.type){case"ObjectExpression":case"ObjectPattern":return lodash__default['default'].last(node.properties);case"ArrayExpression":case"ArrayPattern":return lodash__default['default'].last(node.elements);case"ImportDeclaration":case"ExportNamedDeclaration":return lodash__default['default'].last(node.specifiers);case"FunctionDeclaration":case"FunctionExpression":case"ArrowFunctionExpression":return lodash__default['default'].last(node.params);case"CallExpression":case"NewExpression":return lodash__default['default'].last(node.arguments);default:return null;}}function getTrailingToken(node,lastItem){switch(node.type){case"ObjectExpression":case"ArrayExpression":case"CallExpression":case"NewExpression":return sourceCode.getLastToken(node,1);default:{const nextToken=sourceCode.getTokenAfter(lastItem);if(astUtils.isCommaToken(nextToken)){return nextToken;}return sourceCode.getLastToken(lastItem);}}}function isMultiline(node){const lastItem=getLastItem(node);if(!lastItem){return false;}const penultimateToken=getTrailingToken(node,lastItem);const lastToken=sourceCode.getTokenAfter(penultimateToken);return lastToken.loc.end.line!==penultimateToken.loc.end.line;}function forbidTrailingComma(node){const lastItem=getLastItem(node);if(!lastItem||node.type==="ImportDeclaration"&&lastItem.type!=="ImportSpecifier"){return;}const trailingToken=getTrailingToken(node,lastItem);if(astUtils.isCommaToken(trailingToken)){context.report({node:lastItem,loc:trailingToken.loc,messageId:"unexpected",fix(fixer){return fixer.remove(trailingToken);}});}}function forceTrailingComma(node){const lastItem=getLastItem(node);if(!lastItem||node.type==="ImportDeclaration"&&lastItem.type!=="ImportSpecifier"){return;}if(!isTrailingCommaAllowed(lastItem)){forbidTrailingComma(node);return;}const trailingToken=getTrailingToken(node,lastItem);if(trailingToken.value!==","){context.report({node:lastItem,loc:{start:trailingToken.loc.end,end:astUtils.getNextLocation(sourceCode,trailingToken.loc.end)},messageId:"missing",fix(fixer){return fixer.insertTextAfter(trailingToken,",");}});}}const predicate={always:forceTrailingComma,"always-multiline":function(node){if(isMultiline(node)){forceTrailingComma(node);}else {forbidTrailingComma(node);}},"only-multiline":function(node){if(!isMultiline(node)){forbidTrailingComma(node);}},never:forbidTrailingComma,ignore:lodash__default['default'].noop};return {ObjectExpression:predicate[options.objects],ObjectPattern:predicate[options.objects],ArrayExpression:predicate[options.arrays],ArrayPattern:predicate[options.arrays],ImportDeclaration:predicate[options.imports],ExportNamedDeclaration:predicate[options.exports],FunctionDeclaration:predicate[options.functions],FunctionExpression:predicate[options.functions],ArrowFunctionExpression:predicate[options.functions],CallExpression:predicate[options.functions],NewExpression:predicate[options.functions]};}};var commaSpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing before and after commas",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/comma-spacing"},fixable:"whitespace",schema:[{type:"object",properties:{before:{type:"boolean",default:false},after:{type:"boolean",default:true}},additionalProperties:false}],messages:{missing:"A space is required {{loc}} ','.",unexpected:"There should be no space {{loc}} ','."}},create(context){const sourceCode=context.getSourceCode();const tokensAndComments=sourceCode.tokensAndComments;const options={before:context.options[0]?context.options[0].before:false,after:context.options[0]?context.options[0].after:true};const commaTokensToIgnore=[];function report(node,loc,otherNode){context.report({node,fix(fixer){if(options[loc]){if(loc==="before"){return fixer.insertTextBefore(node," ");}return fixer.insertTextAfter(node," ");}let start,end;if(loc==="before"){start=otherNode.range[1];end=node.range[0];}else {start=node.range[1];end=otherNode.range[0];}return fixer.replaceTextRange([start,end],"");},messageId:options[loc]?"missing":"unexpected",data:{loc}});}function validateCommaItemSpacing(tokens,reportItem){if(tokens.left&&astUtils.isTokenOnSameLine(tokens.left,tokens.comma)&&options.before!==sourceCode.isSpaceBetweenTokens(tokens.left,tokens.comma)){report(reportItem,"before",tokens.left);}if(tokens.right&&astUtils.isClosingParenToken(tokens.right)){return;}if(tokens.right&&!options.after&&tokens.right.type==="Line"){return;}if(tokens.right&&astUtils.isTokenOnSameLine(tokens.comma,tokens.right)&&options.after!==sourceCode.isSpaceBetweenTokens(tokens.comma,tokens.right)){report(reportItem,"after",tokens.right);}}function addNullElementsToIgnoreList(node){let previousToken=sourceCode.getFirstToken(node);node.elements.forEach(element=>{let token;if(element===null){token=sourceCode.getTokenAfter(previousToken);if(astUtils.isCommaToken(token)){commaTokensToIgnore.push(token);}}else {token=sourceCode.getTokenAfter(element);}previousToken=token;});}return {"Program:exit"(){tokensAndComments.forEach((token,i)=>{if(!astUtils.isCommaToken(token)){return;}if(token&&token.type==="JSXText"){return;}const previousToken=tokensAndComments[i-1];const nextToken=tokensAndComments[i+1];validateCommaItemSpacing({comma:token,left:astUtils.isCommaToken(previousToken)||commaTokensToIgnore.indexOf(token)>-1?null:previousToken,right:astUtils.isCommaToken(nextToken)?null:nextToken},token);});},ArrayExpression:addNullElementsToIgnoreList,ArrayPattern:addNullElementsToIgnoreList};}};var commaStyle={meta:{type:"layout",docs:{description:"enforce consistent comma style",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/comma-style"},fixable:"code",schema:[{enum:["first","last"]},{type:"object",properties:{exceptions:{type:"object",additionalProperties:{type:"boolean"}}},additionalProperties:false}],messages:{unexpectedLineBeforeAndAfterComma:"Bad line breaking before and after ','.",expectedCommaFirst:"',' should be placed first.",expectedCommaLast:"',' should be placed last."}},create(context){const style=context.options[0]||"last",sourceCode=context.getSourceCode();const exceptions={ArrayPattern:true,ArrowFunctionExpression:true,CallExpression:true,FunctionDeclaration:true,FunctionExpression:true,ImportDeclaration:true,ObjectPattern:true,NewExpression:true};if(context.options.length===2&&Object.prototype.hasOwnProperty.call(context.options[1],"exceptions")){const keys=Object.keys(context.options[1].exceptions);for(let i=0;i<keys.length;i++){exceptions[keys[i]]=context.options[1].exceptions[keys[i]];}}function getReplacedText(styleType,text){switch(styleType){case"between":return `,${text.replace(astUtils.LINEBREAK_MATCHER,"")}`;case"first":return `${text},`;case"last":return `,${text}`;default:return "";}}function getFixerFunction(styleType,previousItemToken,commaToken,currentItemToken){const text=sourceCode.text.slice(previousItemToken.range[1],commaToken.range[0])+sourceCode.text.slice(commaToken.range[1],currentItemToken.range[0]);const range=[previousItemToken.range[1],currentItemToken.range[0]];return function(fixer){return fixer.replaceTextRange(range,getReplacedText(styleType,text));};}function validateCommaItemSpacing(previousItemToken,commaToken,currentItemToken,reportItem){if(astUtils.isTokenOnSameLine(commaToken,currentItemToken)&&astUtils.isTokenOnSameLine(previousItemToken,commaToken));else if(!astUtils.isTokenOnSameLine(commaToken,currentItemToken)&&!astUtils.isTokenOnSameLine(previousItemToken,commaToken)){const comment=sourceCode.getCommentsAfter(commaToken)[0];const styleType=comment&&comment.type==="Block"&&astUtils.isTokenOnSameLine(commaToken,comment)?style:"between";context.report({node:reportItem,loc:commaToken.loc,messageId:"unexpectedLineBeforeAndAfterComma",fix:getFixerFunction(styleType,previousItemToken,commaToken,currentItemToken)});}else if(style==="first"&&!astUtils.isTokenOnSameLine(commaToken,currentItemToken)){context.report({node:reportItem,loc:commaToken.loc,messageId:"expectedCommaFirst",fix:getFixerFunction(style,previousItemToken,commaToken,currentItemToken)});}else if(style==="last"&&astUtils.isTokenOnSameLine(commaToken,currentItemToken)){context.report({node:reportItem,loc:commaToken.loc,messageId:"expectedCommaLast",fix:getFixerFunction(style,previousItemToken,commaToken,currentItemToken)});}}function validateComma(node,property){const items=node[property],arrayLiteral=node.type==="ArrayExpression"||node.type==="ArrayPattern";if(items.length>1||arrayLiteral){let previousItemToken=sourceCode.getFirstToken(node);items.forEach(item=>{const commaToken=item?sourceCode.getTokenBefore(item):previousItemToken,currentItemToken=item?sourceCode.getFirstToken(item):sourceCode.getTokenAfter(commaToken);if(astUtils.isCommaToken(commaToken)){validateCommaItemSpacing(previousItemToken,commaToken,currentItemToken,item||currentItemToken);}if(item){const tokenAfterItem=sourceCode.getTokenAfter(item,astUtils.isNotClosingParenToken);previousItemToken=tokenAfterItem?sourceCode.getTokenBefore(tokenAfterItem):sourceCode.ast.tokens[sourceCode.ast.tokens.length-1];}});if(arrayLiteral){const lastToken=sourceCode.getLastToken(node),nextToLastToken=sourceCode.getTokenBefore(lastToken);if(astUtils.isCommaToken(nextToLastToken)){validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken),nextToLastToken,lastToken,lastToken);}}}}const nodes={};if(!exceptions.VariableDeclaration){nodes.VariableDeclaration=function(node){validateComma(node,"declarations");};}if(!exceptions.ObjectExpression){nodes.ObjectExpression=function(node){validateComma(node,"properties");};}if(!exceptions.ObjectPattern){nodes.ObjectPattern=function(node){validateComma(node,"properties");};}if(!exceptions.ArrayExpression){nodes.ArrayExpression=function(node){validateComma(node,"elements");};}if(!exceptions.ArrayPattern){nodes.ArrayPattern=function(node){validateComma(node,"elements");};}if(!exceptions.FunctionDeclaration){nodes.FunctionDeclaration=function(node){validateComma(node,"params");};}if(!exceptions.FunctionExpression){nodes.FunctionExpression=function(node){validateComma(node,"params");};}if(!exceptions.ArrowFunctionExpression){nodes.ArrowFunctionExpression=function(node){validateComma(node,"params");};}if(!exceptions.CallExpression){nodes.CallExpression=function(node){validateComma(node,"arguments");};}if(!exceptions.ImportDeclaration){nodes.ImportDeclaration=function(node){validateComma(node,"specifiers");};}if(!exceptions.NewExpression){nodes.NewExpression=function(node){validateComma(node,"arguments");};}return nodes;}};var complexity={meta:{type:"suggestion",docs:{description:"enforce a maximum cyclomatic complexity allowed in a program",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/complexity"},schema:[{oneOf:[{type:"integer",minimum:0},{type:"object",properties:{maximum:{type:"integer",minimum:0},max:{type:"integer",minimum:0}},additionalProperties:false}]}],messages:{complex:"{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}."}},create(context){const option=context.options[0];let THRESHOLD=20;if(typeof option==="object"&&(Object.prototype.hasOwnProperty.call(option,"maximum")||Object.prototype.hasOwnProperty.call(option,"max"))){THRESHOLD=option.maximum||option.max;}else if(typeof option==="number"){THRESHOLD=option;}const fns=[];function startFunction(){fns.push(1);}function endFunction(node){const name=lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(node));const complexity=fns.pop();if(complexity>THRESHOLD){context.report({node,messageId:"complex",data:{name,complexity,max:THRESHOLD}});}}function increaseComplexity(){if(fns.length){fns[fns.length-1]++;}}return {FunctionDeclaration:startFunction,FunctionExpression:startFunction,ArrowFunctionExpression:startFunction,"FunctionDeclaration:exit":endFunction,"FunctionExpression:exit":endFunction,"ArrowFunctionExpression:exit":endFunction,CatchClause:increaseComplexity,ConditionalExpression:increaseComplexity,LogicalExpression:increaseComplexity,ForStatement:increaseComplexity,ForInStatement:increaseComplexity,ForOfStatement:increaseComplexity,IfStatement:increaseComplexity,SwitchCase:function(node){if(node.test){increaseComplexity();}},WhileStatement:increaseComplexity,DoWhileStatement:increaseComplexity,AssignmentExpression(node){if(astUtils.isLogicalAssignmentOperator(node.operator)){increaseComplexity();}}};}};var computedPropertySpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing inside computed property brackets",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/computed-property-spacing"},fixable:"whitespace",schema:[{enum:["always","never"]},{type:"object",properties:{enforceForClassMembers:{type:"boolean",default:true}},additionalProperties:false}],messages:{unexpectedSpaceBefore:"There should be no space before '{{tokenValue}}'.",unexpectedSpaceAfter:"There should be no space after '{{tokenValue}}'.",missingSpaceBefore:"A space is required before '{{tokenValue}}'.",missingSpaceAfter:"A space is required after '{{tokenValue}}'."}},create(context){const sourceCode=context.getSourceCode();const propertyNameMustBeSpaced=context.options[0]==="always";const enforceForClassMembers=!context.options[1]||context.options[1].enforceForClassMembers;function reportNoBeginningSpace(node,token,tokenAfter){context.report({node,loc:{start:token.loc.end,end:tokenAfter.loc.start},messageId:"unexpectedSpaceAfter",data:{tokenValue:token.value},fix(fixer){return fixer.removeRange([token.range[1],tokenAfter.range[0]]);}});}function reportNoEndingSpace(node,token,tokenBefore){context.report({node,loc:{start:tokenBefore.loc.end,end:token.loc.start},messageId:"unexpectedSpaceBefore",data:{tokenValue:token.value},fix(fixer){return fixer.removeRange([tokenBefore.range[1],token.range[0]]);}});}function reportRequiredBeginningSpace(node,token){context.report({node,loc:token.loc,messageId:"missingSpaceAfter",data:{tokenValue:token.value},fix(fixer){return fixer.insertTextAfter(token," ");}});}function reportRequiredEndingSpace(node,token){context.report({node,loc:token.loc,messageId:"missingSpaceBefore",data:{tokenValue:token.value},fix(fixer){return fixer.insertTextBefore(token," ");}});}function checkSpacing(propertyName){return function(node){if(!node.computed){return;}const property=node[propertyName];const before=sourceCode.getTokenBefore(property,astUtils.isOpeningBracketToken),first=sourceCode.getTokenAfter(before,{includeComments:true}),after=sourceCode.getTokenAfter(property,astUtils.isClosingBracketToken),last=sourceCode.getTokenBefore(after,{includeComments:true});if(astUtils.isTokenOnSameLine(before,first)){if(propertyNameMustBeSpaced){if(!sourceCode.isSpaceBetweenTokens(before,first)&&astUtils.isTokenOnSameLine(before,first)){reportRequiredBeginningSpace(node,before);}}else {if(sourceCode.isSpaceBetweenTokens(before,first)){reportNoBeginningSpace(node,before,first);}}}if(astUtils.isTokenOnSameLine(last,after)){if(propertyNameMustBeSpaced){if(!sourceCode.isSpaceBetweenTokens(last,after)&&astUtils.isTokenOnSameLine(last,after)){reportRequiredEndingSpace(node,after);}}else {if(sourceCode.isSpaceBetweenTokens(last,after)){reportNoEndingSpace(node,after,last);}}}};}const listeners={Property:checkSpacing("key"),MemberExpression:checkSpacing("property")};if(enforceForClassMembers){listeners.MethodDefinition=checkSpacing("key");}return listeners;}};function isUnreachable$1(segment){return !segment.reachable;}function isClassConstructor(node){return node.type==="FunctionExpression"&&node.parent&&node.parent.type==="MethodDefinition"&&node.parent.kind==="constructor";}var consistentReturn={meta:{type:"suggestion",docs:{description:"require `return` statements to either always or never specify values",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/consistent-return"},schema:[{type:"object",properties:{treatUndefinedAsUnspecified:{type:"boolean",default:false}},additionalProperties:false}],messages:{missingReturn:"Expected to return a value at the end of {{name}}.",missingReturnValue:"{{name}} expected a return value.",unexpectedReturnValue:"{{name}} expected no return value."}},create(context){const options=context.options[0]||{};const treatUndefinedAsUnspecified=options.treatUndefinedAsUnspecified===true;let funcInfo=null;function checkLastSegment(node){let loc,name;if(!funcInfo.hasReturnValue||funcInfo.codePath.currentSegments.every(isUnreachable$1)||astUtils.isES5Constructor(node)||isClassConstructor(node)){return;}if(node.type==="Program"){loc={line:1,column:0};name="program";}else if(node.type==="ArrowFunctionExpression"){loc=context.getSourceCode().getTokenBefore(node.body,astUtils.isArrowToken).loc.start;}else if(node.parent.type==="MethodDefinition"||node.parent.type==="Property"&&node.parent.method){loc=node.parent.key.loc.start;}else {loc=(node.id||node).loc.start;}if(!name){name=astUtils.getFunctionNameWithKind(node);}context.report({node,loc,messageId:"missingReturn",data:{name}});}return {onCodePathStart(codePath,node){funcInfo={upper:funcInfo,codePath,hasReturn:false,hasReturnValue:false,messageId:"",node};},onCodePathEnd(){funcInfo=funcInfo.upper;},ReturnStatement(node){const argument=node.argument;let hasReturnValue=Boolean(argument);if(treatUndefinedAsUnspecified&&hasReturnValue){hasReturnValue=!astUtils.isSpecificId(argument,"undefined")&&argument.operator!=="void";}if(!funcInfo.hasReturn){funcInfo.hasReturn=true;funcInfo.hasReturnValue=hasReturnValue;funcInfo.messageId=hasReturnValue?"missingReturnValue":"unexpectedReturnValue";funcInfo.data={name:funcInfo.node.type==="Program"?"Program":lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))};}else if(funcInfo.hasReturnValue!==hasReturnValue){context.report({node,messageId:funcInfo.messageId,data:funcInfo.data});}},"Program:exit":checkLastSegment,"FunctionDeclaration:exit":checkLastSegment,"FunctionExpression:exit":checkLastSegment,"ArrowFunctionExpression:exit":checkLastSegment};}};var consistentThis={meta:{type:"suggestion",docs:{description:"enforce consistent naming when capturing the current execution context",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/consistent-this"},schema:{type:"array",items:{type:"string",minLength:1},uniqueItems:true},messages:{aliasNotAssignedToThis:"Designated alias '{{name}}' is not assigned to 'this'.",unexpectedAlias:"Unexpected alias '{{name}}' for 'this'."}},create(context){let aliases=[];if(context.options.length===0){aliases.push("that");}else {aliases=context.options;}function reportBadAssignment(node,name){context.report({node,messageId:"aliasNotAssignedToThis",data:{name}});}function checkAssignment(node,name,value){const isThis=value.type==="ThisExpression";if(aliases.indexOf(name)!==-1){if(!isThis||node.operator&&node.operator!=="="){reportBadAssignment(node,name);}}else if(isThis){context.report({node,messageId:"unexpectedAlias",data:{name}});}}function checkWasAssigned(alias,scope){const variable=scope.set.get(alias);if(!variable){return;}if(variable.defs.some(def=>def.node.type==="VariableDeclarator"&&def.node.init!==null)){return;}if(!variable.references.some(reference=>{const write=reference.writeExpr;return reference.from===scope&&write&&write.type==="ThisExpression"&&write.parent.operator==="=";})){variable.defs.map(def=>def.node).forEach(node=>{reportBadAssignment(node,alias);});}}function ensureWasAssigned(){const scope=context.getScope();aliases.forEach(alias=>{checkWasAssigned(alias,scope);});}return {"Program:exit":ensureWasAssigned,"FunctionExpression:exit":ensureWasAssigned,"FunctionDeclaration:exit":ensureWasAssigned,VariableDeclarator(node){const id=node.id;const isDestructuring=id.type==="ArrayPattern"||id.type==="ObjectPattern";if(node.init!==null&&!isDestructuring){checkAssignment(node,id.name,node.init);}},AssignmentExpression(node){if(node.left.type==="Identifier"){checkAssignment(node,node.left.name,node.right);}}};}};function isReachable$2(segment){return segment.reachable;}function isConstructorFunction$1(node){return node.type==="FunctionExpression"&&node.parent.type==="MethodDefinition"&&node.parent.kind==="constructor";}function isPossibleConstructor(node){if(!node){return false;}switch(node.type){case"ClassExpression":case"FunctionExpression":case"ThisExpression":case"MemberExpression":case"CallExpression":case"NewExpression":case"ChainExpression":case"YieldExpression":case"TaggedTemplateExpression":case"MetaProperty":return true;case"Identifier":return node.name!=="undefined";case"AssignmentExpression":if(["=","&&="].includes(node.operator)){return isPossibleConstructor(node.right);}if(["||=","??="].includes(node.operator)){return isPossibleConstructor(node.left)||isPossibleConstructor(node.right);}return false;case"LogicalExpression":if(node.operator==="&&"){return isPossibleConstructor(node.right);}return isPossibleConstructor(node.left)||isPossibleConstructor(node.right);case"ConditionalExpression":return isPossibleConstructor(node.alternate)||isPossibleConstructor(node.consequent);case"SequenceExpression":{const lastExpression=node.expressions[node.expressions.length-1];return isPossibleConstructor(lastExpression);}default:return false;}}var constructorSuper={meta:{type:"problem",docs:{description:"require `super()` calls in constructors",category:"ECMAScript 6",recommended:true,url:"https://eslint.org/docs/rules/constructor-super"},schema:[],messages:{missingSome:"Lacked a call of 'super()' in some code paths.",missingAll:"Expected to call 'super()'.",duplicate:"Unexpected duplicate 'super()'.",badSuper:"Unexpected 'super()' because 'super' is not a constructor.",unexpected:"Unexpected 'super()'."}},create(context){let funcInfo=null;let segInfoMap=Object.create(null);function isCalledInSomePath(segment){return segment.reachable&&segInfoMap[segment.id].calledInSomePaths;}function isCalledInEveryPath(segment){if(segment.nextSegments.length===1&&segment.nextSegments[0].isLoopedPrevSegment(segment)){return true;}return segment.reachable&&segInfoMap[segment.id].calledInEveryPaths;}return {onCodePathStart(codePath,node){if(isConstructorFunction$1(node)){const classNode=node.parent.parent.parent;const superClass=classNode.superClass;funcInfo={upper:funcInfo,isConstructor:true,hasExtends:Boolean(superClass),superIsConstructor:isPossibleConstructor(superClass),codePath};}else {funcInfo={upper:funcInfo,isConstructor:false,hasExtends:false,superIsConstructor:false,codePath};}},onCodePathEnd(codePath,node){const hasExtends=funcInfo.hasExtends;funcInfo=funcInfo.upper;if(!hasExtends){return;}const segments=codePath.returnedSegments;const calledInEveryPaths=segments.every(isCalledInEveryPath);const calledInSomePaths=segments.some(isCalledInSomePath);if(!calledInEveryPaths){context.report({messageId:calledInSomePaths?"missingSome":"missingAll",node:node.parent});}},onCodePathSegmentStart(segment){if(!(funcInfo&&funcInfo.isConstructor&&funcInfo.hasExtends)){return;}const info=segInfoMap[segment.id]={calledInSomePaths:false,calledInEveryPaths:false,validNodes:[]};const prevSegments=segment.prevSegments;if(prevSegments.length>0){info.calledInSomePaths=prevSegments.some(isCalledInSomePath);info.calledInEveryPaths=prevSegments.every(isCalledInEveryPath);}},onCodePathSegmentLoop(fromSegment,toSegment){if(!(funcInfo&&funcInfo.isConstructor&&funcInfo.hasExtends)){return;}const isRealLoop=toSegment.prevSegments.length>=2;funcInfo.codePath.traverseSegments({first:toSegment,last:fromSegment},segment=>{const info=segInfoMap[segment.id];const prevSegments=segment.prevSegments;info.calledInSomePaths=prevSegments.some(isCalledInSomePath);info.calledInEveryPaths=prevSegments.every(isCalledInEveryPath);if(info.calledInSomePaths||isRealLoop){const nodes=info.validNodes;info.validNodes=[];for(let i=0;i<nodes.length;++i){const node=nodes[i];context.report({messageId:"duplicate",node});}}});},"CallExpression:exit"(node){if(!(funcInfo&&funcInfo.isConstructor)){return;}if(node.callee.type!=="Super"){return;}if(funcInfo.hasExtends){const segments=funcInfo.codePath.currentSegments;let duplicate=false;let info=null;for(let i=0;i<segments.length;++i){const segment=segments[i];if(segment.reachable){info=segInfoMap[segment.id];duplicate=duplicate||info.calledInSomePaths;info.calledInSomePaths=info.calledInEveryPaths=true;}}if(info){if(duplicate){context.report({messageId:"duplicate",node});}else if(!funcInfo.superIsConstructor){context.report({messageId:"badSuper",node});}else {info.validNodes.push(node);}}}else if(funcInfo.codePath.currentSegments.some(isReachable$2)){context.report({messageId:"unexpected",node});}},ReturnStatement(node){if(!(funcInfo&&funcInfo.isConstructor&&funcInfo.hasExtends)){return;}if(!node.argument){return;}const segments=funcInfo.codePath.currentSegments;for(let i=0;i<segments.length;++i){const segment=segments[i];if(segment.reachable){const info=segInfoMap[segment.id];info.calledInSomePaths=info.calledInEveryPaths=true;}}},"Program:exit"(){segInfoMap=Object.create(null);}};}};var curly={meta:{type:"suggestion",docs:{description:"enforce consistent brace style for all control statements",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/curly"},schema:{anyOf:[{type:"array",items:[{enum:["all"]}],minItems:0,maxItems:1},{type:"array",items:[{enum:["multi","multi-line","multi-or-nest"]},{enum:["consistent"]}],minItems:0,maxItems:2}]},fixable:"code",messages:{missingCurlyAfter:"Expected { after '{{name}}'.",missingCurlyAfterCondition:"Expected { after '{{name}}' condition.",unexpectedCurlyAfter:"Unnecessary { after '{{name}}'.",unexpectedCurlyAfterCondition:"Unnecessary { after '{{name}}' condition."}},create(context){const multiOnly=context.options[0]==="multi";const multiLine=context.options[0]==="multi-line";const multiOrNest=context.options[0]==="multi-or-nest";const consistent=context.options[1]==="consistent";const sourceCode=context.getSourceCode();function isCollapsedOneLiner(node){const before=sourceCode.getTokenBefore(node);const last=sourceCode.getLastToken(node);const lastExcludingSemicolon=astUtils.isSemicolonToken(last)?sourceCode.getTokenBefore(last):last;return before.loc.start.line===lastExcludingSemicolon.loc.end.line;}function isOneLiner(node){if(node.type==="EmptyStatement"){return true;}const first=sourceCode.getFirstToken(node);const last=sourceCode.getLastToken(node);const lastExcludingSemicolon=astUtils.isSemicolonToken(last)?sourceCode.getTokenBefore(last):last;return first.loc.start.line===lastExcludingSemicolon.loc.end.line;}function isLexicalDeclaration(node){if(node.type==="VariableDeclaration"){return node.kind==="const"||node.kind==="let";}return node.type==="FunctionDeclaration"||node.type==="ClassDeclaration";}function isElseKeywordToken(token){return token.value==="else"&&token.type==="Keyword";}function getElseKeyword(node){return node.alternate&&sourceCode.getFirstTokenBetween(node.consequent,node.alternate,isElseKeywordToken);}function isFollowedByElseKeyword(node){const nextToken=sourceCode.getTokenAfter(node);return Boolean(nextToken)&&isElseKeywordToken(nextToken);}function needsSemicolon(closingBracket){const tokenBefore=sourceCode.getTokenBefore(closingBracket);const tokenAfter=sourceCode.getTokenAfter(closingBracket);const lastBlockNode=sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);if(astUtils.isSemicolonToken(tokenBefore)){return false;}if(!tokenAfter){return false;}if(lastBlockNode.type==="BlockStatement"&&lastBlockNode.parent.type!=="FunctionExpression"&&lastBlockNode.parent.type!=="ArrowFunctionExpression"){return false;}if(tokenBefore.loc.end.line===tokenAfter.loc.start.line){return true;}if(/^[([/`+-]/u.test(tokenAfter.value)){return true;}if(tokenBefore.type==="Punctuator"&&(tokenBefore.value==="++"||tokenBefore.value==="--")){return true;}return false;}function hasUnsafeIf(node){switch(node.type){case"IfStatement":if(!node.alternate){return true;}return hasUnsafeIf(node.alternate);case"ForStatement":case"ForInStatement":case"ForOfStatement":case"LabeledStatement":case"WithStatement":case"WhileStatement":return hasUnsafeIf(node.body);default:return false;}}function areBracesNecessary(node){const statement=node.body[0];return isLexicalDeclaration(statement)||hasUnsafeIf(statement)&&isFollowedByElseKeyword(node);}function prepareCheck(node,body,name,opts){const hasBlock=body.type==="BlockStatement";let expected=null;if(hasBlock&&(body.body.length!==1||areBracesNecessary(body))){expected=true;}else if(multiOnly){expected=false;}else if(multiLine){if(!isCollapsedOneLiner(body)){expected=true;}}else if(multiOrNest){if(hasBlock){const statement=body.body[0];const leadingCommentsInBlock=sourceCode.getCommentsBefore(statement);expected=!isOneLiner(statement)||leadingCommentsInBlock.length>0;}else {expected=!isOneLiner(body);}}else {expected=true;}return {actual:hasBlock,expected,check(){if(this.expected!==null&&this.expected!==this.actual){if(this.expected){context.report({node,loc:(name!=="else"?node:getElseKeyword(node)).loc.start,messageId:opts&&opts.condition?"missingCurlyAfterCondition":"missingCurlyAfter",data:{name},fix:fixer=>fixer.replaceText(body,`{${sourceCode.getText(body)}}`)});}else {context.report({node,loc:(name!=="else"?node:getElseKeyword(node)).loc.start,messageId:opts&&opts.condition?"unexpectedCurlyAfterCondition":"unexpectedCurlyAfter",data:{name},fix(fixer){const needsPrecedingSpace=node.type==="DoWhileStatement"&&sourceCode.getTokenBefore(body).range[1]===body.range[0]&&!astUtils.canTokensBeAdjacent("do",sourceCode.getFirstToken(body,{skip:1}));const openingBracket=sourceCode.getFirstToken(body);const closingBracket=sourceCode.getLastToken(body);const lastTokenInBlock=sourceCode.getTokenBefore(closingBracket);if(needsSemicolon(closingBracket)){return null;}const resultingBodyText=sourceCode.getText().slice(openingBracket.range[1],lastTokenInBlock.range[0])+sourceCode.getText(lastTokenInBlock)+sourceCode.getText().slice(lastTokenInBlock.range[1],closingBracket.range[0]);return fixer.replaceText(body,(needsPrecedingSpace?" ":"")+resultingBodyText);}});}}}};}function prepareIfChecks(node){const preparedChecks=[];for(let currentNode=node;currentNode;currentNode=currentNode.alternate){preparedChecks.push(prepareCheck(currentNode,currentNode.consequent,"if",{condition:true}));if(currentNode.alternate&&currentNode.alternate.type!=="IfStatement"){preparedChecks.push(prepareCheck(currentNode,currentNode.alternate,"else"));break;}}if(consistent){const expected=preparedChecks.some(preparedCheck=>{if(preparedCheck.expected!==null){return preparedCheck.expected;}return preparedCheck.actual;});preparedChecks.forEach(preparedCheck=>{preparedCheck.expected=expected;});}return preparedChecks;}return {IfStatement(node){const parent=node.parent;const isElseIf=parent.type==="IfStatement"&&parent.alternate===node;if(!isElseIf){prepareIfChecks(node).forEach(preparedCheck=>{preparedCheck.check();});}},WhileStatement(node){prepareCheck(node,node.body,"while",{condition:true}).check();},DoWhileStatement(node){prepareCheck(node,node.body,"do").check();},ForStatement(node){prepareCheck(node,node.body,"for",{condition:true}).check();},ForInStatement(node){prepareCheck(node,node.body,"for-in").check();},ForOfStatement(node){prepareCheck(node,node.body,"for-of").check();}};}};var defaultCaseLast={meta:{type:"suggestion",docs:{description:"enforce default clauses in switch statements to be last",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/default-case-last"},schema:[],messages:{notLast:"Default clause should be the last clause."}},create(context){return {SwitchStatement(node){const cases=node.cases,indexOfDefault=cases.findIndex(c=>c.test===null);if(indexOfDefault!==-1&&indexOfDefault!==cases.length-1){const defaultClause=cases[indexOfDefault];context.report({node:defaultClause,messageId:"notLast"});}}};}};const DEFAULT_COMMENT_PATTERN=/^no default$/iu;var defaultCase={meta:{type:"suggestion",docs:{description:"require `default` cases in `switch` statements",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/default-case"},schema:[{type:"object",properties:{commentPattern:{type:"string"}},additionalProperties:false}],messages:{missingDefaultCase:"Expected a default case."}},create(context){const options=context.options[0]||{};const commentPattern=options.commentPattern?new RegExp(options.commentPattern,"u"):DEFAULT_COMMENT_PATTERN;const sourceCode=context.getSourceCode();function last(collection){return collection[collection.length-1];}return {SwitchStatement(node){if(!node.cases.length){return;}const hasDefault=node.cases.some(v=>v.test===null);if(!hasDefault){let comment;const lastCase=last(node.cases);const comments=sourceCode.getCommentsAfter(lastCase);if(comments.length){comment=last(comments);}if(!comment||!commentPattern.test(comment.value.trim())){context.report({node,messageId:"missingDefaultCase"});}}}};}};var defaultParamLast={meta:{type:"suggestion",docs:{description:"enforce default parameters to be last",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/default-param-last"},schema:[],messages:{shouldBeLast:"Default parameters should be last."}},create(context){function handleFunction(node){let hasSeenPlainParam=false;for(let i=node.params.length-1;i>=0;i-=1){const param=node.params[i];if(param.type!=="AssignmentPattern"&&param.type!=="RestElement"){hasSeenPlainParam=true;continue;}if(hasSeenPlainParam&&param.type==="AssignmentPattern"){context.report({node:param,messageId:"shouldBeLast"});}}}return {FunctionDeclaration:handleFunction,FunctionExpression:handleFunction,ArrowFunctionExpression:handleFunction};}};var dotLocation={meta:{type:"layout",docs:{description:"enforce consistent newlines before and after dots",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/dot-location"},schema:[{enum:["object","property"]}],fixable:"code",messages:{expectedDotAfterObject:"Expected dot to be on same line as object.",expectedDotBeforeProperty:"Expected dot to be on same line as property."}},create(context){const config=context.options[0];const sourceCode=context.getSourceCode();function checkDotLocation(node){const property=node.property;const dotToken=sourceCode.getTokenBefore(property);if(config==="object"||!config){const tokenBeforeDot=sourceCode.getTokenBefore(dotToken);if(!astUtils.isTokenOnSameLine(tokenBeforeDot,dotToken)){context.report({node,loc:dotToken.loc,messageId:"expectedDotAfterObject",*fix(fixer){if(dotToken.value.startsWith(".")&&astUtils.isDecimalIntegerNumericToken(tokenBeforeDot)){yield fixer.insertTextAfter(tokenBeforeDot,` ${dotToken.value}`);}else {yield fixer.insertTextAfter(tokenBeforeDot,dotToken.value);}yield fixer.remove(dotToken);}});}}else if(!astUtils.isTokenOnSameLine(dotToken,property)){context.report({node,loc:dotToken.loc,messageId:"expectedDotBeforeProperty",*fix(fixer){yield fixer.remove(dotToken);yield fixer.insertTextBefore(property,dotToken.value);}});}}return {MemberExpression:function(node){if(!node.computed){checkDotLocation(node);}}};}};var keywords=["abstract","boolean","break","byte","case","catch","char","class","const","continue","debugger","default","delete","do","double","else","enum","export","extends","false","final","finally","float","for","function","goto","if","implements","import","in","instanceof","int","interface","long","native","new","null","package","private","protected","public","return","short","static","super","switch","synchronized","this","throw","throws","transient","true","try","typeof","var","void","volatile","while","with"];const validIdentifier=/^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;const literalTypesToCheck=new Set(["string","boolean"]);var dotNotation={meta:{type:"suggestion",docs:{description:"enforce dot notation whenever possible",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/dot-notation"},schema:[{type:"object",properties:{allowKeywords:{type:"boolean",default:true},allowPattern:{type:"string",default:""}},additionalProperties:false}],fixable:"code",messages:{useDot:"[{{key}}] is better written in dot notation.",useBrackets:".{{key}} is a syntax error."}},create(context){const options=context.options[0]||{};const allowKeywords=options.allowKeywords===void 0||options.allowKeywords;const sourceCode=context.getSourceCode();let allowPattern;if(options.allowPattern){allowPattern=new RegExp(options.allowPattern,"u");}function checkComputedProperty(node,value){if(validIdentifier.test(value)&&(allowKeywords||keywords.indexOf(String(value))===-1)&&!(allowPattern&&allowPattern.test(value))){const formattedValue=node.property.type==="Literal"?JSON.stringify(value):`\`${value}\``;context.report({node:node.property,messageId:"useDot",data:{key:formattedValue},*fix(fixer){const leftBracket=sourceCode.getTokenAfter(node.object,astUtils.isOpeningBracketToken);const rightBracket=sourceCode.getLastToken(node);const nextToken=sourceCode.getTokenAfter(node);if(sourceCode.commentsExistBetween(leftBracket,rightBracket)){return;}if(!node.optional){yield fixer.insertTextBefore(leftBracket,astUtils.isDecimalInteger(node.object)?" .":".");}yield fixer.replaceTextRange([leftBracket.range[0],rightBracket.range[1]],value);if(nextToken&&rightBracket.range[1]===nextToken.range[0]&&!astUtils.canTokensBeAdjacent(String(value),nextToken)){yield fixer.insertTextAfter(node," ");}}});}}return {MemberExpression(node){if(node.computed&&node.property.type==="Literal"&&(literalTypesToCheck.has(typeof node.property.value)||astUtils.isNullLiteral(node.property))){checkComputedProperty(node,node.property.value);}if(node.computed&&node.property.type==="TemplateLiteral"&&node.property.expressions.length===0){checkComputedProperty(node,node.property.quasis[0].value.cooked);}if(!allowKeywords&&!node.computed&&keywords.indexOf(String(node.property.name))!==-1){context.report({node:node.property,messageId:"useBrackets",data:{key:node.property.name},*fix(fixer){const dotToken=sourceCode.getTokenBefore(node.property);if(node.object.type==="Identifier"&&node.object.name==="let"&&!node.optional){return;}if(sourceCode.commentsExistBetween(dotToken,node.property)){return;}if(!node.optional){yield fixer.remove(dotToken);}yield fixer.replaceText(node.property,`["${node.property.name}"]`);}});}}};}};var eolLast={meta:{type:"layout",docs:{description:"require or disallow newline at the end of files",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/eol-last"},fixable:"whitespace",schema:[{enum:["always","never","unix","windows"]}],messages:{missing:"Newline required at end of file but not found.",unexpected:"Newline not allowed at end of file."}},create(context){return {Program:function(node){const sourceCode=context.getSourceCode(),src=sourceCode.getText(),location={column:lodash__default['default'].last(sourceCode.lines).length,line:sourceCode.lines.length},endsWithNewline=src.endsWith("\n");if(!src.length){return;}let mode=context.options[0]||"always",appendCRLF=false;if(mode==="unix"){mode="always";}if(mode==="windows"){mode="always";appendCRLF=true;}if(mode==="always"&&!endsWithNewline){context.report({node,loc:location,messageId:"missing",fix(fixer){return fixer.insertTextAfterRange([0,src.length],appendCRLF?`\r${"\n"}`:"\n");}});}else if(mode==="never"&&endsWithNewline){context.report({node,loc:location,messageId:"unexpected",fix(fixer){const match=/(?:\r?\n)+$/u.exec(sourceCode.text),start=match.index,end=sourceCode.text.length;return fixer.replaceTextRange([start,end],"");}});}}};}};var eqeqeq={meta:{type:"suggestion",docs:{description:"require the use of `===` and `!==`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/eqeqeq"},schema:{anyOf:[{type:"array",items:[{enum:["always"]},{type:"object",properties:{null:{enum:["always","never","ignore"]}},additionalProperties:false}],additionalItems:false},{type:"array",items:[{enum:["smart","allow-null"]}],additionalItems:false}]},fixable:"code",messages:{unexpected:"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'."}},create(context){const config=context.options[0]||"always";const options=context.options[1]||{};const sourceCode=context.getSourceCode();const nullOption=config==="always"?options.null||"always":"ignore";function isTypeOf(node){return node.type==="UnaryExpression"&&node.operator==="typeof";}function isTypeOfBinary(node){return isTypeOf(node.left)||isTypeOf(node.right);}function areLiteralsAndSameType(node){return node.left.type==="Literal"&&node.right.type==="Literal"&&typeof node.left.value===typeof node.right.value;}function isNullCheck(node){return astUtils.isNullLiteral(node.right)||astUtils.isNullLiteral(node.left);}function report(node,expectedOperator){const operatorToken=sourceCode.getFirstTokenBetween(node.left,node.right,token=>token.value===node.operator);context.report({node,loc:operatorToken.loc,messageId:"unexpected",data:{expectedOperator,actualOperator:node.operator},fix(fixer){if(isTypeOfBinary(node)||areLiteralsAndSameType(node)){return fixer.replaceText(operatorToken,expectedOperator);}return null;}});}return {BinaryExpression(node){const isNull=isNullCheck(node);if(node.operator!=="=="&&node.operator!=="!="){if(nullOption==="never"&&isNull){report(node,node.operator.slice(0,-1));}return;}if(config==="smart"&&(isTypeOfBinary(node)||areLiteralsAndSameType(node)||isNull)){return;}if(!(nullOption==="always")&&isNull){return;}report(node,`${node.operator}=`);}};}};var forDirection={meta:{type:"problem",docs:{description:"enforce \"for\" loop update clause moving the counter in the right direction.",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/for-direction"},fixable:null,schema:[],messages:{incorrectDirection:"The update clause in this loop moves the variable in the wrong direction."}},create(context){function report(node){context.report({node,messageId:"incorrectDirection"});}function getRightDirection(update,dir){if(update.right.type==="UnaryExpression"){if(update.right.operator==="-"){return -dir;}}else if(update.right.type==="Identifier"){return 0;}return dir;}function getUpdateDirection(update,counter){if(update.argument.type==="Identifier"&&update.argument.name===counter){if(update.operator==="++"){return 1;}if(update.operator==="--"){return -1;}}return 0;}function getAssignmentDirection(update,counter){if(update.left.name===counter){if(update.operator==="+="){return getRightDirection(update,1);}if(update.operator==="-="){return getRightDirection(update,-1);}}return 0;}return {ForStatement(node){if(node.test&&node.test.type==="BinaryExpression"&&node.test.left.type==="Identifier"&&node.update){const counter=node.test.left.name;const operator=node.test.operator;const update=node.update;let wrongDirection;if(operator==="<"||operator==="<="){wrongDirection=-1;}else if(operator===">"||operator===">="){wrongDirection=1;}else {return;}if(update.type==="UpdateExpression"){if(getUpdateDirection(update,counter)===wrongDirection){report(node);}}else if(update.type==="AssignmentExpression"&&getAssignmentDirection(update,counter)===wrongDirection){report(node);}}}};}};var funcCallSpacing={meta:{type:"layout",docs:{description:"require or disallow spacing between function identifiers and their invocations",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/func-call-spacing"},fixable:"whitespace",schema:{anyOf:[{type:"array",items:[{enum:["never"]}],minItems:0,maxItems:1},{type:"array",items:[{enum:["always"]},{type:"object",properties:{allowNewlines:{type:"boolean"}},additionalProperties:false}],minItems:0,maxItems:2}]},messages:{unexpectedWhitespace:"Unexpected whitespace between function name and paren.",unexpectedNewline:"Unexpected newline between function name and paren.",missing:"Missing space between function name and paren."}},create(context){const never=context.options[0]!=="always";const allowNewlines=!never&&context.options[1]&&context.options[1].allowNewlines;const sourceCode=context.getSourceCode();const text=sourceCode.getText();function checkSpacing(node,leftToken,rightToken){const textBetweenTokens=text.slice(leftToken.range[1],rightToken.range[0]).replace(/\/\*.*?\*\//gu,"");const hasWhitespace=/\s/u.test(textBetweenTokens);const hasNewline=hasWhitespace&&astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);if(never&&hasWhitespace){context.report({node,loc:{start:leftToken.loc.end,end:{line:rightToken.loc.start.line,column:rightToken.loc.start.column-1}},messageId:"unexpectedWhitespace",fix(fixer){if(sourceCode.commentsExistBetween(leftToken,rightToken)){return null;}if(node.optional){return fixer.replaceTextRange([leftToken.range[1],rightToken.range[0]],"?.");}if(hasNewline){return null;}return fixer.removeRange([leftToken.range[1],rightToken.range[0]]);}});}else if(!never&&!hasWhitespace){context.report({node,loc:{start:{line:leftToken.loc.end.line,column:leftToken.loc.end.column-1},end:rightToken.loc.start},messageId:"missing",fix(fixer){if(node.optional){return null;}return fixer.insertTextBefore(rightToken," ");}});}else if(!never&&!allowNewlines&&hasNewline){context.report({node,loc:{start:leftToken.loc.end,end:rightToken.loc.start},messageId:"unexpectedNewline",fix(fixer){if(!node.optional){return null;}if(sourceCode.commentsExistBetween(leftToken,rightToken)){return null;}const range=[leftToken.range[1],rightToken.range[0]];const qdToken=sourceCode.getTokenAfter(leftToken);if(qdToken.range[0]===leftToken.range[1]){return fixer.replaceTextRange(range,"?. ");}if(qdToken.range[1]===rightToken.range[0]){return fixer.replaceTextRange(range," ?.");}return fixer.replaceTextRange(range," ?. ");}});}}return {"CallExpression, NewExpression"(node){const lastToken=sourceCode.getLastToken(node);const lastCalleeToken=sourceCode.getLastToken(node.callee);const parenToken=sourceCode.getFirstTokenBetween(lastCalleeToken,lastToken,astUtils.isOpeningParenToken);const prevToken=parenToken&&sourceCode.getTokenBefore(parenToken,astUtils.isNotQuestionDotToken);if(!(parenToken&&parenToken.range[1]<node.range[1])){return;}checkSpacing(node,prevToken,parenToken);},ImportExpression(node){const leftToken=sourceCode.getFirstToken(node);const rightToken=sourceCode.getTokenAfter(leftToken);checkSpacing(node,leftToken,rightToken);}};}};function isModuleExports(pattern){if(pattern.type==="MemberExpression"&&pattern.object.type==="Identifier"&&pattern.object.name==="module"){if(pattern.property.type==="Identifier"&&pattern.property.name==="exports"){return true;}if(pattern.property.type==="Literal"&&pattern.property.value==="exports"){return true;}}return false;}function isIdentifier(name,ecmaVersion){if(ecmaVersion>=6){return esutils__default['default'].keyword.isIdentifierES6(name);}return esutils__default['default'].keyword.isIdentifierES5(name);}const alwaysOrNever={enum:["always","never"]};const optionsObject={type:"object",properties:{considerPropertyDescriptor:{type:"boolean"},includeCommonJSModuleExports:{type:"boolean"}},additionalProperties:false};var funcNameMatching={meta:{type:"suggestion",docs:{description:"require function names to match the name of the variable or property to which they are assigned",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/func-name-matching"},schema:{anyOf:[{type:"array",additionalItems:false,items:[alwaysOrNever,optionsObject]},{type:"array",additionalItems:false,items:[optionsObject]}]},messages:{matchProperty:"Function name `{{funcName}}` should match property name `{{name}}`.",matchVariable:"Function name `{{funcName}}` should match variable name `{{name}}`.",notMatchProperty:"Function name `{{funcName}}` should not match property name `{{name}}`.",notMatchVariable:"Function name `{{funcName}}` should not match variable name `{{name}}`."}},create(context){const options=(typeof context.options[0]==="object"?context.options[0]:context.options[1])||{};const nameMatches=typeof context.options[0]==="string"?context.options[0]:"always";const considerPropertyDescriptor=options.considerPropertyDescriptor;const includeModuleExports=options.includeCommonJSModuleExports;const ecmaVersion=context.parserOptions&&context.parserOptions.ecmaVersion?context.parserOptions.ecmaVersion:5;function isPropertyCall(objName,funcName,node){if(!node){return false;}return node.type==="CallExpression"&&astUtils.isSpecificMemberAccess(node.callee,objName,funcName);}function shouldWarn(x,y){return nameMatches==="always"&&x!==y||nameMatches==="never"&&x===y;}function report(node,name,funcName,isProp){let messageId;if(nameMatches==="always"&&isProp){messageId="matchProperty";}else if(nameMatches==="always"){messageId="matchVariable";}else if(isProp){messageId="notMatchProperty";}else {messageId="notMatchVariable";}context.report({node,messageId,data:{name,funcName}});}function isStringLiteral(node){return node.type==="Literal"&&typeof node.value==="string";}return {VariableDeclarator(node){if(!node.init||node.init.type!=="FunctionExpression"||node.id.type!=="Identifier"){return;}if(node.init.id&&shouldWarn(node.id.name,node.init.id.name)){report(node,node.id.name,node.init.id.name,false);}},AssignmentExpression(node){if(node.right.type!=="FunctionExpression"||node.left.computed&&node.left.property.type!=="Literal"||!includeModuleExports&&isModuleExports(node.left)||node.left.type!=="Identifier"&&node.left.type!=="MemberExpression"){return;}const isProp=node.left.type==="MemberExpression";const name=isProp?astUtils.getStaticPropertyName(node.left):node.left.name;if(node.right.id&&isIdentifier(name)&&shouldWarn(name,node.right.id.name)){report(node,name,node.right.id.name,isProp);}},Property(node){if(node.value.type!=="FunctionExpression"||!node.value.id||node.computed&&!isStringLiteral(node.key)){return;}if(node.key.type==="Identifier"){const functionName=node.value.id.name;let propertyName=node.key.name;if(considerPropertyDescriptor&&propertyName==="value"){if(isPropertyCall("Object","defineProperty",node.parent.parent)||isPropertyCall("Reflect","defineProperty",node.parent.parent)){const property=node.parent.parent.arguments[1];if(isStringLiteral(property)&&shouldWarn(property.value,functionName)){report(node,property.value,functionName,true);}}else if(isPropertyCall("Object","defineProperties",node.parent.parent.parent.parent)){propertyName=node.parent.parent.key.name;if(!node.parent.parent.computed&&shouldWarn(propertyName,functionName)){report(node,propertyName,functionName,true);}}else if(isPropertyCall("Object","create",node.parent.parent.parent.parent)){propertyName=node.parent.parent.key.name;if(!node.parent.parent.computed&&shouldWarn(propertyName,functionName)){report(node,propertyName,functionName,true);}}else if(shouldWarn(propertyName,functionName)){report(node,propertyName,functionName,true);}}else if(shouldWarn(propertyName,functionName)){report(node,propertyName,functionName,true);}return;}if(isStringLiteral(node.key)&&isIdentifier(node.key.value,ecmaVersion)&&shouldWarn(node.key.value,node.value.id.name)){report(node,node.key.value,node.value.id.name,true);}}};}};function isFunctionName$1(variable){return variable&&variable.defs[0].type==="FunctionName";}var funcNames={meta:{type:"suggestion",docs:{description:"require or disallow named `function` expressions",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/func-names"},schema:{definitions:{value:{enum:["always","as-needed","never"]}},items:[{$ref:"#/definitions/value"},{type:"object",properties:{generators:{$ref:"#/definitions/value"}},additionalProperties:false}]},messages:{unnamed:"Unexpected unnamed {{name}}.",named:"Unexpected named {{name}}."}},create(context){const sourceCode=context.getSourceCode();function getConfigForNode(node){if(node.generator&&context.options.length>1&&context.options[1].generators){return context.options[1].generators;}return context.options[0]||"always";}function isObjectOrClassMethod(node){const parent=node.parent;return parent.type==="MethodDefinition"||parent.type==="Property"&&(parent.method||parent.kind==="get"||parent.kind==="set");}function hasInferredName(node){const parent=node.parent;return isObjectOrClassMethod(node)||parent.type==="VariableDeclarator"&&parent.id.type==="Identifier"&&parent.init===node||parent.type==="Property"&&parent.value===node||parent.type==="AssignmentExpression"&&parent.left.type==="Identifier"&&parent.right===node||parent.type==="AssignmentPattern"&&parent.left.type==="Identifier"&&parent.right===node;}function reportUnexpectedUnnamedFunction(node){context.report({node,messageId:"unnamed",loc:astUtils.getFunctionHeadLoc(node,sourceCode),data:{name:astUtils.getFunctionNameWithKind(node)}});}function reportUnexpectedNamedFunction(node){context.report({node,messageId:"named",loc:astUtils.getFunctionHeadLoc(node,sourceCode),data:{name:astUtils.getFunctionNameWithKind(node)}});}function handleFunction(node){const nameVar=context.getDeclaredVariables(node)[0];if(isFunctionName$1(nameVar)&&nameVar.references.length>0){return;}const hasName=Boolean(node.id&&node.id.name);const config=getConfigForNode(node);if(config==="never"){if(hasName&&node.type!=="FunctionDeclaration"){reportUnexpectedNamedFunction(node);}}else if(config==="as-needed"){if(!hasName&&!hasInferredName(node)){reportUnexpectedUnnamedFunction(node);}}else {if(!hasName&&!isObjectOrClassMethod(node)){reportUnexpectedUnnamedFunction(node);}}}return {"FunctionExpression:exit":handleFunction,"ExportDefaultDeclaration > FunctionDeclaration":handleFunction};}};var funcStyle={meta:{type:"suggestion",docs:{description:"enforce the consistent use of either `function` declarations or expressions",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/func-style"},schema:[{enum:["declaration","expression"]},{type:"object",properties:{allowArrowFunctions:{type:"boolean",default:false}},additionalProperties:false}],messages:{expression:"Expected a function expression.",declaration:"Expected a function declaration."}},create(context){const style=context.options[0],allowArrowFunctions=context.options[1]&&context.options[1].allowArrowFunctions,enforceDeclarations=style==="declaration",stack=[];const nodesToCheck={FunctionDeclaration(node){stack.push(false);if(!enforceDeclarations&&node.parent.type!=="ExportDefaultDeclaration"){context.report({node,messageId:"expression"});}},"FunctionDeclaration:exit"(){stack.pop();},FunctionExpression(node){stack.push(false);if(enforceDeclarations&&node.parent.type==="VariableDeclarator"){context.report({node:node.parent,messageId:"declaration"});}},"FunctionExpression:exit"(){stack.pop();},ThisExpression(){if(stack.length>0){stack[stack.length-1]=true;}}};if(!allowArrowFunctions){nodesToCheck.ArrowFunctionExpression=function(){stack.push(false);};nodesToCheck["ArrowFunctionExpression:exit"]=function(node){const hasThisExpr=stack.pop();if(enforceDeclarations&&!hasThisExpr&&node.parent.type==="VariableDeclarator"){context.report({node:node.parent,messageId:"declaration"});}};}return nodesToCheck;}};var functionCallArgumentNewline={meta:{type:"layout",docs:{description:"enforce line breaks between arguments of a function call",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/function-call-argument-newline"},fixable:"whitespace",schema:[{enum:["always","never","consistent"]}],messages:{unexpectedLineBreak:"There should be no line break here.",missingLineBreak:"There should be a line break after this argument."}},create(context){const sourceCode=context.getSourceCode();const checkers={unexpected:{messageId:"unexpectedLineBreak",check:(prevToken,currentToken)=>prevToken.loc.end.line!==currentToken.loc.start.line,createFix:(token,tokenBefore)=>fixer=>fixer.replaceTextRange([tokenBefore.range[1],token.range[0]]," ")},missing:{messageId:"missingLineBreak",check:(prevToken,currentToken)=>prevToken.loc.end.line===currentToken.loc.start.line,createFix:(token,tokenBefore)=>fixer=>fixer.replaceTextRange([tokenBefore.range[1],token.range[0]],"\n")}};function checkArguments(node,checker){for(let i=1;i<node.arguments.length;i++){const prevArgToken=sourceCode.getLastToken(node.arguments[i-1]);const currentArgToken=sourceCode.getFirstToken(node.arguments[i]);if(checker.check(prevArgToken,currentArgToken)){const tokenBefore=sourceCode.getTokenBefore(currentArgToken,{includeComments:true});const hasLineCommentBefore=tokenBefore.type==="Line";context.report({node,loc:{start:tokenBefore.loc.end,end:currentArgToken.loc.start},messageId:checker.messageId,fix:hasLineCommentBefore?null:checker.createFix(currentArgToken,tokenBefore)});}}}function check(node){if(node.arguments.length<2){return;}const option=context.options[0]||"always";if(option==="never"){checkArguments(node,checkers.unexpected);}else if(option==="always"){checkArguments(node,checkers.missing);}else if(option==="consistent"){const firstArgToken=sourceCode.getLastToken(node.arguments[0]);const secondArgToken=sourceCode.getFirstToken(node.arguments[1]);if(firstArgToken.loc.end.line===secondArgToken.loc.start.line){checkArguments(node,checkers.unexpected);}else {checkArguments(node,checkers.missing);}}}return {CallExpression:check,NewExpression:check};}};var functionParenNewline={meta:{type:"layout",docs:{description:"enforce consistent line breaks inside function parentheses",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/function-paren-newline"},fixable:"whitespace",schema:[{oneOf:[{enum:["always","never","consistent","multiline","multiline-arguments"]},{type:"object",properties:{minItems:{type:"integer",minimum:0}},additionalProperties:false}]}],messages:{expectedBefore:"Expected newline before ')'.",expectedAfter:"Expected newline after '('.",expectedBetween:"Expected newline between arguments/params.",unexpectedBefore:"Unexpected newline before ')'.",unexpectedAfter:"Unexpected newline after '('."}},create(context){const sourceCode=context.getSourceCode();const rawOption=context.options[0]||"multiline";const multilineArgumentsOption=rawOption==="multiline-arguments";let minItems;if(typeof rawOption==="object"){minItems=rawOption.minItems;}else if(rawOption==="always"){minItems=0;}else if(rawOption==="never"){minItems=Infinity;}else {minItems=null;}function shouldHaveNewlines(elements,hasLeftNewline){if(multilineArgumentsOption&&elements.length===1){return hasLeftNewline;}if(rawOption==="multiline"||multilineArgumentsOption){return elements.some((element,index)=>index!==elements.length-1&&element.loc.end.line!==elements[index+1].loc.start.line);}if(rawOption==="consistent"){return hasLeftNewline;}return elements.length>=minItems;}function validateParens(parens,elements){const leftParen=parens.leftParen;const rightParen=parens.rightParen;const tokenAfterLeftParen=sourceCode.getTokenAfter(leftParen);const tokenBeforeRightParen=sourceCode.getTokenBefore(rightParen);const hasLeftNewline=!astUtils.isTokenOnSameLine(leftParen,tokenAfterLeftParen);const hasRightNewline=!astUtils.isTokenOnSameLine(tokenBeforeRightParen,rightParen);const needsNewlines=shouldHaveNewlines(elements,hasLeftNewline);if(hasLeftNewline&&!needsNewlines){context.report({node:leftParen,messageId:"unexpectedAfter",fix(fixer){return sourceCode.getText().slice(leftParen.range[1],tokenAfterLeftParen.range[0]).trim()?null:fixer.removeRange([leftParen.range[1],tokenAfterLeftParen.range[0]]);}});}else if(!hasLeftNewline&&needsNewlines){context.report({node:leftParen,messageId:"expectedAfter",fix:fixer=>fixer.insertTextAfter(leftParen,"\n")});}if(hasRightNewline&&!needsNewlines){context.report({node:rightParen,messageId:"unexpectedBefore",fix(fixer){return sourceCode.getText().slice(tokenBeforeRightParen.range[1],rightParen.range[0]).trim()?null:fixer.removeRange([tokenBeforeRightParen.range[1],rightParen.range[0]]);}});}else if(!hasRightNewline&&needsNewlines){context.report({node:rightParen,messageId:"expectedBefore",fix:fixer=>fixer.insertTextBefore(rightParen,"\n")});}}function validateArguments(parens,elements){const leftParen=parens.leftParen;const tokenAfterLeftParen=sourceCode.getTokenAfter(leftParen);const hasLeftNewline=!astUtils.isTokenOnSameLine(leftParen,tokenAfterLeftParen);const needsNewlines=shouldHaveNewlines(elements,hasLeftNewline);for(let i=0;i<=elements.length-2;i++){const currentElement=elements[i];const nextElement=elements[i+1];const hasNewLine=currentElement.loc.end.line!==nextElement.loc.start.line;if(!hasNewLine&&needsNewlines){context.report({node:currentElement,messageId:"expectedBetween",fix:fixer=>fixer.insertTextBefore(nextElement,"\n")});}}}function getParenTokens(node){switch(node.type){case"NewExpression":if(!node.arguments.length&&!(astUtils.isOpeningParenToken(sourceCode.getLastToken(node,{skip:1}))&&astUtils.isClosingParenToken(sourceCode.getLastToken(node)))){return null;}case"CallExpression":return {leftParen:sourceCode.getTokenAfter(node.callee,astUtils.isOpeningParenToken),rightParen:sourceCode.getLastToken(node)};case"FunctionDeclaration":case"FunctionExpression":{const leftParen=sourceCode.getFirstToken(node,astUtils.isOpeningParenToken);const rightParen=node.params.length?sourceCode.getTokenAfter(node.params[node.params.length-1],astUtils.isClosingParenToken):sourceCode.getTokenAfter(leftParen);return {leftParen,rightParen};}case"ArrowFunctionExpression":{const firstToken=sourceCode.getFirstToken(node,{skip:node.async?1:0});if(!astUtils.isOpeningParenToken(firstToken)){return null;}return {leftParen:firstToken,rightParen:sourceCode.getTokenBefore(node.body,astUtils.isClosingParenToken)};}case"ImportExpression":{const leftParen=sourceCode.getFirstToken(node,1);const rightParen=sourceCode.getLastToken(node);return {leftParen,rightParen};}default:throw new TypeError(`unexpected node with type ${node.type}`);}}return {[["ArrowFunctionExpression","CallExpression","FunctionDeclaration","FunctionExpression","ImportExpression","NewExpression"]](node){const parens=getParenTokens(node);let params;if(node.type==="ImportExpression"){params=[node.source];}else if(astUtils.isFunction(node)){params=node.params;}else {params=node.arguments;}if(parens){validateParens(parens,params);if(multilineArgumentsOption){validateArguments(parens,params);}}}};}};const OVERRIDE_SCHEMA={oneOf:[{enum:["before","after","both","neither"]},{type:"object",properties:{before:{type:"boolean"},after:{type:"boolean"}},additionalProperties:false}]};var generatorStarSpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing around `*` operators in generator functions",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/generator-star-spacing"},fixable:"whitespace",schema:[{oneOf:[{enum:["before","after","both","neither"]},{type:"object",properties:{before:{type:"boolean"},after:{type:"boolean"},named:OVERRIDE_SCHEMA,anonymous:OVERRIDE_SCHEMA,method:OVERRIDE_SCHEMA},additionalProperties:false}]}],messages:{missingBefore:"Missing space before *.",missingAfter:"Missing space after *.",unexpectedBefore:"Unexpected space before *.",unexpectedAfter:"Unexpected space after *."}},create(context){const optionDefinitions={before:{before:true,after:false},after:{before:false,after:true},both:{before:true,after:true},neither:{before:false,after:false}};function optionToDefinition(option,defaults){if(!option){return defaults;}return typeof option==="string"?optionDefinitions[option]:Object.assign({},defaults,option);}const modes=function(option){const defaults=optionToDefinition(option,optionDefinitions.before);return {named:optionToDefinition(option.named,defaults),anonymous:optionToDefinition(option.anonymous,defaults),method:optionToDefinition(option.method,defaults)};}(context.options[0]||{});const sourceCode=context.getSourceCode();function isStarToken(token){return token.value==="*"&&token.type==="Punctuator";}function getStarToken(node){return sourceCode.getFirstToken(node.parent.method||node.parent.type==="MethodDefinition"?node.parent:node,isStarToken);}function capitalize(str){return str[0].toUpperCase()+str.slice(1);}function checkSpacing(kind,side,leftToken,rightToken){if(!!(rightToken.range[0]-leftToken.range[1])!==modes[kind][side]){const after=leftToken.value==="*";const spaceRequired=modes[kind][side];const node=after?leftToken:rightToken;const messageId=`${spaceRequired?"missing":"unexpected"}${capitalize(side)}`;context.report({node,messageId,fix(fixer){if(spaceRequired){if(after){return fixer.insertTextAfter(node," ");}return fixer.insertTextBefore(node," ");}return fixer.removeRange([leftToken.range[1],rightToken.range[0]]);}});}}function checkFunction(node){if(!node.generator){return;}const starToken=getStarToken(node);const prevToken=sourceCode.getTokenBefore(starToken);const nextToken=sourceCode.getTokenAfter(starToken);let kind="named";if(node.parent.type==="MethodDefinition"||node.parent.type==="Property"&&node.parent.method){kind="method";}else if(!node.id){kind="anonymous";}if(!(kind==="method"&&starToken===sourceCode.getFirstToken(node.parent))){checkSpacing(kind,"before",prevToken,starToken);}checkSpacing(kind,"after",starToken,nextToken);}return {FunctionDeclaration:checkFunction,FunctionExpression:checkFunction};}};const TARGET_NODE_TYPE$1=/^(?:Arrow)?FunctionExpression$/u;function isReachable$1(segment){return segment.reachable;}var getterReturn={meta:{type:"problem",docs:{description:"enforce `return` statements in getters",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/getter-return"},fixable:null,schema:[{type:"object",properties:{allowImplicit:{type:"boolean",default:false}},additionalProperties:false}],messages:{expected:"Expected to return a value in {{name}}.",expectedAlways:"Expected {{name}} to always return a value."}},create(context){const options=context.options[0]||{allowImplicit:false};const sourceCode=context.getSourceCode();let funcInfo={upper:null,codePath:null,hasReturn:false,shouldCheck:false,node:null};function checkLastSegment(node){if(funcInfo.shouldCheck&&funcInfo.codePath.currentSegments.some(isReachable$1)){context.report({node,loc:astUtils.getFunctionHeadLoc(node,sourceCode),messageId:funcInfo.hasReturn?"expectedAlways":"expected",data:{name:astUtils.getFunctionNameWithKind(funcInfo.node)}});}}function isGetter(node){const parent=node.parent;if(TARGET_NODE_TYPE$1.test(node.type)&&node.body.type==="BlockStatement"){if(parent.kind==="get"){return true;}if(parent.type==="Property"&&astUtils.getStaticPropertyName(parent)==="get"&&parent.parent.type==="ObjectExpression"){if(parent.parent.parent.type==="CallExpression"&&astUtils.getStaticPropertyName(parent.parent.parent.callee)==="defineProperty"){return true;}if(parent.parent.parent.type==="Property"&&parent.parent.parent.parent.type==="ObjectExpression"&&parent.parent.parent.parent.parent.type==="CallExpression"&&astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee)==="defineProperties"){return true;}}}return false;}return {onCodePathStart(codePath,node){funcInfo={upper:funcInfo,codePath,hasReturn:false,shouldCheck:isGetter(node),node};},onCodePathEnd(){funcInfo=funcInfo.upper;},ReturnStatement(node){if(funcInfo.shouldCheck){funcInfo.hasReturn=true;if(!options.allowImplicit&&!node.argument){context.report({node,messageId:"expected",data:{name:astUtils.getFunctionNameWithKind(funcInfo.node)}});}}},"FunctionExpression:exit":checkLastSegment,"ArrowFunctionExpression:exit":checkLastSegment};}};const ACCEPTABLE_PARENTS=["AssignmentExpression","VariableDeclarator","MemberExpression","ExpressionStatement","CallExpression","ConditionalExpression","Program","VariableDeclaration","ChainExpression"];function findReference$1(scope,node){const references=scope.references.filter(reference=>reference.identifier.range[0]===node.range[0]&&reference.identifier.range[1]===node.range[1]);if(references.length===1){return references[0];}return null;}function isShadowed$2(scope,node){const reference=findReference$1(scope,node);return reference&&reference.resolved&&reference.resolved.defs.length>0;}var globalRequire={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"require `require()` calls to be placed at top-level module scope",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/global-require"},schema:[],messages:{unexpected:"Unexpected require()."}},create(context){return {CallExpression(node){const currentScope=context.getScope();if(node.callee.name==="require"&&!isShadowed$2(currentScope,node.callee)){const isGoodRequire=context.getAncestors().every(parent=>ACCEPTABLE_PARENTS.indexOf(parent.type)>-1);if(!isGoodRequire){context.report({node,messageId:"unexpected"});}}}};}};function areEqualTokenLists(left,right){if(left.length!==right.length){return false;}for(let i=0;i<left.length;i++){const leftToken=left[i],rightToken=right[i];if(leftToken.type!==rightToken.type||leftToken.value!==rightToken.value){return false;}}return true;}function areEqualKeys(left,right){if(typeof left==="string"&&typeof right==="string"){return left===right;}if(Array.isArray(left)&&Array.isArray(right)){return areEqualTokenLists(left,right);}return false;}function isAccessorKind(node){return node.kind==="get"||node.kind==="set";}var groupedAccessorPairs={meta:{type:"suggestion",docs:{description:"require grouped accessor pairs in object literals and classes",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/grouped-accessor-pairs"},schema:[{enum:["anyOrder","getBeforeSet","setBeforeGet"]}],messages:{notGrouped:"Accessor pair {{ formerName }} and {{ latterName }} should be grouped.",invalidOrder:"Expected {{ latterName }} to be before {{ formerName }}."}},create(context){const order=context.options[0]||"anyOrder";const sourceCode=context.getSourceCode();function report(messageId,formerNode,latterNode){context.report({node:latterNode,messageId,loc:astUtils.getFunctionHeadLoc(latterNode.value,sourceCode),data:{formerName:astUtils.getFunctionNameWithKind(formerNode.value),latterName:astUtils.getFunctionNameWithKind(latterNode.value)}});}function createAccessorData(node){const name=astUtils.getStaticPropertyName(node);const key=name!==null?name:sourceCode.getTokens(node.key);return {key,getters:node.kind==="get"?[node]:[],setters:node.kind==="set"?[node]:[]};}function mergeAccessorData(accessors,accessorData){const equalKeyElement=accessors.find(a=>areEqualKeys(a.key,accessorData.key));if(equalKeyElement){equalKeyElement.getters.push(...accessorData.getters);equalKeyElement.setters.push(...accessorData.setters);}else {accessors.push(accessorData);}return accessors;}function checkList(nodes,shouldCheck){const accessors=nodes.filter(shouldCheck).filter(isAccessorKind).map(createAccessorData).reduce(mergeAccessorData,[]);for(const{getters,setters}of accessors){if(getters.length===1&&setters.length===1){const[getter]=getters,[setter]=setters,getterIndex=nodes.indexOf(getter),setterIndex=nodes.indexOf(setter),formerNode=getterIndex<setterIndex?getter:setter,latterNode=getterIndex<setterIndex?setter:getter;if(Math.abs(getterIndex-setterIndex)>1){report("notGrouped",formerNode,latterNode);}else if(order==="getBeforeSet"&&getterIndex>setterIndex||order==="setBeforeGet"&&getterIndex<setterIndex){report("invalidOrder",formerNode,latterNode);}}}}return {ObjectExpression(node){checkList(node.properties,n=>n.type==="Property");},ClassBody(node){checkList(node.body,n=>n.type==="MethodDefinition"&&!n.static);checkList(node.body,n=>n.type==="MethodDefinition"&&n.static);}};}};var guardForIn={meta:{type:"suggestion",docs:{description:"require `for-in` loops to include an `if` statement",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/guard-for-in"},schema:[],messages:{wrap:"The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype."}},create(context){return {ForInStatement(node){const body=node.body;if(body.type==="EmptyStatement"){return;}if(body.type==="IfStatement"){return;}if(body.type==="BlockStatement"&&body.body.length===0){return;}if(body.type==="BlockStatement"&&body.body.length===1&&body.body[0].type==="IfStatement"){return;}if(body.type==="BlockStatement"&&body.body.length>=1&&body.body[0].type==="IfStatement"){const i=body.body[0];if(i.consequent.type==="ContinueStatement"){return;}if(i.consequent.type==="BlockStatement"&&i.consequent.body.length===1&&i.consequent.body[0].type==="ContinueStatement"){return;}}context.report({node,messageId:"wrap"});}};}};var handleCallbackErr={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"require error handling in callbacks",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/handle-callback-err"},schema:[{type:"string"}],messages:{expected:"Expected error to be handled."}},create(context){const errorArgument=context.options[0]||"err";function isPattern(stringToCheck){const firstChar=stringToCheck[0];return firstChar==="^";}function matchesConfiguredErrorName(name){if(isPattern(errorArgument)){const regexp=new RegExp(errorArgument,"u");return regexp.test(name);}return name===errorArgument;}function getParameters(scope){return scope.variables.filter(variable=>variable.defs[0]&&variable.defs[0].type==="Parameter");}function checkForError(node){const scope=context.getScope(),parameters=getParameters(scope),firstParameter=parameters[0];if(firstParameter&&matchesConfiguredErrorName(firstParameter.name)){if(firstParameter.references.length===0){context.report({node,messageId:"expected"});}}}return {FunctionDeclaration:checkForError,FunctionExpression:checkForError,ArrowFunctionExpression:checkForError};}};function isAssignmentTarget$1(node){const parent=node.parent;return parent.type==="AssignmentExpression"&&parent.left===node||parent.type==="ArrayPattern"||parent.type==="RestElement"||parent.type==="Property"&&parent.value===node&&parent.parent.type==="ObjectPattern"||parent.type==="AssignmentPattern"&&parent.left===node;}function isRenamedImport$1(node){const parent=node.parent;return parent.type==="ImportSpecifier"&&parent.imported!==parent.local&&parent.imported===node||parent.type==="ExportSpecifier"&&parent.parent.source&&parent.local!==parent.exported&&parent.local===node;}function isRenamedInDestructuring$1(node){const parent=node.parent;return !parent.computed&&parent.type==="Property"&&parent.parent.type==="ObjectPattern"&&parent.value!==node&&parent.key===node;}function isShorthandPropertyDefinition$1(node){const parent=node.parent;return parent.type==="Property"&&parent.parent.type==="ObjectExpression"&&parent.shorthand;}var idBlacklist={meta:{deprecated:true,replacedBy:["id-denylist"],type:"suggestion",docs:{description:"disallow specified identifiers",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/id-blacklist"},schema:{type:"array",items:{type:"string"},uniqueItems:true},messages:{restricted:"Identifier '{{name}}' is restricted."}},create(context){const denyList=new Set(context.options);const reportedNodes=new Set();let globalScope;function isRestricted(name){return denyList.has(name);}function isReferenceToGlobalVariable(node){const variable=globalScope.set.get(node.name);return variable&&variable.defs.length===0&&variable.references.some(ref=>ref.identifier===node);}function shouldCheck(node){const parent=node.parent;if(parent.type==="MemberExpression"&&parent.property===node&&!parent.computed){return isAssignmentTarget$1(parent);}return parent.type!=="CallExpression"&&parent.type!=="NewExpression"&&!isRenamedImport$1(node)&&!isRenamedInDestructuring$1(node)&&!(isReferenceToGlobalVariable(node)&&!isShorthandPropertyDefinition$1(node));}function report(node){if(!reportedNodes.has(node)){context.report({node,messageId:"restricted",data:{name:node.name}});reportedNodes.add(node);}}return {Program(){globalScope=context.getScope();},Identifier(node){if(isRestricted(node.name)&&shouldCheck(node)){report(node);}}};}};function isAssignmentTarget(node){const parent=node.parent;return parent.type==="AssignmentExpression"&&parent.left===node||parent.type==="ArrayPattern"||parent.type==="RestElement"||parent.type==="Property"&&parent.value===node&&parent.parent.type==="ObjectPattern"||parent.type==="AssignmentPattern"&&parent.left===node;}function isRenamedImport(node){const parent=node.parent;return parent.type==="ImportSpecifier"&&parent.imported!==parent.local&&parent.imported===node||parent.type==="ExportSpecifier"&&parent.parent.source&&parent.local!==parent.exported&&parent.local===node;}function isRenamedInDestructuring(node){const parent=node.parent;return !parent.computed&&parent.type==="Property"&&parent.parent.type==="ObjectPattern"&&parent.value!==node&&parent.key===node;}function isShorthandPropertyDefinition(node){const parent=node.parent;return parent.type==="Property"&&parent.parent.type==="ObjectExpression"&&parent.shorthand;}var idDenylist={meta:{type:"suggestion",docs:{description:"disallow specified identifiers",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/id-denylist"},schema:{type:"array",items:{type:"string"},uniqueItems:true},messages:{restricted:"Identifier '{{name}}' is restricted."}},create(context){const denyList=new Set(context.options);const reportedNodes=new Set();let globalScope;function isRestricted(name){return denyList.has(name);}function isReferenceToGlobalVariable(node){const variable=globalScope.set.get(node.name);return variable&&variable.defs.length===0&&variable.references.some(ref=>ref.identifier===node);}function shouldCheck(node){const parent=node.parent;if(parent.type==="MemberExpression"&&parent.property===node&&!parent.computed){return isAssignmentTarget(parent);}return parent.type!=="CallExpression"&&parent.type!=="NewExpression"&&!isRenamedImport(node)&&!isRenamedInDestructuring(node)&&!(isReferenceToGlobalVariable(node)&&!isShorthandPropertyDefinition(node));}function report(node){if(!reportedNodes.has(node)){context.report({node,messageId:"restricted",data:{name:node.name}});reportedNodes.add(node);}}return {Program(){globalScope=context.getScope();},Identifier(node){if(isRestricted(node.name)&&shouldCheck(node)){report(node);}}};}};var idLength={meta:{type:"suggestion",docs:{description:"enforce minimum and maximum identifier lengths",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/id-length"},schema:[{type:"object",properties:{min:{type:"integer",default:2},max:{type:"integer"},exceptions:{type:"array",uniqueItems:true,items:{type:"string"}},exceptionPatterns:{type:"array",uniqueItems:true,items:{type:"string"}},properties:{enum:["always","never"]}},additionalProperties:false}],messages:{tooShort:"Identifier name '{{name}}' is too short (< {{min}}).",tooLong:"Identifier name '{{name}}' is too long (> {{max}})."}},create(context){const options=context.options[0]||{};const minLength=typeof options.min!=="undefined"?options.min:2;const maxLength=typeof options.max!=="undefined"?options.max:Infinity;const properties=options.properties!=="never";const exceptions=new Set(options.exceptions);const exceptionPatterns=(options.exceptionPatterns||[]).map(pattern=>new RegExp(pattern,"u"));const reportedNode=new Set();function matchesExceptionPattern(name){return exceptionPatterns.some(pattern=>pattern.test(name));}const SUPPORTED_EXPRESSIONS={MemberExpression:properties&&function(parent){return !parent.computed&&(parent.parent.left===parent&&parent.parent.type==="AssignmentExpression"||parent.parent.type==="Property"&&parent.parent.value===parent&&parent.parent.parent.type==="ObjectPattern"&&parent.parent.parent.parent.left===parent.parent.parent);},AssignmentPattern(parent,node){return parent.left===node;},VariableDeclarator(parent,node){return parent.id===node;},Property(parent,node){if(parent.parent.type==="ObjectPattern"){return parent.value!==parent.key&&parent.value===node||parent.value===parent.key&&parent.key===node&&properties;}return properties&&!parent.computed&&parent.key===node;},ImportDefaultSpecifier:true,RestElement:true,FunctionExpression:true,ArrowFunctionExpression:true,ClassDeclaration:true,FunctionDeclaration:true,MethodDefinition:true,CatchClause:true,ArrayPattern:true};return {Identifier(node){const name=node.name;const parent=node.parent;const isShort=name.length<minLength;const isLong=name.length>maxLength;if(!(isShort||isLong)||exceptions.has(name)||matchesExceptionPattern(name)){return;}const isValidExpression=SUPPORTED_EXPRESSIONS[parent.type];if(isValidExpression&&!reportedNode.has(node)&&(isValidExpression===true||isValidExpression(parent,node))){reportedNode.add(node);context.report({node,messageId:isShort?"tooShort":"tooLong",data:{name,min:minLength,max:maxLength}});}}};}};var idMatch={meta:{type:"suggestion",docs:{description:"require identifiers to match a specified regular expression",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/id-match"},schema:[{type:"string"},{type:"object",properties:{properties:{type:"boolean",default:false},onlyDeclarations:{type:"boolean",default:false},ignoreDestructuring:{type:"boolean",default:false}},additionalProperties:false}],messages:{notMatch:"Identifier '{{name}}' does not match the pattern '{{pattern}}'."}},create(context){const pattern=context.options[0]||"^.+$",regexp=new RegExp(pattern,"u");const options=context.options[1]||{},properties=!!options.properties,onlyDeclarations=!!options.onlyDeclarations,ignoreDestructuring=!!options.ignoreDestructuring;const reported=new Map();const ALLOWED_PARENT_TYPES=new Set(["CallExpression","NewExpression"]);const DECLARATION_TYPES=new Set(["FunctionDeclaration","VariableDeclarator"]);const IMPORT_TYPES=new Set(["ImportSpecifier","ImportNamespaceSpecifier","ImportDefaultSpecifier"]);function isInvalid(name){return !regexp.test(name);}function isInsideObjectPattern(node){let{parent}=node;while(parent){if(parent.type==="ObjectPattern"){return true;}parent=parent.parent;}return false;}function shouldReport(effectiveParent,name){return (!onlyDeclarations||DECLARATION_TYPES.has(effectiveParent.type))&&!ALLOWED_PARENT_TYPES.has(effectiveParent.type)&&isInvalid(name);}function report(node){if(!reported.has(node)){context.report({node,messageId:"notMatch",data:{name:node.name,pattern}});reported.set(node,true);}}return {Identifier(node){const name=node.name,parent=node.parent,effectiveParent=parent.type==="MemberExpression"?parent.parent:parent;if(parent.type==="MemberExpression"){if(!properties){return;}if(parent.object.type==="Identifier"&&parent.object.name===name){if(isInvalid(name)){report(node);}}else if(effectiveParent.type==="AssignmentExpression"&&effectiveParent.left.type==="MemberExpression"&&effectiveParent.left.property.name===node.name){if(isInvalid(name)){report(node);}}else if(effectiveParent.type==="AssignmentExpression"&&effectiveParent.right.type!=="MemberExpression"){if(isInvalid(name)){report(node);}}}else if(parent.type==="Property"||parent.type==="AssignmentPattern"){if(parent.parent&&parent.parent.type==="ObjectPattern"){if(parent.shorthand&&parent.value.left&&isInvalid(name)){report(node);}const assignmentKeyEqualsValue=parent.key.name===parent.value.name;if(!assignmentKeyEqualsValue&&parent.key===node){return;}const valueIsInvalid=parent.value.name&&isInvalid(name);if(valueIsInvalid&&!(assignmentKeyEqualsValue&&ignoreDestructuring)){report(node);}}if(!properties||ignoreDestructuring&&isInsideObjectPattern(node)){return;}if(parent.right!==node&&shouldReport(effectiveParent,name)){report(node);}}else if(IMPORT_TYPES.has(parent.type)){if(parent.local&&parent.local.name===node.name&&isInvalid(name)){report(node);}}else if(shouldReport(effectiveParent,name)){report(node);}}};}};const{isCommentToken,isNotOpeningParenToken}=astUtils;var implicitArrowLinebreak={meta:{type:"layout",docs:{description:"enforce the location of arrow function bodies",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/implicit-arrow-linebreak"},fixable:"whitespace",schema:[{enum:["beside","below"]}],messages:{expected:"Expected a linebreak before this expression.",unexpected:"Expected no linebreak before this expression."}},create(context){const sourceCode=context.getSourceCode();const option=context.options[0]||"beside";function validateExpression(node){if(node.body.type==="BlockStatement"){return;}const arrowToken=sourceCode.getTokenBefore(node.body,isNotOpeningParenToken);const firstTokenOfBody=sourceCode.getTokenAfter(arrowToken);if(arrowToken.loc.end.line===firstTokenOfBody.loc.start.line&&option==="below"){context.report({node:firstTokenOfBody,messageId:"expected",fix:fixer=>fixer.insertTextBefore(firstTokenOfBody,"\n")});}else if(arrowToken.loc.end.line!==firstTokenOfBody.loc.start.line&&option==="beside"){context.report({node:firstTokenOfBody,messageId:"unexpected",fix(fixer){if(sourceCode.getFirstTokenBetween(arrowToken,firstTokenOfBody,{includeComments:true,filter:isCommentToken})){return null;}return fixer.replaceTextRange([arrowToken.range[1],firstTokenOfBody.range[0]]," ");}});}}return {ArrowFunctionExpression:node=>validateExpression(node)};}};var indentLegacy={meta:{type:"layout",docs:{description:"enforce consistent indentation",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/indent-legacy"},deprecated:true,replacedBy:["indent"],fixable:"whitespace",schema:[{oneOf:[{enum:["tab"]},{type:"integer",minimum:0}]},{type:"object",properties:{SwitchCase:{type:"integer",minimum:0},VariableDeclarator:{oneOf:[{type:"integer",minimum:0},{type:"object",properties:{var:{type:"integer",minimum:0},let:{type:"integer",minimum:0},const:{type:"integer",minimum:0}}}]},outerIIFEBody:{type:"integer",minimum:0},MemberExpression:{type:"integer",minimum:0},FunctionDeclaration:{type:"object",properties:{parameters:{oneOf:[{type:"integer",minimum:0},{enum:["first"]}]},body:{type:"integer",minimum:0}}},FunctionExpression:{type:"object",properties:{parameters:{oneOf:[{type:"integer",minimum:0},{enum:["first"]}]},body:{type:"integer",minimum:0}}},CallExpression:{type:"object",properties:{parameters:{oneOf:[{type:"integer",minimum:0},{enum:["first"]}]}}},ArrayExpression:{oneOf:[{type:"integer",minimum:0},{enum:["first"]}]},ObjectExpression:{oneOf:[{type:"integer",minimum:0},{enum:["first"]}]}},additionalProperties:false}],messages:{expected:"Expected indentation of {{expected}} but found {{actual}}."}},create(context){const DEFAULT_PARAMETER_INDENT=null;let indentType="space";let indentSize=4;const options={SwitchCase:0,VariableDeclarator:{var:1,let:1,const:1},outerIIFEBody:null,FunctionDeclaration:{parameters:DEFAULT_PARAMETER_INDENT,body:1},FunctionExpression:{parameters:DEFAULT_PARAMETER_INDENT,body:1},CallExpression:{arguments:DEFAULT_PARAMETER_INDENT},ArrayExpression:1,ObjectExpression:1};const sourceCode=context.getSourceCode();if(context.options.length){if(context.options[0]==="tab"){indentSize=1;indentType="tab";}else if(typeof context.options[0]==="number"){indentSize=context.options[0];indentType="space";}if(context.options[1]){const opts=context.options[1];options.SwitchCase=opts.SwitchCase||0;const variableDeclaratorRules=opts.VariableDeclarator;if(typeof variableDeclaratorRules==="number"){options.VariableDeclarator={var:variableDeclaratorRules,let:variableDeclaratorRules,const:variableDeclaratorRules};}else if(typeof variableDeclaratorRules==="object"){Object.assign(options.VariableDeclarator,variableDeclaratorRules);}if(typeof opts.outerIIFEBody==="number"){options.outerIIFEBody=opts.outerIIFEBody;}if(typeof opts.MemberExpression==="number"){options.MemberExpression=opts.MemberExpression;}if(typeof opts.FunctionDeclaration==="object"){Object.assign(options.FunctionDeclaration,opts.FunctionDeclaration);}if(typeof opts.FunctionExpression==="object"){Object.assign(options.FunctionExpression,opts.FunctionExpression);}if(typeof opts.CallExpression==="object"){Object.assign(options.CallExpression,opts.CallExpression);}if(typeof opts.ArrayExpression==="number"||typeof opts.ArrayExpression==="string"){options.ArrayExpression=opts.ArrayExpression;}if(typeof opts.ObjectExpression==="number"||typeof opts.ObjectExpression==="string"){options.ObjectExpression=opts.ObjectExpression;}}}const caseIndentStore={};function createErrorMessageData(expectedAmount,actualSpaces,actualTabs){const expectedStatement=`${expectedAmount} ${indentType}${expectedAmount===1?"":"s"}`;const foundSpacesWord=`space${actualSpaces===1?"":"s"}`;const foundTabsWord=`tab${actualTabs===1?"":"s"}`;let foundStatement;if(actualSpaces>0&&actualTabs>0){foundStatement=`${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`;}else if(actualSpaces>0){foundStatement=indentType==="space"?actualSpaces:`${actualSpaces} ${foundSpacesWord}`;}else if(actualTabs>0){foundStatement=indentType==="tab"?actualTabs:`${actualTabs} ${foundTabsWord}`;}else {foundStatement="0";}return {expected:expectedStatement,actual:foundStatement};}function report(node,needed,gottenSpaces,gottenTabs,loc,isLastNodeCheck){if(gottenSpaces&&gottenTabs){return;}const desiredIndent=(indentType==="space"?" ":"\t").repeat(needed);const textRange=isLastNodeCheck?[node.range[1]-node.loc.end.column,node.range[1]-node.loc.end.column+gottenSpaces+gottenTabs]:[node.range[0]-node.loc.start.column,node.range[0]-node.loc.start.column+gottenSpaces+gottenTabs];context.report({node,loc,messageId:"expected",data:createErrorMessageData(needed,gottenSpaces,gottenTabs),fix:fixer=>fixer.replaceTextRange(textRange,desiredIndent)});}function getNodeIndent(node,byLastLine){const token=byLastLine?sourceCode.getLastToken(node):sourceCode.getFirstToken(node);const srcCharsBeforeNode=sourceCode.getText(token,token.loc.start.column).split("");const indentChars=srcCharsBeforeNode.slice(0,srcCharsBeforeNode.findIndex(char=>char!==" "&&char!=="\t"));const spaces=indentChars.filter(char=>char===" ").length;const tabs=indentChars.filter(char=>char==="\t").length;return {space:spaces,tab:tabs,goodChar:indentType==="space"?spaces:tabs,badChar:indentType==="space"?tabs:spaces};}function isNodeFirstInLine(node,byEndLocation){const firstToken=byEndLocation===true?sourceCode.getLastToken(node,1):sourceCode.getTokenBefore(node),startLine=byEndLocation===true?node.loc.end.line:node.loc.start.line,endLine=firstToken?firstToken.loc.end.line:-1;return startLine!==endLine;}function checkNodeIndent(node,neededIndent){const actualIndent=getNodeIndent(node,false);if(node.type!=="ArrayExpression"&&node.type!=="ObjectExpression"&&(actualIndent.goodChar!==neededIndent||actualIndent.badChar!==0)&&isNodeFirstInLine(node)){report(node,neededIndent,actualIndent.space,actualIndent.tab);}if(node.type==="IfStatement"&&node.alternate){const elseToken=sourceCode.getTokenBefore(node.alternate);checkNodeIndent(elseToken,neededIndent);if(!isNodeFirstInLine(node.alternate)){checkNodeIndent(node.alternate,neededIndent);}}if(node.type==="TryStatement"&&node.handler){const catchToken=sourceCode.getFirstToken(node.handler);checkNodeIndent(catchToken,neededIndent);}if(node.type==="TryStatement"&&node.finalizer){const finallyToken=sourceCode.getTokenBefore(node.finalizer);checkNodeIndent(finallyToken,neededIndent);}if(node.type==="DoWhileStatement"){const whileToken=sourceCode.getTokenAfter(node.body);checkNodeIndent(whileToken,neededIndent);}}function checkNodesIndent(nodes,indent){nodes.forEach(node=>checkNodeIndent(node,indent));}function checkLastNodeLineIndent(node,lastLineIndent){const lastToken=sourceCode.getLastToken(node);const endIndent=getNodeIndent(lastToken,true);if((endIndent.goodChar!==lastLineIndent||endIndent.badChar!==0)&&isNodeFirstInLine(node,true)){report(node,lastLineIndent,endIndent.space,endIndent.tab,{line:lastToken.loc.start.line,column:lastToken.loc.start.column},true);}}function checkLastReturnStatementLineIndent(node,firstLineIndent){const lastToken=sourceCode.getLastToken(node,astUtils.isClosingParenToken);const textBeforeClosingParenthesis=sourceCode.getText(lastToken,lastToken.loc.start.column).slice(0,-1);if(textBeforeClosingParenthesis.trim()){return;}const endIndent=getNodeIndent(lastToken,true);if(endIndent.goodChar!==firstLineIndent){report(node,firstLineIndent,endIndent.space,endIndent.tab,{line:lastToken.loc.start.line,column:lastToken.loc.start.column},true);}}function checkFirstNodeLineIndent(node,firstLineIndent){const startIndent=getNodeIndent(node,false);if((startIndent.goodChar!==firstLineIndent||startIndent.badChar!==0)&&isNodeFirstInLine(node)){report(node,firstLineIndent,startIndent.space,startIndent.tab,{line:node.loc.start.line,column:node.loc.start.column});}}function getParentNodeByType(node,type,stopAtList){let parent=node.parent;const stopAtSet=new Set(stopAtList||["Program"]);while(parent.type!==type&&!stopAtSet.has(parent.type)&&parent.type!=="Program"){parent=parent.parent;}return parent.type===type?parent:null;}function getVariableDeclaratorNode(node){return getParentNodeByType(node,"VariableDeclarator");}function isNodeInVarOnTop(node,varNode){return varNode&&varNode.parent.loc.start.line===node.loc.start.line&&varNode.parent.declarations.length>1;}function isArgBeforeCalleeNodeMultiline(node){const parent=node.parent;if(parent.arguments.length>=2&&parent.arguments[1]===node){return parent.arguments[0].loc.end.line>parent.arguments[0].loc.start.line;}return false;}function isOuterIIFE(node){const parent=node.parent;let stmt=parent.parent;if(parent.type!=="CallExpression"||parent.callee!==node){return false;}while(stmt.type==="UnaryExpression"&&(stmt.operator==="!"||stmt.operator==="~"||stmt.operator==="+"||stmt.operator==="-")||stmt.type==="AssignmentExpression"||stmt.type==="LogicalExpression"||stmt.type==="SequenceExpression"||stmt.type==="VariableDeclarator"){stmt=stmt.parent;}return (stmt.type==="ExpressionStatement"||stmt.type==="VariableDeclaration")&&stmt.parent&&stmt.parent.type==="Program";}function checkIndentInFunctionBlock(node){const calleeNode=node.parent;let indent;if(calleeNode.parent&&(calleeNode.parent.type==="Property"||calleeNode.parent.type==="ArrayExpression")){indent=getNodeIndent(calleeNode,false).goodChar;}else {indent=getNodeIndent(calleeNode).goodChar;}if(calleeNode.parent.type==="CallExpression"){const calleeParent=calleeNode.parent;if(calleeNode.type!=="FunctionExpression"&&calleeNode.type!=="ArrowFunctionExpression"){if(calleeParent&&calleeParent.loc.start.line<node.loc.start.line){indent=getNodeIndent(calleeParent).goodChar;}}else {if(isArgBeforeCalleeNodeMultiline(calleeNode)&&calleeParent.callee.loc.start.line===calleeParent.callee.loc.end.line&&!isNodeFirstInLine(calleeNode)){indent=getNodeIndent(calleeParent).goodChar;}}}let functionOffset=indentSize;if(options.outerIIFEBody!==null&&isOuterIIFE(calleeNode)){functionOffset=options.outerIIFEBody*indentSize;}else if(calleeNode.type==="FunctionExpression"){functionOffset=options.FunctionExpression.body*indentSize;}else if(calleeNode.type==="FunctionDeclaration"){functionOffset=options.FunctionDeclaration.body*indentSize;}indent+=functionOffset;const parentVarNode=getVariableDeclaratorNode(node);if(parentVarNode&&isNodeInVarOnTop(node,parentVarNode)){indent+=indentSize*options.VariableDeclarator[parentVarNode.parent.kind];}if(node.body.length>0){checkNodesIndent(node.body,indent);}checkLastNodeLineIndent(node,indent-functionOffset);}function isSingleLineNode(node){const lastToken=sourceCode.getLastToken(node),startLine=node.loc.start.line,endLine=lastToken.loc.end.line;return startLine===endLine;}function checkIndentInArrayOrObjectBlock(node){if(isSingleLineNode(node)){return;}let elements=node.type==="ArrayExpression"?node.elements:node.properties;elements=elements.filter(elem=>elem!==null);let nodeIndent;let elementsIndent;const parentVarNode=getVariableDeclaratorNode(node);if(isNodeFirstInLine(node)){const parent=node.parent;nodeIndent=getNodeIndent(parent).goodChar;if(!parentVarNode||parentVarNode.loc.start.line!==node.loc.start.line){if(parent.type!=="VariableDeclarator"||parentVarNode===parentVarNode.parent.declarations[0]){if(parent.type==="VariableDeclarator"&&parentVarNode.loc.start.line===parent.loc.start.line){nodeIndent+=indentSize*options.VariableDeclarator[parentVarNode.parent.kind];}else if(parent.type==="ObjectExpression"||parent.type==="ArrayExpression"){const parentElements=node.parent.type==="ObjectExpression"?node.parent.properties:node.parent.elements;if(parentElements[0]&&parentElements[0].loc.start.line===parent.loc.start.line&&parentElements[0].loc.end.line!==parent.loc.start.line);else if(typeof options[parent.type]==="number"){nodeIndent+=options[parent.type]*indentSize;}else {nodeIndent=parentElements[0].loc.start.column;}}else if(parent.type==="CallExpression"||parent.type==="NewExpression"){if(typeof options.CallExpression.arguments==="number"){nodeIndent+=options.CallExpression.arguments*indentSize;}else if(options.CallExpression.arguments==="first"){if(parent.arguments.indexOf(node)!==-1){nodeIndent=parent.arguments[0].loc.start.column;}}else {nodeIndent+=indentSize;}}else if(parent.type==="LogicalExpression"||parent.type==="ArrowFunctionExpression"){nodeIndent+=indentSize;}}}checkFirstNodeLineIndent(node,nodeIndent);}else {nodeIndent=getNodeIndent(node).goodChar;}if(options[node.type]==="first"){elementsIndent=elements.length?elements[0].loc.start.column:0;}else {elementsIndent=nodeIndent+indentSize*options[node.type];}if(isNodeInVarOnTop(node,parentVarNode)){elementsIndent+=indentSize*options.VariableDeclarator[parentVarNode.parent.kind];}checkNodesIndent(elements,elementsIndent);if(elements.length>0){if(elements[elements.length-1].loc.end.line===node.loc.end.line){return;}}checkLastNodeLineIndent(node,nodeIndent+(isNodeInVarOnTop(node,parentVarNode)?options.VariableDeclarator[parentVarNode.parent.kind]*indentSize:0));}function isNodeBodyBlock(node){return node.type==="BlockStatement"||node.type==="ClassBody"||node.body&&node.body.type==="BlockStatement"||node.consequent&&node.consequent.type==="BlockStatement";}function blockIndentationCheck(node){if(isSingleLineNode(node)){return;}if(node.parent&&(node.parent.type==="FunctionExpression"||node.parent.type==="FunctionDeclaration"||node.parent.type==="ArrowFunctionExpression")){checkIndentInFunctionBlock(node);return;}let indent;let nodesToCheck=[];if(node.parent&&["IfStatement","WhileStatement","ForStatement","ForInStatement","ForOfStatement","DoWhileStatement","ClassDeclaration","TryStatement"].indexOf(node.parent.type)!==-1&&isNodeBodyBlock(node)){indent=getNodeIndent(node.parent).goodChar;}else if(node.parent&&node.parent.type==="CatchClause"){indent=getNodeIndent(node.parent.parent).goodChar;}else {indent=getNodeIndent(node).goodChar;}if(node.type==="IfStatement"&&node.consequent.type!=="BlockStatement"){nodesToCheck=[node.consequent];}else if(Array.isArray(node.body)){nodesToCheck=node.body;}else {nodesToCheck=[node.body];}if(nodesToCheck.length>0){checkNodesIndent(nodesToCheck,indent+indentSize);}if(node.type==="BlockStatement"){checkLastNodeLineIndent(node,indent);}}function filterOutSameLineVars(node){return node.declarations.reduce((finalCollection,elem)=>{const lastElem=finalCollection[finalCollection.length-1];if(elem.loc.start.line!==node.loc.start.line&&!lastElem||lastElem&&lastElem.loc.start.line!==elem.loc.start.line){finalCollection.push(elem);}return finalCollection;},[]);}function checkIndentInVariableDeclarations(node){const elements=filterOutSameLineVars(node);const nodeIndent=getNodeIndent(node).goodChar;const lastElement=elements[elements.length-1];const elementsIndent=nodeIndent+indentSize*options.VariableDeclarator[node.kind];checkNodesIndent(elements,elementsIndent);if(sourceCode.getLastToken(node).loc.end.line<=lastElement.loc.end.line){return;}const tokenBeforeLastElement=sourceCode.getTokenBefore(lastElement);if(tokenBeforeLastElement.value===","){checkLastNodeLineIndent(node,getNodeIndent(tokenBeforeLastElement).goodChar);}else {checkLastNodeLineIndent(node,elementsIndent-indentSize);}}function blockLessNodes(node){if(node.body.type!=="BlockStatement"){blockIndentationCheck(node);}}function expectedCaseIndent(node,providedSwitchIndent){const switchNode=node.type==="SwitchStatement"?node:node.parent;const switchIndent=typeof providedSwitchIndent==="undefined"?getNodeIndent(switchNode).goodChar:providedSwitchIndent;let caseIndent;if(caseIndentStore[switchNode.loc.start.line]){return caseIndentStore[switchNode.loc.start.line];}if(switchNode.cases.length>0&&options.SwitchCase===0){caseIndent=switchIndent;}else {caseIndent=switchIndent+indentSize*options.SwitchCase;}caseIndentStore[switchNode.loc.start.line]=caseIndent;return caseIndent;}function isWrappedInParenthesis(node){const statementWithoutArgument=sourceCode.getText(node).replace(sourceCode.getText(node.argument),"");return /^return\s*?\(\s*?\);*?/u.test(statementWithoutArgument);}return {Program(node){if(node.body.length>0){checkNodesIndent(node.body,getNodeIndent(node).goodChar);}},ClassBody:blockIndentationCheck,BlockStatement:blockIndentationCheck,WhileStatement:blockLessNodes,ForStatement:blockLessNodes,ForInStatement:blockLessNodes,ForOfStatement:blockLessNodes,DoWhileStatement:blockLessNodes,IfStatement(node){if(node.consequent.type!=="BlockStatement"&&node.consequent.loc.start.line>node.loc.start.line){blockIndentationCheck(node);}},VariableDeclaration(node){if(node.declarations[node.declarations.length-1].loc.start.line>node.declarations[0].loc.start.line){checkIndentInVariableDeclarations(node);}},ObjectExpression(node){checkIndentInArrayOrObjectBlock(node);},ArrayExpression(node){checkIndentInArrayOrObjectBlock(node);},MemberExpression(node){if(typeof options.MemberExpression==="undefined"){return;}if(isSingleLineNode(node)){return;}if(getParentNodeByType(node,"VariableDeclarator",["FunctionExpression","ArrowFunctionExpression"])){return;}if(getParentNodeByType(node,"AssignmentExpression",["FunctionExpression"])){return;}const propertyIndent=getNodeIndent(node).goodChar+indentSize*options.MemberExpression;const checkNodes=[node.property];const dot=sourceCode.getTokenBefore(node.property);if(dot.type==="Punctuator"&&dot.value==="."){checkNodes.push(dot);}checkNodesIndent(checkNodes,propertyIndent);},SwitchStatement(node){const switchIndent=getNodeIndent(node).goodChar;const caseIndent=expectedCaseIndent(node,switchIndent);checkNodesIndent(node.cases,caseIndent);checkLastNodeLineIndent(node,switchIndent);},SwitchCase(node){if(isSingleLineNode(node)){return;}const caseIndent=expectedCaseIndent(node);checkNodesIndent(node.consequent,caseIndent+indentSize);},FunctionDeclaration(node){if(isSingleLineNode(node)){return;}if(options.FunctionDeclaration.parameters==="first"&&node.params.length){checkNodesIndent(node.params.slice(1),node.params[0].loc.start.column);}else if(options.FunctionDeclaration.parameters!==null){checkNodesIndent(node.params,getNodeIndent(node).goodChar+indentSize*options.FunctionDeclaration.parameters);}},FunctionExpression(node){if(isSingleLineNode(node)){return;}if(options.FunctionExpression.parameters==="first"&&node.params.length){checkNodesIndent(node.params.slice(1),node.params[0].loc.start.column);}else if(options.FunctionExpression.parameters!==null){checkNodesIndent(node.params,getNodeIndent(node).goodChar+indentSize*options.FunctionExpression.parameters);}},ReturnStatement(node){if(isSingleLineNode(node)){return;}const firstLineIndent=getNodeIndent(node).goodChar;if(isWrappedInParenthesis(node)){checkLastReturnStatementLineIndent(node,firstLineIndent);}else {checkNodeIndent(node,firstLineIndent);}},CallExpression(node){if(isSingleLineNode(node)){return;}if(options.CallExpression.arguments==="first"&&node.arguments.length){checkNodesIndent(node.arguments.slice(1),node.arguments[0].loc.start.column);}else if(options.CallExpression.arguments!==null){checkNodesIndent(node.arguments,getNodeIndent(node).goodChar+indentSize*options.CallExpression.arguments);}}};}};const KNOWN_NODES=new Set(["AssignmentExpression","AssignmentPattern","ArrayExpression","ArrayPattern","ArrowFunctionExpression","AwaitExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ChainExpression","ClassBody","ClassDeclaration","ClassExpression","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExperimentalRestProperty","ExperimentalSpreadProperty","ExpressionStatement","ForStatement","ForInStatement","ForOfStatement","FunctionDeclaration","FunctionExpression","Identifier","IfStatement","Literal","LabeledStatement","LogicalExpression","MemberExpression","MetaProperty","MethodDefinition","NewExpression","ObjectExpression","ObjectPattern","Program","Property","RestElement","ReturnStatement","SequenceExpression","SpreadElement","Super","SwitchCase","SwitchStatement","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","JSXFragment","JSXOpeningFragment","JSXClosingFragment","JSXIdentifier","JSXNamespacedName","JSXMemberExpression","JSXEmptyExpression","JSXExpressionContainer","JSXElement","JSXClosingElement","JSXOpeningElement","JSXAttribute","JSXSpreadAttribute","JSXText","ExportDefaultDeclaration","ExportNamedDeclaration","ExportAllDeclaration","ExportSpecifier","ImportDeclaration","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportExpression"]);class BinarySearchTree{constructor(){this._rbTree=functionalRedBlackTree__default['default']();}insert(key,value){const iterator=this._rbTree.find(key);if(iterator.valid){this._rbTree=iterator.update(value);}else {this._rbTree=this._rbTree.insert(key,value);}}findLe(key){const iterator=this._rbTree.le(key);return iterator&&{key:iterator.key,value:iterator.value};}deleteRange(start,end){if(start===end){return;}const iterator=this._rbTree.ge(start);while(iterator.valid&&iterator.key<end){this._rbTree=this._rbTree.remove(iterator.key);iterator.next();}}}class TokenInfo{constructor(sourceCode){this.sourceCode=sourceCode;this.firstTokensByLineNumber=sourceCode.tokensAndComments.reduce((map,token)=>{if(!map.has(token.loc.start.line)){map.set(token.loc.start.line,token);}if(!map.has(token.loc.end.line)&&sourceCode.text.slice(token.range[1]-token.loc.end.column,token.range[1]).trim()){map.set(token.loc.end.line,token);}return map;},new Map());}getFirstTokenOfLine(token){return this.firstTokensByLineNumber.get(token.loc.start.line);}isFirstTokenOfLine(token){return this.getFirstTokenOfLine(token)===token;}getTokenIndent(token){return this.sourceCode.text.slice(token.range[0]-token.loc.start.column,token.range[0]);}}class OffsetStorage{constructor(tokenInfo,indentSize,indentType){this._tokenInfo=tokenInfo;this._indentSize=indentSize;this._indentType=indentType;this._tree=new BinarySearchTree();this._tree.insert(0,{offset:0,from:null,force:false});this._lockedFirstTokens=new WeakMap();this._desiredIndentCache=new WeakMap();this._ignoredTokens=new WeakSet();}_getOffsetDescriptor(token){return this._tree.findLe(token.range[0]).value;}matchOffsetOf(baseToken,offsetToken){this._lockedFirstTokens.set(offsetToken,baseToken);}setDesiredOffset(token,fromToken,offset){return this.setDesiredOffsets(token.range,fromToken,offset);}setDesiredOffsets(range,fromToken,offset,force){const descriptorToInsert={offset,from:fromToken,force};const descriptorAfterRange=this._tree.findLe(range[1]).value;const fromTokenIsInRange=fromToken&&fromToken.range[0]>=range[0]&&fromToken.range[1]<=range[1];const fromTokenDescriptor=fromTokenIsInRange&&this._getOffsetDescriptor(fromToken);this._tree.deleteRange(range[0]+1,range[1]);this._tree.insert(range[0],descriptorToInsert);if(fromTokenIsInRange){this._tree.insert(fromToken.range[0],fromTokenDescriptor);this._tree.insert(fromToken.range[1],descriptorToInsert);}this._tree.insert(range[1],descriptorAfterRange);}getDesiredIndent(token){if(!this._desiredIndentCache.has(token)){if(this._ignoredTokens.has(token)){this._desiredIndentCache.set(token,this._tokenInfo.getTokenIndent(token));}else if(this._lockedFirstTokens.has(token)){const firstToken=this._lockedFirstTokens.get(token);this._desiredIndentCache.set(token,this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken))+this._indentType.repeat(firstToken.loc.start.column-this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));}else {const offsetInfo=this._getOffsetDescriptor(token);const offset=offsetInfo.from&&offsetInfo.from.loc.start.line===token.loc.start.line&&!/^\s*?\n/u.test(token.value)&&!offsetInfo.force?0:offsetInfo.offset*this._indentSize;this._desiredIndentCache.set(token,(offsetInfo.from?this.getDesiredIndent(offsetInfo.from):"")+this._indentType.repeat(offset));}}return this._desiredIndentCache.get(token);}ignoreToken(token){if(this._tokenInfo.isFirstTokenOfLine(token)){this._ignoredTokens.add(token);}}getFirstDependency(token){return this._getOffsetDescriptor(token).from;}}const ELEMENT_LIST_SCHEMA={oneOf:[{type:"integer",minimum:0},{enum:["first","off"]}]};var indent={meta:{type:"layout",docs:{description:"enforce consistent indentation",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/indent"},fixable:"whitespace",schema:[{oneOf:[{enum:["tab"]},{type:"integer",minimum:0}]},{type:"object",properties:{SwitchCase:{type:"integer",minimum:0,default:0},VariableDeclarator:{oneOf:[ELEMENT_LIST_SCHEMA,{type:"object",properties:{var:ELEMENT_LIST_SCHEMA,let:ELEMENT_LIST_SCHEMA,const:ELEMENT_LIST_SCHEMA},additionalProperties:false}]},outerIIFEBody:{oneOf:[{type:"integer",minimum:0},{enum:["off"]}]},MemberExpression:{oneOf:[{type:"integer",minimum:0},{enum:["off"]}]},FunctionDeclaration:{type:"object",properties:{parameters:ELEMENT_LIST_SCHEMA,body:{type:"integer",minimum:0}},additionalProperties:false},FunctionExpression:{type:"object",properties:{parameters:ELEMENT_LIST_SCHEMA,body:{type:"integer",minimum:0}},additionalProperties:false},CallExpression:{type:"object",properties:{arguments:ELEMENT_LIST_SCHEMA},additionalProperties:false},ArrayExpression:ELEMENT_LIST_SCHEMA,ObjectExpression:ELEMENT_LIST_SCHEMA,ImportDeclaration:ELEMENT_LIST_SCHEMA,flatTernaryExpressions:{type:"boolean",default:false},offsetTernaryExpressions:{type:"boolean",default:false},ignoredNodes:{type:"array",items:{type:"string",not:{pattern:":exit$"}}},ignoreComments:{type:"boolean",default:false}},additionalProperties:false}],messages:{wrongIndentation:"Expected indentation of {{expected}} but found {{actual}}."}},create(context){const DEFAULT_VARIABLE_INDENT=1;let indentType="space";let indentSize=4;const options={SwitchCase:0,VariableDeclarator:{var:1,let:1,const:1},outerIIFEBody:1,FunctionDeclaration:{parameters:1,body:1},FunctionExpression:{parameters:1,body:1},CallExpression:{arguments:1},MemberExpression:1,ArrayExpression:1,ObjectExpression:1,ImportDeclaration:1,flatTernaryExpressions:false,ignoredNodes:[],ignoreComments:false};if(context.options.length){if(context.options[0]==="tab"){indentSize=1;indentType="tab";}else {indentSize=context.options[0];indentType="space";}if(context.options[1]){Object.assign(options,context.options[1]);if(typeof options.VariableDeclarator==="number"||options.VariableDeclarator==="first"){options.VariableDeclarator={var:options.VariableDeclarator,let:options.VariableDeclarator,const:options.VariableDeclarator};}}}const sourceCode=context.getSourceCode();const tokenInfo=new TokenInfo(sourceCode);const offsets=new OffsetStorage(tokenInfo,indentSize,indentType==="space"?" ":"\t");const parameterParens=new WeakSet();function createErrorMessageData(expectedAmount,actualSpaces,actualTabs){const expectedStatement=`${expectedAmount} ${indentType}${expectedAmount===1?"":"s"}`;const foundSpacesWord=`space${actualSpaces===1?"":"s"}`;const foundTabsWord=`tab${actualTabs===1?"":"s"}`;let foundStatement;if(actualSpaces>0){foundStatement=indentType==="space"?actualSpaces:`${actualSpaces} ${foundSpacesWord}`;}else if(actualTabs>0){foundStatement=indentType==="tab"?actualTabs:`${actualTabs} ${foundTabsWord}`;}else {foundStatement="0";}return {expected:expectedStatement,actual:foundStatement};}function report(token,neededIndent){const actualIndent=Array.from(tokenInfo.getTokenIndent(token));const numSpaces=actualIndent.filter(char=>char===" ").length;const numTabs=actualIndent.filter(char=>char==="\t").length;context.report({node:token,messageId:"wrongIndentation",data:createErrorMessageData(neededIndent.length,numSpaces,numTabs),loc:{start:{line:token.loc.start.line,column:0},end:{line:token.loc.start.line,column:token.loc.start.column}},fix(fixer){const range=[token.range[0]-token.loc.start.column,token.range[0]];return fixer.replaceTextRange(range,neededIndent);}});}function validateTokenIndent(token,desiredIndent){const indentation=tokenInfo.getTokenIndent(token);return indentation===desiredIndent||indentation.includes(" ")&&indentation.includes("\t");}function isOuterIIFE(node){if(!node.parent||node.parent.type!=="CallExpression"||node.parent.callee!==node){return false;}let statement=node.parent&&node.parent.parent;while(statement.type==="UnaryExpression"&&["!","~","+","-"].indexOf(statement.operator)>-1||statement.type==="AssignmentExpression"||statement.type==="LogicalExpression"||statement.type==="SequenceExpression"||statement.type==="VariableDeclarator"){statement=statement.parent;}return (statement.type==="ExpressionStatement"||statement.type==="VariableDeclaration")&&statement.parent.type==="Program";}function countTrailingLinebreaks(string){const trailingWhitespace=string.match(/\s*$/u)[0];const linebreakMatches=trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());return linebreakMatches===null?0:linebreakMatches.length;}function addElementListIndent(elements,startToken,endToken,offset){function getFirstToken(element){let token=sourceCode.getTokenBefore(element);while(astUtils.isOpeningParenToken(token)&&token!==startToken){token=sourceCode.getTokenBefore(token);}return sourceCode.getTokenAfter(token);}offsets.setDesiredOffsets([startToken.range[1],endToken.range[0]],startToken,typeof offset==="number"?offset:1);offsets.setDesiredOffset(endToken,startToken,0);if(offset==="first"&&elements.length&&!elements[0]){return;}elements.forEach((element,index)=>{if(!element){return;}if(offset==="off"){offsets.ignoreToken(getFirstToken(element));}if(index===0){return;}if(offset==="first"&&tokenInfo.isFirstTokenOfLine(getFirstToken(element))){offsets.matchOffsetOf(getFirstToken(elements[0]),getFirstToken(element));}else {const previousElement=elements[index-1];const firstTokenOfPreviousElement=previousElement&&getFirstToken(previousElement);const previousElementLastToken=previousElement&&sourceCode.getLastToken(previousElement);if(previousElement&&previousElementLastToken.loc.end.line-countTrailingLinebreaks(previousElementLastToken.value)>startToken.loc.end.line){offsets.setDesiredOffsets([previousElement.range[1],element.range[1]],firstTokenOfPreviousElement,0);}}});}function addBlocklessNodeIndent(node){if(node.type!=="BlockStatement"){const lastParentToken=sourceCode.getTokenBefore(node,astUtils.isNotOpeningParenToken);let firstBodyToken=sourceCode.getFirstToken(node);let lastBodyToken=sourceCode.getLastToken(node);while(astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken))&&astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))){firstBodyToken=sourceCode.getTokenBefore(firstBodyToken);lastBodyToken=sourceCode.getTokenAfter(lastBodyToken);}offsets.setDesiredOffsets([firstBodyToken.range[0],lastBodyToken.range[1]],lastParentToken,1);const lastToken=sourceCode.getLastToken(node);if(node.type!=="EmptyStatement"&&astUtils.isSemicolonToken(lastToken)){offsets.setDesiredOffset(lastToken,lastParentToken,0);}}}function addFunctionCallIndent(node){let openingParen;if(node.arguments.length){openingParen=sourceCode.getFirstTokenBetween(node.callee,node.arguments[0],astUtils.isOpeningParenToken);}else {openingParen=sourceCode.getLastToken(node,1);}const closingParen=sourceCode.getLastToken(node);parameterParens.add(openingParen);parameterParens.add(closingParen);if(node.optional){const dotToken=sourceCode.getTokenAfter(node.callee,astUtils.isQuestionDotToken);const calleeParenCount=sourceCode.getTokensBetween(node.callee,dotToken,{filter:astUtils.isClosingParenToken}).length;const firstTokenOfCallee=calleeParenCount?sourceCode.getTokenBefore(node.callee,{skip:calleeParenCount-1}):sourceCode.getFirstToken(node.callee);const lastTokenOfCallee=sourceCode.getTokenBefore(dotToken);const offsetBase=lastTokenOfCallee.loc.end.line===openingParen.loc.start.line?lastTokenOfCallee:firstTokenOfCallee;offsets.setDesiredOffset(dotToken,offsetBase,1);}const offsetAfterToken=node.callee.type==="TaggedTemplateExpression"?sourceCode.getFirstToken(node.callee.quasi):openingParen;const offsetToken=sourceCode.getTokenBefore(offsetAfterToken);offsets.setDesiredOffset(openingParen,offsetToken,0);addElementListIndent(node.arguments,openingParen,closingParen,options.CallExpression.arguments);}function addParensIndent(tokens){const parenStack=[];const parenPairs=[];tokens.forEach(nextToken=>{if(astUtils.isOpeningParenToken(nextToken)){parenStack.push(nextToken);}else if(astUtils.isClosingParenToken(nextToken)){parenPairs.unshift({left:parenStack.pop(),right:nextToken});}});parenPairs.forEach(pair=>{const leftParen=pair.left;const rightParen=pair.right;if(!parameterParens.has(leftParen)&&!parameterParens.has(rightParen)){const parenthesizedTokens=new Set(sourceCode.getTokensBetween(leftParen,rightParen));parenthesizedTokens.forEach(token=>{if(!parenthesizedTokens.has(offsets.getFirstDependency(token))){offsets.setDesiredOffset(token,leftParen,1);}});}offsets.setDesiredOffset(rightParen,leftParen,0);});}function ignoreNode(node){const unknownNodeTokens=new Set(sourceCode.getTokens(node,{includeComments:true}));unknownNodeTokens.forEach(token=>{if(!unknownNodeTokens.has(offsets.getFirstDependency(token))){const firstTokenOfLine=tokenInfo.getFirstTokenOfLine(token);if(token===firstTokenOfLine){offsets.ignoreToken(token);}else {offsets.setDesiredOffset(token,firstTokenOfLine,0);}}});}function isOnFirstLineOfStatement(token,leafNode){let node=leafNode;while(node.parent&&!node.parent.type.endsWith("Statement")&&!node.parent.type.endsWith("Declaration")){node=node.parent;}node=node.parent;return !node||node.loc.start.line===token.loc.start.line;}function hasBlankLinesBetween(firstToken,secondToken){const firstTokenLine=firstToken.loc.end.line;const secondTokenLine=secondToken.loc.start.line;if(firstTokenLine===secondTokenLine||firstTokenLine===secondTokenLine-1){return false;}for(let line=firstTokenLine+1;line<secondTokenLine;++line){if(!tokenInfo.firstTokensByLineNumber.has(line)){return true;}}return false;}const ignoredNodeFirstTokens=new Set();const listenerCallQueue=[];const offsetListeners=lodash__default['default'].mapValues({"ArrayExpression, ArrayPattern"(node){const openingBracket=sourceCode.getFirstToken(node);const closingBracket=sourceCode.getTokenAfter(lodash__default['default'].findLast(node.elements)||openingBracket,astUtils.isClosingBracketToken);addElementListIndent(node.elements,openingBracket,closingBracket,options.ArrayExpression);},"ObjectExpression, ObjectPattern"(node){const openingCurly=sourceCode.getFirstToken(node);const closingCurly=sourceCode.getTokenAfter(node.properties.length?node.properties[node.properties.length-1]:openingCurly,astUtils.isClosingBraceToken);addElementListIndent(node.properties,openingCurly,closingCurly,options.ObjectExpression);},ArrowFunctionExpression(node){const maybeOpeningParen=sourceCode.getFirstToken(node,{skip:node.async?1:0});if(astUtils.isOpeningParenToken(maybeOpeningParen)){const openingParen=maybeOpeningParen;const closingParen=sourceCode.getTokenBefore(node.body,astUtils.isClosingParenToken);parameterParens.add(openingParen);parameterParens.add(closingParen);addElementListIndent(node.params,openingParen,closingParen,options.FunctionExpression.parameters);}addBlocklessNodeIndent(node.body);},AssignmentExpression(node){const operator=sourceCode.getFirstTokenBetween(node.left,node.right,token=>token.value===node.operator);offsets.setDesiredOffsets([operator.range[0],node.range[1]],sourceCode.getLastToken(node.left),1);offsets.ignoreToken(operator);offsets.ignoreToken(sourceCode.getTokenAfter(operator));},"BinaryExpression, LogicalExpression"(node){const operator=sourceCode.getFirstTokenBetween(node.left,node.right,token=>token.value===node.operator);const tokenAfterOperator=sourceCode.getTokenAfter(operator);offsets.ignoreToken(operator);offsets.ignoreToken(tokenAfterOperator);offsets.setDesiredOffset(tokenAfterOperator,operator,0);},"BlockStatement, ClassBody"(node){let blockIndentLevel;if(node.parent&&isOuterIIFE(node.parent)){blockIndentLevel=options.outerIIFEBody;}else if(node.parent&&(node.parent.type==="FunctionExpression"||node.parent.type==="ArrowFunctionExpression")){blockIndentLevel=options.FunctionExpression.body;}else if(node.parent&&node.parent.type==="FunctionDeclaration"){blockIndentLevel=options.FunctionDeclaration.body;}else {blockIndentLevel=1;}if(!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)){offsets.setDesiredOffset(sourceCode.getFirstToken(node),sourceCode.getFirstToken(node.parent),0);}addElementListIndent(node.body,sourceCode.getFirstToken(node),sourceCode.getLastToken(node),blockIndentLevel);},CallExpression:addFunctionCallIndent,"ClassDeclaration[superClass], ClassExpression[superClass]"(node){const classToken=sourceCode.getFirstToken(node);const extendsToken=sourceCode.getTokenBefore(node.superClass,astUtils.isNotOpeningParenToken);offsets.setDesiredOffsets([extendsToken.range[0],node.body.range[0]],classToken,1);},ConditionalExpression(node){const firstToken=sourceCode.getFirstToken(node);if(!options.flatTernaryExpressions||!astUtils.isTokenOnSameLine(node.test,node.consequent)||isOnFirstLineOfStatement(firstToken,node)){const questionMarkToken=sourceCode.getFirstTokenBetween(node.test,node.consequent,token=>token.type==="Punctuator"&&token.value==="?");const colonToken=sourceCode.getFirstTokenBetween(node.consequent,node.alternate,token=>token.type==="Punctuator"&&token.value===":");const firstConsequentToken=sourceCode.getTokenAfter(questionMarkToken);const lastConsequentToken=sourceCode.getTokenBefore(colonToken);const firstAlternateToken=sourceCode.getTokenAfter(colonToken);offsets.setDesiredOffset(questionMarkToken,firstToken,1);offsets.setDesiredOffset(colonToken,firstToken,1);offsets.setDesiredOffset(firstConsequentToken,firstToken,firstConsequentToken.type==="Punctuator"&&options.offsetTernaryExpressions?2:1);if(lastConsequentToken.loc.end.line===firstAlternateToken.loc.start.line){offsets.setDesiredOffset(firstAlternateToken,firstConsequentToken,0);}else {offsets.setDesiredOffset(firstAlternateToken,firstToken,firstAlternateToken.type==="Punctuator"&&options.offsetTernaryExpressions?2:1);}}},"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement":node=>addBlocklessNodeIndent(node.body),ExportNamedDeclaration(node){if(node.declaration===null){const closingCurly=sourceCode.getLastToken(node,astUtils.isClosingBraceToken);addElementListIndent(node.specifiers,sourceCode.getFirstToken(node,{skip:1}),closingCurly,1);if(node.source){offsets.setDesiredOffsets([closingCurly.range[1],node.range[1]],sourceCode.getFirstToken(node),1);}}},ForStatement(node){const forOpeningParen=sourceCode.getFirstToken(node,1);if(node.init){offsets.setDesiredOffsets(node.init.range,forOpeningParen,1);}if(node.test){offsets.setDesiredOffsets(node.test.range,forOpeningParen,1);}if(node.update){offsets.setDesiredOffsets(node.update.range,forOpeningParen,1);}addBlocklessNodeIndent(node.body);},"FunctionDeclaration, FunctionExpression"(node){const closingParen=sourceCode.getTokenBefore(node.body);const openingParen=sourceCode.getTokenBefore(node.params.length?node.params[0]:closingParen);parameterParens.add(openingParen);parameterParens.add(closingParen);addElementListIndent(node.params,openingParen,closingParen,options[node.type].parameters);},IfStatement(node){addBlocklessNodeIndent(node.consequent);if(node.alternate&&node.alternate.type!=="IfStatement"){addBlocklessNodeIndent(node.alternate);}},ImportDeclaration(node){if(node.specifiers.some(specifier=>specifier.type==="ImportSpecifier")){const openingCurly=sourceCode.getFirstToken(node,astUtils.isOpeningBraceToken);const closingCurly=sourceCode.getLastToken(node,astUtils.isClosingBraceToken);addElementListIndent(node.specifiers.filter(specifier=>specifier.type==="ImportSpecifier"),openingCurly,closingCurly,options.ImportDeclaration);}const fromToken=sourceCode.getLastToken(node,token=>token.type==="Identifier"&&token.value==="from");const sourceToken=sourceCode.getLastToken(node,token=>token.type==="String");const semiToken=sourceCode.getLastToken(node,token=>token.type==="Punctuator"&&token.value===";");if(fromToken){const end=semiToken&&semiToken.range[1]===sourceToken.range[1]?node.range[1]:sourceToken.range[1];offsets.setDesiredOffsets([fromToken.range[0],end],sourceCode.getFirstToken(node),1);}},ImportExpression(node){const openingParen=sourceCode.getFirstToken(node,1);const closingParen=sourceCode.getLastToken(node);parameterParens.add(openingParen);parameterParens.add(closingParen);offsets.setDesiredOffset(openingParen,sourceCode.getTokenBefore(openingParen),0);addElementListIndent([node.source],openingParen,closingParen,options.CallExpression.arguments);},"MemberExpression, JSXMemberExpression, MetaProperty"(node){const object=node.type==="MetaProperty"?node.meta:node.object;const firstNonObjectToken=sourceCode.getFirstTokenBetween(object,node.property,astUtils.isNotClosingParenToken);const secondNonObjectToken=sourceCode.getTokenAfter(firstNonObjectToken);const objectParenCount=sourceCode.getTokensBetween(object,node.property,{filter:astUtils.isClosingParenToken}).length;const firstObjectToken=objectParenCount?sourceCode.getTokenBefore(object,{skip:objectParenCount-1}):sourceCode.getFirstToken(object);const lastObjectToken=sourceCode.getTokenBefore(firstNonObjectToken);const firstPropertyToken=node.computed?firstNonObjectToken:secondNonObjectToken;if(node.computed){offsets.setDesiredOffset(sourceCode.getLastToken(node),firstNonObjectToken,0);offsets.setDesiredOffsets(node.property.range,firstNonObjectToken,1);}const offsetBase=lastObjectToken.loc.end.line===firstPropertyToken.loc.start.line?lastObjectToken:firstObjectToken;if(typeof options.MemberExpression==="number"){offsets.setDesiredOffset(firstNonObjectToken,offsetBase,options.MemberExpression);offsets.setDesiredOffset(secondNonObjectToken,node.computed?firstNonObjectToken:offsetBase,options.MemberExpression);}else {offsets.ignoreToken(firstNonObjectToken);offsets.ignoreToken(secondNonObjectToken);offsets.setDesiredOffset(firstNonObjectToken,offsetBase,0);offsets.setDesiredOffset(secondNonObjectToken,firstNonObjectToken,0);}},NewExpression(node){if(node.arguments.length>0||astUtils.isClosingParenToken(sourceCode.getLastToken(node))&&astUtils.isOpeningParenToken(sourceCode.getLastToken(node,1))){addFunctionCallIndent(node);}},Property(node){if(!node.shorthand&&!node.method&&node.kind==="init"){const colon=sourceCode.getFirstTokenBetween(node.key,node.value,astUtils.isColonToken);offsets.ignoreToken(sourceCode.getTokenAfter(colon));}},SwitchStatement(node){const openingCurly=sourceCode.getTokenAfter(node.discriminant,astUtils.isOpeningBraceToken);const closingCurly=sourceCode.getLastToken(node);offsets.setDesiredOffsets([openingCurly.range[1],closingCurly.range[0]],openingCurly,options.SwitchCase);if(node.cases.length){sourceCode.getTokensBetween(node.cases[node.cases.length-1],closingCurly,{includeComments:true,filter:astUtils.isCommentToken}).forEach(token=>offsets.ignoreToken(token));}},SwitchCase(node){if(!(node.consequent.length===1&&node.consequent[0].type==="BlockStatement")){const caseKeyword=sourceCode.getFirstToken(node);const tokenAfterCurrentCase=sourceCode.getTokenAfter(node);offsets.setDesiredOffsets([caseKeyword.range[1],tokenAfterCurrentCase.range[0]],caseKeyword,1);}},TemplateLiteral(node){node.expressions.forEach((expression,index)=>{const previousQuasi=node.quasis[index];const nextQuasi=node.quasis[index+1];const tokenToAlignFrom=previousQuasi.loc.start.line===previousQuasi.loc.end.line?sourceCode.getFirstToken(previousQuasi):null;offsets.setDesiredOffsets([previousQuasi.range[1],nextQuasi.range[0]],tokenToAlignFrom,1);offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi),tokenToAlignFrom,0);});},VariableDeclaration(node){let variableIndent=Object.prototype.hasOwnProperty.call(options.VariableDeclarator,node.kind)?options.VariableDeclarator[node.kind]:DEFAULT_VARIABLE_INDENT;const firstToken=sourceCode.getFirstToken(node),lastToken=sourceCode.getLastToken(node);if(options.VariableDeclarator[node.kind]==="first"){if(node.declarations.length>1){addElementListIndent(node.declarations,firstToken,lastToken,"first");return;}variableIndent=DEFAULT_VARIABLE_INDENT;}if(node.declarations[node.declarations.length-1].loc.start.line>node.loc.start.line){offsets.setDesiredOffsets(node.range,firstToken,variableIndent,true);}else {offsets.setDesiredOffsets(node.range,firstToken,variableIndent);}if(astUtils.isSemicolonToken(lastToken)){offsets.ignoreToken(lastToken);}},VariableDeclarator(node){if(node.init){const equalOperator=sourceCode.getTokenBefore(node.init,astUtils.isNotOpeningParenToken);const tokenAfterOperator=sourceCode.getTokenAfter(equalOperator);offsets.ignoreToken(equalOperator);offsets.ignoreToken(tokenAfterOperator);offsets.setDesiredOffsets([tokenAfterOperator.range[0],node.range[1]],equalOperator,1);offsets.setDesiredOffset(equalOperator,sourceCode.getLastToken(node.id),0);}},"JSXAttribute[value]"(node){const equalsToken=sourceCode.getFirstTokenBetween(node.name,node.value,token=>token.type==="Punctuator"&&token.value==="=");offsets.setDesiredOffsets([equalsToken.range[0],node.value.range[1]],sourceCode.getFirstToken(node.name),1);},JSXElement(node){if(node.closingElement){addElementListIndent(node.children,sourceCode.getFirstToken(node.openingElement),sourceCode.getFirstToken(node.closingElement),1);}},JSXOpeningElement(node){const firstToken=sourceCode.getFirstToken(node);let closingToken;if(node.selfClosing){closingToken=sourceCode.getLastToken(node,{skip:1});offsets.setDesiredOffset(sourceCode.getLastToken(node),closingToken,0);}else {closingToken=sourceCode.getLastToken(node);}offsets.setDesiredOffsets(node.name.range,sourceCode.getFirstToken(node));addElementListIndent(node.attributes,firstToken,closingToken,1);},JSXClosingElement(node){const firstToken=sourceCode.getFirstToken(node);offsets.setDesiredOffsets(node.name.range,firstToken,1);},JSXFragment(node){const firstOpeningToken=sourceCode.getFirstToken(node.openingFragment);const firstClosingToken=sourceCode.getFirstToken(node.closingFragment);addElementListIndent(node.children,firstOpeningToken,firstClosingToken,1);},JSXOpeningFragment(node){const firstToken=sourceCode.getFirstToken(node);const closingToken=sourceCode.getLastToken(node);offsets.setDesiredOffsets(node.range,firstToken,1);offsets.matchOffsetOf(firstToken,closingToken);},JSXClosingFragment(node){const firstToken=sourceCode.getFirstToken(node);const slashToken=sourceCode.getLastToken(node,{skip:1});const closingToken=sourceCode.getLastToken(node);const tokenToMatch=astUtils.isTokenOnSameLine(slashToken,closingToken)?slashToken:closingToken;offsets.setDesiredOffsets(node.range,firstToken,1);offsets.matchOffsetOf(firstToken,tokenToMatch);},JSXExpressionContainer(node){const openingCurly=sourceCode.getFirstToken(node);const closingCurly=sourceCode.getLastToken(node);offsets.setDesiredOffsets([openingCurly.range[1],closingCurly.range[0]],openingCurly,1);},JSXSpreadAttribute(node){const openingCurly=sourceCode.getFirstToken(node);const closingCurly=sourceCode.getLastToken(node);offsets.setDesiredOffsets([openingCurly.range[1],closingCurly.range[0]],openingCurly,1);},"*"(node){const firstToken=sourceCode.getFirstToken(node);if(firstToken&&!ignoredNodeFirstTokens.has(firstToken)){offsets.setDesiredOffsets(node.range,firstToken,0);}}},listener=>node=>listenerCallQueue.push({listener,node}));const ignoredNodes=new Set();function addToIgnoredNodes(node){ignoredNodes.add(node);ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));}const ignoredNodeListeners=options.ignoredNodes.reduce((listeners,ignoredSelector)=>Object.assign(listeners,{[ignoredSelector]:addToIgnoredNodes}),{});return Object.assign(offsetListeners,ignoredNodeListeners,{"*:exit"(node){if(!KNOWN_NODES.has(node.type)){addToIgnoredNodes(node);}},"Program:exit"(){if(options.ignoreComments){sourceCode.getAllComments().forEach(comment=>offsets.ignoreToken(comment));}listenerCallQueue.filter(nodeInfo=>!ignoredNodes.has(nodeInfo.node)).forEach(nodeInfo=>nodeInfo.listener(nodeInfo.node));ignoredNodes.forEach(ignoreNode);addParensIndent(sourceCode.ast.tokens);const precedingTokens=sourceCode.ast.comments.reduce((commentMap,comment)=>{const tokenOrCommentBefore=sourceCode.getTokenBefore(comment,{includeComments:true});return commentMap.set(comment,commentMap.has(tokenOrCommentBefore)?commentMap.get(tokenOrCommentBefore):tokenOrCommentBefore);},new WeakMap());sourceCode.lines.forEach((line,lineIndex)=>{const lineNumber=lineIndex+1;if(!tokenInfo.firstTokensByLineNumber.has(lineNumber)){return;}const firstTokenOfLine=tokenInfo.firstTokensByLineNumber.get(lineNumber);if(firstTokenOfLine.loc.start.line!==lineNumber){return;}if(astUtils.isCommentToken(firstTokenOfLine)){const tokenBefore=precedingTokens.get(firstTokenOfLine);const tokenAfter=tokenBefore?sourceCode.getTokenAfter(tokenBefore):sourceCode.ast.tokens[0];const mayAlignWithBefore=tokenBefore&&!hasBlankLinesBetween(tokenBefore,firstTokenOfLine);const mayAlignWithAfter=tokenAfter&&!hasBlankLinesBetween(firstTokenOfLine,tokenAfter);if(tokenAfter&&astUtils.isSemicolonToken(tokenAfter)&&!astUtils.isTokenOnSameLine(firstTokenOfLine,tokenAfter)){offsets.setDesiredOffset(firstTokenOfLine,tokenAfter,0);}if(mayAlignWithBefore&&validateTokenIndent(firstTokenOfLine,offsets.getDesiredIndent(tokenBefore))||mayAlignWithAfter&&validateTokenIndent(firstTokenOfLine,offsets.getDesiredIndent(tokenAfter))){return;}}if(validateTokenIndent(firstTokenOfLine,offsets.getDesiredIndent(firstTokenOfLine))){return;}report(firstTokenOfLine,offsets.getDesiredIndent(firstTokenOfLine));});}});}};function isForLoop(block){return block.type==="ForInStatement"||block.type==="ForOfStatement"||block.type==="ForStatement";}function isInitialized$1(node){const declaration=node.parent;const block=declaration.parent;if(isForLoop(block)){if(block.type==="ForStatement"){return block.init===declaration;}return block.left===declaration;}return Boolean(node.init);}var initDeclarations={meta:{type:"suggestion",docs:{description:"require or disallow initialization in variable declarations",category:"Variables",recommended:false,url:"https://eslint.org/docs/rules/init-declarations"},schema:{anyOf:[{type:"array",items:[{enum:["always"]}],minItems:0,maxItems:1},{type:"array",items:[{enum:["never"]},{type:"object",properties:{ignoreForLoopInit:{type:"boolean"}},additionalProperties:false}],minItems:0,maxItems:2}]},messages:{initialized:"Variable '{{idName}}' should be initialized on declaration.",notInitialized:"Variable '{{idName}}' should not be initialized on declaration."}},create(context){const mode=context.options[0]||"always";const params=context.options[1]||{};return {"VariableDeclaration:exit"(node){const kind=node.kind,declarations=node.declarations;for(let i=0;i<declarations.length;++i){const declaration=declarations[i],id=declaration.id,initialized=isInitialized$1(declaration),isIgnoredForLoop=params.ignoreForLoopInit&&isForLoop(node.parent);let messageId="";if(mode==="always"&&!initialized){messageId="initialized";}else if(mode==="never"&&kind!=="const"&&initialized&&!isIgnoredForLoop){messageId="notInitialized";}if(id.type==="Identifier"&&messageId){context.report({node:declaration,messageId,data:{idName:id.name}});}}}};}};const QUOTE_SETTINGS$1={"prefer-double":{quote:"\"",description:"singlequote",convert(str){return str.replace(/'/gu,"\"");}},"prefer-single":{quote:"'",description:"doublequote",convert(str){return str.replace(/"/gu,"'");}}};var jsxQuotes={meta:{type:"layout",docs:{description:"enforce the consistent use of either double or single quotes in JSX attributes",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/jsx-quotes"},fixable:"whitespace",schema:[{enum:["prefer-single","prefer-double"]}],messages:{unexpected:"Unexpected usage of {{description}}."}},create(context){const quoteOption=context.options[0]||"prefer-double",setting=QUOTE_SETTINGS$1[quoteOption];function usesExpectedQuotes(node){return node.value.indexOf(setting.quote)!==-1||astUtils.isSurroundedBy(node.raw,setting.quote);}return {JSXAttribute(node){const attributeValue=node.value;if(attributeValue&&astUtils.isStringLiteral(attributeValue)&&!usesExpectedQuotes(attributeValue)){context.report({node:attributeValue,messageId:"unexpected",data:{description:setting.description},fix(fixer){return fixer.replaceText(attributeValue,setting.convert(attributeValue.raw));}});}}};}};function containsLineTerminator(str){return astUtils.LINEBREAK_MATCHER.test(str);}function last(arr){return arr[arr.length-1];}function isSingleLine(node){return node.loc.end.line===node.loc.start.line;}function isSingleLineProperties(properties){const[firstProp]=properties,lastProp=last(properties);return firstProp.loc.start.line===lastProp.loc.end.line;}function initOptionProperty(toOptions,fromOptions){toOptions.mode=fromOptions.mode||"strict";if(typeof fromOptions.beforeColon!=="undefined"){toOptions.beforeColon=+fromOptions.beforeColon;}else {toOptions.beforeColon=0;}if(typeof fromOptions.afterColon!=="undefined"){toOptions.afterColon=+fromOptions.afterColon;}else {toOptions.afterColon=1;}if(typeof fromOptions.align!=="undefined"){if(typeof fromOptions.align==="object"){toOptions.align=fromOptions.align;}else {toOptions.align={on:fromOptions.align,mode:toOptions.mode,beforeColon:toOptions.beforeColon,afterColon:toOptions.afterColon};}}return toOptions;}function initOptions(toOptions,fromOptions){if(typeof fromOptions.align==="object"){toOptions.align=initOptionProperty({},fromOptions.align);toOptions.align.on=fromOptions.align.on||"colon";toOptions.align.mode=fromOptions.align.mode||"strict";toOptions.multiLine=initOptionProperty({},fromOptions.multiLine||fromOptions);toOptions.singleLine=initOptionProperty({},fromOptions.singleLine||fromOptions);}else {toOptions.multiLine=initOptionProperty({},fromOptions.multiLine||fromOptions);toOptions.singleLine=initOptionProperty({},fromOptions.singleLine||fromOptions);if(toOptions.multiLine.align){toOptions.align={on:toOptions.multiLine.align.on,mode:toOptions.multiLine.align.mode||toOptions.multiLine.mode,beforeColon:toOptions.multiLine.align.beforeColon,afterColon:toOptions.multiLine.align.afterColon};}}return toOptions;}var keySpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing between keys and values in object literal properties",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/key-spacing"},fixable:"whitespace",schema:[{anyOf:[{type:"object",properties:{align:{anyOf:[{enum:["colon","value"]},{type:"object",properties:{mode:{enum:["strict","minimum"]},on:{enum:["colon","value"]},beforeColon:{type:"boolean"},afterColon:{type:"boolean"}},additionalProperties:false}]},mode:{enum:["strict","minimum"]},beforeColon:{type:"boolean"},afterColon:{type:"boolean"}},additionalProperties:false},{type:"object",properties:{singleLine:{type:"object",properties:{mode:{enum:["strict","minimum"]},beforeColon:{type:"boolean"},afterColon:{type:"boolean"}},additionalProperties:false},multiLine:{type:"object",properties:{align:{anyOf:[{enum:["colon","value"]},{type:"object",properties:{mode:{enum:["strict","minimum"]},on:{enum:["colon","value"]},beforeColon:{type:"boolean"},afterColon:{type:"boolean"}},additionalProperties:false}]},mode:{enum:["strict","minimum"]},beforeColon:{type:"boolean"},afterColon:{type:"boolean"}},additionalProperties:false}},additionalProperties:false},{type:"object",properties:{singleLine:{type:"object",properties:{mode:{enum:["strict","minimum"]},beforeColon:{type:"boolean"},afterColon:{type:"boolean"}},additionalProperties:false},multiLine:{type:"object",properties:{mode:{enum:["strict","minimum"]},beforeColon:{type:"boolean"},afterColon:{type:"boolean"}},additionalProperties:false},align:{type:"object",properties:{mode:{enum:["strict","minimum"]},on:{enum:["colon","value"]},beforeColon:{type:"boolean"},afterColon:{type:"boolean"}},additionalProperties:false}},additionalProperties:false}]}],messages:{extraKey:"Extra space after {{computed}}key '{{key}}'.",extraValue:"Extra space before value for {{computed}}key '{{key}}'.",missingKey:"Missing space after {{computed}}key '{{key}}'.",missingValue:"Missing space before value for {{computed}}key '{{key}}'."}},create(context){const options=context.options[0]||{},ruleOptions=initOptions({},options),multiLineOptions=ruleOptions.multiLine,singleLineOptions=ruleOptions.singleLine,alignmentOptions=ruleOptions.align||null;const sourceCode=context.getSourceCode();function continuesPropertyGroup(lastMember,candidate){const groupEndLine=lastMember.loc.start.line,candidateStartLine=candidate.loc.start.line;if(candidateStartLine-groupEndLine<=1){return true;}const leadingComments=sourceCode.getCommentsBefore(candidate);if(leadingComments.length&&leadingComments[0].loc.start.line-groupEndLine<=1&&candidateStartLine-last(leadingComments).loc.end.line<=1){for(let i=1;i<leadingComments.length;i++){if(leadingComments[i].loc.start.line-leadingComments[i-1].loc.end.line>1){return false;}}return true;}return false;}function isKeyValueProperty(property){return !(property.method||property.shorthand||property.kind!=="init"||property.type!=="Property");}function getLastTokenBeforeColon(node){const colonToken=sourceCode.getTokenAfter(node,astUtils.isColonToken);return sourceCode.getTokenBefore(colonToken);}function getNextColon(node){return sourceCode.getTokenAfter(node,astUtils.isColonToken);}function getKey(property){const key=property.key;if(property.computed){return sourceCode.getText().slice(key.range[0],key.range[1]);}return astUtils.getStaticPropertyName(property);}function report(property,side,whitespace,expected,mode){const diff=whitespace.length-expected,nextColon=getNextColon(property.key),tokenBeforeColon=sourceCode.getTokenBefore(nextColon,{includeComments:true}),tokenAfterColon=sourceCode.getTokenAfter(nextColon,{includeComments:true}),isKeySide=side==="key",isExtra=diff>0,diffAbs=Math.abs(diff),spaces=Array(diffAbs+1).join(" ");const locStart=isKeySide?tokenBeforeColon.loc.end:nextColon.loc.start;const locEnd=isKeySide?nextColon.loc.start:tokenAfterColon.loc.start;const missingLoc=isKeySide?tokenBeforeColon.loc:tokenAfterColon.loc;const loc=isExtra?{start:locStart,end:locEnd}:missingLoc;if((diff&&mode==="strict"||diff<0&&mode==="minimum"||diff>0&&!expected&&mode==="minimum")&&!(expected&&containsLineTerminator(whitespace))){let fix;if(isExtra){let range;if(isKeySide){range=[tokenBeforeColon.range[1],tokenBeforeColon.range[1]+diffAbs];}else {range=[tokenAfterColon.range[0]-diffAbs,tokenAfterColon.range[0]];}fix=function(fixer){return fixer.removeRange(range);};}else {if(isKeySide){fix=function(fixer){return fixer.insertTextAfter(tokenBeforeColon,spaces);};}else {fix=function(fixer){return fixer.insertTextBefore(tokenAfterColon,spaces);};}}let messageId="";if(isExtra){messageId=side==="key"?"extraKey":"extraValue";}else {messageId=side==="key"?"missingKey":"missingValue";}context.report({node:property[side],loc,messageId,data:{computed:property.computed?"computed ":"",key:getKey(property)},fix});}}function getKeyWidth(property){const startToken=sourceCode.getFirstToken(property);const endToken=getLastTokenBeforeColon(property.key);return endToken.range[1]-startToken.range[0];}function getPropertyWhitespace(property){const whitespace=/(\s*):(\s*)/u.exec(sourceCode.getText().slice(property.key.range[1],property.value.range[0]));if(whitespace){return {beforeColon:whitespace[1],afterColon:whitespace[2]};}return null;}function createGroups(node){if(node.properties.length===1){return [node.properties];}return node.properties.reduce((groups,property)=>{const currentGroup=last(groups),prev=last(currentGroup);if(!prev||continuesPropertyGroup(prev,property)){currentGroup.push(property);}else {groups.push([property]);}return groups;},[[]]);}function verifyGroupAlignment(properties){const length=properties.length,widths=properties.map(getKeyWidth),align=alignmentOptions.on;let targetWidth=Math.max(...widths),beforeColon,afterColon,mode;if(alignmentOptions&&length>1){beforeColon=alignmentOptions.beforeColon;afterColon=alignmentOptions.afterColon;mode=alignmentOptions.mode;}else {beforeColon=multiLineOptions.beforeColon;afterColon=multiLineOptions.afterColon;mode=alignmentOptions.mode;}targetWidth+=align==="colon"?beforeColon:afterColon;for(let i=0;i<length;i++){const property=properties[i];const whitespace=getPropertyWhitespace(property);if(whitespace){const width=widths[i];if(align==="value"){report(property,"key",whitespace.beforeColon,beforeColon,mode);report(property,"value",whitespace.afterColon,targetWidth-width,mode);}else {report(property,"key",whitespace.beforeColon,targetWidth-width,mode);report(property,"value",whitespace.afterColon,afterColon,mode);}}}}function verifySpacing(node,lineOptions){const actual=getPropertyWhitespace(node);if(actual){report(node,"key",actual.beforeColon,lineOptions.beforeColon,lineOptions.mode);report(node,"value",actual.afterColon,lineOptions.afterColon,lineOptions.mode);}}function verifyListSpacing(properties,lineOptions){const length=properties.length;for(let i=0;i<length;i++){verifySpacing(properties[i],lineOptions);}}function verifyAlignment(node){createGroups(node).forEach(group=>{const properties=group.filter(isKeyValueProperty);if(properties.length>0&&isSingleLineProperties(properties)){verifyListSpacing(properties,multiLineOptions);}else {verifyGroupAlignment(properties);}});}if(alignmentOptions){return {ObjectExpression(node){if(isSingleLine(node)){verifyListSpacing(node.properties.filter(isKeyValueProperty),singleLineOptions);}else {verifyAlignment(node);}}};}return {Property(node){verifySpacing(node,isSingleLine(node.parent)?singleLineOptions:multiLineOptions);}};}};const PREV_TOKEN=/^[)\]}>]$/u;const NEXT_TOKEN=/^(?:[([{<~!]|\+\+?|--?)$/u;const PREV_TOKEN_M=/^[)\]}>*]$/u;const NEXT_TOKEN_M=/^[{*]$/u;const TEMPLATE_OPEN_PAREN=/\$\{$/u;const TEMPLATE_CLOSE_PAREN=/^\}/u;const CHECK_TYPE=/^(?:JSXElement|RegularExpression|String|Template)$/u;const KEYS=keywords.concat(["as","async","await","from","get","let","of","set","yield"]);(function(){KEYS.sort();for(let i=1;i<KEYS.length;++i){if(KEYS[i]===KEYS[i-1]){throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);}}})();function isOpenParenOfTemplate(token){return token.type==="Template"&&TEMPLATE_OPEN_PAREN.test(token.value);}function isCloseParenOfTemplate(token){return token.type==="Template"&&TEMPLATE_CLOSE_PAREN.test(token.value);}var keywordSpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing before and after keywords",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/keyword-spacing"},fixable:"whitespace",schema:[{type:"object",properties:{before:{type:"boolean",default:true},after:{type:"boolean",default:true},overrides:{type:"object",properties:KEYS.reduce((retv,key)=>{retv[key]={type:"object",properties:{before:{type:"boolean"},after:{type:"boolean"}},additionalProperties:false};return retv;},{}),additionalProperties:false}},additionalProperties:false}],messages:{expectedBefore:"Expected space(s) before \"{{value}}\".",expectedAfter:"Expected space(s) after \"{{value}}\".",unexpectedBefore:"Unexpected space(s) before \"{{value}}\".",unexpectedAfter:"Unexpected space(s) after \"{{value}}\"."}},create(context){const sourceCode=context.getSourceCode();function expectSpaceBefore(token,pattern){const prevToken=sourceCode.getTokenBefore(token);if(prevToken&&(CHECK_TYPE.test(prevToken.type)||pattern.test(prevToken.value))&&!isOpenParenOfTemplate(prevToken)&&astUtils.isTokenOnSameLine(prevToken,token)&&!sourceCode.isSpaceBetweenTokens(prevToken,token)){context.report({loc:token.loc,messageId:"expectedBefore",data:token,fix(fixer){return fixer.insertTextBefore(token," ");}});}}function unexpectSpaceBefore(token,pattern){const prevToken=sourceCode.getTokenBefore(token);if(prevToken&&(CHECK_TYPE.test(prevToken.type)||pattern.test(prevToken.value))&&!isOpenParenOfTemplate(prevToken)&&astUtils.isTokenOnSameLine(prevToken,token)&&sourceCode.isSpaceBetweenTokens(prevToken,token)){context.report({loc:{start:prevToken.loc.end,end:token.loc.start},messageId:"unexpectedBefore",data:token,fix(fixer){return fixer.removeRange([prevToken.range[1],token.range[0]]);}});}}function expectSpaceAfter(token,pattern){const nextToken=sourceCode.getTokenAfter(token);if(nextToken&&(CHECK_TYPE.test(nextToken.type)||pattern.test(nextToken.value))&&!isCloseParenOfTemplate(nextToken)&&astUtils.isTokenOnSameLine(token,nextToken)&&!sourceCode.isSpaceBetweenTokens(token,nextToken)){context.report({loc:token.loc,messageId:"expectedAfter",data:token,fix(fixer){return fixer.insertTextAfter(token," ");}});}}function unexpectSpaceAfter(token,pattern){const nextToken=sourceCode.getTokenAfter(token);if(nextToken&&(CHECK_TYPE.test(nextToken.type)||pattern.test(nextToken.value))&&!isCloseParenOfTemplate(nextToken)&&astUtils.isTokenOnSameLine(token,nextToken)&&sourceCode.isSpaceBetweenTokens(token,nextToken)){context.report({loc:{start:token.loc.end,end:nextToken.loc.start},messageId:"unexpectedAfter",data:token,fix(fixer){return fixer.removeRange([token.range[1],nextToken.range[0]]);}});}}function parseOptions(options={}){const before=options.before!==false;const after=options.after!==false;const defaultValue={before:before?expectSpaceBefore:unexpectSpaceBefore,after:after?expectSpaceAfter:unexpectSpaceAfter};const overrides=options&&options.overrides||{};const retv=Object.create(null);for(let i=0;i<KEYS.length;++i){const key=KEYS[i];const override=overrides[key];if(override){const thisBefore="before"in override?override.before:before;const thisAfter="after"in override?override.after:after;retv[key]={before:thisBefore?expectSpaceBefore:unexpectSpaceBefore,after:thisAfter?expectSpaceAfter:unexpectSpaceAfter};}else {retv[key]=defaultValue;}}return retv;}const checkMethodMap=parseOptions(context.options[0]);function checkSpacingBefore(token,pattern){checkMethodMap[token.value].before(token,pattern||PREV_TOKEN);}function checkSpacingAfter(token,pattern){checkMethodMap[token.value].after(token,pattern||NEXT_TOKEN);}function checkSpacingAround(token){checkSpacingBefore(token);checkSpacingAfter(token);}function checkSpacingAroundFirstToken(node){const firstToken=node&&sourceCode.getFirstToken(node);if(firstToken&&firstToken.type==="Keyword"){checkSpacingAround(firstToken);}}function checkSpacingBeforeFirstToken(node){const firstToken=node&&sourceCode.getFirstToken(node);if(firstToken&&firstToken.type==="Keyword"){checkSpacingBefore(firstToken);}}function checkSpacingAroundTokenBefore(node){if(node){const token=sourceCode.getTokenBefore(node,astUtils.isKeywordToken);checkSpacingAround(token);}}function checkSpacingForFunction(node){const firstToken=node&&sourceCode.getFirstToken(node);if(firstToken&&(firstToken.type==="Keyword"&&firstToken.value==="function"||firstToken.value==="async")){checkSpacingBefore(firstToken);}}function checkSpacingForClass(node){checkSpacingAroundFirstToken(node);checkSpacingAroundTokenBefore(node.superClass);}function checkSpacingForModuleDeclaration(node){const firstToken=sourceCode.getFirstToken(node);checkSpacingBefore(firstToken,PREV_TOKEN_M);checkSpacingAfter(firstToken,NEXT_TOKEN_M);if(node.type==="ExportDefaultDeclaration"){checkSpacingAround(sourceCode.getTokenAfter(firstToken));}if(node.type==="ExportAllDeclaration"&&node.exported){const asToken=sourceCode.getTokenBefore(node.exported);checkSpacingBefore(asToken,PREV_TOKEN_M);}if(node.source){const fromToken=sourceCode.getTokenBefore(node.source);checkSpacingBefore(fromToken,PREV_TOKEN_M);checkSpacingAfter(fromToken,NEXT_TOKEN_M);}}function checkSpacingForProperty(node){if(node.static){checkSpacingAroundFirstToken(node);}if(node.kind==="get"||node.kind==="set"||(node.method||node.type==="MethodDefinition")&&node.value.async){const token=sourceCode.getTokenBefore(node.key,tok=>{switch(tok.value){case"get":case"set":case"async":return true;default:return false;}});if(!token){throw new Error("Failed to find token get, set, or async beside method name");}checkSpacingAround(token);}}return {DebuggerStatement:checkSpacingAroundFirstToken,WithStatement:checkSpacingAroundFirstToken,BreakStatement:checkSpacingAroundFirstToken,ContinueStatement:checkSpacingAroundFirstToken,ReturnStatement:checkSpacingAroundFirstToken,ThrowStatement:checkSpacingAroundFirstToken,TryStatement:function(node){checkSpacingAroundFirstToken(node);checkSpacingAroundFirstToken(node.handler);checkSpacingAroundTokenBefore(node.finalizer);},IfStatement:function(node){checkSpacingAroundFirstToken(node);checkSpacingAroundTokenBefore(node.alternate);},SwitchStatement:checkSpacingAroundFirstToken,SwitchCase:checkSpacingAroundFirstToken,DoWhileStatement:function(node){checkSpacingAroundFirstToken(node);checkSpacingAroundTokenBefore(node.test);},ForInStatement:function(node){checkSpacingAroundFirstToken(node);checkSpacingAroundTokenBefore(node.right);},ForOfStatement:function(node){if(node.await){checkSpacingBefore(sourceCode.getFirstToken(node,0));checkSpacingAfter(sourceCode.getFirstToken(node,1));}else {checkSpacingAroundFirstToken(node);}checkSpacingAround(sourceCode.getTokenBefore(node.right,astUtils.isNotOpeningParenToken));},ForStatement:checkSpacingAroundFirstToken,WhileStatement:checkSpacingAroundFirstToken,ClassDeclaration:checkSpacingForClass,ExportNamedDeclaration:checkSpacingForModuleDeclaration,ExportDefaultDeclaration:checkSpacingForModuleDeclaration,ExportAllDeclaration:checkSpacingForModuleDeclaration,FunctionDeclaration:checkSpacingForFunction,ImportDeclaration:checkSpacingForModuleDeclaration,VariableDeclaration:checkSpacingAroundFirstToken,ArrowFunctionExpression:checkSpacingForFunction,AwaitExpression:function(node){checkSpacingBefore(sourceCode.getFirstToken(node));},ClassExpression:checkSpacingForClass,FunctionExpression:checkSpacingForFunction,NewExpression:checkSpacingBeforeFirstToken,Super:checkSpacingBeforeFirstToken,ThisExpression:checkSpacingBeforeFirstToken,UnaryExpression:checkSpacingBeforeFirstToken,YieldExpression:checkSpacingBeforeFirstToken,ImportNamespaceSpecifier:function(node){const asToken=sourceCode.getFirstToken(node,1);checkSpacingBefore(asToken,PREV_TOKEN_M);},MethodDefinition:checkSpacingForProperty,Property:checkSpacingForProperty};}};var lineCommentPosition={meta:{type:"layout",docs:{description:"enforce position of line comments",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/line-comment-position"},schema:[{oneOf:[{enum:["above","beside"]},{type:"object",properties:{position:{enum:["above","beside"]},ignorePattern:{type:"string"},applyDefaultPatterns:{type:"boolean"},applyDefaultIgnorePatterns:{type:"boolean"}},additionalProperties:false}]}],messages:{above:"Expected comment to be above code.",beside:"Expected comment to be beside code."}},create(context){const options=context.options[0];let above,ignorePattern,applyDefaultIgnorePatterns=true;if(!options||typeof options==="string"){above=!options||options==="above";}else {above=!options.position||options.position==="above";ignorePattern=options.ignorePattern;if(Object.prototype.hasOwnProperty.call(options,"applyDefaultIgnorePatterns")){applyDefaultIgnorePatterns=options.applyDefaultIgnorePatterns;}else {applyDefaultIgnorePatterns=options.applyDefaultPatterns!==false;}}const defaultIgnoreRegExp=astUtils.COMMENTS_IGNORE_PATTERN;const customIgnoreRegExp=new RegExp(ignorePattern,"u");const sourceCode=context.getSourceCode();return {Program(){const comments=sourceCode.getAllComments();comments.filter(token=>token.type==="Line").forEach(node=>{if(applyDefaultIgnorePatterns&&(defaultIgnoreRegExp.test(node.value)||/^\s*falls?\s?through/u.test(node.value))){return;}if(ignorePattern&&customIgnoreRegExp.test(node.value)){return;}const previous=sourceCode.getTokenBefore(node,{includeComments:true});const isOnSameLine=previous&&previous.loc.end.line===node.loc.start.line;if(above){if(isOnSameLine){context.report({node,messageId:"above"});}}else {if(!isOnSameLine){context.report({node,messageId:"beside"});}}});}};}};var linebreakStyle={meta:{type:"layout",docs:{description:"enforce consistent linebreak style",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/linebreak-style"},fixable:"whitespace",schema:[{enum:["unix","windows"]}],messages:{expectedLF:"Expected linebreaks to be 'LF' but found 'CRLF'.",expectedCRLF:"Expected linebreaks to be 'CRLF' but found 'LF'."}},create(context){const sourceCode=context.getSourceCode();function createFix(range,text){return function(fixer){return fixer.replaceTextRange(range,text);};}return {Program:function(node){const linebreakStyle=context.options[0]||"unix",expectedLF=linebreakStyle==="unix",expectedLFChars=expectedLF?"\n":"\r\n",source=sourceCode.getText(),pattern=astUtils.createGlobalLinebreakMatcher();let match;let i=0;while((match=pattern.exec(source))!==null){i++;if(match[0]===expectedLFChars){continue;}const index=match.index;const range=[index,index+match[0].length];context.report({node,loc:{start:{line:i,column:sourceCode.lines[i-1].length},end:{line:i+1,column:0}},messageId:expectedLF?"expectedLF":"expectedCRLF",fix:createFix(range,expectedLFChars)});}}};}};function getEmptyLineNums(lines){const emptyLines=lines.map((line,i)=>({code:line.trim(),num:i+1})).filter(line=>!line.code).map(line=>line.num);return emptyLines;}function getCommentLineNums(comments){const lines=[];comments.forEach(token=>{const start=token.loc.start.line;const end=token.loc.end.line;lines.push(start,end);});return lines;}var linesAroundComment={meta:{type:"layout",docs:{description:"require empty lines around comments",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/lines-around-comment"},fixable:"whitespace",schema:[{type:"object",properties:{beforeBlockComment:{type:"boolean",default:true},afterBlockComment:{type:"boolean",default:false},beforeLineComment:{type:"boolean",default:false},afterLineComment:{type:"boolean",default:false},allowBlockStart:{type:"boolean",default:false},allowBlockEnd:{type:"boolean",default:false},allowClassStart:{type:"boolean"},allowClassEnd:{type:"boolean"},allowObjectStart:{type:"boolean"},allowObjectEnd:{type:"boolean"},allowArrayStart:{type:"boolean"},allowArrayEnd:{type:"boolean"},ignorePattern:{type:"string"},applyDefaultIgnorePatterns:{type:"boolean"}},additionalProperties:false}],messages:{after:"Expected line after comment.",before:"Expected line before comment."}},create(context){const options=Object.assign({},context.options[0]);const ignorePattern=options.ignorePattern;const defaultIgnoreRegExp=astUtils.COMMENTS_IGNORE_PATTERN;const customIgnoreRegExp=new RegExp(ignorePattern,"u");const applyDefaultIgnorePatterns=options.applyDefaultIgnorePatterns!==false;options.beforeBlockComment=typeof options.beforeBlockComment!=="undefined"?options.beforeBlockComment:true;const sourceCode=context.getSourceCode();const lines=sourceCode.lines,numLines=lines.length+1,comments=sourceCode.getAllComments(),commentLines=getCommentLineNums(comments),emptyLines=getEmptyLineNums(lines),commentAndEmptyLines=commentLines.concat(emptyLines);function codeAroundComment(token){let currentToken=token;do{currentToken=sourceCode.getTokenBefore(currentToken,{includeComments:true});}while(currentToken&&astUtils.isCommentToken(currentToken));if(currentToken&&astUtils.isTokenOnSameLine(currentToken,token)){return true;}currentToken=token;do{currentToken=sourceCode.getTokenAfter(currentToken,{includeComments:true});}while(currentToken&&astUtils.isCommentToken(currentToken));if(currentToken&&astUtils.isTokenOnSameLine(token,currentToken)){return true;}return false;}function isParentNodeType(parent,nodeType){return parent.type===nodeType||parent.body&&parent.body.type===nodeType||parent.consequent&&parent.consequent.type===nodeType;}function getParentNodeOfToken(token){return sourceCode.getNodeByRangeIndex(token.range[0]);}function isCommentAtParentStart(token,nodeType){const parent=getParentNodeOfToken(token);return parent&&isParentNodeType(parent,nodeType)&&token.loc.start.line-parent.loc.start.line===1;}function isCommentAtParentEnd(token,nodeType){const parent=getParentNodeOfToken(token);return parent&&isParentNodeType(parent,nodeType)&&parent.loc.end.line-token.loc.end.line===1;}function isCommentAtBlockStart(token){return isCommentAtParentStart(token,"ClassBody")||isCommentAtParentStart(token,"BlockStatement")||isCommentAtParentStart(token,"SwitchCase");}function isCommentAtBlockEnd(token){return isCommentAtParentEnd(token,"ClassBody")||isCommentAtParentEnd(token,"BlockStatement")||isCommentAtParentEnd(token,"SwitchCase")||isCommentAtParentEnd(token,"SwitchStatement");}function isCommentAtClassStart(token){return isCommentAtParentStart(token,"ClassBody");}function isCommentAtClassEnd(token){return isCommentAtParentEnd(token,"ClassBody");}function isCommentAtObjectStart(token){return isCommentAtParentStart(token,"ObjectExpression")||isCommentAtParentStart(token,"ObjectPattern");}function isCommentAtObjectEnd(token){return isCommentAtParentEnd(token,"ObjectExpression")||isCommentAtParentEnd(token,"ObjectPattern");}function isCommentAtArrayStart(token){return isCommentAtParentStart(token,"ArrayExpression")||isCommentAtParentStart(token,"ArrayPattern");}function isCommentAtArrayEnd(token){return isCommentAtParentEnd(token,"ArrayExpression")||isCommentAtParentEnd(token,"ArrayPattern");}function checkForEmptyLine(token,opts){if(applyDefaultIgnorePatterns&&defaultIgnoreRegExp.test(token.value)){return;}if(ignorePattern&&customIgnoreRegExp.test(token.value)){return;}let after=opts.after,before=opts.before;const prevLineNum=token.loc.start.line-1,nextLineNum=token.loc.end.line+1,commentIsNotAlone=codeAroundComment(token);const blockStartAllowed=options.allowBlockStart&&isCommentAtBlockStart(token)&&!(options.allowClassStart===false&&isCommentAtClassStart(token)),blockEndAllowed=options.allowBlockEnd&&isCommentAtBlockEnd(token)&&!(options.allowClassEnd===false&&isCommentAtClassEnd(token)),classStartAllowed=options.allowClassStart&&isCommentAtClassStart(token),classEndAllowed=options.allowClassEnd&&isCommentAtClassEnd(token),objectStartAllowed=options.allowObjectStart&&isCommentAtObjectStart(token),objectEndAllowed=options.allowObjectEnd&&isCommentAtObjectEnd(token),arrayStartAllowed=options.allowArrayStart&&isCommentAtArrayStart(token),arrayEndAllowed=options.allowArrayEnd&&isCommentAtArrayEnd(token);if(prevLineNum<1){before=false;}if(nextLineNum>=numLines){after=false;}if(commentIsNotAlone){return;}const previousTokenOrComment=sourceCode.getTokenBefore(token,{includeComments:true});const nextTokenOrComment=sourceCode.getTokenAfter(token,{includeComments:true});if(!(blockStartAllowed||classStartAllowed||objectStartAllowed||arrayStartAllowed)&&before&&!commentAndEmptyLines.includes(prevLineNum)&&!(astUtils.isCommentToken(previousTokenOrComment)&&astUtils.isTokenOnSameLine(previousTokenOrComment,token))){const lineStart=token.range[0]-token.loc.start.column;const range=[lineStart,lineStart];context.report({node:token,messageId:"before",fix(fixer){return fixer.insertTextBeforeRange(range,"\n");}});}if(!(blockEndAllowed||classEndAllowed||objectEndAllowed||arrayEndAllowed)&&after&&!commentAndEmptyLines.includes(nextLineNum)&&!(astUtils.isCommentToken(nextTokenOrComment)&&astUtils.isTokenOnSameLine(token,nextTokenOrComment))){context.report({node:token,messageId:"after",fix(fixer){return fixer.insertTextAfter(token,"\n");}});}}return {Program(){comments.forEach(token=>{if(token.type==="Line"){if(options.beforeLineComment||options.afterLineComment){checkForEmptyLine(token,{after:options.afterLineComment,before:options.beforeLineComment});}}else if(token.type==="Block"){if(options.beforeBlockComment||options.afterBlockComment){checkForEmptyLine(token,{after:options.afterBlockComment,before:options.beforeBlockComment});}}});}};}};var linesAroundDirective={meta:{type:"layout",docs:{description:"require or disallow newlines around directives",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/lines-around-directive"},schema:[{oneOf:[{enum:["always","never"]},{type:"object",properties:{before:{enum:["always","never"]},after:{enum:["always","never"]}},additionalProperties:false,minProperties:2}]}],fixable:"whitespace",messages:{expected:"Expected newline {{location}} \"{{value}}\" directive.",unexpected:"Unexpected newline {{location}} \"{{value}}\" directive."},deprecated:true,replacedBy:["padding-line-between-statements"]},create(context){const sourceCode=context.getSourceCode();const config=context.options[0]||"always";const expectLineBefore=typeof config==="string"?config:config.before;const expectLineAfter=typeof config==="string"?config:config.after;function hasNewlineBefore(node){const tokenBefore=sourceCode.getTokenBefore(node,{includeComments:true});const tokenLineBefore=tokenBefore?tokenBefore.loc.end.line:0;return node.loc.start.line-tokenLineBefore>=2;}function getLastTokenOnLine(node){const lastToken=sourceCode.getLastToken(node);const secondToLastToken=sourceCode.getTokenBefore(lastToken);return astUtils.isSemicolonToken(lastToken)&&lastToken.loc.start.line>secondToLastToken.loc.end.line?secondToLastToken:lastToken;}function hasNewlineAfter(node){const lastToken=getLastTokenOnLine(node);const tokenAfter=sourceCode.getTokenAfter(lastToken,{includeComments:true});return tokenAfter.loc.start.line-lastToken.loc.end.line>=2;}function reportError(node,location,expected){context.report({node,messageId:expected?"expected":"unexpected",data:{value:node.expression.value,location},fix(fixer){const lastToken=getLastTokenOnLine(node);if(expected){return location==="before"?fixer.insertTextBefore(node,"\n"):fixer.insertTextAfter(lastToken,"\n");}return fixer.removeRange(location==="before"?[node.range[0]-1,node.range[0]]:[lastToken.range[1],lastToken.range[1]+1]);}});}function checkDirectives(node){const directives=astUtils.getDirectivePrologue(node);if(!directives.length){return;}const firstDirective=directives[0];const leadingComments=sourceCode.getCommentsBefore(firstDirective);if(leadingComments.length){if(expectLineBefore==="always"&&!hasNewlineBefore(firstDirective)){reportError(firstDirective,"before",true);}if(expectLineBefore==="never"&&hasNewlineBefore(firstDirective)){reportError(firstDirective,"before",false);}}else if(node.type==="Program"&&expectLineBefore==="never"&&!leadingComments.length&&hasNewlineBefore(firstDirective)){reportError(firstDirective,"before",false);}const lastDirective=directives[directives.length-1];const statements=node.type==="Program"?node.body:node.body.body;if(lastDirective===statements[statements.length-1]&&!lastDirective.trailingComments){return;}if(expectLineAfter==="always"&&!hasNewlineAfter(lastDirective)){reportError(lastDirective,"after",true);}if(expectLineAfter==="never"&&hasNewlineAfter(lastDirective)){reportError(lastDirective,"after",false);}}return {Program:checkDirectives,FunctionDeclaration:checkDirectives,FunctionExpression:checkDirectives,ArrowFunctionExpression:checkDirectives};}};var linesBetweenClassMembers={meta:{type:"layout",docs:{description:"require or disallow an empty line between class members",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/lines-between-class-members"},fixable:"whitespace",schema:[{enum:["always","never"]},{type:"object",properties:{exceptAfterSingleLine:{type:"boolean",default:false}},additionalProperties:false}],messages:{never:"Unexpected blank line between class members.",always:"Expected blank line between class members."}},create(context){const options=[];options[0]=context.options[0]||"always";options[1]=context.options[1]||{exceptAfterSingleLine:false};const sourceCode=context.getSourceCode();function findLastConsecutiveTokenAfter(prevLastToken,nextFirstToken,maxLine){const after=sourceCode.getTokenAfter(prevLastToken,{includeComments:true});if(after!==nextFirstToken&&after.loc.start.line-prevLastToken.loc.end.line<=maxLine){return findLastConsecutiveTokenAfter(after,nextFirstToken,maxLine);}return prevLastToken;}function findFirstConsecutiveTokenBefore(nextFirstToken,prevLastToken,maxLine){const before=sourceCode.getTokenBefore(nextFirstToken,{includeComments:true});if(before!==prevLastToken&&nextFirstToken.loc.start.line-before.loc.end.line<=maxLine){return findFirstConsecutiveTokenBefore(before,prevLastToken,maxLine);}return nextFirstToken;}function hasTokenOrCommentBetween(before,after){return sourceCode.getTokensBetween(before,after,{includeComments:true}).length!==0;}return {ClassBody(node){const body=node.body;for(let i=0;i<body.length-1;i++){const curFirst=sourceCode.getFirstToken(body[i]);const curLast=sourceCode.getLastToken(body[i]);const nextFirst=sourceCode.getFirstToken(body[i+1]);const isMulti=!astUtils.isTokenOnSameLine(curFirst,curLast);const skip=!isMulti&&options[1].exceptAfterSingleLine;const beforePadding=findLastConsecutiveTokenAfter(curLast,nextFirst,1);const afterPadding=findFirstConsecutiveTokenBefore(nextFirst,curLast,1);const isPadded=afterPadding.loc.start.line-beforePadding.loc.end.line>1;const hasTokenInPadding=hasTokenOrCommentBetween(beforePadding,afterPadding);const curLineLastToken=findLastConsecutiveTokenAfter(curLast,nextFirst,0);if(options[0]==="always"&&!skip&&!isPadded||options[0]==="never"&&isPadded){context.report({node:body[i+1],messageId:isPadded?"never":"always",fix(fixer){if(hasTokenInPadding){return null;}return isPadded?fixer.replaceTextRange([beforePadding.range[1],afterPadding.range[0]],"\n"):fixer.insertTextAfter(curLineLastToken,"\n");}});}}}};}};var maxClassesPerFile={meta:{type:"suggestion",docs:{description:"enforce a maximum number of classes per file",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/max-classes-per-file"},schema:[{type:"integer",minimum:1}],messages:{maximumExceeded:"File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}."}},create(context){const maxClasses=context.options[0]||1;let classCount=0;return {Program(){classCount=0;},"Program:exit"(node){if(classCount>maxClasses){context.report({node,messageId:"maximumExceeded",data:{classCount,max:maxClasses}});}},"ClassDeclaration, ClassExpression"(){classCount++;}};}};var maxDepth={meta:{type:"suggestion",docs:{description:"enforce a maximum depth that blocks can be nested",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/max-depth"},schema:[{oneOf:[{type:"integer",minimum:0},{type:"object",properties:{maximum:{type:"integer",minimum:0},max:{type:"integer",minimum:0}},additionalProperties:false}]}],messages:{tooDeeply:"Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}."}},create(context){const functionStack=[],option=context.options[0];let maxDepth=4;if(typeof option==="object"&&(Object.prototype.hasOwnProperty.call(option,"maximum")||Object.prototype.hasOwnProperty.call(option,"max"))){maxDepth=option.maximum||option.max;}if(typeof option==="number"){maxDepth=option;}function startFunction(){functionStack.push(0);}function endFunction(){functionStack.pop();}function pushBlock(node){const len=++functionStack[functionStack.length-1];if(len>maxDepth){context.report({node,messageId:"tooDeeply",data:{depth:len,maxDepth}});}}function popBlock(){functionStack[functionStack.length-1]--;}return {Program:startFunction,FunctionDeclaration:startFunction,FunctionExpression:startFunction,ArrowFunctionExpression:startFunction,IfStatement(node){if(node.parent.type!=="IfStatement"){pushBlock(node);}},SwitchStatement:pushBlock,TryStatement:pushBlock,DoWhileStatement:pushBlock,WhileStatement:pushBlock,WithStatement:pushBlock,ForStatement:pushBlock,ForInStatement:pushBlock,ForOfStatement:pushBlock,"IfStatement:exit":popBlock,"SwitchStatement:exit":popBlock,"TryStatement:exit":popBlock,"DoWhileStatement:exit":popBlock,"WhileStatement:exit":popBlock,"WithStatement:exit":popBlock,"ForStatement:exit":popBlock,"ForInStatement:exit":popBlock,"ForOfStatement:exit":popBlock,"FunctionDeclaration:exit":endFunction,"FunctionExpression:exit":endFunction,"ArrowFunctionExpression:exit":endFunction,"Program:exit":endFunction};}};const OPTIONS_SCHEMA$1={type:"object",properties:{code:{type:"integer",minimum:0},comments:{type:"integer",minimum:0},tabWidth:{type:"integer",minimum:0},ignorePattern:{type:"string"},ignoreComments:{type:"boolean"},ignoreStrings:{type:"boolean"},ignoreUrls:{type:"boolean"},ignoreTemplateLiterals:{type:"boolean"},ignoreRegExpLiterals:{type:"boolean"},ignoreTrailingComments:{type:"boolean"}},additionalProperties:false};const OPTIONS_OR_INTEGER_SCHEMA$1={anyOf:[OPTIONS_SCHEMA$1,{type:"integer",minimum:0}]};var maxLen={meta:{type:"layout",docs:{description:"enforce a maximum line length",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/max-len"},schema:[OPTIONS_OR_INTEGER_SCHEMA$1,OPTIONS_OR_INTEGER_SCHEMA$1,OPTIONS_SCHEMA$1],messages:{max:"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.",maxComment:"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}."}},create(context){const sourceCode=context.getSourceCode();function computeLineLength(line,tabWidth){let extraCharacterCount=0;line.replace(/\t/gu,(match,offset)=>{const totalOffset=offset+extraCharacterCount,previousTabStopOffset=tabWidth?totalOffset%tabWidth:0;extraCharacterCount+=tabWidth-previousTabStopOffset-1;});return Array.from(line).length+extraCharacterCount;}const options=Object.assign({},context.options[context.options.length-1]);if(typeof context.options[0]==="number"){options.code=context.options[0];}if(typeof context.options[1]==="number"){options.tabWidth=context.options[1];}const maxLength=typeof options.code==="number"?options.code:80,tabWidth=typeof options.tabWidth==="number"?options.tabWidth:4,ignoreComments=!!options.ignoreComments,ignoreStrings=!!options.ignoreStrings,ignoreTemplateLiterals=!!options.ignoreTemplateLiterals,ignoreRegExpLiterals=!!options.ignoreRegExpLiterals,ignoreTrailingComments=!!options.ignoreTrailingComments||!!options.ignoreComments,ignoreUrls=!!options.ignoreUrls,maxCommentLength=options.comments;let ignorePattern=options.ignorePattern||null;if(ignorePattern){ignorePattern=new RegExp(ignorePattern,"u");}function isTrailingComment(line,lineNumber,comment){return comment&&comment.loc.start.line===lineNumber&&lineNumber<=comment.loc.end.line&&(comment.loc.end.line>lineNumber||comment.loc.end.column===line.length);}function isFullLineComment(line,lineNumber,comment){const start=comment.loc.start,end=comment.loc.end,isFirstTokenOnLine=!line.slice(0,comment.loc.start.column).trim();return comment&&(start.line<lineNumber||start.line===lineNumber&&isFirstTokenOnLine)&&(end.line>lineNumber||end.line===lineNumber&&end.column===line.length);}function isJSXEmptyExpressionInSingleLineContainer(node){if(!node||!node.parent||node.type!=="JSXEmptyExpression"||node.parent.type!=="JSXExpressionContainer"){return false;}const parent=node.parent;return parent.loc.start.line===parent.loc.end.line;}function stripTrailingComment(line,comment){return line.slice(0,comment.loc.start.column).replace(/\s+$/u,"");}function ensureArrayAndPush(object,key,value){if(!Array.isArray(object[key])){object[key]=[];}object[key].push(value);}function getAllStrings(){return sourceCode.ast.tokens.filter(token=>token.type==="String"||token.type==="JSXText"&&sourceCode.getNodeByRangeIndex(token.range[0]-1).type==="JSXAttribute");}function getAllTemplateLiterals(){return sourceCode.ast.tokens.filter(token=>token.type==="Template");}function getAllRegExpLiterals(){return sourceCode.ast.tokens.filter(token=>token.type==="RegularExpression");}function groupByLineNumber(acc,node){for(let i=node.loc.start.line;i<=node.loc.end.line;++i){ensureArrayAndPush(acc,i,node);}return acc;}function getAllComments(){const comments=[];sourceCode.getAllComments().forEach(commentNode=>{const containingNode=sourceCode.getNodeByRangeIndex(commentNode.range[0]);if(isJSXEmptyExpressionInSingleLineContainer(containingNode)){if(comments[comments.length-1]!==containingNode.parent){comments.push(containingNode.parent);}}else {comments.push(commentNode);}});return comments;}return {Program:function(node){const lines=sourceCode.lines,comments=ignoreComments||maxCommentLength||ignoreTrailingComments?getAllComments():[];let commentsIndex=0;const strings=getAllStrings();const stringsByLine=strings.reduce(groupByLineNumber,{});const templateLiterals=getAllTemplateLiterals();const templateLiteralsByLine=templateLiterals.reduce(groupByLineNumber,{});const regExpLiterals=getAllRegExpLiterals();const regExpLiteralsByLine=regExpLiterals.reduce(groupByLineNumber,{});lines.forEach((line,i)=>{const lineNumber=i+1;let lineIsComment=false;let textToMeasure;if(commentsIndex<comments.length){let comment=null;do{comment=comments[++commentsIndex];}while(comment&&comment.loc.start.line<=lineNumber);comment=comments[--commentsIndex];if(isFullLineComment(line,lineNumber,comment)){lineIsComment=true;textToMeasure=line;}else if(ignoreTrailingComments&&isTrailingComment(line,lineNumber,comment)){textToMeasure=stripTrailingComment(line,comment);let lastIndex=commentsIndex;while(isTrailingComment(textToMeasure,lineNumber,comments[--lastIndex])){textToMeasure=stripTrailingComment(textToMeasure,comments[lastIndex]);}}else {textToMeasure=line;}}else {textToMeasure=line;}if(ignorePattern&&ignorePattern.test(textToMeasure)||ignoreUrls&&/[^:/?#]:\/\/[^?#]/u.test(textToMeasure)||ignoreStrings&&stringsByLine[lineNumber]||ignoreTemplateLiterals&&templateLiteralsByLine[lineNumber]||ignoreRegExpLiterals&&regExpLiteralsByLine[lineNumber]){return;}const lineLength=computeLineLength(textToMeasure,tabWidth);const commentLengthApplies=lineIsComment&&maxCommentLength;if(lineIsComment&&ignoreComments){return;}const loc={start:{line:lineNumber,column:0},end:{line:lineNumber,column:textToMeasure.length}};if(commentLengthApplies){if(lineLength>maxCommentLength){context.report({node,loc,messageId:"maxComment",data:{lineLength,maxCommentLength}});}}else if(lineLength>maxLength){context.report({node,loc,messageId:"max",data:{lineLength,maxLength}});}});}};}};const OPTIONS_SCHEMA={type:"object",properties:{max:{type:"integer",minimum:0},skipComments:{type:"boolean"},skipBlankLines:{type:"boolean"},IIFEs:{type:"boolean"}},additionalProperties:false};const OPTIONS_OR_INTEGER_SCHEMA={oneOf:[OPTIONS_SCHEMA,{type:"integer",minimum:1}]};function getCommentLineNumbers(comments){const map=new Map();comments.forEach(comment=>{for(let i=comment.loc.start.line;i<=comment.loc.end.line;i++){map.set(i,comment);}});return map;}var maxLinesPerFunction={meta:{type:"suggestion",docs:{description:"enforce a maximum number of lines of code in a function",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/max-lines-per-function"},schema:[OPTIONS_OR_INTEGER_SCHEMA],messages:{exceed:"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."}},create(context){const sourceCode=context.getSourceCode();const lines=sourceCode.lines;const option=context.options[0];let maxLines=50;let skipComments=false;let skipBlankLines=false;let IIFEs=false;if(typeof option==="object"){maxLines=typeof option.max==="number"?option.max:50;skipComments=!!option.skipComments;skipBlankLines=!!option.skipBlankLines;IIFEs=!!option.IIFEs;}else if(typeof option==="number"){maxLines=option;}const commentLineNumbers=getCommentLineNumbers(sourceCode.getAllComments());function isFullLineComment(line,lineNumber,comment){const start=comment.loc.start,end=comment.loc.end,isFirstTokenOnLine=start.line===lineNumber&&!line.slice(0,start.column).trim(),isLastTokenOnLine=end.line===lineNumber&&!line.slice(end.column).trim();return comment&&(start.line<lineNumber||isFirstTokenOnLine)&&(end.line>lineNumber||isLastTokenOnLine);}function isIIFE(node){return (node.type==="FunctionExpression"||node.type==="ArrowFunctionExpression")&&node.parent&&node.parent.type==="CallExpression"&&node.parent.callee===node;}function isEmbedded(node){if(!node.parent){return false;}if(node!==node.parent.value){return false;}if(node.parent.type==="MethodDefinition"){return true;}if(node.parent.type==="Property"){return node.parent.method===true||node.parent.kind==="get"||node.parent.kind==="set";}return false;}function processFunction(funcNode){const node=isEmbedded(funcNode)?funcNode.parent:funcNode;if(!IIFEs&&isIIFE(node)){return;}let lineCount=0;for(let i=node.loc.start.line-1;i<node.loc.end.line;++i){const line=lines[i];if(skipComments){if(commentLineNumbers.has(i+1)&&isFullLineComment(line,i+1,commentLineNumbers.get(i+1))){continue;}}if(skipBlankLines){if(line.match(/^\s*$/u)){continue;}}lineCount++;}if(lineCount>maxLines){const name=lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(funcNode));context.report({node,messageId:"exceed",data:{name,lineCount,maxLines}});}}return {FunctionDeclaration:processFunction,FunctionExpression:processFunction,ArrowFunctionExpression:processFunction};}};var maxLines={meta:{type:"suggestion",docs:{description:"enforce a maximum number of lines per file",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/max-lines"},schema:[{oneOf:[{type:"integer",minimum:0},{type:"object",properties:{max:{type:"integer",minimum:0},skipComments:{type:"boolean"},skipBlankLines:{type:"boolean"}},additionalProperties:false}]}],messages:{exceed:"File has too many lines ({{actual}}). Maximum allowed is {{max}}."}},create(context){const option=context.options[0];let max=300;if(typeof option==="object"&&Object.prototype.hasOwnProperty.call(option,"max")){max=option.max;}else if(typeof option==="number"){max=option;}const skipComments=option&&option.skipComments;const skipBlankLines=option&&option.skipBlankLines;const sourceCode=context.getSourceCode();function isCommentNodeType(token){return token&&(token.type==="Block"||token.type==="Line");}function getLinesWithoutCode(comment){let start=comment.loc.start.line;let end=comment.loc.end.line;let token=comment;do{token=sourceCode.getTokenBefore(token,{includeComments:true});}while(isCommentNodeType(token));if(token&&astUtils.isTokenOnSameLine(token,comment)){start+=1;}token=comment;do{token=sourceCode.getTokenAfter(token,{includeComments:true});}while(isCommentNodeType(token));if(token&&astUtils.isTokenOnSameLine(comment,token)){end-=1;}if(start<=end){return lodash__default['default'].range(start,end+1);}return [];}return {"Program:exit"(){let lines=sourceCode.lines.map((text,i)=>({lineNumber:i+1,text}));if(lines.length>1&&lodash__default['default'].last(lines).text===""){lines.pop();}if(skipBlankLines){lines=lines.filter(l=>l.text.trim()!=="");}if(skipComments){const comments=sourceCode.getAllComments();const commentLines=lodash__default['default'].flatten(comments.map(comment=>getLinesWithoutCode(comment)));lines=lines.filter(l=>!commentLines.includes(l.lineNumber));}if(lines.length>max){const loc={start:{line:lines[max].lineNumber,column:0},end:{line:sourceCode.lines.length,column:lodash__default['default'].last(sourceCode.lines).length}};context.report({loc,messageId:"exceed",data:{max,actual:lines.length}});}}};}};var maxNestedCallbacks={meta:{type:"suggestion",docs:{description:"enforce a maximum depth that callbacks can be nested",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/max-nested-callbacks"},schema:[{oneOf:[{type:"integer",minimum:0},{type:"object",properties:{maximum:{type:"integer",minimum:0},max:{type:"integer",minimum:0}},additionalProperties:false}]}],messages:{exceed:"Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."}},create(context){const option=context.options[0];let THRESHOLD=10;if(typeof option==="object"&&(Object.prototype.hasOwnProperty.call(option,"maximum")||Object.prototype.hasOwnProperty.call(option,"max"))){THRESHOLD=option.maximum||option.max;}else if(typeof option==="number"){THRESHOLD=option;}const callbackStack=[];function checkFunction(node){const parent=node.parent;if(parent.type==="CallExpression"){callbackStack.push(node);}if(callbackStack.length>THRESHOLD){const opts={num:callbackStack.length,max:THRESHOLD};context.report({node,messageId:"exceed",data:opts});}}function popStack(){callbackStack.pop();}return {ArrowFunctionExpression:checkFunction,"ArrowFunctionExpression:exit":popStack,FunctionExpression:checkFunction,"FunctionExpression:exit":popStack};}};var maxParams={meta:{type:"suggestion",docs:{description:"enforce a maximum number of parameters in function definitions",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/max-params"},schema:[{oneOf:[{type:"integer",minimum:0},{type:"object",properties:{maximum:{type:"integer",minimum:0},max:{type:"integer",minimum:0}},additionalProperties:false}]}],messages:{exceed:"{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}."}},create(context){const sourceCode=context.getSourceCode();const option=context.options[0];let numParams=3;if(typeof option==="object"&&(Object.prototype.hasOwnProperty.call(option,"maximum")||Object.prototype.hasOwnProperty.call(option,"max"))){numParams=option.maximum||option.max;}if(typeof option==="number"){numParams=option;}function checkFunction(node){if(node.params.length>numParams){context.report({loc:astUtils.getFunctionHeadLoc(node,sourceCode),node,messageId:"exceed",data:{name:lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(node)),count:node.params.length,max:numParams}});}}return {FunctionDeclaration:checkFunction,ArrowFunctionExpression:checkFunction,FunctionExpression:checkFunction};}};var maxStatementsPerLine={meta:{type:"layout",docs:{description:"enforce a maximum number of statements allowed per line",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/max-statements-per-line"},schema:[{type:"object",properties:{max:{type:"integer",minimum:1,default:1}},additionalProperties:false}],messages:{exceed:"This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}."}},create(context){const sourceCode=context.getSourceCode(),options=context.options[0]||{},maxStatementsPerLine=typeof options.max!=="undefined"?options.max:1;let lastStatementLine=0,numberOfStatementsOnThisLine=0,firstExtraStatement;function reportFirstExtraStatementAndClear(){if(firstExtraStatement){context.report({node:firstExtraStatement,messageId:"exceed",data:{numberOfStatementsOnThisLine,maxStatementsPerLine,statements:numberOfStatementsOnThisLine===1?"statement":"statements"}});}firstExtraStatement=null;}function getActualLastToken(node){return sourceCode.getLastToken(node,astUtils.isNotSemicolonToken);}function enterStatement(node){const line=node.loc.start.line;if(/^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u.test(node.parent.type)&&node.parent.alternate!==node){return;}if(line===lastStatementLine){numberOfStatementsOnThisLine+=1;}else {reportFirstExtraStatementAndClear();numberOfStatementsOnThisLine=1;lastStatementLine=line;}if(numberOfStatementsOnThisLine===maxStatementsPerLine+1){firstExtraStatement=firstExtraStatement||node;}}function leaveStatement(node){const line=getActualLastToken(node).loc.end.line;if(line!==lastStatementLine){reportFirstExtraStatementAndClear();numberOfStatementsOnThisLine=1;lastStatementLine=line;}}return {BreakStatement:enterStatement,ClassDeclaration:enterStatement,ContinueStatement:enterStatement,DebuggerStatement:enterStatement,DoWhileStatement:enterStatement,ExpressionStatement:enterStatement,ForInStatement:enterStatement,ForOfStatement:enterStatement,ForStatement:enterStatement,FunctionDeclaration:enterStatement,IfStatement:enterStatement,ImportDeclaration:enterStatement,LabeledStatement:enterStatement,ReturnStatement:enterStatement,SwitchStatement:enterStatement,ThrowStatement:enterStatement,TryStatement:enterStatement,VariableDeclaration:enterStatement,WhileStatement:enterStatement,WithStatement:enterStatement,ExportNamedDeclaration:enterStatement,ExportDefaultDeclaration:enterStatement,ExportAllDeclaration:enterStatement,"BreakStatement:exit":leaveStatement,"ClassDeclaration:exit":leaveStatement,"ContinueStatement:exit":leaveStatement,"DebuggerStatement:exit":leaveStatement,"DoWhileStatement:exit":leaveStatement,"ExpressionStatement:exit":leaveStatement,"ForInStatement:exit":leaveStatement,"ForOfStatement:exit":leaveStatement,"ForStatement:exit":leaveStatement,"FunctionDeclaration:exit":leaveStatement,"IfStatement:exit":leaveStatement,"ImportDeclaration:exit":leaveStatement,"LabeledStatement:exit":leaveStatement,"ReturnStatement:exit":leaveStatement,"SwitchStatement:exit":leaveStatement,"ThrowStatement:exit":leaveStatement,"TryStatement:exit":leaveStatement,"VariableDeclaration:exit":leaveStatement,"WhileStatement:exit":leaveStatement,"WithStatement:exit":leaveStatement,"ExportNamedDeclaration:exit":leaveStatement,"ExportDefaultDeclaration:exit":leaveStatement,"ExportAllDeclaration:exit":leaveStatement,"Program:exit":reportFirstExtraStatementAndClear};}};var maxStatements={meta:{type:"suggestion",docs:{description:"enforce a maximum number of statements allowed in function blocks",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/max-statements"},schema:[{oneOf:[{type:"integer",minimum:0},{type:"object",properties:{maximum:{type:"integer",minimum:0},max:{type:"integer",minimum:0}},additionalProperties:false}]},{type:"object",properties:{ignoreTopLevelFunctions:{type:"boolean"}},additionalProperties:false}],messages:{exceed:"{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}."}},create(context){const functionStack=[],option=context.options[0],ignoreTopLevelFunctions=context.options[1]&&context.options[1].ignoreTopLevelFunctions||false,topLevelFunctions=[];let maxStatements=10;if(typeof option==="object"&&(Object.prototype.hasOwnProperty.call(option,"maximum")||Object.prototype.hasOwnProperty.call(option,"max"))){maxStatements=option.maximum||option.max;}else if(typeof option==="number"){maxStatements=option;}function reportIfTooManyStatements(node,count,max){if(count>max){const name=lodash__default['default'].upperFirst(astUtils.getFunctionNameWithKind(node));context.report({node,messageId:"exceed",data:{name,count,max}});}}function startFunction(){functionStack.push(0);}function endFunction(node){const count=functionStack.pop();if(ignoreTopLevelFunctions&&functionStack.length===0){topLevelFunctions.push({node,count});}else {reportIfTooManyStatements(node,count,maxStatements);}}return {FunctionDeclaration:startFunction,FunctionExpression:startFunction,ArrowFunctionExpression:startFunction,BlockStatement:function(node){functionStack[functionStack.length-1]+=node.body.length;},"FunctionDeclaration:exit":endFunction,"FunctionExpression:exit":endFunction,"ArrowFunctionExpression:exit":endFunction,"Program:exit"(){if(topLevelFunctions.length===1){return;}topLevelFunctions.forEach(element=>{const count=element.count;const node=element.node;reportIfTooManyStatements(node,count,maxStatements);});}};}};var multilineCommentStyle={meta:{type:"suggestion",docs:{description:"enforce a particular style for multiline comments",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/multiline-comment-style"},fixable:"whitespace",schema:[{enum:["starred-block","separate-lines","bare-block"]}],messages:{expectedBlock:"Expected a block comment instead of consecutive line comments.",expectedBareBlock:"Expected a block comment without padding stars.",startNewline:"Expected a linebreak after '/*'.",endNewline:"Expected a linebreak before '*/'.",missingStar:"Expected a '*' at the start of this line.",alignment:"Expected this line to be aligned with the start of the comment.",expectedLines:"Expected multiple line comments instead of a block comment."}},create(context){const sourceCode=context.getSourceCode();const option=context.options[0]||"starred-block";function isStarredCommentLine(line){return /^\s*\*/u.test(line);}function isStarredBlockComment([firstComment]){if(firstComment.type!=="Block"){return false;}const lines=firstComment.value.split(astUtils.LINEBREAK_MATCHER);return lines.length>0&&lines.every((line,i)=>(i===0||i===lines.length-1?/^\s*$/u:/^\s*\*/u).test(line));}function isJSDocComment([firstComment]){if(firstComment.type!=="Block"){return false;}const lines=firstComment.value.split(astUtils.LINEBREAK_MATCHER);return /^\*\s*$/u.test(lines[0])&&lines.slice(1,-1).every(line=>/^\s* /u.test(line))&&/^\s*$/u.test(lines[lines.length-1]);}function processSeparateLineComments(commentGroup){const allLinesHaveLeadingSpace=commentGroup.map(({value})=>value).filter(line=>line.trim().length).every(line=>line.startsWith(" "));return commentGroup.map(({value})=>allLinesHaveLeadingSpace?value.replace(/^ /u,""):value);}function processStarredBlockComment(comment){const lines=comment.value.split(astUtils.LINEBREAK_MATCHER).filter((line,i,linesArr)=>!(i===0||i===linesArr.length-1)).map(line=>line.replace(/^\s*$/u,""));const allLinesHaveLeadingSpace=lines.map(line=>line.replace(/\s*\*/u,"")).filter(line=>line.trim().length).every(line=>line.startsWith(" "));return lines.map(line=>line.replace(allLinesHaveLeadingSpace?/\s*\* ?/u:/\s*\*/u,""));}function processBareBlockComment(comment){const lines=comment.value.split(astUtils.LINEBREAK_MATCHER).map(line=>line.replace(/^\s*$/u,""));const leadingWhitespace=`${sourceCode.text.slice(comment.range[0]-comment.loc.start.column,comment.range[0])}   `;let offset="";for(const[i,line]of lines.entries()){if(!line.trim().length||i===0){continue;}const[,lineOffset]=line.match(/^(\s*\*?\s*)/u);if(lineOffset.length<leadingWhitespace.length){const newOffset=leadingWhitespace.slice(lineOffset.length-leadingWhitespace.length);if(newOffset.length>offset.length){offset=newOffset;}}}return lines.map(line=>{const match=line.match(/^(\s*\*?\s*)(.*)/u);const[,lineOffset,lineContents]=match;if(lineOffset.length>leadingWhitespace.length){return `${lineOffset.slice(leadingWhitespace.length-(offset.length+lineOffset.length))}${lineContents}`;}if(lineOffset.length<leadingWhitespace.length){return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;}return lineContents;});}function getCommentLines(commentGroup){const[firstComment]=commentGroup;if(firstComment.type==="Line"){return processSeparateLineComments(commentGroup);}if(isStarredBlockComment(commentGroup)){return processStarredBlockComment(firstComment);}return processBareBlockComment(firstComment);}function getInitialOffset(comment){return sourceCode.text.slice(comment.range[0]-comment.loc.start.column,comment.range[0]);}function convertToStarredBlock(firstComment,commentLinesList){const initialOffset=getInitialOffset(firstComment);return `/*\n${commentLinesList.map(line=>`${initialOffset} * ${line}`).join("\n")}\n${initialOffset} */`;}function convertToSeparateLines(firstComment,commentLinesList){return commentLinesList.map(line=>`// ${line}`).join(`\n${getInitialOffset(firstComment)}`);}function convertToBlock(firstComment,commentLinesList){return `/* ${commentLinesList.join(`\n${getInitialOffset(firstComment)}   `)} */`;}const commentGroupCheckers={"starred-block"(commentGroup){const[firstComment]=commentGroup;const commentLines=getCommentLines(commentGroup);if(commentLines.some(value=>value.includes("*/"))){return;}if(commentGroup.length>1){context.report({loc:{start:firstComment.loc.start,end:commentGroup[commentGroup.length-1].loc.end},messageId:"expectedBlock",fix(fixer){const range=[firstComment.range[0],commentGroup[commentGroup.length-1].range[1]];return commentLines.some(value=>value.startsWith("/"))?null:fixer.replaceTextRange(range,convertToStarredBlock(firstComment,commentLines));}});}else {const lines=firstComment.value.split(astUtils.LINEBREAK_MATCHER);const expectedLeadingWhitespace=getInitialOffset(firstComment);const expectedLinePrefix=`${expectedLeadingWhitespace} *`;if(!/^\*?\s*$/u.test(lines[0])){const start=firstComment.value.startsWith("*")?firstComment.range[0]+1:firstComment.range[0];context.report({loc:{start:firstComment.loc.start,end:{line:firstComment.loc.start.line,column:firstComment.loc.start.column+2}},messageId:"startNewline",fix:fixer=>fixer.insertTextAfterRange([start,start+2],`\n${expectedLinePrefix}`)});}if(!/^\s*$/u.test(lines[lines.length-1])){context.report({loc:{start:{line:firstComment.loc.end.line,column:firstComment.loc.end.column-2},end:firstComment.loc.end},messageId:"endNewline",fix:fixer=>fixer.replaceTextRange([firstComment.range[1]-2,firstComment.range[1]],`\n${expectedLinePrefix}/`)});}for(let lineNumber=firstComment.loc.start.line+1;lineNumber<=firstComment.loc.end.line;lineNumber++){const lineText=sourceCode.lines[lineNumber-1];const errorType=isStarredCommentLine(lineText)?"alignment":"missingStar";if(!lineText.startsWith(expectedLinePrefix)){context.report({loc:{start:{line:lineNumber,column:0},end:{line:lineNumber,column:lineText.length}},messageId:errorType,fix(fixer){const lineStartIndex=sourceCode.getIndexFromLoc({line:lineNumber,column:0});if(errorType==="alignment"){const[,commentTextPrefix=""]=lineText.match(/^(\s*\*)/u)||[];const commentTextStartIndex=lineStartIndex+commentTextPrefix.length;return fixer.replaceTextRange([lineStartIndex,commentTextStartIndex],expectedLinePrefix);}const[,commentTextPrefix=""]=lineText.match(/^(\s*)/u)||[];const commentTextStartIndex=lineStartIndex+commentTextPrefix.length;let offset;for(const[idx,line]of lines.entries()){if(!/\S+/u.test(line)){continue;}const lineTextToAlignWith=sourceCode.lines[firstComment.loc.start.line-1+idx];const[,prefix="",initialOffset=""]=lineTextToAlignWith.match(/^(\s*(?:\/?\*)?(\s*))/u)||[];offset=`${commentTextPrefix.slice(prefix.length)}${initialOffset}`;if(/^\s*\//u.test(lineText)&&offset.length===0){offset+=" ";}break;}return fixer.replaceTextRange([lineStartIndex,commentTextStartIndex],`${expectedLinePrefix}${offset}`);}});}}}},"separate-lines"(commentGroup){const[firstComment]=commentGroup;if(firstComment.type!=="Block"||isJSDocComment(commentGroup)){return;}const commentLines=getCommentLines(commentGroup);const tokenAfter=sourceCode.getTokenAfter(firstComment,{includeComments:true});if(tokenAfter&&firstComment.loc.end.line===tokenAfter.loc.start.line){return;}context.report({loc:{start:firstComment.loc.start,end:{line:firstComment.loc.start.line,column:firstComment.loc.start.column+2}},messageId:"expectedLines",fix(fixer){return fixer.replaceText(firstComment,convertToSeparateLines(firstComment,commentLines));}});},"bare-block"(commentGroup){if(isJSDocComment(commentGroup)){return;}const[firstComment]=commentGroup;const commentLines=getCommentLines(commentGroup);if(firstComment.type==="Line"&&commentLines.length>1&&!commentLines.some(value=>value.includes("*/"))){context.report({loc:{start:firstComment.loc.start,end:commentGroup[commentGroup.length-1].loc.end},messageId:"expectedBlock",fix(fixer){return fixer.replaceTextRange([firstComment.range[0],commentGroup[commentGroup.length-1].range[1]],convertToBlock(firstComment,commentLines));}});}if(isStarredBlockComment(commentGroup)){context.report({loc:{start:firstComment.loc.start,end:{line:firstComment.loc.start.line,column:firstComment.loc.start.column+2}},messageId:"expectedBareBlock",fix(fixer){return fixer.replaceText(firstComment,convertToBlock(firstComment,commentLines));}});}}};return {Program(){return sourceCode.getAllComments().filter(comment=>comment.type!=="Shebang").filter(comment=>!astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter(comment=>{const tokenBefore=sourceCode.getTokenBefore(comment,{includeComments:true});return !tokenBefore||tokenBefore.loc.end.line<comment.loc.start.line;}).reduce((commentGroups,comment,index,commentList)=>{const tokenBefore=sourceCode.getTokenBefore(comment,{includeComments:true});if(comment.type==="Line"&&index&&commentList[index-1].type==="Line"&&tokenBefore&&tokenBefore.loc.end.line===comment.loc.start.line-1&&tokenBefore===commentList[index-1]){commentGroups[commentGroups.length-1].push(comment);}else {commentGroups.push([comment]);}return commentGroups;},[]).filter(commentGroup=>!(commentGroup.length===1&&commentGroup[0].loc.start.line===commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);}};}};var multilineTernary={meta:{type:"layout",docs:{description:"enforce newlines between operands of ternary expressions",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/multiline-ternary"},schema:[{enum:["always","always-multiline","never"]}],messages:{expectedTestCons:"Expected newline between test and consequent of ternary expression.",expectedConsAlt:"Expected newline between consequent and alternate of ternary expression.",unexpectedTestCons:"Unexpected newline between test and consequent of ternary expression.",unexpectedConsAlt:"Unexpected newline between consequent and alternate of ternary expression."},fixable:"whitespace"},create(context){const sourceCode=context.getSourceCode();const option=context.options[0];return {ConditionalExpression(node){const questionToken=sourceCode.getTokenAfter(node.test,astUtils.isNotClosingParenToken);const colonToken=sourceCode.getTokenAfter(node.consequent,astUtils.isNotClosingParenToken);const firstTokenOfTest=sourceCode.getFirstToken(node);const lastTokenOfTest=sourceCode.getTokenBefore(questionToken);const firstTokenOfConsequent=sourceCode.getTokenAfter(questionToken);const lastTokenOfConsequent=sourceCode.getTokenBefore(colonToken);const firstTokenOfAlternate=sourceCode.getTokenAfter(colonToken);const areTestAndConsequentOnSameLine=astUtils.isTokenOnSameLine(lastTokenOfTest,firstTokenOfConsequent);const areConsequentAndAlternateOnSameLine=astUtils.isTokenOnSameLine(lastTokenOfConsequent,firstTokenOfAlternate);const hasComments=!!sourceCode.getCommentsInside(node).length;if(!(option!=="never")){if(!areTestAndConsequentOnSameLine){context.report({node:node.test,loc:{start:firstTokenOfTest.loc.start,end:lastTokenOfTest.loc.end},messageId:"unexpectedTestCons",fix:fixer=>{if(hasComments){return null;}const fixers=[];const areTestAndQuestionOnSameLine=astUtils.isTokenOnSameLine(lastTokenOfTest,questionToken);const areQuestionAndConsOnSameLine=astUtils.isTokenOnSameLine(questionToken,firstTokenOfConsequent);if(!areTestAndQuestionOnSameLine){fixers.push(fixer.removeRange([lastTokenOfTest.range[1],questionToken.range[0]]));}if(!areQuestionAndConsOnSameLine){fixers.push(fixer.removeRange([questionToken.range[1],firstTokenOfConsequent.range[0]]));}return fixers;}});}if(!areConsequentAndAlternateOnSameLine){context.report({node:node.consequent,loc:{start:firstTokenOfConsequent.loc.start,end:lastTokenOfConsequent.loc.end},messageId:"unexpectedConsAlt",fix:fixer=>{if(hasComments){return null;}const fixers=[];const areConsAndColonOnSameLine=astUtils.isTokenOnSameLine(lastTokenOfConsequent,colonToken);const areColonAndAltOnSameLine=astUtils.isTokenOnSameLine(colonToken,firstTokenOfAlternate);if(!areConsAndColonOnSameLine){fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1],colonToken.range[0]]));}if(!areColonAndAltOnSameLine){fixers.push(fixer.removeRange([colonToken.range[1],firstTokenOfAlternate.range[0]]));}return fixers;}});}}else {if(option==="always-multiline"&&node.loc.start.line===node.loc.end.line){return;}if(areTestAndConsequentOnSameLine){context.report({node:node.test,loc:{start:firstTokenOfTest.loc.start,end:lastTokenOfTest.loc.end},messageId:"expectedTestCons",fix:fixer=>hasComments?null:fixer.replaceTextRange([lastTokenOfTest.range[1],questionToken.range[0]],"\n")});}if(areConsequentAndAlternateOnSameLine){context.report({node:node.consequent,loc:{start:firstTokenOfConsequent.loc.start,end:lastTokenOfConsequent.loc.end},messageId:"expectedConsAlt",fix:fixer=>hasComments?null:fixer.replaceTextRange([lastTokenOfConsequent.range[1],colonToken.range[0]],"\n")});}}}};}};const CAPS_ALLOWED=["Array","Boolean","Date","Error","Function","Number","Object","RegExp","String","Symbol","BigInt"];function checkArray(obj,key,fallback){if(Object.prototype.hasOwnProperty.call(obj,key)&&!Array.isArray(obj[key])){throw new TypeError(`${key}, if provided, must be an Array`);}return obj[key]||fallback;}function invert(map,key){map[key]=true;return map;}function calculateCapIsNewExceptions(config){let capIsNewExceptions=checkArray(config,"capIsNewExceptions",CAPS_ALLOWED);if(capIsNewExceptions!==CAPS_ALLOWED){capIsNewExceptions=capIsNewExceptions.concat(CAPS_ALLOWED);}return capIsNewExceptions.reduce(invert,{});}var newCap={meta:{type:"suggestion",docs:{description:"require constructor names to begin with a capital letter",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/new-cap"},schema:[{type:"object",properties:{newIsCap:{type:"boolean",default:true},capIsNew:{type:"boolean",default:true},newIsCapExceptions:{type:"array",items:{type:"string"}},newIsCapExceptionPattern:{type:"string"},capIsNewExceptions:{type:"array",items:{type:"string"}},capIsNewExceptionPattern:{type:"string"},properties:{type:"boolean",default:true}},additionalProperties:false}],messages:{upper:"A function with a name starting with an uppercase letter should only be used as a constructor.",lower:"A constructor name should not start with a lowercase letter."}},create(context){const config=Object.assign({},context.options[0]);config.newIsCap=config.newIsCap!==false;config.capIsNew=config.capIsNew!==false;const skipProperties=config.properties===false;const newIsCapExceptions=checkArray(config,"newIsCapExceptions",[]).reduce(invert,{});const newIsCapExceptionPattern=config.newIsCapExceptionPattern?new RegExp(config.newIsCapExceptionPattern,"u"):null;const capIsNewExceptions=calculateCapIsNewExceptions(config);const capIsNewExceptionPattern=config.capIsNewExceptionPattern?new RegExp(config.capIsNewExceptionPattern,"u"):null;const listeners={};const sourceCode=context.getSourceCode();function extractNameFromExpression(node){return node.callee.type==="Identifier"?node.callee.name:astUtils.getStaticPropertyName(node.callee)||"";}function getCap(str){const firstChar=str.charAt(0);const firstCharLower=firstChar.toLowerCase();const firstCharUpper=firstChar.toUpperCase();if(firstCharLower===firstCharUpper){return "non-alpha";}if(firstChar===firstCharLower){return "lower";}return "upper";}function isCapAllowed(allowedMap,node,calleeName,pattern){const sourceText=sourceCode.getText(node.callee);if(allowedMap[calleeName]||allowedMap[sourceText]){return true;}if(pattern&&pattern.test(sourceText)){return true;}const callee=astUtils.skipChainExpression(node.callee);if(calleeName==="UTC"&&callee.type==="MemberExpression"){return callee.object.type==="Identifier"&&callee.object.name==="Date";}return skipProperties&&callee.type==="MemberExpression";}function report(node,messageId){let callee=astUtils.skipChainExpression(node.callee);if(callee.type==="MemberExpression"){callee=callee.property;}context.report({node,loc:callee.loc,messageId});}if(config.newIsCap){listeners.NewExpression=function(node){const constructorName=extractNameFromExpression(node);if(constructorName){const capitalization=getCap(constructorName);const isAllowed=capitalization!=="lower"||isCapAllowed(newIsCapExceptions,node,constructorName,newIsCapExceptionPattern);if(!isAllowed){report(node,"lower");}}};}if(config.capIsNew){listeners.CallExpression=function(node){const calleeName=extractNameFromExpression(node);if(calleeName){const capitalization=getCap(calleeName);const isAllowed=capitalization!=="upper"||isCapAllowed(capIsNewExceptions,node,calleeName,capIsNewExceptionPattern);if(!isAllowed){report(node,"upper");}}};}return listeners;}};var newParens={meta:{type:"layout",docs:{description:"enforce or disallow parentheses when invoking a constructor with no arguments",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/new-parens"},fixable:"code",schema:{anyOf:[{type:"array",items:[{enum:["always","never"]}],minItems:0,maxItems:1}]},messages:{missing:"Missing '()' invoking a constructor.",unnecessary:"Unnecessary '()' invoking a constructor with no arguments."}},create(context){const options=context.options;const always=options[0]!=="never";const sourceCode=context.getSourceCode();return {NewExpression(node){if(node.arguments.length!==0){return;}const lastToken=sourceCode.getLastToken(node);const hasLastParen=lastToken&&astUtils.isClosingParenToken(lastToken);const hasParens=hasLastParen&&astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken))&&node.callee.range[1]<node.range[1];if(always){if(!hasParens){context.report({node,messageId:"missing",fix:fixer=>fixer.insertTextAfter(node,"()")});}}else {if(hasParens){context.report({node,messageId:"unnecessary",fix:fixer=>[fixer.remove(sourceCode.getTokenBefore(lastToken)),fixer.remove(lastToken),fixer.insertTextBefore(node,"("),fixer.insertTextAfter(node,")")]});}}}};}};var newlineAfterVar={meta:{type:"layout",docs:{description:"require or disallow an empty line after variable declarations",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/newline-after-var"},schema:[{enum:["never","always"]}],fixable:"whitespace",messages:{expected:"Expected blank line after variable declarations.",unexpected:"Unexpected blank line after variable declarations."},deprecated:true,replacedBy:["padding-line-between-statements"]},create(context){const sourceCode=context.getSourceCode();const mode=context.options[0]==="never"?"never":"always";const commentEndLine=sourceCode.getAllComments().reduce((result,token)=>{result[token.loc.start.line]=token.loc.end.line;return result;},{});function getLastToken(node){const lastToken=sourceCode.getLastToken(node);if(lastToken.type==="Punctuator"&&lastToken.value===";"){const prevToken=sourceCode.getTokenBefore(lastToken);if(prevToken.loc.end.line!==lastToken.loc.start.line){return prevToken;}}return lastToken;}function isVar(keyword){return keyword==="var"||keyword==="let"||keyword==="const";}function isForTypeSpecifier(keyword){return keyword==="ForStatement"||keyword==="ForInStatement"||keyword==="ForOfStatement";}function isExportSpecifier(nodeType){return nodeType==="ExportNamedDeclaration"||nodeType==="ExportSpecifier"||nodeType==="ExportDefaultDeclaration"||nodeType==="ExportAllDeclaration";}function isLastNode(node){const token=sourceCode.getTokenAfter(node);return !token||token.type==="Punctuator"&&token.value==="}";}function getLastCommentLineOfBlock(commentStartLine){const currentCommentEnd=commentEndLine[commentStartLine];return commentEndLine[currentCommentEnd+1]?getLastCommentLineOfBlock(currentCommentEnd+1):currentCommentEnd;}function hasBlankLineAfterComment(token,commentStartLine){return token.loc.start.line>getLastCommentLineOfBlock(commentStartLine)+1;}return {VariableDeclaration:function(node){const lastToken=getLastToken(node),nextToken=lastToken===sourceCode.getLastToken(node)?sourceCode.getTokenAfter(node):sourceCode.getLastToken(node),nextLineNum=lastToken.loc.end.line+1;if(!nextToken){return;}if(isForTypeSpecifier(node.parent.type)){return;}if(isExportSpecifier(node.parent.type)){return;}if(nextToken.type==="Keyword"&&isVar(nextToken.value)){return;}if(isLastNode(node)){return;}const noNextLineToken=nextToken.loc.start.line>nextLineNum;const hasNextLineComment=typeof commentEndLine[nextLineNum]!=="undefined";if(mode==="never"&&noNextLineToken&&!hasNextLineComment){context.report({node,messageId:"unexpected",data:{identifier:node.name},fix(fixer){const linesBetween=sourceCode.getText().slice(lastToken.range[1],nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);return fixer.replaceTextRange([lastToken.range[1],nextToken.range[0]],`${linesBetween.slice(0,-1).join("")}\n${linesBetween[linesBetween.length-1]}`);}});}if(mode==="always"&&(!noNextLineToken||hasNextLineComment&&!hasBlankLineAfterComment(nextToken,nextLineNum))){context.report({node,messageId:"expected",data:{identifier:node.name},fix(fixer){if((noNextLineToken?getLastCommentLineOfBlock(nextLineNum):lastToken.loc.end.line)===nextToken.loc.start.line){return fixer.insertTextBefore(nextToken,"\n\n");}return fixer.insertTextBeforeRange([nextToken.range[0]-nextToken.loc.start.column,nextToken.range[1]],"\n");}});}}};}};var newlineBeforeReturn={meta:{type:"layout",docs:{description:"require an empty line before `return` statements",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/newline-before-return"},fixable:"whitespace",schema:[],messages:{expected:"Expected newline before return statement."},deprecated:true,replacedBy:["padding-line-between-statements"]},create(context){const sourceCode=context.getSourceCode();function isPrecededByTokens(node,testTokens){const tokenBefore=sourceCode.getTokenBefore(node);return testTokens.some(token=>tokenBefore.value===token);}function isFirstNode(node){const parentType=node.parent.type;if(node.parent.body){return Array.isArray(node.parent.body)?node.parent.body[0]===node:node.parent.body===node;}if(parentType==="IfStatement"){return isPrecededByTokens(node,["else",")"]);}if(parentType==="DoWhileStatement"){return isPrecededByTokens(node,["do"]);}if(parentType==="SwitchCase"){return isPrecededByTokens(node,[":"]);}return isPrecededByTokens(node,[")"]);}function calcCommentLines(node,lineNumTokenBefore){const comments=sourceCode.getCommentsBefore(node);let numLinesComments=0;if(!comments.length){return numLinesComments;}comments.forEach(comment=>{numLinesComments++;if(comment.type==="Block"){numLinesComments+=comment.loc.end.line-comment.loc.start.line;}if(comment.loc.start.line===lineNumTokenBefore){numLinesComments--;}if(comment.loc.end.line===node.loc.start.line){numLinesComments--;}});return numLinesComments;}function getLineNumberOfTokenBefore(node){const tokenBefore=sourceCode.getTokenBefore(node);let lineNumTokenBefore;if(tokenBefore){lineNumTokenBefore=tokenBefore.loc.end.line;}else {lineNumTokenBefore=0;}return lineNumTokenBefore;}function hasNewlineBefore(node){const lineNumNode=node.loc.start.line;const lineNumTokenBefore=getLineNumberOfTokenBefore(node);const commentLines=calcCommentLines(node,lineNumTokenBefore);return lineNumNode-lineNumTokenBefore-commentLines>1;}function canFix(node){const leadingComments=sourceCode.getCommentsBefore(node);const lastLeadingComment=leadingComments[leadingComments.length-1];const tokenBefore=sourceCode.getTokenBefore(node);if(leadingComments.length===0){return true;}if(lastLeadingComment.loc.end.line===tokenBefore.loc.end.line&&lastLeadingComment.loc.end.line!==node.loc.start.line){return true;}return false;}return {ReturnStatement(node){if(!isFirstNode(node)&&!hasNewlineBefore(node)){context.report({node,messageId:"expected",fix(fixer){if(canFix(node)){const tokenBefore=sourceCode.getTokenBefore(node);const newlines=node.loc.start.line===tokenBefore.loc.end.line?"\n\n":"\n";return fixer.insertTextBefore(node,newlines);}return null;}});}}};}};var newlinePerChainedCall={meta:{type:"layout",docs:{description:"require a newline after each call in a method chain",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/newline-per-chained-call"},fixable:"whitespace",schema:[{type:"object",properties:{ignoreChainWithDepth:{type:"integer",minimum:1,maximum:10,default:2}},additionalProperties:false}],messages:{expected:"Expected line break before `{{callee}}`."}},create(context){const options=context.options[0]||{},ignoreChainWithDepth=options.ignoreChainWithDepth||2;const sourceCode=context.getSourceCode();function getPrefix(node){if(node.computed){if(node.optional){return "?.[";}return "[";}if(node.optional){return "?.";}return ".";}function getPropertyText(node){const prefix=getPrefix(node);const lines=sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);const suffix=node.computed&&lines.length===1?"]":"";return prefix+lines[0]+suffix;}return {"CallExpression:exit"(node){const callee=astUtils.skipChainExpression(node.callee);if(callee.type!=="MemberExpression"){return;}let parent=astUtils.skipChainExpression(callee.object);let depth=1;while(parent&&parent.callee){depth+=1;parent=astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);}if(depth>ignoreChainWithDepth&&astUtils.isTokenOnSameLine(callee.object,callee.property)){const firstTokenAfterObject=sourceCode.getTokenAfter(callee.object,astUtils.isNotClosingParenToken);context.report({node:callee.property,loc:{start:firstTokenAfterObject.loc.start,end:callee.loc.end},messageId:"expected",data:{callee:getPropertyText(callee)},fix(fixer){return fixer.insertTextBefore(firstTokenAfterObject,"\n");}});}}};}};const{getStaticPropertyName:getPropertyName$2,getVariableByName,skipChainExpression}=astUtils;function isProhibitedIdentifier(name){return /^(alert|confirm|prompt)$/u.test(name);}function findReference(scope,node){const references=scope.references.filter(reference=>reference.identifier.range[0]===node.range[0]&&reference.identifier.range[1]===node.range[1]);if(references.length===1){return references[0];}return null;}function isShadowed$1(scope,node){const reference=findReference(scope,node);return reference&&reference.resolved&&reference.resolved.defs.length>0;}function isGlobalThisReferenceOrGlobalWindow(scope,node){if(scope.type==="global"&&node.type==="ThisExpression"){return true;}if(node.type==="Identifier"&&(node.name==="window"||node.name==="globalThis"&&getVariableByName(scope,"globalThis"))){return !isShadowed$1(scope,node);}return false;}var noAlert={meta:{type:"suggestion",docs:{description:"disallow the use of `alert`, `confirm`, and `prompt`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-alert"},schema:[],messages:{unexpected:"Unexpected {{name}}."}},create(context){return {CallExpression(node){const callee=skipChainExpression(node.callee),currentScope=context.getScope();if(callee.type==="Identifier"){const name=callee.name;if(!isShadowed$1(currentScope,callee)&&isProhibitedIdentifier(callee.name)){context.report({node,messageId:"unexpected",data:{name}});}}else if(callee.type==="MemberExpression"&&isGlobalThisReferenceOrGlobalWindow(currentScope,callee.object)){const name=getPropertyName$2(callee);if(isProhibitedIdentifier(name)){context.report({node,messageId:"unexpected",data:{name}});}}}};}};var noArrayConstructor={meta:{type:"suggestion",docs:{description:"disallow `Array` constructors",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-array-constructor"},schema:[],messages:{preferLiteral:"The array literal notation [] is preferable."}},create(context){function check(node){if(node.arguments.length!==1&&node.callee.type==="Identifier"&&node.callee.name==="Array"){context.report({node,messageId:"preferLiteral"});}}return {CallExpression:check,NewExpression:check};}};var noAsyncPromiseExecutor={meta:{type:"problem",docs:{description:"disallow using an async function as a Promise executor",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-async-promise-executor"},fixable:null,schema:[],messages:{async:"Promise executor functions should not be async."}},create(context){return {"NewExpression[callee.name='Promise'][arguments.0.async=true]"(node){context.report({node:context.getSourceCode().getFirstToken(node.arguments[0],token=>token.value==="async"),messageId:"async"});}};}};function isBoundary(node){const t=node.type;return t==="FunctionDeclaration"||t==="FunctionExpression"||t==="ArrowFunctionExpression"||t==="ForOfStatement"&&node.await===true;}function isLooped(node,parent){switch(parent.type){case"ForStatement":return node===parent.test||node===parent.update||node===parent.body;case"ForOfStatement":case"ForInStatement":return node===parent.body;case"WhileStatement":case"DoWhileStatement":return node===parent.test||node===parent.body;default:return false;}}var noAwaitInLoop={meta:{type:"problem",docs:{description:"disallow `await` inside of loops",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-await-in-loop"},schema:[],messages:{unexpectedAwait:"Unexpected `await` inside a loop."}},create(context){function validate(awaitNode){if(awaitNode.type==="ForOfStatement"&&!awaitNode.await){return;}let node=awaitNode;let parent=node.parent;while(parent&&!isBoundary(parent)){if(isLooped(node,parent)){context.report({node:awaitNode,messageId:"unexpectedAwait"});return;}node=parent;parent=parent.parent;}}return {AwaitExpression:validate,ForOfStatement:validate};}};const BITWISE_OPERATORS$1=["^","|","&","<<",">>",">>>","^=","|=","&=","<<=",">>=",">>>=","~"];var noBitwise={meta:{type:"suggestion",docs:{description:"disallow bitwise operators",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-bitwise"},schema:[{type:"object",properties:{allow:{type:"array",items:{enum:BITWISE_OPERATORS$1},uniqueItems:true},int32Hint:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpected:"Unexpected use of '{{operator}}'."}},create(context){const options=context.options[0]||{};const allowed=options.allow||[];const int32Hint=options.int32Hint===true;function report(node){context.report({node,messageId:"unexpected",data:{operator:node.operator}});}function hasBitwiseOperator(node){return BITWISE_OPERATORS$1.indexOf(node.operator)!==-1;}function allowedOperator(node){return allowed.indexOf(node.operator)!==-1;}function isInt32Hint(node){return int32Hint&&node.operator==="|"&&node.right&&node.right.type==="Literal"&&node.right.value===0;}function checkNodeForBitwiseOperator(node){if(hasBitwiseOperator(node)&&!allowedOperator(node)&&!isInt32Hint(node)){report(node);}}return {AssignmentExpression:checkNodeForBitwiseOperator,BinaryExpression:checkNodeForBitwiseOperator,UnaryExpression:checkNodeForBitwiseOperator};}};var noBufferConstructor={meta:{deprecated:true,replacedBy:[],type:"problem",docs:{description:"disallow use of the `Buffer()` constructor",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/no-buffer-constructor"},schema:[],messages:{deprecated:"{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead."}},create(context){return {"CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(node){context.report({node,messageId:"deprecated",data:{expr:node.type==="CallExpression"?"Buffer()":"new Buffer()"}});}};}};var noCaller={meta:{type:"suggestion",docs:{description:"disallow the use of `arguments.caller` or `arguments.callee`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-caller"},schema:[],messages:{unexpected:"Avoid arguments.{{prop}}."}},create(context){return {MemberExpression(node){const objectName=node.object.name,propertyName=node.property.name;if(objectName==="arguments"&&!node.computed&&propertyName&&propertyName.match(/^calle[er]$/u)){context.report({node,messageId:"unexpected",data:{prop:propertyName}});}}};}};var noCaseDeclarations={meta:{type:"suggestion",docs:{description:"disallow lexical declarations in case clauses",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-case-declarations"},schema:[],messages:{unexpected:"Unexpected lexical declaration in case block."}},create(context){function isLexicalDeclaration(node){switch(node.type){case"FunctionDeclaration":case"ClassDeclaration":return true;case"VariableDeclaration":return node.kind!=="var";default:return false;}}return {SwitchCase(node){for(let i=0;i<node.consequent.length;i++){const statement=node.consequent[i];if(isLexicalDeclaration(statement)){context.report({node:statement,messageId:"unexpected"});}}}};}};var noCatchShadow={meta:{type:"suggestion",docs:{description:"disallow `catch` clause parameters from shadowing variables in the outer scope",category:"Variables",recommended:false,url:"https://eslint.org/docs/rules/no-catch-shadow"},replacedBy:["no-shadow"],deprecated:true,schema:[],messages:{mutable:"Value of '{{name}}' may be overwritten in IE 8 and earlier."}},create(context){function paramIsShadowing(scope,name){return astUtils.getVariableByName(scope,name)!==null;}return {"CatchClause[param!=null]"(node){let scope=context.getScope();if(scope.block===node){scope=scope.upper;}if(paramIsShadowing(scope,node.param.name)){context.report({node,messageId:"mutable",data:{name:node.param.name}});}}};}};var noClassAssign={meta:{type:"problem",docs:{description:"disallow reassigning class members",category:"ECMAScript 6",recommended:true,url:"https://eslint.org/docs/rules/no-class-assign"},schema:[],messages:{class:"'{{name}}' is a class."}},create(context){function checkVariable(variable){astUtils.getModifyingReferences(variable.references).forEach(reference=>{context.report({node:reference.identifier,messageId:"class",data:{name:reference.identifier.name}});});}function checkForClass(node){context.getDeclaredVariables(node).forEach(checkVariable);}return {ClassDeclaration:checkForClass,ClassExpression:checkForClass};}};var noCompareNegZero={meta:{type:"problem",docs:{description:"disallow comparing against -0",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-compare-neg-zero"},fixable:null,schema:[],messages:{unexpected:"Do not use the '{{operator}}' operator to compare against -0."}},create(context){function isNegZero(node){return node.type==="UnaryExpression"&&node.operator==="-"&&node.argument.type==="Literal"&&node.argument.value===0;}const OPERATORS_TO_CHECK=new Set([">",">=","<","<=","==","===","!=","!=="]);return {BinaryExpression(node){if(OPERATORS_TO_CHECK.has(node.operator)){if(isNegZero(node.left)||isNegZero(node.right)){context.report({node,messageId:"unexpected",data:{operator:node.operator}});}}}};}};const TEST_CONDITION_PARENT_TYPES=new Set(["IfStatement","WhileStatement","DoWhileStatement","ForStatement","ConditionalExpression"]);const NODE_DESCRIPTIONS={DoWhileStatement:"a 'do...while' statement",ForStatement:"a 'for' statement",IfStatement:"an 'if' statement",WhileStatement:"a 'while' statement"};var noCondAssign={meta:{type:"problem",docs:{description:"disallow assignment operators in conditional expressions",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-cond-assign"},schema:[{enum:["except-parens","always"]}],messages:{unexpected:"Unexpected assignment within {{type}}.",missing:"Expected a conditional expression and instead saw an assignment."}},create(context){const prohibitAssign=context.options[0]||"except-parens";const sourceCode=context.getSourceCode();function isConditionalTestExpression(node){return node.parent&&TEST_CONDITION_PARENT_TYPES.has(node.parent.type)&&node===node.parent.test;}function findConditionalAncestor(node){let currentAncestor=node;do{if(isConditionalTestExpression(currentAncestor)){return currentAncestor.parent;}}while((currentAncestor=currentAncestor.parent)&&!astUtils.isFunction(currentAncestor));return null;}function isParenthesisedTwice(node){const previousToken=sourceCode.getTokenBefore(node,1),nextToken=sourceCode.getTokenAfter(node,1);return astUtils.isParenthesised(sourceCode,node)&&previousToken&&astUtils.isOpeningParenToken(previousToken)&&previousToken.range[1]<=node.range[0]&&astUtils.isClosingParenToken(nextToken)&&nextToken.range[0]>=node.range[1];}function testForAssign(node){if(node.test&&node.test.type==="AssignmentExpression"&&(node.type==="ForStatement"?!astUtils.isParenthesised(sourceCode,node.test):!isParenthesisedTwice(node.test))){context.report({node:node.test,messageId:"missing"});}}function testForConditionalAncestor(node){const ancestor=findConditionalAncestor(node);if(ancestor){context.report({node,messageId:"unexpected",data:{type:NODE_DESCRIPTIONS[ancestor.type]||ancestor.type}});}}if(prohibitAssign==="always"){return {AssignmentExpression:testForConditionalAncestor};}return {DoWhileStatement:testForAssign,ForStatement:testForAssign,IfStatement:testForAssign,WhileStatement:testForAssign,ConditionalExpression:testForAssign};}};function isConditional(node){return node&&node.type==="ConditionalExpression";}var noConfusingArrow={meta:{type:"suggestion",docs:{description:"disallow arrow functions where they could be confused with comparisons",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/no-confusing-arrow"},fixable:"code",schema:[{type:"object",properties:{allowParens:{type:"boolean",default:true}},additionalProperties:false}],messages:{confusing:"Arrow function used ambiguously with a conditional expression."}},create(context){const config=context.options[0]||{};const allowParens=config.allowParens||config.allowParens===void 0;const sourceCode=context.getSourceCode();return {ArrowFunctionExpression:function(node){const body=node.body;if(isConditional(body)&&!(allowParens&&astUtils.isParenthesised(sourceCode,body))){context.report({node,messageId:"confusing",fix(fixer){return allowParens&&fixer.replaceText(node.body,`(${sourceCode.getText(node.body)})`);}});}}};}};var noConsole={meta:{type:"suggestion",docs:{description:"disallow the use of `console`",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-console"},schema:[{type:"object",properties:{allow:{type:"array",items:{type:"string"},minItems:1,uniqueItems:true}},additionalProperties:false}],messages:{unexpected:"Unexpected console statement."}},create(context){const options=context.options[0]||{};const allowed=options.allow||[];function isConsole(reference){const id=reference.identifier;return id&&id.name==="console";}function isAllowed(node){const propertyName=astUtils.getStaticPropertyName(node);return propertyName&&allowed.indexOf(propertyName)!==-1;}function isMemberAccessExceptAllowed(reference){const node=reference.identifier;const parent=node.parent;return parent.type==="MemberExpression"&&parent.object===node&&!isAllowed(parent);}function report(reference){const node=reference.identifier.parent;context.report({node,loc:node.loc,messageId:"unexpected"});}return {"Program:exit"(){const scope=context.getScope();const consoleVar=astUtils.getVariableByName(scope,"console");const shadowed=consoleVar&&consoleVar.defs.length>0;const references=consoleVar?consoleVar.references:scope.through.filter(isConsole);if(!shadowed){references.filter(isMemberAccessExceptAllowed).forEach(report);}}};}};var noConstAssign={meta:{type:"problem",docs:{description:"disallow reassigning `const` variables",category:"ECMAScript 6",recommended:true,url:"https://eslint.org/docs/rules/no-const-assign"},schema:[],messages:{const:"'{{name}}' is constant."}},create(context){function checkVariable(variable){astUtils.getModifyingReferences(variable.references).forEach(reference=>{context.report({node:reference.identifier,messageId:"const",data:{name:reference.identifier.name}});});}return {VariableDeclaration(node){if(node.kind==="const"){context.getDeclaredVariables(node).forEach(checkVariable);}}};}};var noConstantCondition={meta:{type:"problem",docs:{description:"disallow constant expressions in conditions",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-constant-condition"},schema:[{type:"object",properties:{checkLoops:{type:"boolean",default:true}},additionalProperties:false}],messages:{unexpected:"Unexpected constant condition."}},create(context){const options=context.options[0]||{},checkLoops=options.checkLoops!==false,loopSetStack=[];let loopsInCurrentScope=new Set();function getBooleanValue(node){if(node.value===null){if(node.raw==="null"){return false;}if(typeof node.regex==="object"){return true;}return null;}return !!node.value;}function isLogicalIdentity(node,operator){switch(node.type){case"Literal":return operator==="||"&&getBooleanValue(node)===true||operator==="&&"&&getBooleanValue(node)===false;case"UnaryExpression":return operator==="&&"&&node.operator==="void";case"LogicalExpression":return operator===node.operator&&(isLogicalIdentity(node.left,operator)||isLogicalIdentity(node.right,operator));case"AssignmentExpression":return ["||=","&&="].includes(node.operator)&&operator===node.operator.slice(0,-1)&&isLogicalIdentity(node.right,operator);}return false;}function isConstant(node,inBooleanPosition){if(!node){return true;}switch(node.type){case"Literal":case"ArrowFunctionExpression":case"FunctionExpression":case"ObjectExpression":return true;case"TemplateLiteral":return inBooleanPosition&&node.quasis.some(quasi=>quasi.value.cooked.length)||node.expressions.every(exp=>isConstant(exp,inBooleanPosition));case"ArrayExpression":{if(node.parent.type==="BinaryExpression"&&node.parent.operator==="+"){return node.elements.every(element=>isConstant(element,false));}return true;}case"UnaryExpression":if(node.operator==="void"||node.operator==="typeof"&&inBooleanPosition){return true;}if(node.operator==="!"){return isConstant(node.argument,true);}return isConstant(node.argument,false);case"BinaryExpression":return isConstant(node.left,false)&&isConstant(node.right,false)&&node.operator!=="in";case"LogicalExpression":{const isLeftConstant=isConstant(node.left,inBooleanPosition);const isRightConstant=isConstant(node.right,inBooleanPosition);const isLeftShortCircuit=isLeftConstant&&isLogicalIdentity(node.left,node.operator);const isRightShortCircuit=inBooleanPosition&&isRightConstant&&isLogicalIdentity(node.right,node.operator);return isLeftConstant&&isRightConstant||isLeftShortCircuit||isRightShortCircuit;}case"AssignmentExpression":if(node.operator==="="){return isConstant(node.right,inBooleanPosition);}if(["||=","&&="].includes(node.operator)&&inBooleanPosition){return isLogicalIdentity(node.right,node.operator.slice(0,-1));}return false;case"SequenceExpression":return isConstant(node.expressions[node.expressions.length-1],inBooleanPosition);}return false;}function trackConstantConditionLoop(node){if(node.test&&isConstant(node.test,true)){loopsInCurrentScope.add(node);}}function checkConstantConditionLoopInSet(node){if(loopsInCurrentScope.has(node)){loopsInCurrentScope.delete(node);context.report({node:node.test,messageId:"unexpected"});}}function reportIfConstant(node){if(node.test&&isConstant(node.test,true)){context.report({node:node.test,messageId:"unexpected"});}}function enterFunction(){loopSetStack.push(loopsInCurrentScope);loopsInCurrentScope=new Set();}function exitFunction(){loopsInCurrentScope=loopSetStack.pop();}function checkLoop(node){if(checkLoops){trackConstantConditionLoop(node);}}return {ConditionalExpression:reportIfConstant,IfStatement:reportIfConstant,WhileStatement:checkLoop,"WhileStatement:exit":checkConstantConditionLoopInSet,DoWhileStatement:checkLoop,"DoWhileStatement:exit":checkConstantConditionLoopInSet,ForStatement:checkLoop,"ForStatement > .test":node=>checkLoop(node.parent),"ForStatement:exit":checkConstantConditionLoopInSet,FunctionDeclaration:enterFunction,"FunctionDeclaration:exit":exitFunction,FunctionExpression:enterFunction,"FunctionExpression:exit":exitFunction,YieldExpression:()=>loopsInCurrentScope.clear()};}};var noConstructorReturn={meta:{type:"problem",docs:{description:"disallow returning value from constructor",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-constructor-return"},schema:{},fixable:null,messages:{unexpected:"Unexpected return statement in constructor."}},create(context){const stack=[];return {onCodePathStart(_,node){stack.push(node);},onCodePathEnd(){stack.pop();},ReturnStatement(node){const last=stack[stack.length-1];if(!last.parent){return;}if(last.parent.type==="MethodDefinition"&&last.parent.kind==="constructor"&&(node.parent.parent===last||node.argument)){context.report({node,messageId:"unexpected"});}}};}};var noContinue={meta:{type:"suggestion",docs:{description:"disallow `continue` statements",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-continue"},schema:[],messages:{unexpected:"Unexpected use of continue statement."}},create(context){return {ContinueStatement(node){context.report({node,messageId:"unexpected"});}};}};const RegExpValidator$1=regexpp__default['default'].RegExpValidator;const collector=new class{constructor(){this._source="";this._controlChars=[];this._validator=new RegExpValidator$1(this);}onPatternEnter(){this._controlChars=[];}onCharacter(start,end,cp){if(cp>=0x00&&cp<=0x1F&&(this._source.codePointAt(start)===cp||this._source.slice(start,end).startsWith("\\x")||this._source.slice(start,end).startsWith("\\u"))){this._controlChars.push(`\\x${`0${cp.toString(16)}`.slice(-2)}`);}}collectControlChars(regexpStr){try{this._source=regexpStr;this._validator.validatePattern(regexpStr);}catch{}return this._controlChars;}}();var noControlRegex={meta:{type:"problem",docs:{description:"disallow control characters in regular expressions",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-control-regex"},schema:[],messages:{unexpected:"Unexpected control character(s) in regular expression: {{controlChars}}."}},create(context){function getRegExpPattern(node){if(node.regex){return node.regex.pattern;}if(typeof node.value==="string"&&(node.parent.type==="NewExpression"||node.parent.type==="CallExpression")&&node.parent.callee.type==="Identifier"&&node.parent.callee.name==="RegExp"&&node.parent.arguments[0]===node){return node.value;}return null;}return {Literal(node){const pattern=getRegExpPattern(node);if(pattern){const controlCharacters=collector.collectControlChars(pattern);if(controlCharacters.length>0){context.report({node,messageId:"unexpected",data:{controlChars:controlCharacters.join(", ")}});}}}};}};var noDebugger={meta:{type:"problem",docs:{description:"disallow the use of `debugger`",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-debugger"},fixable:null,schema:[],messages:{unexpected:"Unexpected 'debugger' statement."}},create(context){return {DebuggerStatement(node){context.report({node,messageId:"unexpected"});}};}};var noDeleteVar={meta:{type:"suggestion",docs:{description:"disallow deleting variables",category:"Variables",recommended:true,url:"https://eslint.org/docs/rules/no-delete-var"},schema:[],messages:{unexpected:"Variables should not be deleted."}},create(context){return {UnaryExpression(node){if(node.operator==="delete"&&node.argument.type==="Identifier"){context.report({node,messageId:"unexpected"});}}};}};var noDivRegex={meta:{type:"suggestion",docs:{description:"disallow division operators explicitly at the beginning of regular expressions",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-div-regex"},fixable:"code",schema:[],messages:{unexpected:"A regular expression literal can be confused with '/='."}},create(context){const sourceCode=context.getSourceCode();return {Literal(node){const token=sourceCode.getFirstToken(node);if(token.type==="RegularExpression"&&token.value[1]==="="){context.report({node,messageId:"unexpected",fix(fixer){return fixer.replaceTextRange([token.range[0]+1,token.range[0]+2],"[=]");}});}}};}};var noDupeArgs={meta:{type:"problem",docs:{description:"disallow duplicate arguments in `function` definitions",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-dupe-args"},schema:[],messages:{unexpected:"Duplicate param '{{name}}'."}},create(context){function isParameter(def){return def.type==="Parameter";}function checkParams(node){const variables=context.getDeclaredVariables(node);for(let i=0;i<variables.length;++i){const variable=variables[i];const defs=variable.defs.filter(isParameter);if(defs.length>=2){context.report({node,messageId:"unexpected",data:{name:variable.name}});}}}return {FunctionDeclaration:checkParams,FunctionExpression:checkParams};}};var noDupeClassMembers={meta:{type:"problem",docs:{description:"disallow duplicate class members",category:"ECMAScript 6",recommended:true,url:"https://eslint.org/docs/rules/no-dupe-class-members"},schema:[],messages:{unexpected:"Duplicate name '{{name}}'."}},create(context){let stack=[];function getState(name,isStatic){const stateMap=stack[stack.length-1];const key=`$${name}`;if(!stateMap[key]){stateMap[key]={nonStatic:{init:false,get:false,set:false},static:{init:false,get:false,set:false}};}return stateMap[key][isStatic?"static":"nonStatic"];}return {Program(){stack=[];},ClassBody(){stack.push(Object.create(null));},"ClassBody:exit"(){stack.pop();},MethodDefinition(node){const name=astUtils.getStaticPropertyName(node);if(name===null||node.kind==="constructor"){return;}const state=getState(name,node.static);let isDuplicate=false;if(node.kind==="get"){isDuplicate=state.init||state.get;state.get=true;}else if(node.kind==="set"){isDuplicate=state.init||state.set;state.set=true;}else {isDuplicate=state.init||state.get||state.set;state.init=true;}if(isDuplicate){context.report({node,messageId:"unexpected",data:{name}});}}};}};function isSubsetByComparator(comparator,arrA,arrB){return arrA.every(a=>arrB.some(b=>comparator(a,b)));}function splitByLogicalOperator(operator,node){if(node.type==="LogicalExpression"&&node.operator===operator){return [...splitByLogicalOperator(operator,node.left),...splitByLogicalOperator(operator,node.right)];}return [node];}const splitByOr=splitByLogicalOperator.bind(null,"||");const splitByAnd=splitByLogicalOperator.bind(null,"&&");var noDupeElseIf={meta:{type:"problem",docs:{description:"disallow duplicate conditions in if-else-if chains",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-dupe-else-if"},schema:[],messages:{unexpected:"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain."}},create(context){const sourceCode=context.getSourceCode();function equal(a,b){if(a.type!==b.type){return false;}if(a.type==="LogicalExpression"&&(a.operator==="||"||a.operator==="&&")&&a.operator===b.operator){return equal(a.left,b.left)&&equal(a.right,b.right)||equal(a.left,b.right)&&equal(a.right,b.left);}return astUtils.equalTokens(a,b,sourceCode);}const isSubset=isSubsetByComparator.bind(null,equal);return {IfStatement(node){const test=node.test,conditionsToCheck=test.type==="LogicalExpression"&&test.operator==="&&"?[test,...splitByAnd(test)]:[test];let current=node,listToCheck=conditionsToCheck.map(c=>splitByOr(c).map(splitByAnd));while(current.parent&&current.parent.type==="IfStatement"&&current.parent.alternate===current){current=current.parent;const currentOrOperands=splitByOr(current.test).map(splitByAnd);listToCheck=listToCheck.map(orOperands=>orOperands.filter(orOperand=>!currentOrOperands.some(currentOrOperand=>isSubset(currentOrOperand,orOperand))));if(listToCheck.some(orOperands=>orOperands.length===0)){context.report({node:test,messageId:"unexpected"});break;}}}};}};const GET_KIND=/^(?:init|get)$/u;const SET_KIND=/^(?:init|set)$/u;class ObjectInfo{constructor(upper,node){this.upper=upper;this.node=node;this.properties=new Map();}getPropertyInfo(node){const name=astUtils.getStaticPropertyName(node);if(!this.properties.has(name)){this.properties.set(name,{get:false,set:false});}return this.properties.get(name);}isPropertyDefined(node){const entry=this.getPropertyInfo(node);return GET_KIND.test(node.kind)&&entry.get||SET_KIND.test(node.kind)&&entry.set;}defineProperty(node){const entry=this.getPropertyInfo(node);if(GET_KIND.test(node.kind)){entry.get=true;}if(SET_KIND.test(node.kind)){entry.set=true;}}}var noDupeKeys={meta:{type:"problem",docs:{description:"disallow duplicate keys in object literals",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-dupe-keys"},schema:[],messages:{unexpected:"Duplicate key '{{name}}'."}},create(context){let info=null;return {ObjectExpression(node){info=new ObjectInfo(info,node);},"ObjectExpression:exit"(){info=info.upper;},Property(node){const name=astUtils.getStaticPropertyName(node);if(node.parent.type!=="ObjectExpression"){return;}if(name===null){return;}if(info.isPropertyDefined(node)){context.report({node:info.node,loc:node.key.loc,messageId:"unexpected",data:{name}});}info.defineProperty(node);}};}};var noDuplicateCase={meta:{type:"problem",docs:{description:"disallow duplicate case labels",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-duplicate-case"},schema:[],messages:{unexpected:"Duplicate case label."}},create(context){const sourceCode=context.getSourceCode();function equal(a,b){if(a.type!==b.type){return false;}return astUtils.equalTokens(a,b,sourceCode);}return {SwitchStatement(node){const previousTests=[];for(const switchCase of node.cases){if(switchCase.test){const test=switchCase.test;if(previousTests.some(previousTest=>equal(previousTest,test))){context.report({node:switchCase,messageId:"unexpected"});}else {previousTests.push(test);}}}}};}};function getValue(node){if(node&&node.source&&node.source.value){return node.source.value.trim();}return "";}function checkAndReport(context,node,value,array,messageId){if(array.indexOf(value)!==-1){context.report({node,messageId,data:{module:value}});}}function handleImports(context,includeExports,importsInFile,exportsInFile){return function(node){const value=getValue(node);if(value){checkAndReport(context,node,value,importsInFile,"import");if(includeExports){checkAndReport(context,node,value,exportsInFile,"importAs");}importsInFile.push(value);}};}function handleExports(context,importsInFile,exportsInFile){return function(node){const value=getValue(node);if(value){checkAndReport(context,node,value,exportsInFile,"export");checkAndReport(context,node,value,importsInFile,"exportAs");exportsInFile.push(value);}};}var noDuplicateImports={meta:{type:"problem",docs:{description:"disallow duplicate module imports",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/no-duplicate-imports"},schema:[{type:"object",properties:{includeExports:{type:"boolean",default:false}},additionalProperties:false}],messages:{import:"'{{module}}' import is duplicated.",importAs:"'{{module}}' import is duplicated as export.",export:"'{{module}}' export is duplicated.",exportAs:"'{{module}}' export is duplicated as import."}},create(context){const includeExports=(context.options[0]||{}).includeExports,importsInFile=[],exportsInFile=[];const handlers={ImportDeclaration:handleImports(context,includeExports,importsInFile,exportsInFile)};if(includeExports){handlers.ExportNamedDeclaration=handleExports(context,importsInFile,exportsInFile);handlers.ExportAllDeclaration=handleExports(context,importsInFile,exportsInFile);}return handlers;}};class FixTracker{constructor(fixer,sourceCode){this.fixer=fixer;this.sourceCode=sourceCode;this.retainedRange=null;}retainRange(range){this.retainedRange=range;return this;}retainEnclosingFunction(node){const functionNode=astUtils.getUpperFunction(node);return this.retainRange(functionNode?functionNode.range:this.sourceCode.ast.range);}retainSurroundingTokens(nodeOrToken){const tokenBefore=this.sourceCode.getTokenBefore(nodeOrToken)||nodeOrToken;const tokenAfter=this.sourceCode.getTokenAfter(nodeOrToken)||nodeOrToken;return this.retainRange([tokenBefore.range[0],tokenAfter.range[1]]);}replaceTextRange(range,text){let actualRange;if(this.retainedRange){actualRange=[Math.min(this.retainedRange[0],range[0]),Math.max(this.retainedRange[1],range[1])];}else {actualRange=range;}return this.fixer.replaceTextRange(actualRange,this.sourceCode.text.slice(actualRange[0],range[0])+text+this.sourceCode.text.slice(range[1],actualRange[1]));}remove(nodeOrToken){return this.replaceTextRange(nodeOrToken.range,"");}}var fixTracker=FixTracker;var noElseReturn={meta:{type:"suggestion",docs:{description:"disallow `else` blocks after `return` statements in `if` statements",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-else-return"},schema:[{type:"object",properties:{allowElseIf:{type:"boolean",default:true}},additionalProperties:false}],fixable:"code",messages:{unexpected:"Unnecessary 'else' after 'return'."}},create(context){function isSafeToDeclare(names,scope){if(names.length===0){return true;}const functionScope=scope.variableScope;const declaredVariables=scope.variables.filter(({defs})=>defs.length>0);if(declaredVariables.some(({name})=>names.includes(name))){return false;}if(scope!==functionScope&&scope.upper.type==="catch"){if(scope.upper.variables.some(({name})=>names.includes(name))){return false;}}const usedImplicitVariables=scope.variables.filter(({defs,references})=>defs.length===0&&references.length>0);if(usedImplicitVariables.some(({name})=>names.includes(name))){return false;}if(scope.through.some(t=>names.includes(t.identifier.name))){return false;}if(scope!==functionScope){const scopeNodeRange=scope.block.range;const variablesToCheck=functionScope.variables.filter(({name})=>names.includes(name));if(variablesToCheck.some(v=>v.defs.some(({node:{range}})=>scopeNodeRange[0]<=range[0]&&range[1]<=scopeNodeRange[1]))){return false;}}return true;}function isSafeFromNameCollisions(node,scope){if(node.type==="FunctionDeclaration"){return false;}if(node.type!=="BlockStatement"){return true;}const elseBlockScope=scope.childScopes.find(({block})=>block===node);if(!elseBlockScope){return true;}const namesToCheck=elseBlockScope.variables.map(({name})=>name);return isSafeToDeclare(namesToCheck,scope);}function displayReport(node){const currentScope=context.getScope();context.report({node,messageId:"unexpected",fix:fixer=>{if(!isSafeFromNameCollisions(node,currentScope)){return null;}const sourceCode=context.getSourceCode();const startToken=sourceCode.getFirstToken(node);const elseToken=sourceCode.getTokenBefore(startToken);const source=sourceCode.getText(node);const lastIfToken=sourceCode.getTokenBefore(elseToken);let fixedSource,firstTokenOfElseBlock;if(startToken.type==="Punctuator"&&startToken.value==="{"){firstTokenOfElseBlock=sourceCode.getTokenAfter(startToken);}else {firstTokenOfElseBlock=startToken;}const ifBlockMaybeUnsafe=node.parent.consequent.type!=="BlockStatement"&&lastIfToken.value!==";";const elseBlockUnsafe=/^[([/+`-]/u.test(firstTokenOfElseBlock.value);if(ifBlockMaybeUnsafe&&elseBlockUnsafe){return null;}const endToken=sourceCode.getLastToken(node);const lastTokenOfElseBlock=sourceCode.getTokenBefore(endToken);if(lastTokenOfElseBlock.value!==";"){const nextToken=sourceCode.getTokenAfter(endToken);const nextTokenUnsafe=nextToken&&/^[([/+`-]/u.test(nextToken.value);const nextTokenOnSameLine=nextToken&&nextToken.loc.start.line===lastTokenOfElseBlock.loc.start.line;if(nextTokenUnsafe||nextTokenOnSameLine&&nextToken.value!=="}"){return null;}}if(startToken.type==="Punctuator"&&startToken.value==="{"){fixedSource=source.slice(1,-1);}else {fixedSource=source;}return new fixTracker(fixer,sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0],node.range[1]],fixedSource);}});}function checkForReturn(node){return node.type==="ReturnStatement";}function naiveHasReturn(node){if(node.type==="BlockStatement"){const body=node.body,lastChildNode=body[body.length-1];return lastChildNode&&checkForReturn(lastChildNode);}return checkForReturn(node);}function hasElse(node){return node.alternate&&node.consequent;}function checkForIf(node){return node.type==="IfStatement"&&hasElse(node)&&naiveHasReturn(node.alternate)&&naiveHasReturn(node.consequent);}function checkForReturnOrIf(node){return checkForReturn(node)||checkForIf(node);}function alwaysReturns(node){if(node.type==="BlockStatement"){return node.body.some(checkForReturnOrIf);}return checkForReturnOrIf(node);}const allowElseIf=!(context.options[0]&&context.options[0].allowElseIf===false);return {"IfStatement:exit":allowElseIf?function(node){const parent=node.parent;if(!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)){return;}const consequents=[];let alternate;for(let currentNode=node;currentNode.type==="IfStatement";currentNode=currentNode.alternate){if(!currentNode.alternate){return;}consequents.push(currentNode.consequent);alternate=currentNode.alternate;}if(consequents.every(alwaysReturns)){displayReport(alternate);}}:function(node){const parent=node.parent;if(!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)){return;}const alternate=node.alternate;if(alternate&&alwaysReturns(node.consequent)){displayReport(alternate);}}};}};const regex=/^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimuys]*$/u;var noEmptyCharacterClass={meta:{type:"problem",docs:{description:"disallow empty character classes in regular expressions",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-empty-character-class"},schema:[],messages:{unexpected:"Empty class."}},create(context){const sourceCode=context.getSourceCode();return {Literal(node){const token=sourceCode.getFirstToken(node);if(token.type==="RegularExpression"&&!regex.test(token.value)){context.report({node,messageId:"unexpected"});}}};}};const ALLOW_OPTIONS=Object.freeze(["functions","arrowFunctions","generatorFunctions","methods","generatorMethods","getters","setters","constructors","asyncFunctions","asyncMethods"]);function getKind(node){const parent=node.parent;let kind="";if(node.type==="ArrowFunctionExpression"){return "arrowFunctions";}if(parent.type==="Property"){if(parent.kind==="get"){return "getters";}if(parent.kind==="set"){return "setters";}kind=parent.method?"methods":"functions";}else if(parent.type==="MethodDefinition"){if(parent.kind==="get"){return "getters";}if(parent.kind==="set"){return "setters";}if(parent.kind==="constructor"){return "constructors";}kind="methods";}else {kind="functions";}let prefix="";if(node.generator){prefix="generator";}else if(node.async){prefix="async";}else {return kind;}return prefix+kind[0].toUpperCase()+kind.slice(1);}var noEmptyFunction={meta:{type:"suggestion",docs:{description:"disallow empty functions",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-empty-function"},schema:[{type:"object",properties:{allow:{type:"array",items:{enum:ALLOW_OPTIONS},uniqueItems:true}},additionalProperties:false}],messages:{unexpected:"Unexpected empty {{name}}."}},create(context){const options=context.options[0]||{};const allowed=options.allow||[];const sourceCode=context.getSourceCode();function reportIfEmpty(node){const kind=getKind(node);const name=astUtils.getFunctionNameWithKind(node);const innerComments=sourceCode.getTokens(node.body,{includeComments:true,filter:astUtils.isCommentToken});if(allowed.indexOf(kind)===-1&&node.body.type==="BlockStatement"&&node.body.body.length===0&&innerComments.length===0){context.report({node,loc:node.body.loc,messageId:"unexpected",data:{name}});}}return {ArrowFunctionExpression:reportIfEmpty,FunctionDeclaration:reportIfEmpty,FunctionExpression:reportIfEmpty};}};var noEmptyPattern={meta:{type:"problem",docs:{description:"disallow empty destructuring patterns",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-empty-pattern"},schema:[],messages:{unexpected:"Unexpected empty {{type}} pattern."}},create(context){return {ObjectPattern(node){if(node.properties.length===0){context.report({node,messageId:"unexpected",data:{type:"object"}});}},ArrayPattern(node){if(node.elements.length===0){context.report({node,messageId:"unexpected",data:{type:"array"}});}}};}};var noEmpty={meta:{type:"suggestion",docs:{description:"disallow empty block statements",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-empty"},schema:[{type:"object",properties:{allowEmptyCatch:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpected:"Empty {{type}} statement."}},create(context){const options=context.options[0]||{},allowEmptyCatch=options.allowEmptyCatch||false;const sourceCode=context.getSourceCode();return {BlockStatement(node){if(node.body.length!==0){return;}if(astUtils.isFunction(node.parent)){return;}if(allowEmptyCatch&&node.parent.type==="CatchClause"){return;}if(sourceCode.getCommentsInside(node).length>0){return;}context.report({node,messageId:"unexpected",data:{type:"block"}});},SwitchStatement(node){if(typeof node.cases==="undefined"||node.cases.length===0){context.report({node,messageId:"unexpected",data:{type:"switch"}});}}};}};var noEqNull={meta:{type:"suggestion",docs:{description:"disallow `null` comparisons without type-checking operators",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-eq-null"},schema:[],messages:{unexpected:"Use '===' to compare with null."}},create(context){return {BinaryExpression(node){const badOperator=node.operator==="=="||node.operator==="!=";if(node.right.type==="Literal"&&node.right.raw==="null"&&badOperator||node.left.type==="Literal"&&node.left.raw==="null"&&badOperator){context.report({node,messageId:"unexpected"});}}};}};const candidatesOfGlobalObject=Object.freeze(["global","window","globalThis"]);function isMember(node,name){return astUtils.isSpecificMemberAccess(node,null,name);}var noEval={meta:{type:"suggestion",docs:{description:"disallow the use of `eval()`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-eval"},schema:[{type:"object",properties:{allowIndirect:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpected:"eval can be harmful."}},create(context){const allowIndirect=Boolean(context.options[0]&&context.options[0].allowIndirect);const sourceCode=context.getSourceCode();let funcInfo=null;function enterVarScope(node){const strict=context.getScope().isStrict;funcInfo={upper:funcInfo,node,strict,defaultThis:false,initialized:strict};}function exitVarScope(){funcInfo=funcInfo.upper;}function report(node){const parent=node.parent;const locationNode=node.type==="MemberExpression"?node.property:node;const reportNode=parent.type==="CallExpression"&&parent.callee===node?parent:node;context.report({node:reportNode,loc:locationNode.loc,messageId:"unexpected"});}function reportAccessingEvalViaGlobalObject(globalScope){for(let i=0;i<candidatesOfGlobalObject.length;++i){const name=candidatesOfGlobalObject[i];const variable=astUtils.getVariableByName(globalScope,name);if(!variable){continue;}const references=variable.references;for(let j=0;j<references.length;++j){const identifier=references[j].identifier;let node=identifier.parent;while(isMember(node,name)){node=node.parent;}if(isMember(node,"eval")){report(node);}}}}function reportAccessingEval(globalScope){const variable=astUtils.getVariableByName(globalScope,"eval");if(!variable){return;}const references=variable.references;for(let i=0;i<references.length;++i){const reference=references[i];const id=reference.identifier;if(id.name==="eval"&&!astUtils.isCallee(id)){report(id);}}}if(allowIndirect){return {"CallExpression:exit"(node){const callee=node.callee;if(!node.optional&&astUtils.isSpecificId(callee,"eval")){report(callee);}}};}return {"CallExpression:exit"(node){const callee=node.callee;if(astUtils.isSpecificId(callee,"eval")){report(callee);}},Program(node){const scope=context.getScope(),features=context.parserOptions.ecmaFeatures||{},strict=scope.isStrict||node.sourceType==="module"||features.globalReturn&&scope.childScopes[0].isStrict;funcInfo={upper:null,node,strict,defaultThis:true,initialized:true};},"Program:exit"(){const globalScope=context.getScope();exitVarScope();reportAccessingEval(globalScope);reportAccessingEvalViaGlobalObject(globalScope);},FunctionDeclaration:enterVarScope,"FunctionDeclaration:exit":exitVarScope,FunctionExpression:enterVarScope,"FunctionExpression:exit":exitVarScope,ArrowFunctionExpression:enterVarScope,"ArrowFunctionExpression:exit":exitVarScope,ThisExpression(node){if(!isMember(node.parent,"eval")){return;}if(!funcInfo.initialized){funcInfo.initialized=true;funcInfo.defaultThis=astUtils.isDefaultThisBinding(funcInfo.node,sourceCode);}if(!funcInfo.strict&&funcInfo.defaultThis){report(node.parent);}}};}};var noExAssign={meta:{type:"problem",docs:{description:"disallow reassigning exceptions in `catch` clauses",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-ex-assign"},schema:[],messages:{unexpected:"Do not assign to the exception parameter."}},create(context){function checkVariable(variable){astUtils.getModifyingReferences(variable.references).forEach(reference=>{context.report({node:reference.identifier,messageId:"unexpected"});});}return {CatchClause(node){context.getDeclaredVariables(node).forEach(checkVariable);}};}};var noExtendNative={meta:{type:"suggestion",docs:{description:"disallow extending native types",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-extend-native"},schema:[{type:"object",properties:{exceptions:{type:"array",items:{type:"string"},uniqueItems:true}},additionalProperties:false}],messages:{unexpected:"{{builtin}} prototype is read only, properties should not be added."}},create(context){const config=context.options[0]||{};const exceptions=new Set(config.exceptions||[]);const modifiedBuiltins=new Set(Object.keys(globals__default['default'].builtin).filter(builtin=>builtin[0].toUpperCase()===builtin[0]).filter(builtin=>!exceptions.has(builtin)));function reportNode(node,builtin){context.report({node,messageId:"unexpected",data:{builtin}});}function isPrototypePropertyAccessed(identifierNode){return Boolean(identifierNode&&identifierNode.parent&&identifierNode.parent.type==="MemberExpression"&&identifierNode.parent.object===identifierNode&&astUtils.getStaticPropertyName(identifierNode.parent)==="prototype");}function isAssigningToPropertyOf(node){return node.parent.type==="MemberExpression"&&node.parent.object===node&&node.parent.parent.type==="AssignmentExpression"&&node.parent.parent.left===node.parent;}function isInDefinePropertyCall(node){return node.parent.type==="CallExpression"&&node.parent.arguments[0]===node&&astUtils.isSpecificMemberAccess(node.parent.callee,"Object",/^definePropert(?:y|ies)$/u);}function checkAndReportPrototypeExtension(identifierNode){if(!isPrototypePropertyAccessed(identifierNode)){return;}const prototypeNode=identifierNode.parent.parent.type==="ChainExpression"?identifierNode.parent.parent:identifierNode.parent;if(isAssigningToPropertyOf(prototypeNode)){reportNode(prototypeNode.parent.parent,identifierNode.name);}else if(isInDefinePropertyCall(prototypeNode)){reportNode(prototypeNode.parent,identifierNode.name);}}return {"Program:exit"(){const globalScope=context.getScope();modifiedBuiltins.forEach(builtin=>{const builtinVar=globalScope.set.get(builtin);if(builtinVar&&builtinVar.references){builtinVar.references.map(ref=>ref.identifier).forEach(checkAndReportPrototypeExtension);}});}};}};const SIDE_EFFECT_FREE_NODE_TYPES=new Set(["Literal","Identifier","ThisExpression","FunctionExpression"]);var noExtraBind={meta:{type:"suggestion",docs:{description:"disallow unnecessary calls to `.bind()`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-extra-bind"},schema:[],fixable:"code",messages:{unexpected:"The function binding is unnecessary."}},create(context){const sourceCode=context.getSourceCode();let scopeInfo=null;function isSideEffectFree(node){return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);}function report(node){const memberNode=node.parent;const callNode=memberNode.parent.type==="ChainExpression"?memberNode.parent.parent:memberNode.parent;context.report({node:callNode,messageId:"unexpected",loc:memberNode.property.loc,fix(fixer){if(!isSideEffectFree(callNode.arguments[0])){return null;}const tokenPairs=[[sourceCode.getTokenAfter(memberNode.object,astUtils.isNotClosingParenToken),sourceCode.getLastToken(memberNode)],[sourceCode.getTokenAfter(memberNode,astUtils.isNotClosingParenToken),sourceCode.getLastToken(callNode)]];const firstTokenToRemove=tokenPairs[0][0];const lastTokenToRemove=tokenPairs[1][1];if(sourceCode.commentsExistBetween(firstTokenToRemove,lastTokenToRemove)){return null;}return tokenPairs.map(([start,end])=>fixer.removeRange([start.range[0],end.range[1]]));}});}function isCalleeOfBindMethod(node){if(!astUtils.isSpecificMemberAccess(node.parent,null,"bind")){return false;}const bindNode=node.parent.parent.type==="ChainExpression"?node.parent.parent:node.parent;return bindNode.parent.type==="CallExpression"&&bindNode.parent.callee===bindNode&&bindNode.parent.arguments.length===1&&bindNode.parent.arguments[0].type!=="SpreadElement";}function enterFunction(node){scopeInfo={isBound:isCalleeOfBindMethod(node),thisFound:false,upper:scopeInfo};}function exitFunction(node){if(scopeInfo.isBound&&!scopeInfo.thisFound){report(node);}scopeInfo=scopeInfo.upper;}function markAsThisFound(){if(scopeInfo){scopeInfo.thisFound=true;}}return {"ArrowFunctionExpression:exit":function(node){if(isCalleeOfBindMethod(node)){report(node);}},FunctionDeclaration:enterFunction,"FunctionDeclaration:exit":exitFunction,FunctionExpression:enterFunction,"FunctionExpression:exit":exitFunction,ThisExpression:markAsThisFound};}};const precedence=astUtils.getPrecedence;var noExtraBooleanCast={meta:{type:"suggestion",docs:{description:"disallow unnecessary boolean casts",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-extra-boolean-cast"},schema:[{type:"object",properties:{enforceForLogicalOperands:{type:"boolean",default:false}},additionalProperties:false}],fixable:"code",messages:{unexpectedCall:"Redundant Boolean call.",unexpectedNegation:"Redundant double negation."}},create(context){const sourceCode=context.getSourceCode();const BOOLEAN_NODE_TYPES=["IfStatement","DoWhileStatement","WhileStatement","ConditionalExpression","ForStatement"];function isBooleanFunctionOrConstructorCall(node){return (node.type==="CallExpression"||node.type==="NewExpression")&&node.callee.type==="Identifier"&&node.callee.name==="Boolean";}function isLogicalContext(node){return node.type==="LogicalExpression"&&(node.operator==="||"||node.operator==="&&")&&context.options.length&&context.options[0].enforceForLogicalOperands===true;}function isInBooleanContext(node){return isBooleanFunctionOrConstructorCall(node.parent)&&node===node.parent.arguments[0]||BOOLEAN_NODE_TYPES.indexOf(node.parent.type)!==-1&&node===node.parent.test||node.parent.type==="UnaryExpression"&&node.parent.operator==="!";}function isInFlaggedContext(node){if(node.parent.type==="ChainExpression"){return isInFlaggedContext(node.parent);}return isInBooleanContext(node)||isLogicalContext(node.parent)&&isInFlaggedContext(node.parent);}function hasCommentsInside(node){return Boolean(sourceCode.getCommentsInside(node).length);}function isParenthesized(node){return eslintUtils__default['default'].isParenthesized(1,node,sourceCode);}function needsParens(previousNode,node){if(previousNode.parent.type==="ChainExpression"){return needsParens(previousNode.parent,node);}if(isParenthesized(previousNode)){return false;}const parent=previousNode.parent;switch(parent.type){case"CallExpression":case"NewExpression":return node.type==="SequenceExpression";case"IfStatement":case"DoWhileStatement":case"WhileStatement":case"ForStatement":return false;case"ConditionalExpression":return precedence(node)<=precedence(parent);case"UnaryExpression":return precedence(node)<precedence(parent);case"LogicalExpression":if(astUtils.isMixedLogicalAndCoalesceExpressions(node,parent)){return true;}if(previousNode===parent.left){return precedence(node)<precedence(parent);}return precedence(node)<=precedence(parent);default:throw new Error(`Unexpected parent type: ${parent.type}`);}}return {UnaryExpression(node){const parent=node.parent;if(node.operator!=="!"||parent.type!=="UnaryExpression"||parent.operator!=="!"){return;}if(isInFlaggedContext(parent)){context.report({node:parent,messageId:"unexpectedNegation",fix(fixer){if(hasCommentsInside(parent)){return null;}if(needsParens(parent,node.argument)){return fixer.replaceText(parent,`(${sourceCode.getText(node.argument)})`);}let prefix="";const tokenBefore=sourceCode.getTokenBefore(parent);const firstReplacementToken=sourceCode.getFirstToken(node.argument);if(tokenBefore&&tokenBefore.range[1]===parent.range[0]&&!astUtils.canTokensBeAdjacent(tokenBefore,firstReplacementToken)){prefix=" ";}return fixer.replaceText(parent,prefix+sourceCode.getText(node.argument));}});}},CallExpression(node){if(node.callee.type!=="Identifier"||node.callee.name!=="Boolean"){return;}if(isInFlaggedContext(node)){context.report({node,messageId:"unexpectedCall",fix(fixer){const parent=node.parent;if(node.arguments.length===0){if(parent.type==="UnaryExpression"&&parent.operator==="!"){if(hasCommentsInside(parent)){return null;}let prefix="";const tokenBefore=sourceCode.getTokenBefore(parent);if(tokenBefore&&tokenBefore.range[1]===parent.range[0]&&!astUtils.canTokensBeAdjacent(tokenBefore,"true")){prefix=" ";}return fixer.replaceText(parent,prefix+"true");}if(hasCommentsInside(node)){return null;}return fixer.replaceText(node,"false");}if(node.arguments.length===1){const argument=node.arguments[0];if(argument.type==="SpreadElement"||hasCommentsInside(node)){return null;}if(needsParens(node,argument)){return fixer.replaceText(node,`(${sourceCode.getText(argument)})`);}return fixer.replaceText(node,sourceCode.getText(argument));}return null;}});}}};}};var noExtraLabel={meta:{type:"suggestion",docs:{description:"disallow unnecessary labels",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-extra-label"},schema:[],fixable:"code",messages:{unexpected:"This label '{{name}}' is unnecessary."}},create(context){const sourceCode=context.getSourceCode();let scopeInfo=null;function enterBreakableStatement(node){scopeInfo={label:node.parent.type==="LabeledStatement"?node.parent.label:null,breakable:true,upper:scopeInfo};}function exitBreakableStatement(){scopeInfo=scopeInfo.upper;}function enterLabeledStatement(node){if(!astUtils.isBreakableStatement(node.body)){scopeInfo={label:node.label,breakable:false,upper:scopeInfo};}}function exitLabeledStatement(node){if(!astUtils.isBreakableStatement(node.body)){scopeInfo=scopeInfo.upper;}}function reportIfUnnecessary(node){if(!node.label){return;}const labelNode=node.label;for(let info=scopeInfo;info!==null;info=info.upper){if(info.breakable||info.label&&info.label.name===labelNode.name){if(info.breakable&&info.label&&info.label.name===labelNode.name){context.report({node:labelNode,messageId:"unexpected",data:labelNode,fix(fixer){const breakOrContinueToken=sourceCode.getFirstToken(node);if(sourceCode.commentsExistBetween(breakOrContinueToken,labelNode)){return null;}return fixer.removeRange([breakOrContinueToken.range[1],labelNode.range[1]]);}});}return;}}}return {WhileStatement:enterBreakableStatement,"WhileStatement:exit":exitBreakableStatement,DoWhileStatement:enterBreakableStatement,"DoWhileStatement:exit":exitBreakableStatement,ForStatement:enterBreakableStatement,"ForStatement:exit":exitBreakableStatement,ForInStatement:enterBreakableStatement,"ForInStatement:exit":exitBreakableStatement,ForOfStatement:enterBreakableStatement,"ForOfStatement:exit":exitBreakableStatement,SwitchStatement:enterBreakableStatement,"SwitchStatement:exit":exitBreakableStatement,LabeledStatement:enterLabeledStatement,"LabeledStatement:exit":exitLabeledStatement,BreakStatement:reportIfUnnecessary,ContinueStatement:reportIfUnnecessary};}};const{isParenthesized:isParenthesizedRaw}=eslintUtils__default['default'];var noExtraParens={meta:{type:"layout",docs:{description:"disallow unnecessary parentheses",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-extra-parens"},fixable:"code",schema:{anyOf:[{type:"array",items:[{enum:["functions"]}],minItems:0,maxItems:1},{type:"array",items:[{enum:["all"]},{type:"object",properties:{conditionalAssign:{type:"boolean"},nestedBinaryExpressions:{type:"boolean"},returnAssign:{type:"boolean"},ignoreJSX:{enum:["none","all","single-line","multi-line"]},enforceForArrowConditionals:{type:"boolean"},enforceForSequenceExpressions:{type:"boolean"},enforceForNewInMemberExpressions:{type:"boolean"},enforceForFunctionPrototypeMethods:{type:"boolean"}},additionalProperties:false}],minItems:0,maxItems:2}]},messages:{unexpected:"Unnecessary parentheses around expression."}},create(context){const sourceCode=context.getSourceCode();const tokensToIgnore=new WeakSet();const precedence=astUtils.getPrecedence;const ALL_NODES=context.options[0]!=="functions";const EXCEPT_COND_ASSIGN=ALL_NODES&&context.options[1]&&context.options[1].conditionalAssign===false;const NESTED_BINARY=ALL_NODES&&context.options[1]&&context.options[1].nestedBinaryExpressions===false;const EXCEPT_RETURN_ASSIGN=ALL_NODES&&context.options[1]&&context.options[1].returnAssign===false;const IGNORE_JSX=ALL_NODES&&context.options[1]&&context.options[1].ignoreJSX;const IGNORE_ARROW_CONDITIONALS=ALL_NODES&&context.options[1]&&context.options[1].enforceForArrowConditionals===false;const IGNORE_SEQUENCE_EXPRESSIONS=ALL_NODES&&context.options[1]&&context.options[1].enforceForSequenceExpressions===false;const IGNORE_NEW_IN_MEMBER_EXPR=ALL_NODES&&context.options[1]&&context.options[1].enforceForNewInMemberExpressions===false;const IGNORE_FUNCTION_PROTOTYPE_METHODS=ALL_NODES&&context.options[1]&&context.options[1].enforceForFunctionPrototypeMethods===false;const PRECEDENCE_OF_ASSIGNMENT_EXPR=precedence({type:"AssignmentExpression"});const PRECEDENCE_OF_UPDATE_EXPR=precedence({type:"UpdateExpression"});let reportsBuffer;function isImmediateFunctionPrototypeMethodCall(node){const callNode=astUtils.skipChainExpression(node);if(callNode.type!=="CallExpression"){return false;}const callee=astUtils.skipChainExpression(callNode.callee);return callee.type==="MemberExpression"&&callee.object.type==="FunctionExpression"&&["call","apply"].includes(astUtils.getStaticPropertyName(callee));}function ruleApplies(node){if(node.type==="JSXElement"||node.type==="JSXFragment"){const isSingleLine=node.loc.start.line===node.loc.end.line;switch(IGNORE_JSX){case"all":return false;case"multi-line":return isSingleLine;case"single-line":return !isSingleLine;}}if(node.type==="SequenceExpression"&&IGNORE_SEQUENCE_EXPRESSIONS){return false;}if(isImmediateFunctionPrototypeMethodCall(node)&&IGNORE_FUNCTION_PROTOTYPE_METHODS){return false;}return ALL_NODES||node.type==="FunctionExpression"||node.type==="ArrowFunctionExpression";}function isParenthesised(node){return isParenthesizedRaw(1,node,sourceCode);}function isParenthesisedTwice(node){return isParenthesizedRaw(2,node,sourceCode);}function hasExcessParens(node){return ruleApplies(node)&&isParenthesised(node);}function hasDoubleExcessParens(node){return ruleApplies(node)&&isParenthesisedTwice(node);}function hasExcessParensWithPrecedence(node,precedenceLowerLimit){if(ruleApplies(node)&&isParenthesised(node)){if(precedence(node)>=precedenceLowerLimit||isParenthesisedTwice(node)){return true;}}return false;}function isCondAssignException(node){return EXCEPT_COND_ASSIGN&&node.test.type==="AssignmentExpression";}function isInReturnStatement(node){for(let currentNode=node;currentNode;currentNode=currentNode.parent){if(currentNode.type==="ReturnStatement"||currentNode.type==="ArrowFunctionExpression"&&currentNode.body.type!=="BlockStatement"){return true;}}return false;}function isNewExpressionWithParens(newExpression){const lastToken=sourceCode.getLastToken(newExpression);const penultimateToken=sourceCode.getTokenBefore(lastToken);return newExpression.arguments.length>0||astUtils.isOpeningParenToken(penultimateToken)&&astUtils.isClosingParenToken(lastToken)&&newExpression.callee.range[1]<newExpression.range[1];}function containsAssignment(node){if(node.type==="AssignmentExpression"){return true;}if(node.type==="ConditionalExpression"&&(node.consequent.type==="AssignmentExpression"||node.alternate.type==="AssignmentExpression")){return true;}if(node.left&&node.left.type==="AssignmentExpression"||node.right&&node.right.type==="AssignmentExpression"){return true;}return false;}function isReturnAssignException(node){if(!EXCEPT_RETURN_ASSIGN||!isInReturnStatement(node)){return false;}if(node.type==="ReturnStatement"){return node.argument&&containsAssignment(node.argument);}if(node.type==="ArrowFunctionExpression"&&node.body.type!=="BlockStatement"){return containsAssignment(node.body);}return containsAssignment(node);}function hasExcessParensNoLineTerminator(token,node){if(token.loc.end.line===node.loc.start.line){return hasExcessParens(node);}return hasDoubleExcessParens(node);}function requiresLeadingSpace(node){const leftParenToken=sourceCode.getTokenBefore(node);const tokenBeforeLeftParen=sourceCode.getTokenBefore(leftParenToken,{includeComments:true});const tokenAfterLeftParen=sourceCode.getTokenAfter(leftParenToken,{includeComments:true});return tokenBeforeLeftParen&&tokenBeforeLeftParen.range[1]===leftParenToken.range[0]&&leftParenToken.range[1]===tokenAfterLeftParen.range[0]&&!astUtils.canTokensBeAdjacent(tokenBeforeLeftParen,tokenAfterLeftParen);}function requiresTrailingSpace(node){const nextTwoTokens=sourceCode.getTokensAfter(node,{count:2});const rightParenToken=nextTwoTokens[0];const tokenAfterRightParen=nextTwoTokens[1];const tokenBeforeRightParen=sourceCode.getLastToken(node);return rightParenToken&&tokenAfterRightParen&&!sourceCode.isSpaceBetweenTokens(rightParenToken,tokenAfterRightParen)&&!astUtils.canTokensBeAdjacent(tokenBeforeRightParen,tokenAfterRightParen);}function isIIFE(node){const maybeCallNode=astUtils.skipChainExpression(node);return maybeCallNode.type==="CallExpression"&&maybeCallNode.callee.type==="FunctionExpression";}function canBeAssignmentTarget(node){return node&&(node.type==="Identifier"||node.type==="MemberExpression");}function report(node){const leftParenToken=sourceCode.getTokenBefore(node);const rightParenToken=sourceCode.getTokenAfter(node);if(!isParenthesisedTwice(node)){if(tokensToIgnore.has(sourceCode.getFirstToken(node))){return;}if(isIIFE(node)&&!isParenthesised(node.callee)){return;}}function finishReport(){context.report({node,loc:leftParenToken.loc,messageId:"unexpected",fix(fixer){const parenthesizedSource=sourceCode.text.slice(leftParenToken.range[1],rightParenToken.range[0]);return fixer.replaceTextRange([leftParenToken.range[0],rightParenToken.range[1]],(requiresLeadingSpace(node)?" ":"")+parenthesizedSource+(requiresTrailingSpace(node)?" ":""));}});}if(reportsBuffer){reportsBuffer.reports.push({node,finishReport});return;}finishReport();}function checkArgumentWithPrecedence(node){if(hasExcessParensWithPrecedence(node.argument,precedence(node))){report(node.argument);}}function doesMemberExpressionContainCallExpression(node){let currentNode=node.object;let currentNodeType=node.object.type;while(currentNodeType==="MemberExpression"){currentNode=currentNode.object;currentNodeType=currentNode.type;}return currentNodeType==="CallExpression";}function checkCallNew(node){const callee=node.callee;if(hasExcessParensWithPrecedence(callee,precedence(node))){if(hasDoubleExcessParens(callee)||!(isIIFE(node)||callee.type==="NewExpression"&&!isNewExpressionWithParens(callee)&&!(node.type==="NewExpression"&&!isNewExpressionWithParens(node))||node.type==="NewExpression"&&callee.type==="MemberExpression"&&doesMemberExpressionContainCallExpression(callee)||!node.optional&&callee.type==="ChainExpression")){report(node.callee);}}node.arguments.filter(arg=>hasExcessParensWithPrecedence(arg,PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);}function checkBinaryLogical(node){const prec=precedence(node);const leftPrecedence=precedence(node.left);const rightPrecedence=precedence(node.right);const isExponentiation=node.operator==="**";const shouldSkipLeft=NESTED_BINARY&&(node.left.type==="BinaryExpression"||node.left.type==="LogicalExpression");const shouldSkipRight=NESTED_BINARY&&(node.right.type==="BinaryExpression"||node.right.type==="LogicalExpression");if(!shouldSkipLeft&&hasExcessParens(node.left)){if(!(["AwaitExpression","UnaryExpression"].includes(node.left.type)&&isExponentiation)&&!astUtils.isMixedLogicalAndCoalesceExpressions(node.left,node)&&(leftPrecedence>prec||leftPrecedence===prec&&!isExponentiation)||isParenthesisedTwice(node.left)){report(node.left);}}if(!shouldSkipRight&&hasExcessParens(node.right)){if(!astUtils.isMixedLogicalAndCoalesceExpressions(node.right,node)&&(rightPrecedence>prec||rightPrecedence===prec&&isExponentiation)||isParenthesisedTwice(node.right)){report(node.right);}}}function checkClass(node){if(!node.superClass){return;}const hasExtraParens=precedence(node.superClass)>PRECEDENCE_OF_UPDATE_EXPR?hasExcessParens(node.superClass):hasDoubleExcessParens(node.superClass);if(hasExtraParens){report(node.superClass);}}function checkSpreadOperator(node){if(hasExcessParensWithPrecedence(node.argument,PRECEDENCE_OF_ASSIGNMENT_EXPR)){report(node.argument);}}function checkExpressionOrExportStatement(node){const firstToken=isParenthesised(node)?sourceCode.getTokenBefore(node):sourceCode.getFirstToken(node);const secondToken=sourceCode.getTokenAfter(firstToken,astUtils.isNotOpeningParenToken);const thirdToken=secondToken?sourceCode.getTokenAfter(secondToken):null;const tokenAfterClosingParens=secondToken?sourceCode.getTokenAfter(secondToken,astUtils.isNotClosingParenToken):null;if(astUtils.isOpeningParenToken(firstToken)&&(astUtils.isOpeningBraceToken(secondToken)||secondToken.type==="Keyword"&&(secondToken.value==="function"||secondToken.value==="class"||secondToken.value==="let"&&tokenAfterClosingParens&&(astUtils.isOpeningBracketToken(tokenAfterClosingParens)||tokenAfterClosingParens.type==="Identifier"))||secondToken&&secondToken.type==="Identifier"&&secondToken.value==="async"&&thirdToken&&thirdToken.type==="Keyword"&&thirdToken.value==="function")){tokensToIgnore.add(secondToken);}const hasExtraParens=node.parent.type==="ExportDefaultDeclaration"?hasExcessParensWithPrecedence(node,PRECEDENCE_OF_ASSIGNMENT_EXPR):hasExcessParens(node);if(hasExtraParens){report(node);}}function pathToAncestor(node,ancestor){const path=[node];let currentNode=node;while(currentNode!==ancestor){currentNode=currentNode.parent;if(currentNode===null){throw new Error("Nodes are not in the ancestor-descendant relationship.");}path.push(currentNode);}return path;}function pathToDescendant(node,descendant){return pathToAncestor(descendant,node).reverse();}function isSafelyEnclosingInExpression(node,child){switch(node.type){case"ArrayExpression":case"ArrayPattern":case"BlockStatement":case"ObjectExpression":case"ObjectPattern":case"TemplateLiteral":return true;case"ArrowFunctionExpression":case"FunctionExpression":return node.params.includes(child);case"CallExpression":case"NewExpression":return node.arguments.includes(child);case"MemberExpression":return node.computed&&node.property===child;case"ConditionalExpression":return node.consequent===child;default:return false;}}function startNewReportsBuffering(){reportsBuffer={upper:reportsBuffer,inExpressionNodes:[],reports:[]};}function endCurrentReportsBuffering(){const{upper,inExpressionNodes,reports}=reportsBuffer;if(upper){upper.inExpressionNodes.push(...inExpressionNodes);upper.reports.push(...reports);}else {reports.forEach(({finishReport})=>finishReport());}reportsBuffer=upper;}function isInCurrentReportsBuffer(node){return reportsBuffer.reports.some(r=>r.node===node);}function removeFromCurrentReportsBuffer(node){reportsBuffer.reports=reportsBuffer.reports.filter(r=>r.node!==node);}function isMemberExpInNewCallee(node){if(node.type==="MemberExpression"){return node.parent.type==="NewExpression"&&node.parent.callee===node?true:node.parent.object===node&&isMemberExpInNewCallee(node.parent);}return false;}return {ArrayExpression(node){node.elements.filter(e=>e&&hasExcessParensWithPrecedence(e,PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);},ArrayPattern(node){node.elements.filter(e=>canBeAssignmentTarget(e)&&hasExcessParens(e)).forEach(report);},ArrowFunctionExpression(node){if(isReturnAssignException(node)){return;}if(node.body.type==="ConditionalExpression"&&IGNORE_ARROW_CONDITIONALS){return;}if(node.body.type!=="BlockStatement"){const firstBodyToken=sourceCode.getFirstToken(node.body,astUtils.isNotOpeningParenToken);const tokenBeforeFirst=sourceCode.getTokenBefore(firstBodyToken);if(astUtils.isOpeningParenToken(tokenBeforeFirst)&&astUtils.isOpeningBraceToken(firstBodyToken)){tokensToIgnore.add(firstBodyToken);}if(hasExcessParensWithPrecedence(node.body,PRECEDENCE_OF_ASSIGNMENT_EXPR)){report(node.body);}}},AssignmentExpression(node){if(canBeAssignmentTarget(node.left)&&hasExcessParens(node.left)){report(node.left);}if(!isReturnAssignException(node)&&hasExcessParensWithPrecedence(node.right,precedence(node))){report(node.right);}},BinaryExpression(node){if(reportsBuffer&&node.operator==="in"){reportsBuffer.inExpressionNodes.push(node);}checkBinaryLogical(node);},CallExpression:checkCallNew,ClassBody(node){node.body.filter(member=>member.type==="MethodDefinition"&&member.computed&&member.key).filter(member=>hasExcessParensWithPrecedence(member.key,PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(member=>report(member.key));},ConditionalExpression(node){if(isReturnAssignException(node)){return;}if(!isCondAssignException(node)&&hasExcessParensWithPrecedence(node.test,precedence({type:"LogicalExpression",operator:"||"}))){report(node.test);}if(hasExcessParensWithPrecedence(node.consequent,PRECEDENCE_OF_ASSIGNMENT_EXPR)){report(node.consequent);}if(hasExcessParensWithPrecedence(node.alternate,PRECEDENCE_OF_ASSIGNMENT_EXPR)){report(node.alternate);}},DoWhileStatement(node){if(hasExcessParens(node.test)&&!isCondAssignException(node)){report(node.test);}},ExportDefaultDeclaration:node=>checkExpressionOrExportStatement(node.declaration),ExpressionStatement:node=>checkExpressionOrExportStatement(node.expression),ForInStatement(node){if(node.left.type!=="VariableDeclaration"){const firstLeftToken=sourceCode.getFirstToken(node.left,astUtils.isNotOpeningParenToken);if(firstLeftToken.value==="let"&&astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken,astUtils.isNotClosingParenToken))){tokensToIgnore.add(firstLeftToken);}}if(hasExcessParens(node.left)){report(node.left);}if(hasExcessParens(node.right)){report(node.right);}},ForOfStatement(node){if(node.left.type!=="VariableDeclaration"){const firstLeftToken=sourceCode.getFirstToken(node.left,astUtils.isNotOpeningParenToken);if(firstLeftToken.value==="let"){tokensToIgnore.add(firstLeftToken);}}if(hasExcessParens(node.left)){report(node.left);}if(hasExcessParensWithPrecedence(node.right,PRECEDENCE_OF_ASSIGNMENT_EXPR)){report(node.right);}},ForStatement(node){if(node.test&&hasExcessParens(node.test)&&!isCondAssignException(node)){report(node.test);}if(node.update&&hasExcessParens(node.update)){report(node.update);}if(node.init){if(node.init.type!=="VariableDeclaration"){const firstToken=sourceCode.getFirstToken(node.init,astUtils.isNotOpeningParenToken);if(firstToken.value==="let"&&astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstToken,astUtils.isNotClosingParenToken))){tokensToIgnore.add(firstToken);}}startNewReportsBuffering();if(hasExcessParens(node.init)){report(node.init);}}},"ForStatement > *.init:exit"(node){if(reportsBuffer.reports.length){reportsBuffer.inExpressionNodes.forEach(inExpressionNode=>{const path=pathToDescendant(node,inExpressionNode);let nodeToExclude;for(let i=0;i<path.length;i++){const pathNode=path[i];if(i<path.length-1){const nextPathNode=path[i+1];if(isSafelyEnclosingInExpression(pathNode,nextPathNode)){return;}}if(isParenthesised(pathNode)){if(isInCurrentReportsBuffer(pathNode)){if(isParenthesisedTwice(pathNode)){return;}if(!nodeToExclude){nodeToExclude=pathNode;}}else {return;}}}removeFromCurrentReportsBuffer(nodeToExclude);});}endCurrentReportsBuffering();},IfStatement(node){if(hasExcessParens(node.test)&&!isCondAssignException(node)){report(node.test);}},ImportExpression(node){const{source}=node;if(source.type==="SequenceExpression"){if(hasDoubleExcessParens(source)){report(source);}}else if(hasExcessParens(source)){report(source);}},LogicalExpression:checkBinaryLogical,MemberExpression(node){const shouldAllowWrapOnce=isMemberExpInNewCallee(node)&&doesMemberExpressionContainCallExpression(node);const nodeObjHasExcessParens=shouldAllowWrapOnce?hasDoubleExcessParens(node.object):hasExcessParens(node.object)&&!(isImmediateFunctionPrototypeMethodCall(node.parent)&&node.parent.callee===node&&IGNORE_FUNCTION_PROTOTYPE_METHODS);if(nodeObjHasExcessParens&&precedence(node.object)>=precedence(node)&&(node.computed||!(astUtils.isDecimalInteger(node.object)||node.object.type==="Literal"&&node.object.regex))){report(node.object);}if(nodeObjHasExcessParens&&node.object.type==="CallExpression"){report(node.object);}if(nodeObjHasExcessParens&&!IGNORE_NEW_IN_MEMBER_EXPR&&node.object.type==="NewExpression"&&isNewExpressionWithParens(node.object)){report(node.object);}if(nodeObjHasExcessParens&&node.optional&&node.object.type==="ChainExpression"){report(node.object);}if(node.computed&&hasExcessParens(node.property)){report(node.property);}},NewExpression:checkCallNew,ObjectExpression(node){node.properties.filter(property=>property.value&&hasExcessParensWithPrecedence(property.value,PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(property=>report(property.value));},ObjectPattern(node){node.properties.filter(property=>{const value=property.value;return canBeAssignmentTarget(value)&&hasExcessParens(value);}).forEach(property=>report(property.value));},Property(node){if(node.computed){const{key}=node;if(key&&hasExcessParensWithPrecedence(key,PRECEDENCE_OF_ASSIGNMENT_EXPR)){report(key);}}},RestElement(node){const argument=node.argument;if(canBeAssignmentTarget(argument)&&hasExcessParens(argument)){report(argument);}},ReturnStatement(node){const returnToken=sourceCode.getFirstToken(node);if(isReturnAssignException(node)){return;}if(node.argument&&hasExcessParensNoLineTerminator(returnToken,node.argument)&&!(node.argument.type==="Literal"&&node.argument.regex)){report(node.argument);}},SequenceExpression(node){const precedenceOfNode=precedence(node);node.expressions.filter(e=>hasExcessParensWithPrecedence(e,precedenceOfNode)).forEach(report);},SwitchCase(node){if(node.test&&hasExcessParens(node.test)){report(node.test);}},SwitchStatement(node){if(hasExcessParens(node.discriminant)){report(node.discriminant);}},ThrowStatement(node){const throwToken=sourceCode.getFirstToken(node);if(hasExcessParensNoLineTerminator(throwToken,node.argument)){report(node.argument);}},UnaryExpression:checkArgumentWithPrecedence,UpdateExpression(node){if(node.prefix){checkArgumentWithPrecedence(node);}else {const{argument}=node;const operatorToken=sourceCode.getLastToken(node);if(argument.loc.end.line===operatorToken.loc.start.line){checkArgumentWithPrecedence(node);}else {if(hasDoubleExcessParens(argument)){report(argument);}}}},AwaitExpression:checkArgumentWithPrecedence,VariableDeclarator(node){if(node.init&&hasExcessParensWithPrecedence(node.init,PRECEDENCE_OF_ASSIGNMENT_EXPR)&&!(node.init.type==="Literal"&&node.init.regex)){report(node.init);}},WhileStatement(node){if(hasExcessParens(node.test)&&!isCondAssignException(node)){report(node.test);}},WithStatement(node){if(hasExcessParens(node.object)){report(node.object);}},YieldExpression(node){if(node.argument){const yieldToken=sourceCode.getFirstToken(node);if(precedence(node.argument)>=precedence(node)&&hasExcessParensNoLineTerminator(yieldToken,node.argument)||hasDoubleExcessParens(node.argument)){report(node.argument);}}},ClassDeclaration:checkClass,ClassExpression:checkClass,SpreadElement:checkSpreadOperator,SpreadProperty:checkSpreadOperator,ExperimentalSpreadProperty:checkSpreadOperator,TemplateLiteral(node){node.expressions.filter(e=>e&&hasExcessParens(e)).forEach(report);},AssignmentPattern(node){const{left,right}=node;if(canBeAssignmentTarget(left)&&hasExcessParens(left)){report(left);}if(right&&hasExcessParensWithPrecedence(right,PRECEDENCE_OF_ASSIGNMENT_EXPR)){report(right);}}};}};var noExtraSemi={meta:{type:"suggestion",docs:{description:"disallow unnecessary semicolons",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-extra-semi"},fixable:"code",schema:[],messages:{unexpected:"Unnecessary semicolon."}},create(context){const sourceCode=context.getSourceCode();function report(nodeOrToken){context.report({node:nodeOrToken,messageId:"unexpected",fix(fixer){return new fixTracker(fixer,context.getSourceCode()).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken);}});}function checkForPartOfClassBody(firstToken){for(let token=firstToken;token.type==="Punctuator"&&!astUtils.isClosingBraceToken(token);token=sourceCode.getTokenAfter(token)){if(astUtils.isSemicolonToken(token)){report(token);}}}return {EmptyStatement(node){const parent=node.parent;if(["ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoWhileStatement","IfStatement","LabeledStatement","WithStatement"].indexOf(parent.type)===-1){report(node);}},ClassBody(node){checkForPartOfClassBody(sourceCode.getFirstToken(node,1));},MethodDefinition(node){checkForPartOfClassBody(sourceCode.getTokenAfter(node));}};}};const DEFAULT_FALLTHROUGH_COMMENT=/falls?\s?through/iu;function hasFallthroughComment(node,context,fallthroughCommentPattern){const sourceCode=context.getSourceCode();const comment=lodash__default['default'].last(sourceCode.getCommentsBefore(node));return Boolean(comment&&fallthroughCommentPattern.test(comment.value));}function isReachable(segment){return segment.reachable;}function hasBlankLinesBetween(node,token){return token.loc.start.line>node.loc.end.line+1;}var noFallthrough={meta:{type:"problem",docs:{description:"disallow fallthrough of `case` statements",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-fallthrough"},schema:[{type:"object",properties:{commentPattern:{type:"string",default:""}},additionalProperties:false}],messages:{case:"Expected a 'break' statement before 'case'.",default:"Expected a 'break' statement before 'default'."}},create(context){const options=context.options[0]||{};let currentCodePath=null;const sourceCode=context.getSourceCode();let fallthroughCase=null;let fallthroughCommentPattern=null;if(options.commentPattern){fallthroughCommentPattern=new RegExp(options.commentPattern,"u");}else {fallthroughCommentPattern=DEFAULT_FALLTHROUGH_COMMENT;}return {onCodePathStart(codePath){currentCodePath=codePath;},onCodePathEnd(){currentCodePath=currentCodePath.upper;},SwitchCase(node){if(fallthroughCase&&!hasFallthroughComment(node,context,fallthroughCommentPattern)){context.report({messageId:node.test?"case":"default",node});}fallthroughCase=null;},"SwitchCase:exit"(node){const nextToken=sourceCode.getTokenAfter(node);if(currentCodePath.currentSegments.some(isReachable)&&(node.consequent.length>0||hasBlankLinesBetween(node,nextToken))&&lodash__default['default'].last(node.parent.cases)!==node){fallthroughCase=node;}}};}};var noFloatingDecimal={meta:{type:"suggestion",docs:{description:"disallow leading or trailing decimal points in numeric literals",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-floating-decimal"},schema:[],fixable:"code",messages:{leading:"A leading decimal point can be confused with a dot.",trailing:"A trailing decimal point can be confused with a dot."}},create(context){const sourceCode=context.getSourceCode();return {Literal(node){if(typeof node.value==="number"){if(node.raw.startsWith(".")){context.report({node,messageId:"leading",fix(fixer){const tokenBefore=sourceCode.getTokenBefore(node);const needsSpaceBefore=tokenBefore&&tokenBefore.range[1]===node.range[0]&&!astUtils.canTokensBeAdjacent(tokenBefore,`0${node.raw}`);return fixer.insertTextBefore(node,needsSpaceBefore?" 0":"0");}});}if(node.raw.indexOf(".")===node.raw.length-1){context.report({node,messageId:"trailing",fix:fixer=>fixer.insertTextAfter(node,"0")});}}}};}};var noFuncAssign={meta:{type:"problem",docs:{description:"disallow reassigning `function` declarations",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-func-assign"},schema:[],messages:{isAFunction:"'{{name}}' is a function."}},create(context){function checkReference(references){astUtils.getModifyingReferences(references).forEach(reference=>{context.report({node:reference.identifier,messageId:"isAFunction",data:{name:reference.identifier.name}});});}function checkVariable(variable){if(variable.defs[0].type==="FunctionName"){checkReference(variable.references);}}function checkForFunction(node){context.getDeclaredVariables(node).forEach(checkVariable);}return {FunctionDeclaration:checkForFunction,FunctionExpression:checkForFunction};}};var noGlobalAssign={meta:{type:"suggestion",docs:{description:"disallow assignments to native objects or read-only global variables",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-global-assign"},schema:[{type:"object",properties:{exceptions:{type:"array",items:{type:"string"},uniqueItems:true}},additionalProperties:false}],messages:{globalShouldNotBeModified:"Read-only global '{{name}}' should not be modified."}},create(context){const config=context.options[0];const exceptions=config&&config.exceptions||[];function checkReference(reference,index,references){const identifier=reference.identifier;if(reference.init===false&&reference.isWrite()&&(index===0||references[index-1].identifier!==identifier)){context.report({node:identifier,messageId:"globalShouldNotBeModified",data:{name:identifier.name}});}}function checkVariable(variable){if(variable.writeable===false&&exceptions.indexOf(variable.name)===-1){variable.references.forEach(checkReference);}}return {Program(){const globalScope=context.getScope();globalScope.variables.forEach(checkVariable);}};}};const INDEX_OF_PATTERN=/^(?:i|lastI)ndexOf$/u;const ALLOWABLE_OPERATORS=["~","!!","+","*"];function parseOptions$1(options){return {boolean:"boolean"in options?options.boolean:true,number:"number"in options?options.number:true,string:"string"in options?options.string:true,disallowTemplateShorthand:"disallowTemplateShorthand"in options?options.disallowTemplateShorthand:false,allow:options.allow||[]};}function isDoubleLogicalNegating(node){return node.operator==="!"&&node.argument.type==="UnaryExpression"&&node.argument.operator==="!";}function isBinaryNegatingOfIndexOf(node){if(node.operator!=="~"){return false;}const callNode=astUtils.skipChainExpression(node.argument);return callNode.type==="CallExpression"&&astUtils.isSpecificMemberAccess(callNode.callee,null,INDEX_OF_PATTERN);}function isMultiplyByOne(node){return node.operator==="*"&&(node.left.type==="Literal"&&node.left.value===1||node.right.type==="Literal"&&node.right.value===1);}function isNumeric(node){return node.type==="Literal"&&typeof node.value==="number"||node.type==="CallExpression"&&(node.callee.name==="Number"||node.callee.name==="parseInt"||node.callee.name==="parseFloat");}function getNonNumericOperand(node){const left=node.left,right=node.right;if(right.type!=="BinaryExpression"&&!isNumeric(right)){return right;}if(left.type!=="BinaryExpression"&&!isNumeric(left)){return left;}return null;}function isEmptyString(node){return astUtils.isStringLiteral(node)&&(node.value===""||node.type==="TemplateLiteral"&&node.quasis.length===1&&node.quasis[0].value.cooked==="");}function isConcatWithEmptyString(node){return node.operator==="+"&&(isEmptyString(node.left)&&!astUtils.isStringLiteral(node.right)||isEmptyString(node.right)&&!astUtils.isStringLiteral(node.left));}function isAppendEmptyString(node){return node.operator==="+="&&isEmptyString(node.right);}function getNonEmptyOperand(node){return isEmptyString(node.left)?node.right:node.left;}var noImplicitCoercion={meta:{type:"suggestion",docs:{description:"disallow shorthand type conversions",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-implicit-coercion"},fixable:"code",schema:[{type:"object",properties:{boolean:{type:"boolean",default:true},number:{type:"boolean",default:true},string:{type:"boolean",default:true},disallowTemplateShorthand:{type:"boolean",default:false},allow:{type:"array",items:{enum:ALLOWABLE_OPERATORS},uniqueItems:true}},additionalProperties:false}],messages:{useRecommendation:"use `{{recommendation}}` instead."}},create(context){const options=parseOptions$1(context.options[0]||{});const sourceCode=context.getSourceCode();function report(node,recommendation,shouldFix){context.report({node,messageId:"useRecommendation",data:{recommendation},fix(fixer){if(!shouldFix){return null;}const tokenBefore=sourceCode.getTokenBefore(node);if(tokenBefore&&tokenBefore.range[1]===node.range[0]&&!astUtils.canTokensBeAdjacent(tokenBefore,recommendation)){return fixer.replaceText(node,` ${recommendation}`);}return fixer.replaceText(node,recommendation);}});}return {UnaryExpression(node){let operatorAllowed=options.allow.indexOf("!!")>=0;if(!operatorAllowed&&options.boolean&&isDoubleLogicalNegating(node)){const recommendation=`Boolean(${sourceCode.getText(node.argument.argument)})`;report(node,recommendation,true);}operatorAllowed=options.allow.indexOf("~")>=0;if(!operatorAllowed&&options.boolean&&isBinaryNegatingOfIndexOf(node)){const comparison=node.argument.type==="ChainExpression"?">= 0":"!== -1";const recommendation=`${sourceCode.getText(node.argument)} ${comparison}`;report(node,recommendation,false);}operatorAllowed=options.allow.indexOf("+")>=0;if(!operatorAllowed&&options.number&&node.operator==="+"&&!isNumeric(node.argument)){const recommendation=`Number(${sourceCode.getText(node.argument)})`;report(node,recommendation,true);}},"BinaryExpression:exit"(node){let operatorAllowed=options.allow.indexOf("*")>=0;const nonNumericOperand=!operatorAllowed&&options.number&&isMultiplyByOne(node)&&getNonNumericOperand(node);if(nonNumericOperand){const recommendation=`Number(${sourceCode.getText(nonNumericOperand)})`;report(node,recommendation,true);}operatorAllowed=options.allow.indexOf("+")>=0;if(!operatorAllowed&&options.string&&isConcatWithEmptyString(node)){const recommendation=`String(${sourceCode.getText(getNonEmptyOperand(node))})`;report(node,recommendation,true);}},AssignmentExpression(node){const operatorAllowed=options.allow.indexOf("+")>=0;if(!operatorAllowed&&options.string&&isAppendEmptyString(node)){const code=sourceCode.getText(getNonEmptyOperand(node));report(node,`${code} = String(${code})`,true);}},TemplateLiteral(node){if(!options.disallowTemplateShorthand){return;}if(node.parent.type==="TaggedTemplateExpression"){return;}if(node.expressions.length!==1){return;}if(node.quasis[0].value.cooked!==""){return;}if(node.quasis[1].value.cooked!==""){return;}const code=sourceCode.getText(node.expressions[0]);report(node,`String(${code})`,true);}};}};var noImplicitGlobals={meta:{type:"suggestion",docs:{description:"disallow declarations in the global scope",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-implicit-globals"},schema:[{type:"object",properties:{lexicalBindings:{type:"boolean",default:false}},additionalProperties:false}],messages:{globalNonLexicalBinding:"Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.",globalLexicalBinding:"Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.",globalVariableLeak:"Global variable leak, declare the variable if it is intended to be local.",assignmentToReadonlyGlobal:"Unexpected assignment to read-only global variable.",redeclarationOfReadonlyGlobal:"Unexpected redeclaration of read-only global variable."}},create(context){const checkLexicalBindings=context.options[0]&&context.options[0].lexicalBindings===true;function report(node,messageId,kind){context.report({node,messageId,data:{kind}});}return {Program(){const scope=context.getScope();scope.variables.forEach(variable=>{const isReadonlyEslintGlobalVariable=variable.writeable===false;const isWritableEslintGlobalVariable=variable.writeable===true;if(isWritableEslintGlobalVariable){return;}variable.defs.forEach(def=>{const defNode=def.node;if(def.type==="FunctionName"||def.type==="Variable"&&def.parent.kind==="var"){if(isReadonlyEslintGlobalVariable){report(defNode,"redeclarationOfReadonlyGlobal");}else {report(defNode,"globalNonLexicalBinding",def.type==="FunctionName"?"function":`'${def.parent.kind}'`);}}if(checkLexicalBindings){if(def.type==="ClassName"||def.type==="Variable"&&(def.parent.kind==="let"||def.parent.kind==="const")){if(isReadonlyEslintGlobalVariable){report(defNode,"redeclarationOfReadonlyGlobal");}else {report(defNode,"globalLexicalBinding",def.type==="ClassName"?"class":`'${def.parent.kind}'`);}}}});});scope.implicit.variables.forEach(variable=>{const scopeVariable=scope.set.get(variable.name);let messageId;if(scopeVariable){if(scopeVariable.writeable){return;}messageId="assignmentToReadonlyGlobal";}else {messageId="globalVariableLeak";}variable.defs.forEach(def=>{report(def.node,messageId);});});}};}};const{getStaticValue}=eslintUtils__default['default'];var noImpliedEval={meta:{type:"suggestion",docs:{description:"disallow the use of `eval()`-like methods",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-implied-eval"},schema:[],messages:{impliedEval:"Implied eval. Consider passing a function instead of a string."}},create(context){const GLOBAL_CANDIDATES=Object.freeze(["global","window","globalThis"]);const EVAL_LIKE_FUNC_PATTERN=/^(?:set(?:Interval|Timeout)|execScript)$/u;function isEvaluatedString(node){if(node.type==="Literal"&&typeof node.value==="string"||node.type==="TemplateLiteral"){return true;}if(node.type==="BinaryExpression"&&node.operator==="+"){return isEvaluatedString(node.left)||isEvaluatedString(node.right);}return false;}function reportImpliedEvalCallExpression(node){const[firstArgument]=node.arguments;if(firstArgument){const staticValue=getStaticValue(firstArgument,context.getScope());const isStaticString=staticValue&&typeof staticValue.value==="string";const isString=isStaticString||isEvaluatedString(firstArgument);if(isString){context.report({node,messageId:"impliedEval"});}}}function reportImpliedEvalViaGlobal(globalVar){const{references,name}=globalVar;references.forEach(ref=>{const identifier=ref.identifier;let node=identifier.parent;while(astUtils.isSpecificMemberAccess(node,null,name)){node=node.parent;}if(astUtils.isSpecificMemberAccess(node,null,EVAL_LIKE_FUNC_PATTERN)){const calleeNode=node.parent.type==="ChainExpression"?node.parent:node;const parent=calleeNode.parent;if(parent.type==="CallExpression"&&parent.callee===calleeNode){reportImpliedEvalCallExpression(parent);}}});}return {CallExpression(node){if(astUtils.isSpecificId(node.callee,EVAL_LIKE_FUNC_PATTERN)){reportImpliedEvalCallExpression(node);}},"Program:exit"(){const globalScope=context.getScope();GLOBAL_CANDIDATES.map(candidate=>astUtils.getVariableByName(globalScope,candidate)).filter(globalVar=>!!globalVar&&globalVar.defs.length===0).forEach(reportImpliedEvalViaGlobal);}};}};const{findVariable:findVariable$3}=eslintUtils__default['default'];const WellKnownMutationFunctions={Object:/^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,Reflect:/^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u};function isAssignmentLeft(node){const{parent}=node;return parent.type==="AssignmentExpression"&&parent.left===node||parent.type==="ArrayPattern"||parent.type==="Property"&&parent.value===node&&parent.parent.type==="ObjectPattern"||parent.type==="RestElement"||parent.type==="AssignmentPattern"&&parent.left===node;}function isOperandOfMutationUnaryOperator(node){const argumentNode=node.parent.type==="ChainExpression"?node.parent:node;const{parent}=argumentNode;return parent.type==="UpdateExpression"&&parent.argument===argumentNode||parent.type==="UnaryExpression"&&parent.operator==="delete"&&parent.argument===argumentNode;}function isIterationVariable(node){const{parent}=node;return parent.type==="ForInStatement"&&parent.left===node||parent.type==="ForOfStatement"&&parent.left===node;}function isArgumentOfWellKnownMutationFunction(node,scope){const{parent}=node;if(parent.type!=="CallExpression"||parent.arguments[0]!==node){return false;}const callee=astUtils.skipChainExpression(parent.callee);if(!astUtils.isSpecificMemberAccess(callee,"Object",WellKnownMutationFunctions.Object)&&!astUtils.isSpecificMemberAccess(callee,"Reflect",WellKnownMutationFunctions.Reflect)){return false;}const variable=findVariable$3(scope,callee.object);return variable!==null&&variable.scope.type==="global";}function isMemberWrite(id,scope){const{parent}=id;return parent.type==="MemberExpression"&&parent.object===id&&(isAssignmentLeft(parent)||isOperandOfMutationUnaryOperator(parent)||isIterationVariable(parent))||isArgumentOfWellKnownMutationFunction(id,scope);}function getWriteNode(id){let node=id.parent;while(node&&node.type!=="AssignmentExpression"&&node.type!=="UpdateExpression"&&node.type!=="UnaryExpression"&&node.type!=="CallExpression"&&node.type!=="ForInStatement"&&node.type!=="ForOfStatement"){node=node.parent;}return node||id;}var noImportAssign={meta:{type:"problem",docs:{description:"disallow assigning to imported bindings",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-import-assign"},schema:[],messages:{readonly:"'{{name}}' is read-only.",readonlyMember:"The members of '{{name}}' are read-only."}},create(context){return {ImportDeclaration(node){const scope=context.getScope();for(const variable of context.getDeclaredVariables(node)){const shouldCheckMembers=variable.defs.some(d=>d.node.type==="ImportNamespaceSpecifier");let prevIdNode=null;for(const reference of variable.references){const idNode=reference.identifier;if(idNode===prevIdNode){continue;}prevIdNode=idNode;if(reference.isWrite()){context.report({node:getWriteNode(idNode),messageId:"readonly",data:{name:idNode.name}});}else if(shouldCheckMembers&&isMemberWrite(idNode,scope)){context.report({node:getWriteNode(idNode),messageId:"readonlyMember",data:{name:idNode.name}});}}}}};}};var noInlineComments={meta:{type:"suggestion",docs:{description:"disallow inline comments after code",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-inline-comments"},schema:[{type:"object",properties:{ignorePattern:{type:"string"}},additionalProperties:false}],messages:{unexpectedInlineComment:"Unexpected comment inline with code."}},create(context){const sourceCode=context.getSourceCode();const options=context.options[0];let customIgnoreRegExp;if(options&&options.ignorePattern){customIgnoreRegExp=new RegExp(options.ignorePattern,"u");}function testCodeAroundComment(node){const startLine=String(sourceCode.lines[node.loc.start.line-1]),endLine=String(sourceCode.lines[node.loc.end.line-1]),preamble=startLine.slice(0,node.loc.start.column).trim(),postamble=endLine.slice(node.loc.end.column).trim(),isPreambleEmpty=!preamble,isPostambleEmpty=!postamble;if(isPreambleEmpty&&isPostambleEmpty){return;}if(customIgnoreRegExp&&customIgnoreRegExp.test(node.value)){return;}if((isPreambleEmpty||preamble==="{")&&(isPostambleEmpty||postamble==="}")){const enclosingNode=sourceCode.getNodeByRangeIndex(node.range[0]);if(enclosingNode&&enclosingNode.type==="JSXEmptyExpression"){return;}}if(astUtils.isDirectiveComment(node)){return;}context.report({node,messageId:"unexpectedInlineComment"});}return {Program(){sourceCode.getAllComments().filter(token=>token.type!=="Shebang").forEach(testCodeAroundComment);}};}};const validParent=new Set(["Program","ExportNamedDeclaration","ExportDefaultDeclaration"]);const validBlockStatementParent=new Set(["FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"]);var noInnerDeclarations={meta:{type:"problem",docs:{description:"disallow variable or `function` declarations in nested blocks",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-inner-declarations"},schema:[{enum:["functions","both"]}],messages:{moveDeclToRoot:"Move {{type}} declaration to {{body}} root."}},create(context){function check(node){const parent=node.parent;if(parent.type==="BlockStatement"&&validBlockStatementParent.has(parent.parent.type)){return;}if(validParent.has(parent.type)){return;}const upperFunction=astUtils.getUpperFunction(parent);context.report({node,messageId:"moveDeclToRoot",data:{type:node.type==="FunctionDeclaration"?"function":"variable",body:upperFunction===null?"program":"function body"}});}return {FunctionDeclaration:check,VariableDeclaration(node){if(context.options[0]==="both"&&node.kind==="var"){check(node);}}};}};const RegExpValidator=regexpp__default['default'].RegExpValidator;const validator=new RegExpValidator();const validFlags=/[gimuys]/gu;const undefined1=void 0;var noInvalidRegexp={meta:{type:"problem",docs:{description:"disallow invalid regular expression strings in `RegExp` constructors",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-invalid-regexp"},schema:[{type:"object",properties:{allowConstructorFlags:{type:"array",items:{type:"string"}}},additionalProperties:false}],messages:{regexMessage:"{{message}}."}},create(context){const options=context.options[0];let allowedFlags=null;if(options&&options.allowConstructorFlags){const temp=options.allowConstructorFlags.join("").replace(validFlags,"");if(temp){allowedFlags=new RegExp(`[${temp}]`,"giu");}}function isString(node){return node&&node.type==="Literal"&&typeof node.value==="string";}function getFlags(node){if(node.arguments.length<2){return "";}if(isString(node.arguments[1])){return node.arguments[1].value;}return null;}function validateRegExpPattern(pattern,uFlag){try{validator.validatePattern(pattern,undefined1,undefined1,uFlag);return null;}catch(err){return err.message;}}function validateRegExpFlags(flags){try{validator.validateFlags(flags);return null;}catch{return `Invalid flags supplied to RegExp constructor '${flags}'`;}}return {"CallExpression, NewExpression"(node){if(node.callee.type!=="Identifier"||node.callee.name!=="RegExp"||!isString(node.arguments[0])){return;}const pattern=node.arguments[0].value;let flags=getFlags(node);if(flags&&allowedFlags){flags=flags.replace(allowedFlags,"");}const message=flags&&validateRegExpFlags(flags)||(flags===null?validateRegExpPattern(pattern,true)&&validateRegExpPattern(pattern,false):validateRegExpPattern(pattern,flags.includes("u")));if(message){context.report({node,messageId:"regexMessage",data:{message}});}}};}};var noInvalidThis={meta:{type:"suggestion",docs:{description:"disallow `this` keywords outside of classes or class-like objects",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-invalid-this"},schema:[{type:"object",properties:{capIsConstructor:{type:"boolean",default:true}},additionalProperties:false}],messages:{unexpectedThis:"Unexpected 'this'."}},create(context){const options=context.options[0]||{};const capIsConstructor=options.capIsConstructor!==false;const stack=[],sourceCode=context.getSourceCode();stack.getCurrent=function(){const current=this[this.length-1];if(!current.init){current.init=true;current.valid=!astUtils.isDefaultThisBinding(current.node,sourceCode,{capIsConstructor});}return current;};function enterFunction(node){stack.push({init:!context.getScope().isStrict,node,valid:true});}function exitFunction(){stack.pop();}return {Program(node){const scope=context.getScope(),features=context.parserOptions.ecmaFeatures||{};stack.push({init:true,node,valid:!(scope.isStrict||node.sourceType==="module"||features.globalReturn&&scope.childScopes[0].isStrict)});},"Program:exit"(){stack.pop();},FunctionDeclaration:enterFunction,"FunctionDeclaration:exit":exitFunction,FunctionExpression:enterFunction,"FunctionExpression:exit":exitFunction,ThisExpression(node){const current=stack.getCurrent();if(current&&!current.valid){context.report({node,messageId:"unexpectedThis"});}}};}};const ALL_IRREGULARS=/[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u;const IRREGULAR_WHITESPACE=/[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mgu;const IRREGULAR_LINE_TERMINATORS=/[\u2028\u2029]/mgu;const LINE_BREAK=astUtils.createGlobalLinebreakMatcher();var noIrregularWhitespace={meta:{type:"problem",docs:{description:"disallow irregular whitespace",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-irregular-whitespace"},schema:[{type:"object",properties:{skipComments:{type:"boolean",default:false},skipStrings:{type:"boolean",default:true},skipTemplates:{type:"boolean",default:false},skipRegExps:{type:"boolean",default:false}},additionalProperties:false}],messages:{noIrregularWhitespace:"Irregular whitespace not allowed."}},create(context){let errors=[];const options=context.options[0]||{};const skipComments=!!options.skipComments;const skipStrings=options.skipStrings!==false;const skipRegExps=!!options.skipRegExps;const skipTemplates=!!options.skipTemplates;const sourceCode=context.getSourceCode();const commentNodes=sourceCode.getAllComments();function removeWhitespaceError(node){const locStart=node.loc.start;const locEnd=node.loc.end;errors=errors.filter(({loc:{start:errorLocStart}})=>errorLocStart.line<locStart.line||errorLocStart.line===locStart.line&&errorLocStart.column<locStart.column||errorLocStart.line===locEnd.line&&errorLocStart.column>=locEnd.column||errorLocStart.line>locEnd.line);}function removeInvalidNodeErrorsInIdentifierOrLiteral(node){const shouldCheckStrings=skipStrings&&typeof node.value==="string";const shouldCheckRegExps=skipRegExps&&Boolean(node.regex);if(shouldCheckStrings||shouldCheckRegExps){if(ALL_IRREGULARS.test(node.raw)){removeWhitespaceError(node);}}}function removeInvalidNodeErrorsInTemplateLiteral(node){if(typeof node.value.raw==="string"){if(ALL_IRREGULARS.test(node.value.raw)){removeWhitespaceError(node);}}}function removeInvalidNodeErrorsInComment(node){if(ALL_IRREGULARS.test(node.value)){removeWhitespaceError(node);}}function checkForIrregularWhitespace(node){const sourceLines=sourceCode.lines;sourceLines.forEach((sourceLine,lineIndex)=>{const lineNumber=lineIndex+1;let match;while((match=IRREGULAR_WHITESPACE.exec(sourceLine))!==null){errors.push({node,messageId:"noIrregularWhitespace",loc:{start:{line:lineNumber,column:match.index},end:{line:lineNumber,column:match.index+match[0].length}}});}});}function checkForIrregularLineTerminators(node){const source=sourceCode.getText(),sourceLines=sourceCode.lines,linebreaks=source.match(LINE_BREAK);let lastLineIndex=-1,match;while((match=IRREGULAR_LINE_TERMINATORS.exec(source))!==null){const lineIndex=linebreaks.indexOf(match[0],lastLineIndex+1)||0;errors.push({node,messageId:"noIrregularWhitespace",loc:{start:{line:lineIndex+1,column:sourceLines[lineIndex].length},end:{line:lineIndex+2,column:0}}});lastLineIndex=lineIndex;}}function noop(){}const nodes={};if(ALL_IRREGULARS.test(sourceCode.getText())){nodes.Program=function(node){checkForIrregularWhitespace(node);checkForIrregularLineTerminators(node);};nodes.Identifier=removeInvalidNodeErrorsInIdentifierOrLiteral;nodes.Literal=removeInvalidNodeErrorsInIdentifierOrLiteral;nodes.TemplateElement=skipTemplates?removeInvalidNodeErrorsInTemplateLiteral:noop;nodes["Program:exit"]=function(){if(skipComments){commentNodes.forEach(removeInvalidNodeErrorsInComment);}errors.forEach(error=>context.report(error));};}else {nodes.Program=noop;}return nodes;}};const{getStaticPropertyName:getStaticPropertyName$1}=astUtils;var noIterator={meta:{type:"suggestion",docs:{description:"disallow the use of the `__iterator__` property",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-iterator"},schema:[],messages:{noIterator:"Reserved name '__iterator__'."}},create(context){return {MemberExpression(node){if(getStaticPropertyName$1(node)==="__iterator__"){context.report({node,messageId:"noIterator"});}}};}};var noLabelVar={meta:{type:"suggestion",docs:{description:"disallow labels that share a name with a variable",category:"Variables",recommended:false,url:"https://eslint.org/docs/rules/no-label-var"},schema:[],messages:{identifierClashWithLabel:"Found identifier with same name as label."}},create(context){function findIdentifier(scope,name){return astUtils.getVariableByName(scope,name)!==null;}return {LabeledStatement(node){const scope=context.getScope();if(findIdentifier(scope,node.label.name)){context.report({node,messageId:"identifierClashWithLabel"});}}};}};var noLabels={meta:{type:"suggestion",docs:{description:"disallow labeled statements",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-labels"},schema:[{type:"object",properties:{allowLoop:{type:"boolean",default:false},allowSwitch:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpectedLabel:"Unexpected labeled statement.",unexpectedLabelInBreak:"Unexpected label in break statement.",unexpectedLabelInContinue:"Unexpected label in continue statement."}},create(context){const options=context.options[0];const allowLoop=options&&options.allowLoop;const allowSwitch=options&&options.allowSwitch;let scopeInfo=null;function getBodyKind(node){if(astUtils.isLoop(node)){return "loop";}if(node.type==="SwitchStatement"){return "switch";}return "other";}function isAllowed(kind){switch(kind){case"loop":return allowLoop;case"switch":return allowSwitch;default:return false;}}function getKind(label){let info=scopeInfo;while(info){if(info.label===label){return info.kind;}info=info.upper;}return "other";}return {LabeledStatement(node){scopeInfo={label:node.label.name,kind:getBodyKind(node.body),upper:scopeInfo};},"LabeledStatement:exit"(node){if(!isAllowed(scopeInfo.kind)){context.report({node,messageId:"unexpectedLabel"});}scopeInfo=scopeInfo.upper;},BreakStatement(node){if(node.label&&!isAllowed(getKind(node.label.name))){context.report({node,messageId:"unexpectedLabelInBreak"});}},ContinueStatement(node){if(node.label&&!isAllowed(getKind(node.label.name))){context.report({node,messageId:"unexpectedLabelInContinue"});}}};}};var noLoneBlocks={meta:{type:"suggestion",docs:{description:"disallow unnecessary nested blocks",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-lone-blocks"},schema:[],messages:{redundantBlock:"Block is redundant.",redundantNestedBlock:"Nested block is redundant."}},create(context){const loneBlocks=[];let ruleDef;function report(node){const messageId=node.parent.type==="BlockStatement"?"redundantNestedBlock":"redundantBlock";context.report({node,messageId});}function isLoneBlock(node){return node.parent.type==="BlockStatement"||node.parent.type==="Program"||node.parent.type==="SwitchCase"&&!(node.parent.consequent[0]===node&&node.parent.consequent.length===1);}function markLoneBlock(){if(loneBlocks.length===0){return;}const block=context.getAncestors().pop();if(loneBlocks[loneBlocks.length-1]===block){loneBlocks.pop();}}ruleDef={BlockStatement(node){if(isLoneBlock(node)){report(node);}}};if(context.parserOptions.ecmaVersion>=6){ruleDef={BlockStatement(node){if(isLoneBlock(node)){loneBlocks.push(node);}},"BlockStatement:exit"(node){if(loneBlocks.length>0&&loneBlocks[loneBlocks.length-1]===node){loneBlocks.pop();report(node);}else if(node.parent.type==="BlockStatement"&&node.parent.body.length===1){report(node);}}};ruleDef.VariableDeclaration=function(node){if(node.kind==="let"||node.kind==="const"){markLoneBlock();}};ruleDef.FunctionDeclaration=function(){if(context.getScope().isStrict){markLoneBlock();}};ruleDef.ClassDeclaration=markLoneBlock;}return ruleDef;}};var noLonelyIf={meta:{type:"suggestion",docs:{description:"disallow `if` statements as the only statement in `else` blocks",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-lonely-if"},schema:[],fixable:"code",messages:{unexpectedLonelyIf:"Unexpected if as the only statement in an else block."}},create(context){const sourceCode=context.getSourceCode();return {IfStatement(node){const ancestors=context.getAncestors(),parent=ancestors.pop(),grandparent=ancestors.pop();if(parent&&parent.type==="BlockStatement"&&parent.body.length===1&&grandparent&&grandparent.type==="IfStatement"&&parent===grandparent.alternate){context.report({node,messageId:"unexpectedLonelyIf",fix(fixer){const openingElseCurly=sourceCode.getFirstToken(parent);const closingElseCurly=sourceCode.getLastToken(parent);const elseKeyword=sourceCode.getTokenBefore(openingElseCurly);const tokenAfterElseBlock=sourceCode.getTokenAfter(closingElseCurly);const lastIfToken=sourceCode.getLastToken(node.consequent);const sourceText=sourceCode.getText();if(sourceText.slice(openingElseCurly.range[1],node.range[0]).trim()||sourceText.slice(node.range[1],closingElseCurly.range[0]).trim()){return null;}if(node.consequent.type!=="BlockStatement"&&lastIfToken.value!==";"&&tokenAfterElseBlock&&(node.consequent.loc.end.line===tokenAfterElseBlock.loc.start.line||/^[([/+`-]/u.test(tokenAfterElseBlock.value)||lastIfToken.value==="++"||lastIfToken.value==="--")){return null;}return fixer.replaceTextRange([openingElseCurly.range[0],closingElseCurly.range[1]],(elseKeyword.range[1]===openingElseCurly.range[0]?" ":"")+sourceCode.getText(node));}});}}};}};function getContainingLoopNode(node){for(let currentNode=node;currentNode.parent;currentNode=currentNode.parent){const parent=currentNode.parent;switch(parent.type){case"WhileStatement":case"DoWhileStatement":return parent;case"ForStatement":if(parent.init!==currentNode){return parent;}break;case"ForInStatement":case"ForOfStatement":if(parent.right!==currentNode){return parent;}break;case"ArrowFunctionExpression":case"FunctionExpression":case"FunctionDeclaration":return null;}}return null;}function getTopLoopNode(node,excludedNode){const border=excludedNode?excludedNode.range[1]:0;let retv=node;let containingLoopNode=node;while(containingLoopNode&&containingLoopNode.range[0]>=border){retv=containingLoopNode;containingLoopNode=getContainingLoopNode(containingLoopNode);}return retv;}function isSafe(loopNode,reference){const variable=reference.resolved;const definition=variable&&variable.defs[0];const declaration=definition&&definition.parent;const kind=declaration&&declaration.type==="VariableDeclaration"?declaration.kind:"";if(kind==="const"){return true;}if(kind==="let"&&declaration.range[0]>loopNode.range[0]&&declaration.range[1]<loopNode.range[1]){return true;}const border=getTopLoopNode(loopNode,kind==="let"?declaration:null).range[0];return Boolean(variable)&&variable.references.every(function(upperRef){const id=upperRef.identifier;return !upperRef.isWrite()||variable.scope.variableScope===upperRef.from.variableScope&&id.range[0]<border;});}var noLoopFunc={meta:{type:"suggestion",docs:{description:"disallow function declarations that contain unsafe references inside loop statements",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-loop-func"},schema:[],messages:{unsafeRefs:"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}."}},create(context){function checkForLoops(node){const loopNode=getContainingLoopNode(node);if(!loopNode){return;}const references=context.getScope().through;const unsafeRefs=references.filter(r=>!isSafe(loopNode,r)).map(r=>r.identifier.name);if(unsafeRefs.length>0){context.report({node,messageId:"unsafeRefs",data:{varNames:`'${unsafeRefs.join("', '")}'`}});}}return {ArrowFunctionExpression:checkForLoops,FunctionExpression:checkForLoops,FunctionDeclaration:checkForLoops};}};var noLossOfPrecision={meta:{type:"problem",docs:{description:"disallow literal numbers that lose precision",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-loss-of-precision"},schema:[],messages:{noLossOfPrecision:"This number literal will lose precision at runtime."}},create(context){function isNumber(node){return typeof node.value==="number";}function getRaw(node){return node.raw.replace(/_/gu,"");}function isBaseTen(node){return ["0x","0X","0b","0B","0o","0O"].every(prefix=>!node.raw.startsWith(prefix))&&!/^0[0-7]+$/u.test(node.raw);}function notBaseTenLosesPrecision(node){const rawString=getRaw(node).toUpperCase();let base=0;if(rawString.startsWith("0B")){base=2;}else if(rawString.startsWith("0X")){base=16;}else {base=8;}return !rawString.endsWith(node.value.toString(base).toUpperCase());}function addDecimalPointToNumber(stringNumber){return `${stringNumber.slice(0,1)}.${stringNumber.slice(1)}`;}function removeLeadingZeros(numberAsString){return numberAsString.replace(/^0*/u,"");}function removeTrailingZeros(numberAsString){return numberAsString.replace(/0*$/u,"");}function normalizeInteger(stringInteger){const significantDigits=removeTrailingZeros(removeLeadingZeros(stringInteger));return {magnitude:stringInteger.startsWith("0")?stringInteger.length-2:stringInteger.length-1,coefficient:addDecimalPointToNumber(significantDigits)};}function normalizeFloat(stringFloat){const trimmedFloat=removeLeadingZeros(stringFloat);if(trimmedFloat.startsWith(".")){const decimalDigits=trimmedFloat.split(".").pop();const significantDigits=removeLeadingZeros(decimalDigits);return {magnitude:significantDigits.length-decimalDigits.length-1,coefficient:addDecimalPointToNumber(significantDigits)};}return {magnitude:trimmedFloat.indexOf(".")-1,coefficient:addDecimalPointToNumber(trimmedFloat.replace(".",""))};}function convertNumberToScientificNotation(stringNumber){const splitNumber=stringNumber.replace("E","e").split("e");const originalCoefficient=splitNumber[0];const normalizedNumber=stringNumber.includes(".")?normalizeFloat(originalCoefficient):normalizeInteger(originalCoefficient);const normalizedCoefficient=normalizedNumber.coefficient;const magnitude=splitNumber.length>1?parseInt(splitNumber[1],10)+normalizedNumber.magnitude:normalizedNumber.magnitude;return `${normalizedCoefficient}e${magnitude}`;}function baseTenLosesPrecision(node){const normalizedRawNumber=convertNumberToScientificNotation(getRaw(node));const requestedPrecision=normalizedRawNumber.split("e")[0].replace(".","").length;if(requestedPrecision>100){return true;}const storedNumber=node.value.toPrecision(requestedPrecision);const normalizedStoredNumber=convertNumberToScientificNotation(storedNumber);return normalizedRawNumber!==normalizedStoredNumber;}function losesPrecision(node){return isBaseTen(node)?baseTenLosesPrecision(node):notBaseTenLosesPrecision(node);}return {Literal(node){if(node.value&&isNumber(node)&&losesPrecision(node)){context.report({messageId:"noLossOfPrecision",node});}}};}};const MAX_ARRAY_LENGTH=4294967295;function normalizeIgnoreValue(x){if(typeof x==="string"){return BigInt(x.slice(0,-1));}return x;}var noMagicNumbers={meta:{type:"suggestion",docs:{description:"disallow magic numbers",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-magic-numbers"},schema:[{type:"object",properties:{detectObjects:{type:"boolean",default:false},enforceConst:{type:"boolean",default:false},ignore:{type:"array",items:{anyOf:[{type:"number"},{type:"string",pattern:"^[+-]?(?:0|[1-9][0-9]*)n$"}]},uniqueItems:true},ignoreArrayIndexes:{type:"boolean",default:false},ignoreDefaultValues:{type:"boolean",default:false}},additionalProperties:false}],messages:{useConst:"Number constants declarations must use 'const'.",noMagic:"No magic number: {{raw}}."}},create(context){const config=context.options[0]||{},detectObjects=!!config.detectObjects,enforceConst=!!config.enforceConst,ignore=(config.ignore||[]).map(normalizeIgnoreValue),ignoreArrayIndexes=!!config.ignoreArrayIndexes,ignoreDefaultValues=!!config.ignoreDefaultValues;const okTypes=detectObjects?[]:["ObjectExpression","Property","AssignmentExpression"];function isIgnoredValue(value){return ignore.indexOf(value)!==-1;}function isDefaultValue(fullNumberNode){const parent=fullNumberNode.parent;return parent.type==="AssignmentPattern"&&parent.right===fullNumberNode;}function isParseIntRadix(fullNumberNode){const parent=fullNumberNode.parent;return parent.type==="CallExpression"&&fullNumberNode===parent.arguments[1]&&(astUtils.isSpecificId(parent.callee,"parseInt")||astUtils.isSpecificMemberAccess(parent.callee,"Number","parseInt"));}function isJSXNumber(fullNumberNode){return fullNumberNode.parent.type.indexOf("JSX")===0;}function isArrayIndex(fullNumberNode,value){const parent=fullNumberNode.parent;return parent.type==="MemberExpression"&&parent.property===fullNumberNode&&(Number.isInteger(value)||typeof value==="bigint")&&value>=0&&value<MAX_ARRAY_LENGTH;}return {Literal(node){if(!astUtils.isNumericLiteral(node)){return;}let fullNumberNode;let value;let raw;if(node.parent.type==="UnaryExpression"&&node.parent.operator==="-"){fullNumberNode=node.parent;value=-node.value;raw=`-${node.raw}`;}else {fullNumberNode=node;value=node.value;raw=node.raw;}const parent=fullNumberNode.parent;if(isIgnoredValue(value)||ignoreDefaultValues&&isDefaultValue(fullNumberNode)||isParseIntRadix(fullNumberNode)||isJSXNumber(fullNumberNode)||ignoreArrayIndexes&&isArrayIndex(fullNumberNode,value)){return;}if(parent.type==="VariableDeclarator"){if(enforceConst&&parent.parent.kind!=="const"){context.report({node:fullNumberNode,messageId:"useConst"});}}else if(okTypes.indexOf(parent.type)===-1||parent.type==="AssignmentExpression"&&parent.left.type==="Identifier"){context.report({node:fullNumberNode,messageId:"noMagic",data:{raw}});}}};}};var isCombiningCharacter$1=function(codePoint){return /^[\p{Mc}\p{Me}\p{Mn}]$/u.test(String.fromCodePoint(codePoint));};var isEmojiModifier$1=function(code){return code>=0x1F3FB&&code<=0x1F3FF;};var isRegionalIndicatorSymbol$1=function(code){return code>=0x1F1E6&&code<=0x1F1FF;};var isSurrogatePair$1=function(lead,tail){return lead>=0xD800&&lead<0xDC00&&tail>=0xDC00&&tail<0xE000;};var unicode={isCombiningCharacter:isCombiningCharacter$1,isEmojiModifier:isEmojiModifier$1,isRegionalIndicatorSymbol:isRegionalIndicatorSymbol$1,isSurrogatePair:isSurrogatePair$1};const{CALL:CALL$7,CONSTRUCT:CONSTRUCT$5,ReferenceTracker:ReferenceTracker$7,getStringIfConstant:getStringIfConstant$3}=eslintUtils__default['default'];const{RegExpParser:RegExpParser$1,visitRegExpAST:visitRegExpAST$1}=regexpp__default['default'];const{isCombiningCharacter,isEmojiModifier,isRegionalIndicatorSymbol,isSurrogatePair}=unicode;function*iterateCharacterSequence(nodes){let seq=[];for(const node of nodes){switch(node.type){case"Character":seq.push(node.value);break;case"CharacterClassRange":seq.push(node.min.value);yield seq;seq=[node.max.value];break;case"CharacterSet":if(seq.length>0){yield seq;seq=[];}break;}}if(seq.length>0){yield seq;}}const hasCharacterSequence={surrogatePairWithoutUFlag(chars){return chars.some((c,i)=>i!==0&&isSurrogatePair(chars[i-1],c));},combiningClass(chars){return chars.some((c,i)=>i!==0&&isCombiningCharacter(c)&&!isCombiningCharacter(chars[i-1]));},emojiModifier(chars){return chars.some((c,i)=>i!==0&&isEmojiModifier(c)&&!isEmojiModifier(chars[i-1]));},regionalIndicatorSymbol(chars){return chars.some((c,i)=>i!==0&&isRegionalIndicatorSymbol(c)&&isRegionalIndicatorSymbol(chars[i-1]));},zwj(chars){const lastIndex=chars.length-1;return chars.some((c,i)=>i!==0&&i!==lastIndex&&c===0x200d&&chars[i-1]!==0x200d&&chars[i+1]!==0x200d);}};const kinds=Object.keys(hasCharacterSequence);var noMisleadingCharacterClass={meta:{type:"problem",docs:{description:"disallow characters which are made with multiple code points in character class syntax",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-misleading-character-class"},schema:[],messages:{surrogatePairWithoutUFlag:"Unexpected surrogate pair in character class. Use 'u' flag.",combiningClass:"Unexpected combined character in character class.",emojiModifier:"Unexpected modified Emoji in character class.",regionalIndicatorSymbol:"Unexpected national flag in character class.",zwj:"Unexpected joined character sequence in character class."}},create(context){const parser=new RegExpParser$1();function verify(node,pattern,flags){const has={surrogatePairWithoutUFlag:false,combiningClass:false,variationSelector:false,emojiModifier:false,regionalIndicatorSymbol:false,zwj:false};let patternNode;try{patternNode=parser.parsePattern(pattern,0,pattern.length,flags.includes("u"));}catch{return;}visitRegExpAST$1(patternNode,{onCharacterClassEnter(ccNode){for(const chars of iterateCharacterSequence(ccNode.elements)){for(const kind of kinds){has[kind]=has[kind]||hasCharacterSequence[kind](chars);}}}});for(const kind of kinds){if(has[kind]){context.report({node,messageId:kind});}}}return {"Literal[regex]"(node){verify(node,node.regex.pattern,node.regex.flags);},"Program"(){const scope=context.getScope();const tracker=new ReferenceTracker$7(scope);for(const{node}of tracker.iterateGlobalReferences({RegExp:{[CALL$7]:true,[CONSTRUCT$5]:true}})){const[patternNode,flagsNode]=node.arguments;const pattern=getStringIfConstant$3(patternNode,scope);const flags=getStringIfConstant$3(flagsNode,scope);if(typeof pattern==="string"){verify(node,pattern,flags||"");}}}};}};const ARITHMETIC_OPERATORS=["+","-","*","/","%","**"];const BITWISE_OPERATORS=["&","|","^","~","<<",">>",">>>"];const COMPARISON_OPERATORS=["==","!=","===","!==",">",">=","<","<="];const LOGICAL_OPERATORS=["&&","||"];const RELATIONAL_OPERATORS=["in","instanceof"];const TERNARY_OPERATOR=["?:"];const COALESCE_OPERATOR=["??"];const ALL_OPERATORS=[].concat(ARITHMETIC_OPERATORS,BITWISE_OPERATORS,COMPARISON_OPERATORS,LOGICAL_OPERATORS,RELATIONAL_OPERATORS,TERNARY_OPERATOR,COALESCE_OPERATOR);const DEFAULT_GROUPS=[ARITHMETIC_OPERATORS,BITWISE_OPERATORS,COMPARISON_OPERATORS,LOGICAL_OPERATORS,RELATIONAL_OPERATORS];const TARGET_NODE_TYPE=/^(?:Binary|Logical|Conditional)Expression$/u;function normalizeOptions$1(options={}){const hasGroups=options.groups&&options.groups.length>0;const groups=hasGroups?options.groups:DEFAULT_GROUPS;const allowSamePrecedence=options.allowSamePrecedence!==false;return {groups,allowSamePrecedence};}function includesBothInAGroup(groups,left,right){return groups.some(group=>group.indexOf(left)!==-1&&group.indexOf(right)!==-1);}function getChildNode(node){return node.type==="ConditionalExpression"?node.test:node.left;}var noMixedOperators={meta:{type:"suggestion",docs:{description:"disallow mixed binary operators",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-mixed-operators"},schema:[{type:"object",properties:{groups:{type:"array",items:{type:"array",items:{enum:ALL_OPERATORS},minItems:2,uniqueItems:true},uniqueItems:true},allowSamePrecedence:{type:"boolean",default:true}},additionalProperties:false}],messages:{unexpectedMixedOperator:"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'."}},create(context){const sourceCode=context.getSourceCode();const options=normalizeOptions$1(context.options[0]);function shouldIgnore(node){const a=node;const b=node.parent;return !includesBothInAGroup(options.groups,a.operator,b.type==="ConditionalExpression"?"?:":b.operator)||options.allowSamePrecedence&&astUtils.getPrecedence(a)===astUtils.getPrecedence(b);}function isMixedWithParent(node){return node.operator!==node.parent.operator&&!astUtils.isParenthesised(sourceCode,node);}function getOperatorToken(node){return sourceCode.getTokenAfter(getChildNode(node),astUtils.isNotClosingParenToken);}function reportBothOperators(node){const parent=node.parent;const left=getChildNode(parent)===node?node:parent;const right=getChildNode(parent)!==node?node:parent;const data={leftOperator:left.operator||"?:",rightOperator:right.operator||"?:"};context.report({node:left,loc:getOperatorToken(left).loc,messageId:"unexpectedMixedOperator",data});context.report({node:right,loc:getOperatorToken(right).loc,messageId:"unexpectedMixedOperator",data});}function check(node){if(TARGET_NODE_TYPE.test(node.parent.type)&&isMixedWithParent(node)&&!shouldIgnore(node)){reportBothOperators(node);}}return {BinaryExpression:check,LogicalExpression:check};}};var noMixedRequires={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"disallow `require` calls to be mixed with regular variable declarations",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/no-mixed-requires"},schema:[{oneOf:[{type:"boolean"},{type:"object",properties:{grouping:{type:"boolean"},allowCall:{type:"boolean"}},additionalProperties:false}]}],messages:{noMixRequire:"Do not mix 'require' and other declarations.",noMixCoreModuleFileComputed:"Do not mix core, module, file and computed requires."}},create(context){const options=context.options[0];let grouping=false,allowCall=false;if(typeof options==="object"){grouping=options.grouping;allowCall=options.allowCall;}else {grouping=!!options;}const BUILTIN_MODULES=function(){return ["assert","buffer","child_process","cluster","crypto","dgram","dns","domain","events","fs","http","https","net","os","path","punycode","querystring","readline","repl","smalloc","stream","string_decoder","tls","tty","url","util","v8","vm","zlib"];}();const DECL_REQUIRE="require",DECL_UNINITIALIZED="uninitialized",DECL_OTHER="other";const REQ_COMPUTED="computed";function getDeclarationType(initExpression){if(!initExpression){return DECL_UNINITIALIZED;}if(initExpression.type==="CallExpression"&&initExpression.callee.type==="Identifier"&&initExpression.callee.name==="require"){return DECL_REQUIRE;}if(allowCall&&initExpression.type==="CallExpression"&&initExpression.callee.type==="CallExpression"){return getDeclarationType(initExpression.callee);}if(initExpression.type==="MemberExpression"){return getDeclarationType(initExpression.object);}return DECL_OTHER;}function inferModuleType(initExpression){if(initExpression.type==="MemberExpression"){return inferModuleType(initExpression.object);}if(initExpression.arguments.length===0){return REQ_COMPUTED;}const arg=initExpression.arguments[0];if(arg.type!=="Literal"||typeof arg.value!=="string"){return REQ_COMPUTED;}if(BUILTIN_MODULES.indexOf(arg.value)!==-1){return "core";}if(/^\.{0,2}\//u.test(arg.value)){return "file";}return "module";}function isMixed(declarations){const contains={};declarations.forEach(declaration=>{const type=getDeclarationType(declaration.init);contains[type]=true;});return !!(contains[DECL_REQUIRE]&&(contains[DECL_UNINITIALIZED]||contains[DECL_OTHER]));}function isGrouped(declarations){const found={};declarations.forEach(declaration=>{if(getDeclarationType(declaration.init)===DECL_REQUIRE){found[inferModuleType(declaration.init)]=true;}});return Object.keys(found).length<=1;}return {VariableDeclaration(node){if(isMixed(node.declarations)){context.report({node,messageId:"noMixRequire"});}else if(grouping&&!isGrouped(node.declarations)){context.report({node,messageId:"noMixCoreModuleFileComputed"});}}};}};var noMixedSpacesAndTabs={meta:{type:"layout",docs:{description:"disallow mixed spaces and tabs for indentation",category:"Stylistic Issues",recommended:true,url:"https://eslint.org/docs/rules/no-mixed-spaces-and-tabs"},schema:[{enum:["smart-tabs",true,false]}],messages:{mixedSpacesAndTabs:"Mixed spaces and tabs."}},create(context){const sourceCode=context.getSourceCode();let smartTabs;switch(context.options[0]){case true:case"smart-tabs":smartTabs=true;break;default:smartTabs=false;}return {"Program:exit"(node){const lines=sourceCode.lines,comments=sourceCode.getAllComments(),ignoredCommentLines=new Set();comments.forEach(comment=>{for(let i=comment.loc.start.line+1;i<=comment.loc.end.line;i++){ignoredCommentLines.add(i);}});let regex=/^(?=( +|\t+))\1(?:\t| )/u;if(smartTabs){regex=/^(?=(\t*))\1(?=( +))\2\t/u;}lines.forEach((line,i)=>{const match=regex.exec(line);if(match){const lineNumber=i+1;const loc={start:{line:lineNumber,column:match[0].length-2},end:{line:lineNumber,column:match[0].length}};if(!ignoredCommentLines.has(lineNumber)){const containingNode=sourceCode.getNodeByRangeIndex(sourceCode.getIndexFromLoc(loc.start));if(!(containingNode&&["Literal","TemplateElement"].includes(containingNode.type))){context.report({node,loc,messageId:"mixedSpacesAndTabs"});}}}});}};}};var noMultiAssign={meta:{type:"suggestion",docs:{description:"disallow use of chained assignment expressions",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-multi-assign"},schema:[{type:"object",properties:{ignoreNonDeclaration:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpectedChain:"Unexpected chained assignment."}},create(context){const options=context.options[0]||{ignoreNonDeclaration:false};const targetParent=options.ignoreNonDeclaration?["VariableDeclarator"]:["AssignmentExpression","VariableDeclarator"];return {AssignmentExpression(node){if(targetParent.indexOf(node.parent.type)!==-1){context.report({node,messageId:"unexpectedChain"});}}};}};var noMultiSpaces={meta:{type:"layout",docs:{description:"disallow multiple spaces",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-multi-spaces"},fixable:"whitespace",schema:[{type:"object",properties:{exceptions:{type:"object",patternProperties:{"^([A-Z][a-z]*)+$":{type:"boolean"}},additionalProperties:false},ignoreEOLComments:{type:"boolean",default:false}},additionalProperties:false}],messages:{multipleSpaces:"Multiple spaces found before '{{displayValue}}'."}},create(context){const sourceCode=context.getSourceCode();const options=context.options[0]||{};const ignoreEOLComments=options.ignoreEOLComments;const exceptions=Object.assign({Property:true},options.exceptions);const hasExceptions=Object.keys(exceptions).filter(key=>exceptions[key]).length>0;function formatReportedCommentValue(token){const valueLines=token.value.split("\n");const value=valueLines[0];const formattedValue=`${value.slice(0,12)}...`;return valueLines.length===1&&value.length<=12?value:formattedValue;}return {Program(){sourceCode.tokensAndComments.forEach((leftToken,leftIndex,tokensAndComments)=>{if(leftIndex===tokensAndComments.length-1){return;}const rightToken=tokensAndComments[leftIndex+1];if(!sourceCode.text.slice(leftToken.range[1],rightToken.range[0]).includes("  ")||leftToken.loc.end.line<rightToken.loc.start.line){return;}if(ignoreEOLComments&&astUtils.isCommentToken(rightToken)&&(leftIndex===tokensAndComments.length-2||rightToken.loc.end.line<tokensAndComments[leftIndex+2].loc.start.line)){return;}if(hasExceptions){const parentNode=sourceCode.getNodeByRangeIndex(rightToken.range[0]-1);if(parentNode&&exceptions[parentNode.type]){return;}}let displayValue;if(rightToken.type==="Block"){displayValue=`/*${formatReportedCommentValue(rightToken)}*/`;}else if(rightToken.type==="Line"){displayValue=`//${formatReportedCommentValue(rightToken)}`;}else {displayValue=rightToken.value;}context.report({node:rightToken,loc:{start:leftToken.loc.end,end:rightToken.loc.start},messageId:"multipleSpaces",data:{displayValue},fix:fixer=>fixer.replaceTextRange([leftToken.range[1],rightToken.range[0]]," ")});});}};}};var noMultiStr={meta:{type:"suggestion",docs:{description:"disallow multiline strings",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-multi-str"},schema:[],messages:{multilineString:"Multiline support is limited to browsers supporting ES5 only."}},create(context){function isJSXElement(node){return node.type.indexOf("JSX")===0;}return {Literal(node){if(astUtils.LINEBREAK_MATCHER.test(node.raw)&&!isJSXElement(node.parent)){context.report({node,messageId:"multilineString"});}}};}};var noMultipleEmptyLines={meta:{type:"layout",docs:{description:"disallow multiple empty lines",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-multiple-empty-lines"},fixable:"whitespace",schema:[{type:"object",properties:{max:{type:"integer",minimum:0},maxEOF:{type:"integer",minimum:0},maxBOF:{type:"integer",minimum:0}},required:["max"],additionalProperties:false}],messages:{blankBeginningOfFile:"Too many blank lines at the beginning of file. Max of {{max}} allowed.",blankEndOfFile:"Too many blank lines at the end of file. Max of {{max}} allowed.",consecutiveBlank:"More than {{max}} blank {{pluralizedLines}} not allowed."}},create(context){let max=2,maxEOF=max,maxBOF=max;if(context.options.length){max=context.options[0].max;maxEOF=typeof context.options[0].maxEOF!=="undefined"?context.options[0].maxEOF:max;maxBOF=typeof context.options[0].maxBOF!=="undefined"?context.options[0].maxBOF:max;}const sourceCode=context.getSourceCode();const allLines=sourceCode.lines[sourceCode.lines.length-1]===""?sourceCode.lines.slice(0,-1):sourceCode.lines;const templateLiteralLines=new Set();return {TemplateLiteral(node){node.quasis.forEach(literalPart=>{for(let ignoredLine=literalPart.loc.start.line;ignoredLine<literalPart.loc.end.line;ignoredLine++){templateLiteralLines.add(ignoredLine);}});},"Program:exit"(node){return allLines.reduce((nonEmptyLineNumbers,line,index)=>{if(line.trim()||templateLiteralLines.has(index+1)){nonEmptyLineNumbers.push(index+1);}return nonEmptyLineNumbers;},[]).concat(allLines.length+1).reduce((lastLineNumber,lineNumber)=>{let messageId,maxAllowed;if(lastLineNumber===0){messageId="blankBeginningOfFile";maxAllowed=maxBOF;}else if(lineNumber===allLines.length+1){messageId="blankEndOfFile";maxAllowed=maxEOF;}else {messageId="consecutiveBlank";maxAllowed=max;}if(lineNumber-lastLineNumber-1>maxAllowed){context.report({node,loc:{start:{line:lastLineNumber+maxAllowed+1,column:0},end:{line:lineNumber,column:0}},messageId,data:{max:maxAllowed,pluralizedLines:maxAllowed===1?"line":"lines"},fix(fixer){const rangeStart=sourceCode.getIndexFromLoc({line:lastLineNumber+1,column:0});const lineNumberAfterRemovedLines=lineNumber-maxAllowed;const rangeEnd=lineNumberAfterRemovedLines<=allLines.length?sourceCode.getIndexFromLoc({line:lineNumberAfterRemovedLines,column:0}):sourceCode.text.length;return fixer.removeRange([rangeStart,rangeEnd]);}});}return lineNumber;},0);}};}};var noNativeReassign={meta:{type:"suggestion",docs:{description:"disallow assignments to native objects or read-only global variables",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-native-reassign"},deprecated:true,replacedBy:["no-global-assign"],schema:[{type:"object",properties:{exceptions:{type:"array",items:{type:"string"},uniqueItems:true}},additionalProperties:false}],messages:{nativeReassign:"Read-only global '{{name}}' should not be modified."}},create(context){const config=context.options[0];const exceptions=config&&config.exceptions||[];function checkReference(reference,index,references){const identifier=reference.identifier;if(reference.init===false&&reference.isWrite()&&(index===0||references[index-1].identifier!==identifier)){context.report({node:identifier,messageId:"nativeReassign",data:identifier});}}function checkVariable(variable){if(variable.writeable===false&&exceptions.indexOf(variable.name)===-1){variable.references.forEach(checkReference);}}return {Program(){const globalScope=context.getScope();globalScope.variables.forEach(checkVariable);}};}};var noNegatedCondition={meta:{type:"suggestion",docs:{description:"disallow negated conditions",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-negated-condition"},schema:[],messages:{unexpectedNegated:"Unexpected negated condition."}},create(context){function hasElseWithoutCondition(node){return node.alternate&&node.alternate.type!=="IfStatement";}function isNegatedUnaryExpression(test){return test.type==="UnaryExpression"&&test.operator==="!";}function isNegatedBinaryExpression(test){return test.type==="BinaryExpression"&&(test.operator==="!="||test.operator==="!==");}function isNegatedIf(node){return isNegatedUnaryExpression(node.test)||isNegatedBinaryExpression(node.test);}return {IfStatement(node){if(!hasElseWithoutCondition(node)){return;}if(isNegatedIf(node)){context.report({node,messageId:"unexpectedNegated"});}},ConditionalExpression(node){if(isNegatedIf(node)){context.report({node,messageId:"unexpectedNegated"});}}};}};var noNegatedInLhs={meta:{type:"problem",docs:{description:"disallow negating the left operand in `in` expressions",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-negated-in-lhs"},replacedBy:["no-unsafe-negation"],deprecated:true,schema:[],messages:{negatedLHS:"The 'in' expression's left operand is negated."}},create(context){return {BinaryExpression(node){if(node.operator==="in"&&node.left.type==="UnaryExpression"&&node.left.operator==="!"){context.report({node,messageId:"negatedLHS"});}}};}};var noNestedTernary={meta:{type:"suggestion",docs:{description:"disallow nested ternary expressions",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-nested-ternary"},schema:[],messages:{noNestedTernary:"Do not nest ternary expressions."}},create(context){return {ConditionalExpression(node){if(node.alternate.type==="ConditionalExpression"||node.consequent.type==="ConditionalExpression"){context.report({node,messageId:"noNestedTernary"});}}};}};var noNewFunc={meta:{type:"suggestion",docs:{description:"disallow `new` operators with the `Function` object",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-new-func"},schema:[],messages:{noFunctionConstructor:"The Function constructor is eval."}},create(context){return {"Program:exit"(){const globalScope=context.getScope();const variable=globalScope.set.get("Function");if(variable&&variable.defs.length===0){variable.references.forEach(ref=>{const node=ref.identifier;const{parent}=node;if(parent&&(parent.type==="NewExpression"||parent.type==="CallExpression")&&node===parent.callee){context.report({node:parent,messageId:"noFunctionConstructor"});}});}}};}};var noNewObject={meta:{type:"suggestion",docs:{description:"disallow `Object` constructors",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-new-object"},schema:[],messages:{preferLiteral:"The object literal notation {} is preferrable."}},create(context){return {NewExpression(node){const variable=astUtils.getVariableByName(context.getScope(),node.callee.name);if(variable&&variable.identifiers.length>0){return;}if(node.callee.name==="Object"){context.report({node,messageId:"preferLiteral"});}}};}};var noNewRequire={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"disallow `new` operators with calls to `require`",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/no-new-require"},schema:[],messages:{noNewRequire:"Unexpected use of new with require."}},create(context){return {NewExpression(node){if(node.callee.type==="Identifier"&&node.callee.name==="require"){context.report({node,messageId:"noNewRequire"});}}};}};var noNewSymbol={meta:{type:"problem",docs:{description:"disallow `new` operators with the `Symbol` object",category:"ECMAScript 6",recommended:true,url:"https://eslint.org/docs/rules/no-new-symbol"},schema:[],messages:{noNewSymbol:"`Symbol` cannot be called as a constructor."}},create(context){return {"Program:exit"(){const globalScope=context.getScope();const variable=globalScope.set.get("Symbol");if(variable&&variable.defs.length===0){variable.references.forEach(ref=>{const node=ref.identifier;const parent=node.parent;if(parent&&parent.type==="NewExpression"&&parent.callee===node){context.report({node,messageId:"noNewSymbol"});}});}}};}};var noNewWrappers={meta:{type:"suggestion",docs:{description:"disallow `new` operators with the `String`, `Number`, and `Boolean` objects",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-new-wrappers"},schema:[],messages:{noConstructor:"Do not use {{fn}} as a constructor."}},create(context){return {NewExpression(node){if(["String","Number","Boolean"].indexOf(node.callee.name)>-1){context.report({node,messageId:"noConstructor",data:{fn:node.callee.name}});}}};}};var noNew={meta:{type:"suggestion",docs:{description:"disallow `new` operators outside of assignments or comparisons",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-new"},schema:[],messages:{noNewStatement:"Do not use 'new' for side effects."}},create(context){return {"ExpressionStatement > NewExpression"(node){context.report({node:node.parent,messageId:"noNewStatement"});}};}};const QUICK_TEST_REGEX=/\\[89]/u;function getUnicodeEscape(character){return `\\u${character.charCodeAt(0).toString(16).padStart(4,"0")}`;}var noNonoctalDecimalEscape={meta:{type:"suggestion",docs:{description:"disallow `\\8` and `\\9` escape sequences in string literals",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-nonoctal-decimal-escape",suggestion:true},schema:[],messages:{decimalEscape:"Don't use '{{decimalEscape}}' escape sequence.",refactor:"Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.",escapeBackslash:"Replace '{{original}}' with '{{replacement}}' to include the actual backslash character."}},create(context){const sourceCode=context.getSourceCode();function createSuggestion(messageId,range,replacement){return {messageId,data:{original:sourceCode.getText().slice(...range),replacement},fix(fixer){return fixer.replaceTextRange(range,replacement);}};}return {Literal(node){if(typeof node.value!=="string"){return;}if(!QUICK_TEST_REGEX.test(node.raw)){return;}let match;while(match=/(?:[^\\]|(?<previousEscape>\\.))*?(?<decimalEscape>\\[89])/suy.exec(node.raw)){const{previousEscape,decimalEscape}=match.groups;const decimalEscapeRangeEnd=node.range[0]+match.index+match[0].length;const decimalEscapeRangeStart=decimalEscapeRangeEnd-decimalEscape.length;const decimalEscapeRange=[decimalEscapeRangeStart,decimalEscapeRangeEnd];const suggest=[];if(previousEscape==="\\0"){suggest.push(createSuggestion("refactor",[decimalEscapeRangeStart-previousEscape.length,decimalEscapeRangeEnd],`${getUnicodeEscape("\0")}${decimalEscape[1]}`),createSuggestion("refactor",decimalEscapeRange,getUnicodeEscape(decimalEscape[1])));}else {suggest.push(createSuggestion("refactor",decimalEscapeRange,decimalEscape[1]));}suggest.push(createSuggestion("escapeBackslash",decimalEscapeRange,`\\${decimalEscape}`));context.report({node,loc:{start:sourceCode.getLocFromIndex(decimalEscapeRangeStart),end:sourceCode.getLocFromIndex(decimalEscapeRangeEnd)},messageId:"decimalEscape",data:{decimalEscape},suggest});}}};}};const{CALL:CALL$6,CONSTRUCT:CONSTRUCT$4,ReferenceTracker:ReferenceTracker$6}=eslintUtils__default['default'];const getPropertyName$1=astUtils.getStaticPropertyName;const nonCallableGlobals=["Atomics","JSON","Math","Reflect"];function getReportNodeName(node){if(node.type==="ChainExpression"){return getReportNodeName(node.expression);}if(node.type==="MemberExpression"){return getPropertyName$1(node);}return node.name;}var noObjCalls={meta:{type:"problem",docs:{description:"disallow calling global object properties as functions",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-obj-calls"},schema:[],messages:{unexpectedCall:"'{{name}}' is not a function.",unexpectedRefCall:"'{{name}}' is reference to '{{ref}}', which is not a function."}},create(context){return {Program(){const scope=context.getScope();const tracker=new ReferenceTracker$6(scope);const traceMap={};for(const g of nonCallableGlobals){traceMap[g]={[CALL$6]:true,[CONSTRUCT$4]:true};}for(const{node,path}of tracker.iterateGlobalReferences(traceMap)){const name=getReportNodeName(node.callee);const ref=path[0];const messageId=name===ref?"unexpectedCall":"unexpectedRefCall";context.report({node,messageId,data:{name,ref}});}}};}};var noOctalEscape={meta:{type:"suggestion",docs:{description:"disallow octal escape sequences in string literals",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-octal-escape"},schema:[],messages:{octalEscapeSequence:"Don't use octal: '\\{{sequence}}'. Use '\\u....' instead."}},create(context){return {Literal(node){if(typeof node.value!=="string"){return;}const match=node.raw.match(/^(?:[^\\]|\\.)*?\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su);if(match){context.report({node,messageId:"octalEscapeSequence",data:{sequence:match[1]}});}}};}};var noOctal={meta:{type:"suggestion",docs:{description:"disallow octal literals",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-octal"},schema:[],messages:{noOcatal:"Octal literals should not be used."}},create(context){return {Literal(node){if(typeof node.value==="number"&&/^0[0-9]/u.test(node.raw)){context.report({node,messageId:"noOcatal"});}}};}};const stopNodePattern=/(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;var noParamReassign={meta:{type:"suggestion",docs:{description:"disallow reassigning `function` parameters",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-param-reassign"},schema:[{oneOf:[{type:"object",properties:{props:{enum:[false]}},additionalProperties:false},{type:"object",properties:{props:{enum:[true]},ignorePropertyModificationsFor:{type:"array",items:{type:"string"},uniqueItems:true},ignorePropertyModificationsForRegex:{type:"array",items:{type:"string"},uniqueItems:true}},additionalProperties:false}]}],messages:{assignmentToFunctionParam:"Assignment to function parameter '{{name}}'.",assignmentToFunctionParamProp:"Assignment to property of function parameter '{{name}}'."}},create(context){const props=context.options[0]&&context.options[0].props;const ignoredPropertyAssignmentsFor=context.options[0]&&context.options[0].ignorePropertyModificationsFor||[];const ignoredPropertyAssignmentsForRegex=context.options[0]&&context.options[0].ignorePropertyModificationsForRegex||[];function isModifyingProp(reference){let node=reference.identifier;let parent=node.parent;while(parent&&(!stopNodePattern.test(parent.type)||parent.type==="ForInStatement"||parent.type==="ForOfStatement")){switch(parent.type){case"AssignmentExpression":return parent.left===node;case"UpdateExpression":return true;case"UnaryExpression":if(parent.operator==="delete"){return true;}break;case"ForInStatement":case"ForOfStatement":if(parent.left===node){return true;}return false;case"CallExpression":if(parent.callee!==node){return false;}break;case"MemberExpression":if(parent.property===node){return false;}break;case"Property":if(parent.key===node){return false;}break;case"ConditionalExpression":if(parent.test===node){return false;}break;}node=parent;parent=node.parent;}return false;}function isIgnoredPropertyAssignment(identifierName){return ignoredPropertyAssignmentsFor.includes(identifierName)||ignoredPropertyAssignmentsForRegex.some(ignored=>new RegExp(ignored,"u").test(identifierName));}function checkReference(reference,index,references){const identifier=reference.identifier;if(identifier&&!reference.init&&(index===0||references[index-1].identifier!==identifier)){if(reference.isWrite()){context.report({node:identifier,messageId:"assignmentToFunctionParam",data:{name:identifier.name}});}else if(props&&isModifyingProp(reference)&&!isIgnoredPropertyAssignment(identifier.name)){context.report({node:identifier,messageId:"assignmentToFunctionParamProp",data:{name:identifier.name}});}}}function checkVariable(variable){if(variable.defs[0].type==="Parameter"){variable.references.forEach(checkReference);}}function checkForFunction(node){context.getDeclaredVariables(node).forEach(checkVariable);}return {"FunctionDeclaration:exit":checkForFunction,"FunctionExpression:exit":checkForFunction,"ArrowFunctionExpression:exit":checkForFunction};}};var noPathConcat={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"disallow string concatenation with `__dirname` and `__filename`",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/no-path-concat"},schema:[],messages:{usePathFunctions:"Use path.join() or path.resolve() instead of + to create paths."}},create(context){const MATCHER=/^__(?:dir|file)name$/u;return {BinaryExpression(node){const left=node.left,right=node.right;if(node.operator==="+"&&(left.type==="Identifier"&&MATCHER.test(left.name)||right.type==="Identifier"&&MATCHER.test(right.name))){context.report({node,messageId:"usePathFunctions"});}}};}};function isForStatementUpdate(node){const parent=node.parent;return parent.type==="ForStatement"&&parent.update===node;}function isForLoopAfterthought(node){const parent=node.parent;if(parent.type==="SequenceExpression"){return isForLoopAfterthought(parent);}return isForStatementUpdate(node);}var noPlusplus={meta:{type:"suggestion",docs:{description:"disallow the unary operators `++` and `--`",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-plusplus"},schema:[{type:"object",properties:{allowForLoopAfterthoughts:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpectedUnaryOp:"Unary operator '{{operator}}' used."}},create(context){const config=context.options[0];let allowForLoopAfterthoughts=false;if(typeof config==="object"){allowForLoopAfterthoughts=config.allowForLoopAfterthoughts===true;}return {UpdateExpression(node){if(allowForLoopAfterthoughts&&isForLoopAfterthought(node)){return;}context.report({node,messageId:"unexpectedUnaryOp",data:{operator:node.operator}});}};}};var noProcessEnv={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"disallow the use of `process.env`",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/no-process-env"},schema:[],messages:{unexpectedProcessEnv:"Unexpected use of process.env."}},create(context){return {MemberExpression(node){const objectName=node.object.name,propertyName=node.property.name;if(objectName==="process"&&!node.computed&&propertyName&&propertyName==="env"){context.report({node,messageId:"unexpectedProcessEnv"});}}};}};var noProcessExit={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"disallow the use of `process.exit()`",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/no-process-exit"},schema:[],messages:{noProcessExit:"Don't use process.exit(); throw an error instead."}},create(context){return {"CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(node){context.report({node:node.parent,messageId:"noProcessExit"});}};}};const{findVariable:findVariable$2}=eslintUtils__default['default'];const functionTypesToCheck=new Set(["ArrowFunctionExpression","FunctionExpression"]);function isGlobalReference$1(node,scope){const variable=findVariable$2(scope,node);return variable!==null&&variable.scope.type==="global"&&variable.defs.length===0;}function getOuterScope$1(scope){const upper=scope.upper;if(upper.type==="function-expression-name"){return upper.upper;}return upper;}function isPromiseExecutor(node,scope){const parent=node.parent;return parent.type==="NewExpression"&&parent.arguments[0]===node&&parent.callee.type==="Identifier"&&parent.callee.name==="Promise"&&isGlobalReference$1(parent.callee,getOuterScope$1(scope));}var noPromiseExecutorReturn={meta:{type:"problem",docs:{description:"disallow returning values from Promise executor functions",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-promise-executor-return"},schema:[],messages:{returnsValue:"Return values from promise executor functions cannot be read."}},create(context){let funcInfo=null;function report(node){context.report({node,messageId:"returnsValue"});}return {onCodePathStart(_,node){funcInfo={upper:funcInfo,shouldCheck:functionTypesToCheck.has(node.type)&&isPromiseExecutor(node,context.getScope())};if(funcInfo.shouldCheck&&node.type==="ArrowFunctionExpression"&&node.expression){report(node.body);}},onCodePathEnd(){funcInfo=funcInfo.upper;},ReturnStatement(node){if(funcInfo.shouldCheck&&node.argument){report(node);}}};}};const{getStaticPropertyName}=astUtils;var noProto={meta:{type:"suggestion",docs:{description:"disallow the use of the `__proto__` property",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-proto"},schema:[],messages:{unexpectedProto:"The '__proto__' property is deprecated."}},create(context){return {MemberExpression(node){if(getStaticPropertyName(node)==="__proto__"){context.report({node,messageId:"unexpectedProto"});}}};}};var noPrototypeBuiltins={meta:{type:"problem",docs:{description:"disallow calling some `Object.prototype` methods directly on objects",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-prototype-builtins"},schema:[],messages:{prototypeBuildIn:"Do not access Object.prototype method '{{prop}}' from target object."}},create(context){const DISALLOWED_PROPS=["hasOwnProperty","isPrototypeOf","propertyIsEnumerable"];return {CallExpression:function(node){const callee=astUtils.skipChainExpression(node.callee);if(callee.type!=="MemberExpression"){return;}const propName=astUtils.getStaticPropertyName(callee);if(propName!==null&&DISALLOWED_PROPS.indexOf(propName)>-1){context.report({messageId:"prototypeBuildIn",loc:callee.property.loc,data:{prop:propName},node});}}};}};var noRedeclare={meta:{type:"suggestion",docs:{description:"disallow variable redeclaration",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-redeclare"},messages:{redeclared:"'{{id}}' is already defined.",redeclaredAsBuiltin:"'{{id}}' is already defined as a built-in global variable.",redeclaredBySyntax:"'{{id}}' is already defined by a variable declaration."},schema:[{type:"object",properties:{builtinGlobals:{type:"boolean",default:true}},additionalProperties:false}]},create(context){const options={builtinGlobals:Boolean(context.options.length===0||context.options[0].builtinGlobals)};const sourceCode=context.getSourceCode();function*iterateDeclarations(variable){if(options.builtinGlobals&&(variable.eslintImplicitGlobalSetting==="readonly"||variable.eslintImplicitGlobalSetting==="writable")){yield {type:"builtin"};}for(const id of variable.identifiers){yield {type:"syntax",node:id,loc:id.loc};}if(variable.eslintExplicitGlobalComments){for(const comment of variable.eslintExplicitGlobalComments){yield {type:"comment",node:comment,loc:astUtils.getNameLocationInGlobalDirectiveComment(sourceCode,comment,variable.name)};}}}function findVariablesInScope(scope){for(const variable of scope.variables){const[declaration,...extraDeclarations]=iterateDeclarations(variable);if(extraDeclarations.length===0){continue;}const detailMessageId=declaration.type==="builtin"?"redeclaredAsBuiltin":"redeclaredBySyntax";const data={id:variable.name};for(const{type,node,loc}of extraDeclarations){const messageId=type===declaration.type?"redeclared":detailMessageId;context.report({node,loc,messageId,data});}}}function checkForBlock(node){const scope=context.getScope();if(scope.block===node){findVariablesInScope(scope);}}return {Program(){const scope=context.getScope();findVariablesInScope(scope);if(scope.type==="global"&&scope.childScopes[0]&&scope.block===scope.childScopes[0].block){findVariablesInScope(scope.childScopes[0]);}},FunctionDeclaration:checkForBlock,FunctionExpression:checkForBlock,ArrowFunctionExpression:checkForBlock,BlockStatement:checkForBlock,ForStatement:checkForBlock,ForInStatement:checkForBlock,ForOfStatement:checkForBlock,SwitchStatement:checkForBlock};}};const regExpParser=new regexpp__default['default'].RegExpParser();const DOUBLE_SPACE=/ {2}/u;function isString(node){return node&&node.type==="Literal"&&typeof node.value==="string";}var noRegexSpaces={meta:{type:"suggestion",docs:{description:"disallow multiple spaces in regular expressions",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-regex-spaces"},schema:[],fixable:"code",messages:{multipleSpaces:"Spaces are hard to count. Use {{{length}}}."}},create(context){function checkRegex(nodeToReport,pattern,rawPattern,rawPatternStartRange,flags){if(!DOUBLE_SPACE.test(rawPattern)){return;}const characterClassNodes=[];let regExpAST;try{regExpAST=regExpParser.parsePattern(pattern,0,pattern.length,flags.includes("u"));}catch{return;}regexpp__default['default'].visitRegExpAST(regExpAST,{onCharacterClassEnter(ccNode){characterClassNodes.push(ccNode);}});let match;while(match=/( {2,})(?: [+*{?]|[^+*{?]|$)/gu.exec(pattern)){const{1:{length},index}=match;if(characterClassNodes.every(({start,end})=>index<start||end<=index)){context.report({node:nodeToReport,messageId:"multipleSpaces",data:{length},fix(fixer){if(pattern!==rawPattern){return null;}return fixer.replaceTextRange([rawPatternStartRange+index,rawPatternStartRange+index+length],` {${length}}`);}});return;}}}function checkFunction(node){const scope=context.getScope();const regExpVar=astUtils.getVariableByName(scope,"RegExp");const shadowed=regExpVar&&regExpVar.defs.length>0;const patternNode=node.arguments[0];const flagsNode=node.arguments[1];if(node.callee.type==="Identifier"&&node.callee.name==="RegExp"&&isString(patternNode)&&!shadowed){const pattern=patternNode.value;const rawPattern=patternNode.raw.slice(1,-1);const rawPatternStartRange=patternNode.range[0]+1;const flags=isString(flagsNode)?flagsNode.value:"";checkRegex(node,pattern,rawPattern,rawPatternStartRange,flags);}}return {Literal:function(node){if(node.regex){const pattern=node.regex.pattern;const rawPattern=node.raw.slice(1,node.raw.lastIndexOf("/"));const rawPatternStartRange=node.range[0]+1;const flags=node.regex.flags;checkRegex(node,pattern,rawPattern,rawPatternStartRange,flags);}},CallExpression:checkFunction,NewExpression:checkFunction};}};var noRestrictedExports={meta:{type:"suggestion",docs:{description:"disallow specified names in exports",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/no-restricted-exports"},schema:[{type:"object",properties:{restrictedNamedExports:{type:"array",items:{type:"string"},uniqueItems:true}},additionalProperties:false}],messages:{restrictedNamed:"'{{name}}' is restricted from being used as an exported name."}},create(context){const restrictedNames=new Set(context.options[0]&&context.options[0].restrictedNamedExports);function checkExportedName(node){const name=node.name;if(restrictedNames.has(name)){context.report({node,messageId:"restrictedNamed",data:{name}});}}return {ExportAllDeclaration(node){if(node.exported){checkExportedName(node.exported);}},ExportNamedDeclaration(node){const declaration=node.declaration;if(declaration){if(declaration.type==="FunctionDeclaration"||declaration.type==="ClassDeclaration"){checkExportedName(declaration.id);}else if(declaration.type==="VariableDeclaration"){context.getDeclaredVariables(declaration).map(v=>v.defs.find(d=>d.parent===declaration)).map(d=>d.name).forEach(checkExportedName);}}else {node.specifiers.map(s=>s.exported).forEach(checkExportedName);}}};}};var noRestrictedGlobals={meta:{type:"suggestion",docs:{description:"disallow specified global variables",category:"Variables",recommended:false,url:"https://eslint.org/docs/rules/no-restricted-globals"},schema:{type:"array",items:{oneOf:[{type:"string"},{type:"object",properties:{name:{type:"string"},message:{type:"string"}},required:["name"],additionalProperties:false}]},uniqueItems:true,minItems:0},messages:{defaultMessage:"Unexpected use of '{{name}}'.",customMessage:"Unexpected use of '{{name}}'. {{customMessage}}"}},create(context){if(context.options.length===0){return {};}const restrictedGlobalMessages=context.options.reduce((memo,option)=>{if(typeof option==="string"){memo[option]=null;}else {memo[option.name]=option.message;}return memo;},{});function reportReference(reference){const name=reference.identifier.name,customMessage=restrictedGlobalMessages[name],messageId=customMessage?"customMessage":"defaultMessage";context.report({node:reference.identifier,messageId,data:{name,customMessage}});}function isRestricted(name){return Object.prototype.hasOwnProperty.call(restrictedGlobalMessages,name);}return {Program(){const scope=context.getScope();scope.variables.forEach(variable=>{if(!variable.defs.length&&isRestricted(variable.name)){variable.references.forEach(reportReference);}});scope.through.forEach(reference=>{if(isRestricted(reference.identifier.name)){reportReference(reference);}});}};}};const arrayOfStrings$1={type:"array",items:{type:"string"},uniqueItems:true};const arrayOfStringsOrObjects$1={type:"array",items:{anyOf:[{type:"string"},{type:"object",properties:{name:{type:"string"},message:{type:"string",minLength:1},importNames:{type:"array",items:{type:"string"}}},additionalProperties:false,required:["name"]}]},uniqueItems:true};var noRestrictedImports={meta:{type:"suggestion",docs:{description:"disallow specified modules when loaded by `import`",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/no-restricted-imports"},messages:{path:"'{{importSource}}' import is restricted from being used.",pathWithCustomMessage:"'{{importSource}}' import is restricted from being used. {{customMessage}}",patterns:"'{{importSource}}' import is restricted from being used by a pattern.",everything:"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",everythingWithCustomMessage:"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}",importName:"'{{importName}}' import from '{{importSource}}' is restricted.",importNameWithCustomMessage:"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}"},schema:{anyOf:[arrayOfStringsOrObjects$1,{type:"array",items:[{type:"object",properties:{paths:arrayOfStringsOrObjects$1,patterns:arrayOfStrings$1},additionalProperties:false}],additionalItems:false}]}},create(context){const sourceCode=context.getSourceCode();const options=Array.isArray(context.options)?context.options:[];const isPathAndPatternsObject=typeof options[0]==="object"&&(Object.prototype.hasOwnProperty.call(options[0],"paths")||Object.prototype.hasOwnProperty.call(options[0],"patterns"));const restrictedPaths=(isPathAndPatternsObject?options[0].paths:context.options)||[];const restrictedPatterns=(isPathAndPatternsObject?options[0].patterns:[])||[];if(Object.keys(restrictedPaths).length===0&&restrictedPatterns.length===0){return {};}const restrictedPathMessages=restrictedPaths.reduce((memo,importSource)=>{if(typeof importSource==="string"){memo[importSource]={message:null};}else {memo[importSource.name]={message:importSource.message,importNames:importSource.importNames};}return memo;},{});const restrictedPatternsMatcher=ignore__default['default']().add(restrictedPatterns);function checkRestrictedPathAndReport(importSource,importNames,node){if(!Object.prototype.hasOwnProperty.call(restrictedPathMessages,importSource)){return;}const customMessage=restrictedPathMessages[importSource].message;const restrictedImportNames=restrictedPathMessages[importSource].importNames;if(restrictedImportNames){if(importNames.has("*")){const specifierData=importNames.get("*")[0];context.report({node,messageId:customMessage?"everythingWithCustomMessage":"everything",loc:specifierData.loc,data:{importSource,importNames:restrictedImportNames,customMessage}});}restrictedImportNames.forEach(importName=>{if(importNames.has(importName)){const specifiers=importNames.get(importName);specifiers.forEach(specifier=>{context.report({node,messageId:customMessage?"importNameWithCustomMessage":"importName",loc:specifier.loc,data:{importSource,customMessage,importName}});});}});}else {context.report({node,messageId:customMessage?"pathWithCustomMessage":"path",data:{importSource,customMessage}});}}function reportPathForPatterns(node){const importSource=node.source.value.trim();context.report({node,messageId:"patterns",data:{importSource}});}function isRestrictedPattern(importSource){return restrictedPatterns.length>0&&restrictedPatternsMatcher.ignores(importSource);}function checkNode(node){const importSource=node.source.value.trim();const importNames=new Map();if(node.type==="ExportAllDeclaration"){const starToken=sourceCode.getFirstToken(node,1);importNames.set("*",[{loc:starToken.loc}]);}else if(node.specifiers){for(const specifier of node.specifiers){let name;const specifierData={loc:specifier.loc};if(specifier.type==="ImportDefaultSpecifier"){name="default";}else if(specifier.type==="ImportNamespaceSpecifier"){name="*";}else if(specifier.imported){name=specifier.imported.name;}else if(specifier.local){name=specifier.local.name;}if(name){if(importNames.has(name)){importNames.get(name).push(specifierData);}else {importNames.set(name,[specifierData]);}}}}checkRestrictedPathAndReport(importSource,importNames,node);if(isRestrictedPattern(importSource)){reportPathForPatterns(node);}}return {ImportDeclaration:checkNode,ExportNamedDeclaration(node){if(node.source){checkNode(node);}},ExportAllDeclaration:checkNode};}};const arrayOfStrings={type:"array",items:{type:"string"},uniqueItems:true};const arrayOfStringsOrObjects={type:"array",items:{anyOf:[{type:"string"},{type:"object",properties:{name:{type:"string"},message:{type:"string",minLength:1}},additionalProperties:false,required:["name"]}]},uniqueItems:true};var noRestrictedModules={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"disallow specified modules when loaded by `require`",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/no-restricted-modules"},schema:{anyOf:[arrayOfStringsOrObjects,{type:"array",items:{type:"object",properties:{paths:arrayOfStringsOrObjects,patterns:arrayOfStrings},additionalProperties:false},additionalItems:false}]},messages:{defaultMessage:"'{{name}}' module is restricted from being used.",customMessage:"'{{name}}' module is restricted from being used. {{customMessage}}",patternMessage:"'{{name}}' module is restricted from being used by a pattern."}},create(context){const options=Array.isArray(context.options)?context.options:[];const isPathAndPatternsObject=typeof options[0]==="object"&&(Object.prototype.hasOwnProperty.call(options[0],"paths")||Object.prototype.hasOwnProperty.call(options[0],"patterns"));const restrictedPaths=(isPathAndPatternsObject?options[0].paths:context.options)||[];const restrictedPatterns=(isPathAndPatternsObject?options[0].patterns:[])||[];const restrictedPathMessages=restrictedPaths.reduce((memo,importName)=>{if(typeof importName==="string"){memo[importName]=null;}else {memo[importName.name]=importName.message;}return memo;},{});if(Object.keys(restrictedPaths).length===0&&restrictedPatterns.length===0){return {};}const ig=ignore__default['default']().add(restrictedPatterns);function isStringLiteral(node){return node&&node.type==="Literal"&&typeof node.value==="string";}function isStaticTemplateLiteral(node){return node&&node.type==="TemplateLiteral"&&node.expressions.length===0;}function isRequireCall(node){return node.callee.type==="Identifier"&&node.callee.name==="require";}function getFirstArgumentString(node){if(isStringLiteral(node)){return node.value.trim();}if(isStaticTemplateLiteral(node)){return node.quasis[0].value.cooked.trim();}return null;}function reportPath(node,name){const customMessage=restrictedPathMessages[name];const messageId=customMessage?"customMessage":"defaultMessage";context.report({node,messageId,data:{name,customMessage}});}function isRestrictedPath(name){return Object.prototype.hasOwnProperty.call(restrictedPathMessages,name);}return {CallExpression(node){if(isRequireCall(node)){if(node.arguments.length){const name=getFirstArgumentString(node.arguments[0]);if(name){if(isRestrictedPath(name)){reportPath(node,name);}if(restrictedPatterns.length>0&&ig.ignores(name)){context.report({node,messageId:"patternMessage",data:{name}});}}}}}};}};var noRestrictedProperties={meta:{type:"suggestion",docs:{description:"disallow certain properties on certain objects",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-restricted-properties"},schema:{type:"array",items:{anyOf:[{type:"object",properties:{object:{type:"string"},property:{type:"string"},message:{type:"string"}},additionalProperties:false,required:["object"]},{type:"object",properties:{object:{type:"string"},property:{type:"string"},message:{type:"string"}},additionalProperties:false,required:["property"]}]},uniqueItems:true},messages:{restrictedObjectProperty:"'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",restrictedProperty:"'{{propertyName}}' is restricted from being used.{{message}}"}},create(context){const restrictedCalls=context.options;if(restrictedCalls.length===0){return {};}const restrictedProperties=new Map();const globallyRestrictedObjects=new Map();const globallyRestrictedProperties=new Map();restrictedCalls.forEach(option=>{const objectName=option.object;const propertyName=option.property;if(typeof objectName==="undefined"){globallyRestrictedProperties.set(propertyName,{message:option.message});}else if(typeof propertyName==="undefined"){globallyRestrictedObjects.set(objectName,{message:option.message});}else {if(!restrictedProperties.has(objectName)){restrictedProperties.set(objectName,new Map());}restrictedProperties.get(objectName).set(propertyName,{message:option.message});}});function checkPropertyAccess(node,objectName,propertyName){if(propertyName===null){return;}const matchedObject=restrictedProperties.get(objectName);const matchedObjectProperty=matchedObject?matchedObject.get(propertyName):globallyRestrictedObjects.get(objectName);const globalMatchedProperty=globallyRestrictedProperties.get(propertyName);if(matchedObjectProperty){const message=matchedObjectProperty.message?` ${matchedObjectProperty.message}`:"";context.report({node,messageId:"restrictedObjectProperty",data:{objectName,propertyName,message}});}else if(globalMatchedProperty){const message=globalMatchedProperty.message?` ${globalMatchedProperty.message}`:"";context.report({node,messageId:"restrictedProperty",data:{propertyName,message}});}}function checkDestructuringAssignment(node){if(node.right.type==="Identifier"){const objectName=node.right.name;if(node.left.type==="ObjectPattern"){node.left.properties.forEach(property=>{checkPropertyAccess(node.left,objectName,astUtils.getStaticPropertyName(property));});}}}return {MemberExpression(node){checkPropertyAccess(node,node.object&&node.object.name,astUtils.getStaticPropertyName(node));},VariableDeclarator(node){if(node.init&&node.init.type==="Identifier"){const objectName=node.init.name;if(node.id.type==="ObjectPattern"){node.id.properties.forEach(property=>{checkPropertyAccess(node.id,objectName,astUtils.getStaticPropertyName(property));});}}},AssignmentExpression:checkDestructuringAssignment,AssignmentPattern:checkDestructuringAssignment};}};var noRestrictedSyntax={meta:{type:"suggestion",docs:{description:"disallow specified syntax",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-restricted-syntax"},schema:{type:"array",items:{oneOf:[{type:"string"},{type:"object",properties:{selector:{type:"string"},message:{type:"string"}},required:["selector"],additionalProperties:false}]},uniqueItems:true,minItems:0},messages:{restrictedSyntax:"{{message}}"}},create(context){return context.options.reduce((result,selectorOrObject)=>{const isStringFormat=typeof selectorOrObject==="string";const hasCustomMessage=!isStringFormat&&Boolean(selectorOrObject.message);const selector=isStringFormat?selectorOrObject:selectorOrObject.selector;const message=hasCustomMessage?selectorOrObject.message:`Using '${selector}' is not allowed.`;return Object.assign(result,{[selector](node){context.report({node,messageId:"restrictedSyntax",data:{message}});}});},{});}};const SENTINEL_TYPE$1=/^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;var noReturnAssign={meta:{type:"suggestion",docs:{description:"disallow assignment operators in `return` statements",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-return-assign"},schema:[{enum:["except-parens","always"]}],messages:{returnAssignment:"Return statement should not contain assignment.",arrowAssignment:"Arrow function should not return assignment."}},create(context){const always=(context.options[0]||"except-parens")!=="except-parens";const sourceCode=context.getSourceCode();return {AssignmentExpression(node){if(!always&&astUtils.isParenthesised(sourceCode,node)){return;}let currentChild=node;let parent=currentChild.parent;while(parent&&!SENTINEL_TYPE$1.test(parent.type)){currentChild=parent;parent=parent.parent;}if(parent&&parent.type==="ReturnStatement"){context.report({node:parent,messageId:"returnAssignment"});}else if(parent&&parent.type==="ArrowFunctionExpression"&&parent.body===currentChild){context.report({node:parent,messageId:"arrowAssignment"});}}};}};var noReturnAwait={meta:{type:"suggestion",docs:{description:"disallow unnecessary `return await`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-return-await"},fixable:null,schema:[],messages:{redundantUseOfAwait:"Redundant use of `await` on a return value."}},create(context){function reportUnnecessaryAwait(node){context.report({node:context.getSourceCode().getFirstToken(node),loc:node.loc,messageId:"redundantUseOfAwait"});}function hasErrorHandler(node){let ancestor=node;while(!astUtils.isFunction(ancestor)&&ancestor.type!=="Program"){if(ancestor.parent.type==="TryStatement"&&(ancestor===ancestor.parent.block||ancestor===ancestor.parent.handler&&ancestor.parent.finalizer)){return true;}ancestor=ancestor.parent;}return false;}function isInTailCallPosition(node){if(node.parent.type==="ArrowFunctionExpression"){return true;}if(node.parent.type==="ReturnStatement"){return !hasErrorHandler(node.parent);}if(node.parent.type==="ConditionalExpression"&&(node===node.parent.consequent||node===node.parent.alternate)){return isInTailCallPosition(node.parent);}if(node.parent.type==="LogicalExpression"&&node===node.parent.right){return isInTailCallPosition(node.parent);}if(node.parent.type==="SequenceExpression"&&node===node.parent.expressions[node.parent.expressions.length-1]){return isInTailCallPosition(node.parent);}return false;}return {AwaitExpression(node){if(isInTailCallPosition(node)&&!hasErrorHandler(node)){reportUnnecessaryAwait(node);}}};}};var noScriptUrl={meta:{type:"suggestion",docs:{description:"disallow `javascript:` urls",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-script-url"},schema:[],messages:{unexpectedScriptURL:"Script URL is a form of eval."}},create(context){function check(node){const value=astUtils.getStaticStringValue(node);if(typeof value==="string"&&value.toLowerCase().indexOf("javascript:")===0){context.report({node,messageId:"unexpectedScriptURL"});}}return {Literal(node){if(node.value&&typeof node.value==="string"){check(node);}},TemplateLiteral(node){if(!(node.parent&&node.parent.type==="TaggedTemplateExpression")){check(node);}}};}};const SPACES=/\s+/gu;function eachSelfAssignment(left,right,props,report){if(!left||!right);else if(left.type==="Identifier"&&right.type==="Identifier"&&left.name===right.name){report(right);}else if(left.type==="ArrayPattern"&&right.type==="ArrayExpression"){const end=Math.min(left.elements.length,right.elements.length);for(let i=0;i<end;++i){const leftElement=left.elements[i];const rightElement=right.elements[i];if(leftElement&&leftElement.type==="RestElement"&&i<right.elements.length-1){break;}eachSelfAssignment(leftElement,rightElement,props,report);if(rightElement&&rightElement.type==="SpreadElement"){break;}}}else if(left.type==="RestElement"&&right.type==="SpreadElement"){eachSelfAssignment(left.argument,right.argument,props,report);}else if(left.type==="ObjectPattern"&&right.type==="ObjectExpression"&&right.properties.length>=1){let startJ=0;for(let i=right.properties.length-1;i>=0;--i){const propType=right.properties[i].type;if(propType==="SpreadElement"||propType==="ExperimentalSpreadProperty"){startJ=i+1;break;}}for(let i=0;i<left.properties.length;++i){for(let j=startJ;j<right.properties.length;++j){eachSelfAssignment(left.properties[i],right.properties[j],props,report);}}}else if(left.type==="Property"&&right.type==="Property"&&right.kind==="init"&&!right.method){const leftName=astUtils.getStaticPropertyName(left);if(leftName!==null&&leftName===astUtils.getStaticPropertyName(right)){eachSelfAssignment(left.value,right.value,props,report);}}else if(props&&astUtils.skipChainExpression(left).type==="MemberExpression"&&astUtils.skipChainExpression(right).type==="MemberExpression"&&astUtils.isSameReference(left,right)){report(right);}}var noSelfAssign={meta:{type:"problem",docs:{description:"disallow assignments where both sides are exactly the same",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-self-assign"},schema:[{type:"object",properties:{props:{type:"boolean",default:true}},additionalProperties:false}],messages:{selfAssignment:"'{{name}}' is assigned to itself."}},create(context){const sourceCode=context.getSourceCode();const[{props=true}={}]=context.options;function report(node){context.report({node,messageId:"selfAssignment",data:{name:sourceCode.getText(node).replace(SPACES,"")}});}return {AssignmentExpression(node){if(node.operator==="="){eachSelfAssignment(node.left,node.right,props,report);}}};}};var noSelfCompare={meta:{type:"problem",docs:{description:"disallow comparisons where both sides are exactly the same",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-self-compare"},schema:[],messages:{comparingToSelf:"Comparing to itself is potentially pointless."}},create(context){const sourceCode=context.getSourceCode();function hasSameTokens(nodeA,nodeB){const tokensA=sourceCode.getTokens(nodeA);const tokensB=sourceCode.getTokens(nodeB);return tokensA.length===tokensB.length&&tokensA.every((token,index)=>token.type===tokensB[index].type&&token.value===tokensB[index].value);}return {BinaryExpression(node){const operators=new Set(["===","==","!==","!=",">","<",">=","<="]);if(operators.has(node.operator)&&hasSameTokens(node.left,node.right)){context.report({node,messageId:"comparingToSelf"});}}};}};const DEFAULT_OPTIONS={allowInParentheses:true};var noSequences={meta:{type:"suggestion",docs:{description:"disallow comma operators",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-sequences"},schema:[{properties:{allowInParentheses:{type:"boolean",default:true}},additionalProperties:false}],messages:{unexpectedCommaExpression:"Unexpected use of comma operator."}},create(context){const options=Object.assign({},DEFAULT_OPTIONS,context.options[0]);const sourceCode=context.getSourceCode();const parenthesized={DoWhileStatement:"test",IfStatement:"test",SwitchStatement:"discriminant",WhileStatement:"test",WithStatement:"object",ArrowFunctionExpression:"body"};function requiresExtraParens(node){return node.parent&&parenthesized[node.parent.type]&&node===node.parent[parenthesized[node.parent.type]];}function isParenthesised(node){return astUtils.isParenthesised(sourceCode,node);}function isParenthesisedTwice(node){const previousToken=sourceCode.getTokenBefore(node,1),nextToken=sourceCode.getTokenAfter(node,1);return isParenthesised(node)&&previousToken&&nextToken&&astUtils.isOpeningParenToken(previousToken)&&previousToken.range[1]<=node.range[0]&&astUtils.isClosingParenToken(nextToken)&&nextToken.range[0]>=node.range[1];}return {SequenceExpression(node){if(node.parent.type==="ForStatement"&&(node===node.parent.init||node===node.parent.update)){return;}if(options.allowInParentheses){if(requiresExtraParens(node)){if(isParenthesisedTwice(node)){return;}}else {if(isParenthesised(node)){return;}}}const firstCommaToken=sourceCode.getTokenAfter(node.expressions[0],astUtils.isCommaToken);context.report({node,loc:firstCommaToken.loc,messageId:"unexpectedCommaExpression"});}};}};const{findVariable:findVariable$1}=eslintUtils__default['default'];function isGlobalReference(node,scope){const variable=findVariable$1(scope,node);return variable!==null&&variable.scope.type==="global"&&variable.defs.length===0;}function isArgumentOfGlobalMethodCall(node,scope,objectName,methodName,index){const callNode=node.parent;return callNode.type==="CallExpression"&&callNode.arguments[index]===node&&astUtils.isSpecificMemberAccess(callNode.callee,objectName,methodName)&&isGlobalReference(astUtils.skipChainExpression(callNode.callee).object,scope);}function isPropertyDescriptor(node,scope){if(isArgumentOfGlobalMethodCall(node,scope,"Object","defineProperty",2)||isArgumentOfGlobalMethodCall(node,scope,"Reflect","defineProperty",2)){return true;}const parent=node.parent;if(parent.type==="Property"&&parent.value===node){const grandparent=parent.parent;if(grandparent.type==="ObjectExpression"&&(isArgumentOfGlobalMethodCall(grandparent,scope,"Object","create",1)||isArgumentOfGlobalMethodCall(grandparent,scope,"Object","defineProperties",1))){return true;}}return false;}function isSetter(node,scope){const parent=node.parent;if(parent.kind==="set"&&parent.value===node){return true;}if(parent.type==="Property"&&parent.value===node&&astUtils.getStaticPropertyName(parent)==="set"&&parent.parent.type==="ObjectExpression"&&isPropertyDescriptor(parent.parent,scope)){return true;}return false;}function getOuterScope(scope){const upper=scope.upper;if(upper.type==="function-expression-name"){return upper.upper;}return upper;}var noSetterReturn={meta:{type:"problem",docs:{description:"disallow returning values from setters",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-setter-return"},schema:[],messages:{returnsValue:"Setter cannot return a value."}},create(context){let funcInfo=null;function enterFunction(node){const outerScope=getOuterScope(context.getScope());funcInfo={upper:funcInfo,isSetter:isSetter(node,outerScope)};}function exitFunction(){funcInfo=funcInfo.upper;}function report(node){context.report({node,messageId:"returnsValue"});}return {FunctionDeclaration:enterFunction,FunctionExpression:enterFunction,ArrowFunctionExpression(node){enterFunction(node);if(funcInfo.isSetter&&node.expression){report(node.body);}},"FunctionDeclaration:exit":exitFunction,"FunctionExpression:exit":exitFunction,"ArrowFunctionExpression:exit":exitFunction,ReturnStatement(node){if(funcInfo&&funcInfo.isSetter&&node.argument){report(node);}}};}};function safelyShadowsUndefined(variable){return variable.name==="undefined"&&variable.references.every(ref=>!ref.isWrite())&&variable.defs.every(def=>def.node.type==="VariableDeclarator"&&def.node.init===null);}var noShadowRestrictedNames={meta:{type:"suggestion",docs:{description:"disallow identifiers from shadowing restricted names",category:"Variables",recommended:true,url:"https://eslint.org/docs/rules/no-shadow-restricted-names"},schema:[],messages:{shadowingRestrictedName:"Shadowing of global property '{{name}}'."}},create(context){const RESTRICTED=new Set(["undefined","NaN","Infinity","arguments","eval"]);return {"VariableDeclaration, :function, CatchClause"(node){for(const variable of context.getDeclaredVariables(node)){if(variable.defs.length>0&&RESTRICTED.has(variable.name)&&!safelyShadowsUndefined(variable)){context.report({node:variable.defs[0].name,messageId:"shadowingRestrictedName",data:{name:variable.name}});}}}};}};var noShadow={meta:{type:"suggestion",docs:{description:"disallow variable declarations from shadowing variables declared in the outer scope",category:"Variables",recommended:false,url:"https://eslint.org/docs/rules/no-shadow"},schema:[{type:"object",properties:{builtinGlobals:{type:"boolean",default:false},hoist:{enum:["all","functions","never"],default:"functions"},allow:{type:"array",items:{type:"string"}}},additionalProperties:false}],messages:{noShadow:"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.",noShadowGlobal:"'{{name}}' is already a global variable."}},create(context){const options={builtinGlobals:context.options[0]&&context.options[0].builtinGlobals,hoist:context.options[0]&&context.options[0].hoist||"functions",allow:context.options[0]&&context.options[0].allow||[]};function isAllowed(variable){return options.allow.indexOf(variable.name)!==-1;}function isDuplicatedClassNameVariable(variable){const block=variable.scope.block;return block.type==="ClassDeclaration"&&block.id===variable.identifiers[0];}function isOnInitializer(variable,scopeVar){const outerScope=scopeVar.scope;const outerDef=scopeVar.defs[0];const outer=outerDef&&outerDef.parent&&outerDef.parent.range;const innerScope=variable.scope;const innerDef=variable.defs[0];const inner=innerDef&&innerDef.name.range;return outer&&inner&&outer[0]<inner[0]&&inner[1]<outer[1]&&(innerDef.type==="FunctionName"&&innerDef.node.type==="FunctionExpression"||innerDef.node.type==="ClassExpression")&&outerScope===innerScope.upper;}function getNameRange(variable){const def=variable.defs[0];return def&&def.name.range;}function getDeclaredLocation(variable){const identifier=variable.identifiers[0];let obj;if(identifier){obj={global:false,line:identifier.loc.start.line,column:identifier.loc.start.column+1};}else {obj={global:true};}return obj;}function isInTdz(variable,scopeVar){const outerDef=scopeVar.defs[0];const inner=getNameRange(variable);const outer=getNameRange(scopeVar);return inner&&outer&&inner[1]<outer[0]&&(options.hoist!=="functions"||!outerDef||outerDef.node.type!=="FunctionDeclaration");}function checkForShadows(scope){const variables=scope.variables;for(let i=0;i<variables.length;++i){const variable=variables[i];if(variable.identifiers.length===0||isDuplicatedClassNameVariable(variable)||isAllowed(variable)){continue;}const shadowed=astUtils.getVariableByName(scope.upper,variable.name);if(shadowed&&(shadowed.identifiers.length>0||options.builtinGlobals&&"writeable"in shadowed)&&!isOnInitializer(variable,shadowed)&&!(options.hoist!=="all"&&isInTdz(variable,shadowed))){const location=getDeclaredLocation(shadowed);const messageId=location.global?"noShadowGlobal":"noShadow";const data={name:variable.name};if(!location.global){data.shadowedLine=location.line;data.shadowedColumn=location.column;}context.report({node:variable.identifiers[0],messageId,data});}}}return {"Program:exit"(){const globalScope=context.getScope();const stack=globalScope.childScopes.slice();while(stack.length){const scope=stack.pop();stack.push(...scope.childScopes);checkForShadows(scope);}}};}};var noSpacedFunc={meta:{type:"layout",docs:{description:"disallow spacing between function identifiers and their applications (deprecated)",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-spaced-func"},deprecated:true,replacedBy:["func-call-spacing"],fixable:"whitespace",schema:[],messages:{noSpacedFunction:"Unexpected space between function name and paren."}},create(context){const sourceCode=context.getSourceCode();function detectOpenSpaces(node){const lastCalleeToken=sourceCode.getLastToken(node.callee);let prevToken=lastCalleeToken,parenToken=sourceCode.getTokenAfter(lastCalleeToken);while(parenToken&&parenToken.range[1]<node.range[1]&&parenToken.value!=="("){prevToken=parenToken;parenToken=sourceCode.getTokenAfter(parenToken);}if(parenToken&&parenToken.range[1]<node.range[1]&&sourceCode.isSpaceBetweenTokens(prevToken,parenToken)){context.report({node,loc:lastCalleeToken.loc.start,messageId:"noSpacedFunction",fix(fixer){return fixer.removeRange([prevToken.range[1],parenToken.range[0]]);}});}}return {CallExpression:detectOpenSpaces,NewExpression:detectOpenSpaces};}};var noSparseArrays={meta:{type:"problem",docs:{description:"disallow sparse arrays",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-sparse-arrays"},schema:[],messages:{unexpectedSparseArray:"Unexpected comma in middle of array."}},create(context){return {ArrayExpression(node){const emptySpot=node.elements.indexOf(null)>-1;if(emptySpot){context.report({node,messageId:"unexpectedSparseArray"});}}};}};var noSync={meta:{deprecated:true,replacedBy:[],type:"suggestion",docs:{description:"disallow synchronous methods",category:"Node.js and CommonJS",recommended:false,url:"https://eslint.org/docs/rules/no-sync"},schema:[{type:"object",properties:{allowAtRootLevel:{type:"boolean",default:false}},additionalProperties:false}],messages:{noSync:"Unexpected sync method: '{{propertyName}}'."}},create(context){const selector=context.options[0]&&context.options[0].allowAtRootLevel?":function MemberExpression[property.name=/.*Sync$/]":"MemberExpression[property.name=/.*Sync$/]";return {[selector](node){context.report({node,messageId:"noSync",data:{propertyName:node.property.name}});}};}};const tabRegex=/\t+/gu;const anyNonWhitespaceRegex=/\S/u;var noTabs={meta:{type:"layout",docs:{description:"disallow all tabs",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-tabs"},schema:[{type:"object",properties:{allowIndentationTabs:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpectedTab:"Unexpected tab character."}},create(context){const sourceCode=context.getSourceCode();const allowIndentationTabs=context.options&&context.options[0]&&context.options[0].allowIndentationTabs;return {Program(node){sourceCode.getLines().forEach((line,index)=>{let match;while((match=tabRegex.exec(line))!==null){if(allowIndentationTabs&&!anyNonWhitespaceRegex.test(line.slice(0,match.index))){continue;}context.report({node,loc:{start:{line:index+1,column:match.index},end:{line:index+1,column:match.index+match[0].length}},messageId:"unexpectedTab"});}});}};}};var noTemplateCurlyInString={meta:{type:"problem",docs:{description:"disallow template literal placeholder syntax in regular strings",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-template-curly-in-string"},schema:[],messages:{unexpectedTemplateExpression:"Unexpected template string expression."}},create(context){return {Literal(node){if(typeof node.value==="string"&&/\$\{[^}]+\}/u.test(node.value)){context.report({node,messageId:"unexpectedTemplateExpression"});}}};}};var noTernary={meta:{type:"suggestion",docs:{description:"disallow ternary operators",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-ternary"},schema:[],messages:{noTernaryOperator:"Ternary operator used."}},create(context){return {ConditionalExpression(node){context.report({node,messageId:"noTernaryOperator"});}};}};function isConstructorFunction(node){return node.type==="FunctionExpression"&&node.parent.type==="MethodDefinition"&&node.parent.kind==="constructor";}var noThisBeforeSuper={meta:{type:"problem",docs:{description:"disallow `this`/`super` before calling `super()` in constructors",category:"ECMAScript 6",recommended:true,url:"https://eslint.org/docs/rules/no-this-before-super"},schema:[],messages:{noBeforeSuper:"'{{kind}}' is not allowed before 'super()'."}},create(context){let funcInfo=null;let segInfoMap=Object.create(null);function isCalled(segment){return !segment.reachable||segInfoMap[segment.id].superCalled;}function isInConstructorOfDerivedClass(){return Boolean(funcInfo&&funcInfo.isConstructor&&funcInfo.hasExtends);}function isBeforeCallOfSuper(){return isInConstructorOfDerivedClass()&&!funcInfo.codePath.currentSegments.every(isCalled);}function setInvalid(node){const segments=funcInfo.codePath.currentSegments;for(let i=0;i<segments.length;++i){const segment=segments[i];if(segment.reachable){segInfoMap[segment.id].invalidNodes.push(node);}}}function setSuperCalled(){const segments=funcInfo.codePath.currentSegments;for(let i=0;i<segments.length;++i){const segment=segments[i];if(segment.reachable){segInfoMap[segment.id].superCalled=true;}}}return {onCodePathStart(codePath,node){if(isConstructorFunction(node)){const classNode=node.parent.parent.parent;funcInfo={upper:funcInfo,isConstructor:true,hasExtends:Boolean(classNode.superClass&&!astUtils.isNullOrUndefined(classNode.superClass)),codePath};}else {funcInfo={upper:funcInfo,isConstructor:false,hasExtends:false,codePath};}},onCodePathEnd(codePath){const isDerivedClass=funcInfo.hasExtends;funcInfo=funcInfo.upper;if(!isDerivedClass){return;}codePath.traverseSegments((segment,controller)=>{const info=segInfoMap[segment.id];for(let i=0;i<info.invalidNodes.length;++i){const invalidNode=info.invalidNodes[i];context.report({messageId:"noBeforeSuper",node:invalidNode,data:{kind:invalidNode.type==="Super"?"super":"this"}});}if(info.superCalled){controller.skip();}});},onCodePathSegmentStart(segment){if(!isInConstructorOfDerivedClass()){return;}segInfoMap[segment.id]={superCalled:segment.prevSegments.length>0&&segment.prevSegments.every(isCalled),invalidNodes:[]};},onCodePathSegmentLoop(fromSegment,toSegment){if(!isInConstructorOfDerivedClass()){return;}funcInfo.codePath.traverseSegments({first:toSegment,last:fromSegment},(segment,controller)=>{const info=segInfoMap[segment.id];if(info.superCalled){info.invalidNodes=[];controller.skip();}else if(segment.prevSegments.length>0&&segment.prevSegments.every(isCalled)){info.superCalled=true;info.invalidNodes=[];}});},ThisExpression(node){if(isBeforeCallOfSuper()){setInvalid(node);}},Super(node){if(!astUtils.isCallee(node)&&isBeforeCallOfSuper()){setInvalid(node);}},"CallExpression:exit"(node){if(node.callee.type==="Super"&&isBeforeCallOfSuper()){setSuperCalled();}},"Program:exit"(){segInfoMap=Object.create(null);}};}};var noThrowLiteral={meta:{type:"suggestion",docs:{description:"disallow throwing literals as exceptions",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-throw-literal"},schema:[],messages:{object:"Expected an error object to be thrown.",undef:"Do not throw undefined."}},create(context){return {ThrowStatement(node){if(!astUtils.couldBeError(node.argument)){context.report({node,messageId:"object"});}else if(node.argument.type==="Identifier"){if(node.argument.name==="undefined"){context.report({node,messageId:"undef"});}}}};}};var noTrailingSpaces={meta:{type:"layout",docs:{description:"disallow trailing whitespace at the end of lines",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-trailing-spaces"},fixable:"whitespace",schema:[{type:"object",properties:{skipBlankLines:{type:"boolean",default:false},ignoreComments:{type:"boolean",default:false}},additionalProperties:false}],messages:{trailingSpace:"Trailing spaces not allowed."}},create(context){const sourceCode=context.getSourceCode();const options=context.options[0]||{},skipBlankLines=options.skipBlankLines||false,ignoreComments=options.ignoreComments||false;function report(node,location,fixRange){context.report({node,loc:location,messageId:"trailingSpace",fix(fixer){return fixer.removeRange(fixRange);}});}function getCommentLineNumbers(comments){const lines=new Set();comments.forEach(comment=>{const endLine=comment.type==="Block"?comment.loc.end.line-1:comment.loc.end.line;for(let i=comment.loc.start.line;i<=endLine;i++){lines.add(i);}});return lines;}return {Program:function(node){const re=new RegExp(`${"[ \t\xA0\u2000-\u200B\u3000]"}+$`,"u"),skipMatch=new RegExp(`^${"[ \t\xA0\u2000-\u200B\u3000]"}*$`,"u"),lines=sourceCode.lines,linebreaks=sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),comments=sourceCode.getAllComments(),commentLineNumbers=getCommentLineNumbers(comments);let totalLength=0,fixRange=[];for(let i=0,ii=lines.length;i<ii;i++){const lineNumber=i+1;const linebreakLength=linebreaks&&linebreaks[i]?linebreaks[i].length:1;const lineLength=lines[i].length+linebreakLength;const matches=re.exec(lines[i]);if(matches){const location={start:{line:lineNumber,column:matches.index},end:{line:lineNumber,column:lineLength-linebreakLength}};const rangeStart=totalLength+location.start.column;const rangeEnd=totalLength+location.end.column;const containingNode=sourceCode.getNodeByRangeIndex(rangeStart);if(containingNode&&containingNode.type==="TemplateElement"&&rangeStart>containingNode.parent.range[0]&&rangeEnd<containingNode.parent.range[1]){totalLength+=lineLength;continue;}if(skipBlankLines&&skipMatch.test(lines[i])){totalLength+=lineLength;continue;}fixRange=[rangeStart,rangeEnd];if(!ignoreComments||!commentLineNumbers.has(lineNumber)){report(node,location,fixRange);}}totalLength+=lineLength;}}};}};var noUndefInit={meta:{type:"suggestion",docs:{description:"disallow initializing variables to `undefined`",category:"Variables",recommended:false,url:"https://eslint.org/docs/rules/no-undef-init"},schema:[],fixable:"code",messages:{unnecessaryUndefinedInit:"It's not necessary to initialize '{{name}}' to undefined."}},create(context){const sourceCode=context.getSourceCode();return {VariableDeclarator(node){const name=sourceCode.getText(node.id),init=node.init&&node.init.name,scope=context.getScope(),undefinedVar=astUtils.getVariableByName(scope,"undefined"),shadowed=undefinedVar&&undefinedVar.defs.length>0,lastToken=sourceCode.getLastToken(node);if(init==="undefined"&&node.parent.kind!=="const"&&!shadowed){context.report({node,messageId:"unnecessaryUndefinedInit",data:{name},fix(fixer){if(node.parent.kind==="var"){return null;}if(node.id.type==="ArrayPattern"||node.id.type==="ObjectPattern"){return null;}if(sourceCode.commentsExistBetween(node.id,lastToken)){return null;}return fixer.removeRange([node.id.range[1],node.range[1]]);}});}}};}};function hasTypeOfOperator(node){const parent=node.parent;return parent.type==="UnaryExpression"&&parent.operator==="typeof";}var noUndef={meta:{type:"problem",docs:{description:"disallow the use of undeclared variables unless mentioned in `/*global */` comments",category:"Variables",recommended:true,url:"https://eslint.org/docs/rules/no-undef"},schema:[{type:"object",properties:{typeof:{type:"boolean",default:false}},additionalProperties:false}],messages:{undef:"'{{name}}' is not defined."}},create(context){const options=context.options[0];const considerTypeOf=options&&options.typeof===true||false;return {"Program:exit"(){const globalScope=context.getScope();globalScope.through.forEach(ref=>{const identifier=ref.identifier;if(!considerTypeOf&&hasTypeOfOperator(identifier)){return;}context.report({node:identifier,messageId:"undef",data:identifier});});}};}};var noUndefined={meta:{type:"suggestion",docs:{description:"disallow the use of `undefined` as an identifier",category:"Variables",recommended:false,url:"https://eslint.org/docs/rules/no-undefined"},schema:[],messages:{unexpectedUndefined:"Unexpected use of undefined."}},create(context){function report(node){context.report({node,messageId:"unexpectedUndefined"});}function checkScope(scope){const undefinedVar=scope.set.get("undefined");if(!undefinedVar){return;}const references=undefinedVar.references;const defs=undefinedVar.defs;references.filter(ref=>!ref.init).forEach(ref=>report(ref.identifier));defs.forEach(def=>report(def.name));}return {"Program:exit"(){const globalScope=context.getScope();const stack=[globalScope];while(stack.length){const scope=stack.pop();stack.push(...scope.childScopes);checkScope(scope);}}};}};var noUnderscoreDangle={meta:{type:"suggestion",docs:{description:"disallow dangling underscores in identifiers",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-underscore-dangle"},schema:[{type:"object",properties:{allow:{type:"array",items:{type:"string"}},allowAfterThis:{type:"boolean",default:false},allowAfterSuper:{type:"boolean",default:false},allowAfterThisConstructor:{type:"boolean",default:false},enforceInMethodNames:{type:"boolean",default:false},allowFunctionParams:{type:"boolean",default:true}},additionalProperties:false}],messages:{unexpectedUnderscore:"Unexpected dangling '_' in '{{identifier}}'."}},create(context){const options=context.options[0]||{};const ALLOWED_VARIABLES=options.allow?options.allow:[];const allowAfterThis=typeof options.allowAfterThis!=="undefined"?options.allowAfterThis:false;const allowAfterSuper=typeof options.allowAfterSuper!=="undefined"?options.allowAfterSuper:false;const allowAfterThisConstructor=typeof options.allowAfterThisConstructor!=="undefined"?options.allowAfterThisConstructor:false;const enforceInMethodNames=typeof options.enforceInMethodNames!=="undefined"?options.enforceInMethodNames:false;const allowFunctionParams=typeof options.allowFunctionParams!=="undefined"?options.allowFunctionParams:true;function isAllowed(identifier){return ALLOWED_VARIABLES.some(ident=>ident===identifier);}function hasDanglingUnderscore(identifier){const len=identifier.length;return identifier!=="_"&&(identifier[0]==="_"||identifier[len-1]==="_");}function isSpecialCaseIdentifierForMemberExpression(identifier){return identifier==="__proto__";}function isSpecialCaseIdentifierInVariableExpression(identifier){return identifier==="_";}function isThisConstructorReference(node){return node.object.type==="MemberExpression"&&node.object.property.name==="constructor"&&node.object.object.type==="ThisExpression";}function checkForDanglingUnderscoreInFunctionParameters(node){if(!allowFunctionParams){node.params.forEach(param=>{const{type}=param;let nodeToCheck;if(type==="RestElement"){nodeToCheck=param.argument;}else if(type==="AssignmentPattern"){nodeToCheck=param.left;}else {nodeToCheck=param;}if(nodeToCheck.type==="Identifier"){const identifier=nodeToCheck.name;if(hasDanglingUnderscore(identifier)&&!isAllowed(identifier)){context.report({node:param,messageId:"unexpectedUnderscore",data:{identifier}});}}});}}function checkForDanglingUnderscoreInFunction(node){if(node.type==="FunctionDeclaration"&&node.id){const identifier=node.id.name;if(typeof identifier!=="undefined"&&hasDanglingUnderscore(identifier)&&!isAllowed(identifier)){context.report({node,messageId:"unexpectedUnderscore",data:{identifier}});}}checkForDanglingUnderscoreInFunctionParameters(node);}function checkForDanglingUnderscoreInMethod(node){const identifier=node.key.name;const isMethod=node.type==="MethodDefinition"||node.type==="Property"&&node.method;if(typeof identifier!=="undefined"&&enforceInMethodNames&&isMethod&&hasDanglingUnderscore(identifier)&&!isAllowed(identifier)){context.report({node,messageId:"unexpectedUnderscore",data:{identifier}});}}return {FunctionDeclaration:checkForDanglingUnderscoreInFunction,VariableDeclarator:function(node){const identifier=node.id.name;if(typeof identifier!=="undefined"&&hasDanglingUnderscore(identifier)&&!isSpecialCaseIdentifierInVariableExpression(identifier)&&!isAllowed(identifier)){context.report({node,messageId:"unexpectedUnderscore",data:{identifier}});}},MemberExpression:function(node){const identifier=node.property.name,isMemberOfThis=node.object.type==="ThisExpression",isMemberOfSuper=node.object.type==="Super",isMemberOfThisConstructor=isThisConstructorReference(node);if(typeof identifier!=="undefined"&&hasDanglingUnderscore(identifier)&&!(isMemberOfThis&&allowAfterThis)&&!(isMemberOfSuper&&allowAfterSuper)&&!(isMemberOfThisConstructor&&allowAfterThisConstructor)&&!isSpecialCaseIdentifierForMemberExpression(identifier)&&!isAllowed(identifier)){context.report({node,messageId:"unexpectedUnderscore",data:{identifier}});}},MethodDefinition:checkForDanglingUnderscoreInMethod,Property:checkForDanglingUnderscoreInMethod,FunctionExpression:checkForDanglingUnderscoreInFunction,ArrowFunctionExpression:checkForDanglingUnderscoreInFunction};}};var noUnexpectedMultiline={meta:{type:"problem",docs:{description:"disallow confusing multiline expressions",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-unexpected-multiline"},schema:[],messages:{function:"Unexpected newline between function and ( of function call.",property:"Unexpected newline between object and [ of property access.",taggedTemplate:"Unexpected newline between template tag and template literal.",division:"Unexpected newline between numerator and division operator."}},create(context){const sourceCode=context.getSourceCode();function checkForBreakAfter(node,messageId){const openParen=sourceCode.getTokenAfter(node,astUtils.isNotClosingParenToken);const nodeExpressionEnd=sourceCode.getTokenBefore(openParen);if(openParen.loc.start.line!==nodeExpressionEnd.loc.end.line){context.report({node,loc:openParen.loc,messageId});}}return {MemberExpression(node){if(!node.computed||node.optional){return;}checkForBreakAfter(node.object,"property");},TaggedTemplateExpression(node){const{quasi}=node;const tokenBefore=sourceCode.getTokenBefore(quasi);if(tokenBefore.loc.end.line!==quasi.loc.start.line){context.report({node,loc:{start:quasi.loc.start,end:{line:quasi.loc.start.line,column:quasi.loc.start.column+1}},messageId:"taggedTemplate"});}},CallExpression(node){if(node.arguments.length===0||node.optional){return;}checkForBreakAfter(node.callee,"function");},"BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(node){const secondSlash=sourceCode.getTokenAfter(node,token=>token.value==="/");const tokenAfterOperator=sourceCode.getTokenAfter(secondSlash);if(tokenAfterOperator.type==="Identifier"&&/^[gimsuy]+$/u.test(tokenAfterOperator.value)&&secondSlash.range[1]===tokenAfterOperator.range[0]){checkForBreakAfter(node.left,"division");}}};}};const SENTINEL_PATTERN=/(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;const LOOP_PATTERN=/^(?:DoWhile|For|While)Statement$/u;const GROUP_PATTERN=/^(?:BinaryExpression|ConditionalExpression)$/u;const SKIP_PATTERN=/^(?:ArrowFunction|Class|Function)Expression$/u;const DYNAMIC_PATTERN=/^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;function isWriteReference(reference){if(reference.init){const def=reference.resolved&&reference.resolved.defs[0];if(!def||def.type!=="Variable"||def.parent.kind!=="var"){return false;}}return reference.isWrite();}function isUnmodified(condition){return !condition.modified;}function isUnmodifiedAndNotBelongToGroup(condition){return !(condition.modified||condition.group);}function isInRange$1(node,reference){const or=node.range;const ir=reference.identifier.range;return or[0]<=ir[0]&&ir[1]<=or[1];}const isInLoop={WhileStatement:isInRange$1,DoWhileStatement:isInRange$1,ForStatement(node,reference){return isInRange$1(node,reference)&&!(node.init&&isInRange$1(node.init,reference));}};function getEncloseFunctionDeclaration(reference){let node=reference.identifier;while(node){if(node.type==="FunctionDeclaration"){return node.id?node:null;}node=node.parent;}return null;}function updateModifiedFlag(conditions,modifiers){for(let i=0;i<conditions.length;++i){const condition=conditions[i];for(let j=0;!condition.modified&&j<modifiers.length;++j){const modifier=modifiers[j];let funcNode,funcVar;const inLoop=condition.isInLoop(modifier)||Boolean((funcNode=getEncloseFunctionDeclaration(modifier))&&(funcVar=astUtils.getVariableByName(modifier.from.upper,funcNode.id.name))&&funcVar.references.some(condition.isInLoop));condition.modified=inLoop;}}}var noUnmodifiedLoopCondition={meta:{type:"problem",docs:{description:"disallow unmodified loop conditions",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-unmodified-loop-condition"},schema:[],messages:{loopConditionNotModified:"'{{name}}' is not modified in this loop."}},create(context){const sourceCode=context.getSourceCode();let groupMap=null;function report(condition){const node=condition.reference.identifier;context.report({node,messageId:"loopConditionNotModified",data:node});}function registerConditionsToGroup(conditions){for(let i=0;i<conditions.length;++i){const condition=conditions[i];if(condition.group){let group=groupMap.get(condition.group);if(!group){group=[];groupMap.set(condition.group,group);}group.push(condition);}}}function checkConditionsInGroup(conditions){if(conditions.every(isUnmodified)){conditions.forEach(report);}}function hasDynamicExpressions(root){let retv=false;_commonjsHelpers11cbc178.traverser.traverse(root,{visitorKeys:sourceCode.visitorKeys,enter(node){if(DYNAMIC_PATTERN.test(node.type)){retv=true;this.break();}else if(SKIP_PATTERN.test(node.type)){this.skip();}}});return retv;}function toLoopCondition(reference){if(reference.init){return null;}let group=null;let child=reference.identifier;let node=child.parent;while(node){if(SENTINEL_PATTERN.test(node.type)){if(LOOP_PATTERN.test(node.type)&&node.test===child){return {reference,group,isInLoop:isInLoop[node.type].bind(null,node),modified:false};}break;}if(GROUP_PATTERN.test(node.type)){if(hasDynamicExpressions(node)){break;}else {group=node;}}child=node;node=node.parent;}return null;}function checkReferences(variable){const conditions=variable.references.map(toLoopCondition).filter(Boolean);if(conditions.length===0){return;}registerConditionsToGroup(conditions);const modifiers=variable.references.filter(isWriteReference);if(modifiers.length>0){updateModifiedFlag(conditions,modifiers);}conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);}return {"Program:exit"(){const queue=[context.getScope()];groupMap=new Map();let scope;while(scope=queue.pop()){queue.push(...scope.childScopes);scope.variables.forEach(checkReferences);}groupMap.forEach(checkConditionsInGroup);groupMap=null;}};}};const BOOLEAN_OPERATORS=new Set(["==","===","!=","!==",">",">=","<","<=","in","instanceof"]);const OPERATOR_INVERSES={"==":"!=","!=":"==","===":"!==","!==":"==="};const OR_PRECEDENCE=astUtils.getPrecedence({type:"LogicalExpression",operator:"||"});var noUnneededTernary={meta:{type:"suggestion",docs:{description:"disallow ternary operators when simpler alternatives exist",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-unneeded-ternary"},schema:[{type:"object",properties:{defaultAssignment:{type:"boolean",default:true}},additionalProperties:false}],fixable:"code",messages:{unnecessaryConditionalExpression:"Unnecessary use of boolean literals in conditional expression.",unnecessaryConditionalAssignment:"Unnecessary use of conditional expression for default assignment."}},create(context){const options=context.options[0]||{};const defaultAssignment=options.defaultAssignment!==false;const sourceCode=context.getSourceCode();function isBooleanLiteral(node){return node.type==="Literal"&&typeof node.value==="boolean";}function invertExpression(node){if(node.type==="BinaryExpression"&&Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES,node.operator)){const operatorToken=sourceCode.getFirstTokenBetween(node.left,node.right,token=>token.value===node.operator);const text=sourceCode.getText();return text.slice(node.range[0],operatorToken.range[0])+OPERATOR_INVERSES[node.operator]+text.slice(operatorToken.range[1],node.range[1]);}if(astUtils.getPrecedence(node)<astUtils.getPrecedence({type:"UnaryExpression"})){return `!(${astUtils.getParenthesisedText(sourceCode,node)})`;}return `!${astUtils.getParenthesisedText(sourceCode,node)}`;}function isBooleanExpression(node){return node.type==="BinaryExpression"&&BOOLEAN_OPERATORS.has(node.operator)||node.type==="UnaryExpression"&&node.operator==="!";}function matchesDefaultAssignment(node){return node.test.type==="Identifier"&&node.consequent.type==="Identifier"&&node.test.name===node.consequent.name;}return {ConditionalExpression(node){if(isBooleanLiteral(node.alternate)&&isBooleanLiteral(node.consequent)){context.report({node,messageId:"unnecessaryConditionalExpression",fix(fixer){if(node.consequent.value===node.alternate.value){return node.test.type==="Identifier"?fixer.replaceText(node,node.consequent.value.toString()):null;}if(node.alternate.value){return fixer.replaceText(node,invertExpression(node.test));}return fixer.replaceText(node,isBooleanExpression(node.test)?astUtils.getParenthesisedText(sourceCode,node.test):`!${invertExpression(node.test)}`);}});}else if(!defaultAssignment&&matchesDefaultAssignment(node)){context.report({node,messageId:"unnecessaryConditionalAssignment",fix:fixer=>{const shouldParenthesizeAlternate=(astUtils.getPrecedence(node.alternate)<OR_PRECEDENCE||astUtils.isCoalesceExpression(node.alternate))&&!astUtils.isParenthesised(sourceCode,node.alternate);const alternateText=shouldParenthesizeAlternate?`(${sourceCode.getText(node.alternate)})`:astUtils.getParenthesisedText(sourceCode,node.alternate);const testText=astUtils.getParenthesisedText(sourceCode,node.test);return fixer.replaceText(node,`${testText} || ${alternateText}`);}});}}};}};const allLoopTypes=["WhileStatement","DoWhileStatement","ForStatement","ForInStatement","ForOfStatement"];function isLoopingTarget(node){const parent=node.parent;if(parent){switch(parent.type){case"WhileStatement":return node===parent.test;case"DoWhileStatement":return node===parent.body;case"ForStatement":return node===(parent.update||parent.test||parent.body);case"ForInStatement":case"ForOfStatement":return node===parent.left;}}return false;}function getDifference(arrA,arrB){return arrA.filter(a=>!arrB.includes(a));}var noUnreachableLoop={meta:{type:"problem",docs:{description:"disallow loops with a body that allows only one iteration",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-unreachable-loop"},schema:[{type:"object",properties:{ignore:{type:"array",items:{enum:allLoopTypes},uniqueItems:true}},additionalProperties:false}],messages:{invalid:"Invalid loop. Its body allows only one iteration."}},create(context){const ignoredLoopTypes=context.options[0]&&context.options[0].ignore||[],loopTypesToCheck=getDifference(allLoopTypes,ignoredLoopTypes),loopSelector=loopTypesToCheck.join(","),loopsByTargetSegments=new Map(),loopsToReport=new Set();let currentCodePath=null;return {onCodePathStart(codePath){currentCodePath=codePath;},onCodePathEnd(){currentCodePath=currentCodePath.upper;},[loopSelector](node){if(currentCodePath.currentSegments.some(segment=>segment.reachable)){loopsToReport.add(node);}},onCodePathSegmentStart(segment,node){if(isLoopingTarget(node)){const loop=node.parent;loopsByTargetSegments.set(segment,loop);}},onCodePathSegmentLoop(_,toSegment,node){const loop=loopsByTargetSegments.get(toSegment);if(node===loop||node.type==="ContinueStatement"){loopsToReport.delete(loop);}},"Program:exit"(){loopsToReport.forEach(node=>context.report({node,messageId:"invalid"}));}};}};function isInitialized(node){return Boolean(node.init);}function isUnreachable(segment){return !segment.reachable;}class ConsecutiveRange{constructor(sourceCode){this.sourceCode=sourceCode;this.startNode=null;this.endNode=null;}get location(){return {start:this.startNode.loc.start,end:this.endNode.loc.end};}get isEmpty(){return !(this.startNode&&this.endNode);}contains(node){return node.range[0]>=this.startNode.range[0]&&node.range[1]<=this.endNode.range[1];}isConsecutive(node){return this.contains(this.sourceCode.getTokenBefore(node));}merge(node){this.endNode=node;}reset(node){this.startNode=this.endNode=node;}}var noUnreachable={meta:{type:"problem",docs:{description:"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-unreachable"},schema:[],messages:{unreachableCode:"Unreachable code."}},create(context){let currentCodePath=null;const range=new ConsecutiveRange(context.getSourceCode());function reportIfUnreachable(node){let nextNode=null;if(node&&currentCodePath.currentSegments.every(isUnreachable)){if(range.isEmpty){range.reset(node);return;}if(range.contains(node)){return;}if(range.isConsecutive(node)){range.merge(node);return;}nextNode=node;}if(!range.isEmpty){context.report({messageId:"unreachableCode",loc:range.location,node:range.startNode});}range.reset(nextNode);}return {onCodePathStart(codePath){currentCodePath=codePath;},onCodePathEnd(){currentCodePath=currentCodePath.upper;},BlockStatement:reportIfUnreachable,BreakStatement:reportIfUnreachable,ClassDeclaration:reportIfUnreachable,ContinueStatement:reportIfUnreachable,DebuggerStatement:reportIfUnreachable,DoWhileStatement:reportIfUnreachable,ExpressionStatement:reportIfUnreachable,ForInStatement:reportIfUnreachable,ForOfStatement:reportIfUnreachable,ForStatement:reportIfUnreachable,IfStatement:reportIfUnreachable,ImportDeclaration:reportIfUnreachable,LabeledStatement:reportIfUnreachable,ReturnStatement:reportIfUnreachable,SwitchStatement:reportIfUnreachable,ThrowStatement:reportIfUnreachable,TryStatement:reportIfUnreachable,VariableDeclaration(node){if(node.kind!=="var"||node.declarations.some(isInitialized)){reportIfUnreachable(node);}},WhileStatement:reportIfUnreachable,WithStatement:reportIfUnreachable,ExportNamedDeclaration:reportIfUnreachable,ExportDefaultDeclaration:reportIfUnreachable,ExportAllDeclaration:reportIfUnreachable,"Program:exit"(){reportIfUnreachable();}};}};const SENTINEL_NODE_TYPE_RETURN_THROW=/^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;const SENTINEL_NODE_TYPE_BREAK=/^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;const SENTINEL_NODE_TYPE_CONTINUE=/^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;var noUnsafeFinally={meta:{type:"problem",docs:{description:"disallow control flow statements in `finally` blocks",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-unsafe-finally"},schema:[],messages:{unsafeUsage:"Unsafe usage of {{nodeType}}."}},create(context){function isFinallyBlock(node){return node.parent.type==="TryStatement"&&node.parent.finalizer===node;}function isInFinallyBlock(node,label){let labelInside=false;let sentinelNodeType;if(node.type==="BreakStatement"&&!node.label){sentinelNodeType=SENTINEL_NODE_TYPE_BREAK;}else if(node.type==="ContinueStatement"){sentinelNodeType=SENTINEL_NODE_TYPE_CONTINUE;}else {sentinelNodeType=SENTINEL_NODE_TYPE_RETURN_THROW;}for(let currentNode=node;currentNode&&!sentinelNodeType.test(currentNode.type);currentNode=currentNode.parent){if(currentNode.parent.label&&label&&currentNode.parent.label.name===label.name){labelInside=true;}if(isFinallyBlock(currentNode)){if(label&&labelInside){return false;}return true;}}return false;}function check(node){if(isInFinallyBlock(node,node.label)){context.report({messageId:"unsafeUsage",data:{nodeType:node.type},node,line:node.loc.line,column:node.loc.column});}}return {ReturnStatement:check,ThrowStatement:check,BreakStatement:check,ContinueStatement:check};}};function isInOrInstanceOfOperator(op){return op==="in"||op==="instanceof";}function isOrderingRelationalOperator(op){return op==="<"||op===">"||op===">="||op==="<=";}function isNegation(node){return node.type==="UnaryExpression"&&node.operator==="!";}var noUnsafeNegation={meta:{type:"problem",docs:{description:"disallow negating the left operand of relational operators",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/no-unsafe-negation",suggestion:true},schema:[{type:"object",properties:{enforceForOrderingRelations:{type:"boolean",default:false}},additionalProperties:false}],fixable:null,messages:{unexpected:"Unexpected negating the left operand of '{{operator}}' operator.",suggestNegatedExpression:"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.",suggestParenthesisedNegation:"Wrap negation in '()' to make the intention explicit. This preserves the current behavior."}},create(context){const sourceCode=context.getSourceCode();const options=context.options[0]||{};const enforceForOrderingRelations=options.enforceForOrderingRelations===true;return {BinaryExpression(node){const operator=node.operator;const orderingRelationRuleApplies=enforceForOrderingRelations&&isOrderingRelationalOperator(operator);if((isInOrInstanceOfOperator(operator)||orderingRelationRuleApplies)&&isNegation(node.left)&&!astUtils.isParenthesised(sourceCode,node.left)){context.report({node,loc:node.left.loc,messageId:"unexpected",data:{operator},suggest:[{messageId:"suggestNegatedExpression",data:{operator},fix(fixer){const negationToken=sourceCode.getFirstToken(node.left);const fixRange=[negationToken.range[1],node.range[1]];const text=sourceCode.text.slice(fixRange[0],fixRange[1]);return fixer.replaceTextRange(fixRange,`(${text})`);}},{messageId:"suggestParenthesisedNegation",fix(fixer){return fixer.replaceText(node.left,`(${sourceCode.getText(node.left)})`);}}]});}}};}};const UNSAFE_ARITHMETIC_OPERATORS=new Set(["+","-","/","*","%","**"]);const UNSAFE_ASSIGNMENT_OPERATORS=new Set(["+=","-=","/=","*=","%=","**="]);const UNSAFE_RELATIONAL_OPERATORS=new Set(["in","instanceof"]);function isDestructuringPattern(node){return node.type==="ObjectPattern"||node.type==="ArrayPattern";}var noUnsafeOptionalChaining={meta:{type:"problem",docs:{description:"disallow use of optional chaining in contexts where the `undefined` value is not allowed",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-unsafe-optional-chaining"},schema:[{type:"object",properties:{disallowArithmeticOperators:{type:"boolean",default:false}},additionalProperties:false}],fixable:null,messages:{unsafeOptionalChain:"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.",unsafeArithmetic:"Unsafe arithmetic operation on optional chaining. It can result in NaN."}},create(context){const options=context.options[0]||{};const disallowArithmeticOperators=options.disallowArithmeticOperators||false;function reportUnsafeUsage(node){context.report({messageId:"unsafeOptionalChain",node});}function reportUnsafeArithmetic(node){context.report({messageId:"unsafeArithmetic",node});}function checkUndefinedShortCircuit(node,reportFunc){if(!node){return;}switch(node.type){case"LogicalExpression":if(node.operator==="||"||node.operator==="??"){checkUndefinedShortCircuit(node.right,reportFunc);}else if(node.operator==="&&"){checkUndefinedShortCircuit(node.left,reportFunc);checkUndefinedShortCircuit(node.right,reportFunc);}break;case"SequenceExpression":checkUndefinedShortCircuit(node.expressions[node.expressions.length-1],reportFunc);break;case"ConditionalExpression":checkUndefinedShortCircuit(node.consequent,reportFunc);checkUndefinedShortCircuit(node.alternate,reportFunc);break;case"AwaitExpression":checkUndefinedShortCircuit(node.argument,reportFunc);break;case"ChainExpression":reportFunc(node);break;}}function checkUnsafeUsage(node){checkUndefinedShortCircuit(node,reportUnsafeUsage);}function checkUnsafeArithmetic(node){checkUndefinedShortCircuit(node,reportUnsafeArithmetic);}return {"AssignmentExpression, AssignmentPattern"(node){if(isDestructuringPattern(node.left)){checkUnsafeUsage(node.right);}},"ClassDeclaration, ClassExpression"(node){checkUnsafeUsage(node.superClass);},CallExpression(node){if(!node.optional){checkUnsafeUsage(node.callee);}},NewExpression(node){checkUnsafeUsage(node.callee);},VariableDeclarator(node){if(isDestructuringPattern(node.id)){checkUnsafeUsage(node.init);}},MemberExpression(node){if(!node.optional){checkUnsafeUsage(node.object);}},TaggedTemplateExpression(node){checkUnsafeUsage(node.tag);},ForOfStatement(node){checkUnsafeUsage(node.right);},SpreadElement(node){if(node.parent&&node.parent.type!=="ObjectExpression"){checkUnsafeUsage(node.argument);}},BinaryExpression(node){if(UNSAFE_RELATIONAL_OPERATORS.has(node.operator)){checkUnsafeUsage(node.right);}if(disallowArithmeticOperators&&UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)){checkUnsafeArithmetic(node.right);checkUnsafeArithmetic(node.left);}},WithStatement(node){checkUnsafeUsage(node.object);},UnaryExpression(node){if(disallowArithmeticOperators&&UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)){checkUnsafeArithmetic(node.argument);}},AssignmentExpression(node){if(disallowArithmeticOperators&&UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)){checkUnsafeArithmetic(node.right);}}};}};function alwaysTrue(){return true;}function alwaysFalse(){return false;}var noUnusedExpressions={meta:{type:"suggestion",docs:{description:"disallow unused expressions",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-unused-expressions"},schema:[{type:"object",properties:{allowShortCircuit:{type:"boolean",default:false},allowTernary:{type:"boolean",default:false},allowTaggedTemplates:{type:"boolean",default:false},enforceForJSX:{type:"boolean",default:false}},additionalProperties:false}],messages:{unusedExpression:"Expected an assignment or function call and instead saw an expression."}},create(context){const config=context.options[0]||{},allowShortCircuit=config.allowShortCircuit||false,allowTernary=config.allowTernary||false,allowTaggedTemplates=config.allowTaggedTemplates||false,enforceForJSX=config.enforceForJSX||false;function looksLikeDirective(node){return node.type==="ExpressionStatement"&&node.expression.type==="Literal"&&typeof node.expression.value==="string";}function takeWhile(predicate,list){for(let i=0;i<list.length;++i){if(!predicate(list[i])){return list.slice(0,i);}}return list.slice();}function directives(node){return takeWhile(looksLikeDirective,node.body);}function isDirective(node,ancestors){const parent=ancestors[ancestors.length-1],grandparent=ancestors[ancestors.length-2];return (parent.type==="Program"||parent.type==="BlockStatement"&&/Function/u.test(grandparent.type))&&directives(parent).indexOf(node)>=0;}const Checker=Object.assign(Object.create(null),{isDisallowed(node){return (Checker[node.type]||alwaysFalse)(node);},ArrayExpression:alwaysTrue,ArrowFunctionExpression:alwaysTrue,BinaryExpression:alwaysTrue,ChainExpression(node){return Checker.isDisallowed(node.expression);},ClassExpression:alwaysTrue,ConditionalExpression(node){if(allowTernary){return Checker.isDisallowed(node.consequent)||Checker.isDisallowed(node.alternate);}return true;},FunctionExpression:alwaysTrue,Identifier:alwaysTrue,JSXElement(){return enforceForJSX;},JSXFragment(){return enforceForJSX;},Literal:alwaysTrue,LogicalExpression(node){if(allowShortCircuit){return Checker.isDisallowed(node.right);}return true;},MemberExpression:alwaysTrue,MetaProperty:alwaysTrue,ObjectExpression:alwaysTrue,SequenceExpression:alwaysTrue,TaggedTemplateExpression(){return !allowTaggedTemplates;},TemplateLiteral:alwaysTrue,ThisExpression:alwaysTrue,UnaryExpression(node){return node.operator!=="void"&&node.operator!=="delete";}});return {ExpressionStatement(node){if(Checker.isDisallowed(node.expression)&&!isDirective(node,context.getAncestors())){context.report({node,messageId:"unusedExpression"});}}};}};var noUnusedLabels={meta:{type:"suggestion",docs:{description:"disallow unused labels",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-unused-labels"},schema:[],fixable:"code",messages:{unused:"'{{name}}:' is defined but never used."}},create(context){const sourceCode=context.getSourceCode();let scopeInfo=null;function enterLabeledScope(node){scopeInfo={label:node.label.name,used:false,upper:scopeInfo};}function exitLabeledScope(node){if(!scopeInfo.used){context.report({node:node.label,messageId:"unused",data:node.label,fix(fixer){if(sourceCode.getTokenAfter(node.label,{includeComments:true})===sourceCode.getTokenBefore(node.body,{includeComments:true})){return fixer.removeRange([node.range[0],node.body.range[0]]);}return null;}});}scopeInfo=scopeInfo.upper;}function markAsUsed(node){if(!node.label){return;}const label=node.label.name;let info=scopeInfo;while(info){if(info.label===label){info.used=true;break;}info=info.upper;}}return {LabeledStatement:enterLabeledScope,"LabeledStatement:exit":exitLabeledScope,BreakStatement:markAsUsed,ContinueStatement:markAsUsed};}};var noUnusedVars={meta:{type:"problem",docs:{description:"disallow unused variables",category:"Variables",recommended:true,url:"https://eslint.org/docs/rules/no-unused-vars"},schema:[{oneOf:[{enum:["all","local"]},{type:"object",properties:{vars:{enum:["all","local"]},varsIgnorePattern:{type:"string"},args:{enum:["all","after-used","none"]},ignoreRestSiblings:{type:"boolean"},argsIgnorePattern:{type:"string"},caughtErrors:{enum:["all","none"]},caughtErrorsIgnorePattern:{type:"string"}},additionalProperties:false}]}],messages:{unusedVar:"'{{varName}}' is {{action}} but never used{{additional}}."}},create(context){const sourceCode=context.getSourceCode();const config={vars:"all",args:"after-used",ignoreRestSiblings:false,caughtErrors:"none"};const firstOption=context.options[0];if(firstOption){if(typeof firstOption==="string"){config.vars=firstOption;}else {config.vars=firstOption.vars||config.vars;config.args=firstOption.args||config.args;config.ignoreRestSiblings=firstOption.ignoreRestSiblings||config.ignoreRestSiblings;config.caughtErrors=firstOption.caughtErrors||config.caughtErrors;if(firstOption.varsIgnorePattern){config.varsIgnorePattern=new RegExp(firstOption.varsIgnorePattern,"u");}if(firstOption.argsIgnorePattern){config.argsIgnorePattern=new RegExp(firstOption.argsIgnorePattern,"u");}if(firstOption.caughtErrorsIgnorePattern){config.caughtErrorsIgnorePattern=new RegExp(firstOption.caughtErrorsIgnorePattern,"u");}}}function getDefinedMessageData(unusedVar){const defType=unusedVar.defs&&unusedVar.defs[0]&&unusedVar.defs[0].type;let type;let pattern;if(defType==="CatchClause"&&config.caughtErrorsIgnorePattern){type="args";pattern=config.caughtErrorsIgnorePattern.toString();}else if(defType==="Parameter"&&config.argsIgnorePattern){type="args";pattern=config.argsIgnorePattern.toString();}else if(defType!=="Parameter"&&config.varsIgnorePattern){type="vars";pattern=config.varsIgnorePattern.toString();}const additional=type?`. Allowed unused ${type} must match ${pattern}`:"";return {varName:unusedVar.name,action:"defined",additional};}function getAssignedMessageData(unusedVar){const additional=config.varsIgnorePattern?`. Allowed unused vars must match ${config.varsIgnorePattern.toString()}`:"";return {varName:unusedVar.name,action:"assigned a value",additional};}function isExported(variable){const definition=variable.defs[0];if(definition){let node=definition.node;if(node.type==="VariableDeclarator"){node=node.parent;}else if(definition.type==="Parameter"){return false;}return node.parent.type.indexOf("Export")===0;}return false;}function hasRestSibling(node){return node.type==="Property"&&node.parent.type==="ObjectPattern"&&/^(?:RestElement|(?:Experimental)?RestProperty)$/u.test(node.parent.properties[node.parent.properties.length-1].type);}function hasRestSpreadSibling(variable){if(config.ignoreRestSiblings){const hasRestSiblingDefinition=variable.defs.some(def=>hasRestSibling(def.name.parent));const hasRestSiblingReference=variable.references.some(ref=>hasRestSibling(ref.identifier.parent));return hasRestSiblingDefinition||hasRestSiblingReference;}return false;}function isReadRef(ref){return ref.isRead();}function isSelfReference(ref,nodes){let scope=ref.from;while(scope){if(nodes.indexOf(scope.block)>=0){return true;}scope=scope.upper;}return false;}function getFunctionDefinitions(variable){const functionDefinitions=[];variable.defs.forEach(def=>{const{type,node}=def;if(type==="FunctionName"){functionDefinitions.push(node);}if(type==="Variable"&&node.init&&(node.init.type==="FunctionExpression"||node.init.type==="ArrowFunctionExpression")){functionDefinitions.push(node.init);}});return functionDefinitions;}function isInside(inner,outer){return inner.range[0]>=outer.range[0]&&inner.range[1]<=outer.range[1];}function getRhsNode(ref,prevRhsNode){const id=ref.identifier;const parent=id.parent;const grandparent=parent.parent;const refScope=ref.from.variableScope;const varScope=ref.resolved.scope.variableScope;const canBeUsedLater=refScope!==varScope||astUtils.isInLoop(id);if(prevRhsNode&&isInside(id,prevRhsNode)){return prevRhsNode;}if(parent.type==="AssignmentExpression"&&grandparent.type==="ExpressionStatement"&&id===parent.left&&!canBeUsedLater){return parent.right;}return null;}function isStorableFunction(funcNode,rhsNode){let node=funcNode;let parent=funcNode.parent;while(parent&&isInside(parent,rhsNode)){switch(parent.type){case"SequenceExpression":if(parent.expressions[parent.expressions.length-1]!==node){return false;}break;case"CallExpression":case"NewExpression":return parent.callee!==node;case"AssignmentExpression":case"TaggedTemplateExpression":case"YieldExpression":return true;default:if(/(?:Statement|Declaration)$/u.test(parent.type)){return true;}}node=parent;parent=parent.parent;}return false;}function isInsideOfStorableFunction(id,rhsNode){const funcNode=astUtils.getUpperFunction(id);return funcNode&&isInside(funcNode,rhsNode)&&isStorableFunction(funcNode,rhsNode);}function isReadForItself(ref,rhsNode){const id=ref.identifier;const parent=id.parent;const grandparent=parent.parent;return ref.isRead()&&(parent.type==="AssignmentExpression"&&grandparent.type==="ExpressionStatement"&&parent.left===id||parent.type==="UpdateExpression"&&grandparent.type==="ExpressionStatement"||rhsNode&&isInside(id,rhsNode)&&!isInsideOfStorableFunction(id,rhsNode));}function isForInRef(ref){let target=ref.identifier.parent;if(target.type==="VariableDeclarator"){target=target.parent.parent;}if(target.type!=="ForInStatement"){return false;}if(target.body.type==="BlockStatement"){target=target.body.body[0];}else {target=target.body;}if(!target){return false;}return target.type==="ReturnStatement";}function isUsedVariable(variable){const functionNodes=getFunctionDefinitions(variable),isFunctionDefinition=functionNodes.length>0;let rhsNode=null;return variable.references.some(ref=>{if(isForInRef(ref)){return true;}const forItself=isReadForItself(ref,rhsNode);rhsNode=getRhsNode(ref,rhsNode);return isReadRef(ref)&&!forItself&&!(isFunctionDefinition&&isSelfReference(ref,functionNodes));});}function isAfterLastUsedArg(variable){const def=variable.defs[0];const params=context.getDeclaredVariables(def.node);const posteriorParams=params.slice(params.indexOf(variable)+1);return !posteriorParams.some(v=>v.references.length>0||v.eslintUsed);}function collectUnusedVariables(scope,unusedVars){const variables=scope.variables;const childScopes=scope.childScopes;let i,l;if(scope.type!=="global"||config.vars==="all"){for(i=0,l=variables.length;i<l;++i){const variable=variables[i];if(scope.type==="class"&&scope.block.id===variable.identifiers[0]){continue;}if(scope.functionExpressionScope||variable.eslintUsed){continue;}if(scope.type==="function"&&variable.name==="arguments"&&variable.identifiers.length===0){continue;}const def=variable.defs[0];if(def){const type=def.type;if(type==="CatchClause"){if(config.caughtErrors==="none"){continue;}if(config.caughtErrorsIgnorePattern&&config.caughtErrorsIgnorePattern.test(def.name.name)){continue;}}if(type==="Parameter"){if((def.node.parent.type==="Property"||def.node.parent.type==="MethodDefinition")&&def.node.parent.kind==="set"){continue;}if(config.args==="none"){continue;}if(config.argsIgnorePattern&&config.argsIgnorePattern.test(def.name.name)){continue;}if(config.args==="after-used"&&astUtils.isFunction(def.name.parent)&&!isAfterLastUsedArg(variable)){continue;}}else {if(config.varsIgnorePattern&&config.varsIgnorePattern.test(def.name.name)){continue;}}}if(!isUsedVariable(variable)&&!isExported(variable)&&!hasRestSpreadSibling(variable)){unusedVars.push(variable);}}}for(i=0,l=childScopes.length;i<l;++i){collectUnusedVariables(childScopes[i],unusedVars);}return unusedVars;}return {"Program:exit"(programNode){const unusedVars=collectUnusedVariables(context.getScope(),[]);for(let i=0,l=unusedVars.length;i<l;++i){const unusedVar=unusedVars[i];if(unusedVar.defs.length>0){context.report({node:unusedVar.references.length?unusedVar.references[unusedVar.references.length-1].identifier:unusedVar.identifiers[0],messageId:"unusedVar",data:unusedVar.references.some(ref=>ref.isWrite())?getAssignedMessageData(unusedVar):getDefinedMessageData(unusedVar)});}else if(unusedVar.eslintExplicitGlobalComments){const directiveComment=unusedVar.eslintExplicitGlobalComments[0];context.report({node:programNode,loc:astUtils.getNameLocationInGlobalDirectiveComment(sourceCode,directiveComment,unusedVar.name),messageId:"unusedVar",data:getDefinedMessageData(unusedVar)});}}}};}};const SENTINEL_TYPE=/^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;const FOR_IN_OF_TYPE=/^For(?:In|Of)Statement$/u;function parseOptions(options){let functions=true;let classes=true;let variables=true;if(typeof options==="string"){functions=options!=="nofunc";}else if(typeof options==="object"&&options!==null){functions=options.functions!==false;classes=options.classes!==false;variables=options.variables!==false;}return {functions,classes,variables};}function isFunction(variable){return variable.defs[0].type==="FunctionName";}function isOuterClass(variable,reference){return variable.defs[0].type==="ClassName"&&variable.scope.variableScope!==reference.from.variableScope;}function isOuterVariable(variable,reference){return variable.defs[0].type==="Variable"&&variable.scope.variableScope!==reference.from.variableScope;}function isInRange(node,location){return node&&node.range[0]<=location&&location<=node.range[1];}function isInInitializer(variable,reference){if(variable.scope!==reference.from){return false;}let node=variable.identifiers[0].parent;const location=reference.identifier.range[1];while(node){if(node.type==="VariableDeclarator"){if(isInRange(node.init,location)){return true;}if(FOR_IN_OF_TYPE.test(node.parent.parent.type)&&isInRange(node.parent.parent.right,location)){return true;}break;}else if(node.type==="AssignmentPattern"){if(isInRange(node.right,location)){return true;}}else if(SENTINEL_TYPE.test(node.type)){break;}node=node.parent;}return false;}var noUseBeforeDefine={meta:{type:"problem",docs:{description:"disallow the use of variables before they are defined",category:"Variables",recommended:false,url:"https://eslint.org/docs/rules/no-use-before-define"},schema:[{oneOf:[{enum:["nofunc"]},{type:"object",properties:{functions:{type:"boolean"},classes:{type:"boolean"},variables:{type:"boolean"}},additionalProperties:false}]}],messages:{usedBeforeDefined:"'{{name}}' was used before it was defined."}},create(context){const options=parseOptions(context.options[0]);function isForbidden(variable,reference){if(isFunction(variable)){return options.functions;}if(isOuterClass(variable,reference)){return options.classes;}if(isOuterVariable(variable,reference)){return options.variables;}return true;}function findVariablesInScope(scope){scope.references.forEach(reference=>{const variable=reference.resolved;if(reference.init||!variable||variable.identifiers.length===0||variable.identifiers[0].range[1]<reference.identifier.range[1]&&!isInInitializer(variable,reference)||!isForbidden(variable,reference)){return;}context.report({node:reference.identifier,messageId:"usedBeforeDefined",data:reference.identifier});});scope.childScopes.forEach(findVariablesInScope);}return {Program(){findVariablesInScope(context.getScope());}};}};const{CALL:CALL$5,CONSTRUCT:CONSTRUCT$3,ReferenceTracker:ReferenceTracker$5,getStringIfConstant:getStringIfConstant$2}=eslintUtils__default['default'];const{RegExpParser,visitRegExpAST}=regexpp__default['default'];const parser$1=new RegExpParser();function getPathToRoot(node){const path=[];let current=node;do{path.push(current);current=current.parent;}while(current);return path;}function isLookaround(node){return node.type==="Assertion"&&(node.kind==="lookahead"||node.kind==="lookbehind");}function isNegativeLookaround(node){return isLookaround(node)&&node.negate;}var noUselessBackreference={meta:{type:"problem",docs:{description:"disallow useless backreferences in regular expressions",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/no-useless-backreference"},schema:[],messages:{nested:"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.",forward:"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.",backward:"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.",disjunctive:"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.",intoNegativeLookaround:"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround."}},create(context){function checkRegex(node,pattern,flags){let regExpAST;try{regExpAST=parser$1.parsePattern(pattern,0,pattern.length,flags.includes("u"));}catch{return;}visitRegExpAST(regExpAST,{onBackreferenceEnter(bref){const group=bref.resolved,brefPath=getPathToRoot(bref),groupPath=getPathToRoot(group);let messageId=null;if(brefPath.includes(group)){messageId="nested";}else {let i=brefPath.length-1,j=groupPath.length-1;do{i--;j--;}while(brefPath[i]===groupPath[j]);const indexOfLowestCommonAncestor=j+1,groupCut=groupPath.slice(0,indexOfLowestCommonAncestor),commonPath=groupPath.slice(indexOfLowestCommonAncestor),lowestCommonLookaround=commonPath.find(isLookaround),isMatchingBackward=lowestCommonLookaround&&lowestCommonLookaround.kind==="lookbehind";if(!isMatchingBackward&&bref.end<=group.start){messageId="forward";}else if(isMatchingBackward&&group.end<=bref.start){messageId="backward";}else if(lodash__default['default'].last(groupCut).type==="Alternative"){messageId="disjunctive";}else if(groupCut.some(isNegativeLookaround)){messageId="intoNegativeLookaround";}}if(messageId){context.report({node,messageId,data:{bref:bref.raw,group:group.raw}});}}});}return {"Literal[regex]"(node){const{pattern,flags}=node.regex;checkRegex(node,pattern,flags);},Program(){const scope=context.getScope(),tracker=new ReferenceTracker$5(scope),traceMap={RegExp:{[CALL$5]:true,[CONSTRUCT$3]:true}};for(const{node}of tracker.iterateGlobalReferences(traceMap)){const[patternNode,flagsNode]=node.arguments,pattern=getStringIfConstant$2(patternNode,scope),flags=getStringIfConstant$2(flagsNode,scope);if(typeof pattern==="string"){checkRegex(node,pattern,flags||"");}}}};}};function isCallOrNonVariadicApply(node){const callee=astUtils.skipChainExpression(node.callee);return callee.type==="MemberExpression"&&callee.property.type==="Identifier"&&callee.computed===false&&(callee.property.name==="call"&&node.arguments.length>=1||callee.property.name==="apply"&&node.arguments.length===2&&node.arguments[1].type==="ArrayExpression");}function isValidThisArg$1(expectedThis,thisArg,sourceCode){if(!expectedThis){return astUtils.isNullOrUndefined(thisArg);}return astUtils.equalTokens(expectedThis,thisArg,sourceCode);}var noUselessCall={meta:{type:"suggestion",docs:{description:"disallow unnecessary calls to `.call()` and `.apply()`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-useless-call"},schema:[],messages:{unnecessaryCall:"Unnecessary '.{{name}}()'."}},create(context){const sourceCode=context.getSourceCode();return {CallExpression(node){if(!isCallOrNonVariadicApply(node)){return;}const callee=astUtils.skipChainExpression(node.callee);const applied=astUtils.skipChainExpression(callee.object);const expectedThis=applied.type==="MemberExpression"?applied.object:null;const thisArg=node.arguments[0];if(isValidThisArg$1(expectedThis,thisArg,sourceCode)){context.report({node,messageId:"unnecessaryCall",data:{name:callee.property.name}});}}};}};var noUselessCatch={meta:{type:"suggestion",docs:{description:"disallow unnecessary `catch` clauses",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-useless-catch"},schema:[],messages:{unnecessaryCatchClause:"Unnecessary catch clause.",unnecessaryCatch:"Unnecessary try/catch wrapper."}},create(context){return {CatchClause(node){if(node.param&&node.param.type==="Identifier"&&node.body.body.length&&node.body.body[0].type==="ThrowStatement"&&node.body.body[0].argument.type==="Identifier"&&node.body.body[0].argument.name===node.param.name){if(node.parent.finalizer){context.report({node,messageId:"unnecessaryCatchClause"});}else {context.report({node:node.parent,messageId:"unnecessaryCatch"});}}}};}};var noUselessComputedKey={meta:{type:"suggestion",docs:{description:"disallow unnecessary computed property keys in objects and classes",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/no-useless-computed-key"},schema:[{type:"object",properties:{enforceForClassMembers:{type:"boolean",default:false}},additionalProperties:false}],fixable:"code",messages:{unnecessarilyComputedProperty:"Unnecessarily computed property [{{property}}] found."}},create(context){const sourceCode=context.getSourceCode();const enforceForClassMembers=context.options[0]&&context.options[0].enforceForClassMembers;function check(node){if(!node.computed){return;}const key=node.key,nodeType=typeof key.value;let allowedKey;if(node.type==="MethodDefinition"){allowedKey=node.static?"prototype":"constructor";}else {allowedKey="__proto__";}if(key.type==="Literal"&&(nodeType==="string"||nodeType==="number")&&key.value!==allowedKey){context.report({node,messageId:"unnecessarilyComputedProperty",data:{property:sourceCode.getText(key)},fix(fixer){const leftSquareBracket=sourceCode.getTokenBefore(key,astUtils.isOpeningBracketToken);const rightSquareBracket=sourceCode.getTokenAfter(key,astUtils.isClosingBracketToken);if(sourceCode.commentsExistBetween(leftSquareBracket,rightSquareBracket)){return null;}const tokenBeforeLeftBracket=sourceCode.getTokenBefore(leftSquareBracket);const needsSpaceBeforeKey=tokenBeforeLeftBracket.range[1]===leftSquareBracket.range[0]&&!astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket,sourceCode.getFirstToken(key));const replacementKey=(needsSpaceBeforeKey?" ":"")+key.raw;return fixer.replaceTextRange([leftSquareBracket.range[0],rightSquareBracket.range[1]],replacementKey);}});}}return {Property:check,MethodDefinition:enforceForClassMembers?check:lodash__default['default'].noop};}};function isConcatenation$1(node){return node.type==="BinaryExpression"&&node.operator==="+";}function isConcatOperatorToken(token){return token.value==="+"&&token.type==="Punctuator";}function getLeft(node){let left=node.left;while(isConcatenation$1(left)){left=left.right;}return left;}function getRight(node){let right=node.right;while(isConcatenation$1(right)){right=right.left;}return right;}var noUselessConcat={meta:{type:"suggestion",docs:{description:"disallow unnecessary concatenation of literals or template literals",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-useless-concat"},schema:[],messages:{unexpectedConcat:"Unexpected string concatenation of literals."}},create(context){const sourceCode=context.getSourceCode();return {BinaryExpression(node){if(node.operator!=="+"){return;}const left=getLeft(node);const right=getRight(node);if(astUtils.isStringLiteral(left)&&astUtils.isStringLiteral(right)&&astUtils.isTokenOnSameLine(left,right)){const operatorToken=sourceCode.getFirstTokenBetween(left,right,isConcatOperatorToken);context.report({node,loc:operatorToken.loc,messageId:"unexpectedConcat"});}}};}};function isSingleSuperCall(body){return body.length===1&&body[0].type==="ExpressionStatement"&&body[0].expression.type==="CallExpression"&&body[0].expression.callee.type==="Super";}function isSimple(node){return node.type==="Identifier"||node.type==="RestElement";}function isSpreadArguments(superArgs){return superArgs.length===1&&superArgs[0].type==="SpreadElement"&&superArgs[0].argument.type==="Identifier"&&superArgs[0].argument.name==="arguments";}function isValidIdentifierPair(ctorParam,superArg){return ctorParam.type==="Identifier"&&superArg.type==="Identifier"&&ctorParam.name===superArg.name;}function isValidRestSpreadPair(ctorParam,superArg){return ctorParam.type==="RestElement"&&superArg.type==="SpreadElement"&&isValidIdentifierPair(ctorParam.argument,superArg.argument);}function isValidPair(ctorParam,superArg){return isValidIdentifierPair(ctorParam,superArg)||isValidRestSpreadPair(ctorParam,superArg);}function isPassingThrough(ctorParams,superArgs){if(ctorParams.length!==superArgs.length){return false;}for(let i=0;i<ctorParams.length;++i){if(!isValidPair(ctorParams[i],superArgs[i])){return false;}}return true;}function isRedundantSuperCall(body,ctorParams){return isSingleSuperCall(body)&&ctorParams.every(isSimple)&&(isSpreadArguments(body[0].expression.arguments)||isPassingThrough(ctorParams,body[0].expression.arguments));}var noUselessConstructor={meta:{type:"suggestion",docs:{description:"disallow unnecessary constructors",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/no-useless-constructor"},schema:[],messages:{noUselessConstructor:"Useless constructor."}},create(context){return {MethodDefinition:function(node){if(node.kind!=="constructor"){return;}if(!node.value.body){return;}const body=node.value.body.body;const ctorParams=node.value.params;const superClass=node.parent.parent.superClass;if(superClass?isRedundantSuperCall(body,ctorParams):body.length===0){context.report({node,messageId:"noUselessConstructor"});}}};}};function union(setA,setB){return new Set(function*(){yield*setA;yield*setB;}());}const VALID_STRING_ESCAPES=union(new Set("\\nrvtbfux"),astUtils.LINEBREAKS);const REGEX_GENERAL_ESCAPES=new Set("\\bcdDfnpPrsStvwWxu0123456789]");const REGEX_NON_CHARCLASS_ESCAPES=union(REGEX_GENERAL_ESCAPES,new Set("^/.$*+?[{}|()Bk"));function parseRegExp(regExpText){const charList=[];regExpText.split("").reduce((state,char,index)=>{if(!state.escapeNextChar){if(char==="\\"){return Object.assign(state,{escapeNextChar:true});}if(char==="["&&!state.inCharClass){return Object.assign(state,{inCharClass:true,startingCharClass:true});}if(char==="]"&&state.inCharClass){if(charList.length&&charList[charList.length-1].inCharClass){charList[charList.length-1].endsCharClass=true;}return Object.assign(state,{inCharClass:false,startingCharClass:false});}}charList.push({text:char,index,escaped:state.escapeNextChar,inCharClass:state.inCharClass,startsCharClass:state.startingCharClass,endsCharClass:false});return Object.assign(state,{escapeNextChar:false,startingCharClass:false});},{escapeNextChar:false,inCharClass:false,startingCharClass:false});return charList;}var noUselessEscape={meta:{type:"suggestion",docs:{description:"disallow unnecessary escape characters",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-useless-escape",suggestion:true},messages:{unnecessaryEscape:"Unnecessary escape character: \\{{character}}.",removeEscape:"Remove the `\\`. This maintains the current functionality.",escapeBackslash:"Replace the `\\` with `\\\\` to include the actual backslash character."},schema:[]},create(context){const sourceCode=context.getSourceCode();function report(node,startOffset,character){const rangeStart=node.range[0]+startOffset;const range=[rangeStart,rangeStart+1];const start=sourceCode.getLocFromIndex(rangeStart);context.report({node,loc:{start,end:{line:start.line,column:start.column+1}},messageId:"unnecessaryEscape",data:{character},suggest:[{messageId:"removeEscape",fix(fixer){return fixer.removeRange(range);}},{messageId:"escapeBackslash",fix(fixer){return fixer.insertTextBeforeRange(range,"\\");}}]});}function validateString(node,match){const isTemplateElement=node.type==="TemplateElement";const escapedChar=match[0][1];let isUnnecessaryEscape=!VALID_STRING_ESCAPES.has(escapedChar);let isQuoteEscape;if(isTemplateElement){isQuoteEscape=escapedChar==="`";if(escapedChar==="$"){isUnnecessaryEscape=match.input[match.index+2]!=="{";}else if(escapedChar==="{"){isUnnecessaryEscape=match.input[match.index-1]!=="$";}}else {isQuoteEscape=escapedChar===node.raw[0];}if(isUnnecessaryEscape&&!isQuoteEscape){report(node,match.index,match[0].slice(1));}}function check(node){const isTemplateElement=node.type==="TemplateElement";if(isTemplateElement&&node.parent&&node.parent.parent&&node.parent.parent.type==="TaggedTemplateExpression"&&node.parent===node.parent.parent.quasi){return;}if(typeof node.value==="string"||isTemplateElement){if(node.parent.type==="JSXAttribute"||node.parent.type==="JSXElement"||node.parent.type==="JSXFragment"){return;}const value=isTemplateElement?sourceCode.getText(node):node.raw;let match;while(match=/\\[^\d]/gu.exec(value)){validateString(node,match);}}else if(node.regex){parseRegExp(node.regex.pattern).filter(charInfo=>!(charInfo.text==="-"&&charInfo.inCharClass&&!charInfo.startsCharClass&&!charInfo.endsCharClass)).filter(charInfo=>!(charInfo.text==="^"&&charInfo.startsCharClass)).filter(charInfo=>charInfo.escaped).filter(charInfo=>!(charInfo.inCharClass?REGEX_GENERAL_ESCAPES:REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text)).forEach(charInfo=>report(node,charInfo.index,charInfo.text));}}return {Literal:check,TemplateElement:check};}};var noUselessRename={meta:{type:"suggestion",docs:{description:"disallow renaming import, export, and destructured assignments to the same name",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/no-useless-rename"},fixable:"code",schema:[{type:"object",properties:{ignoreDestructuring:{type:"boolean",default:false},ignoreImport:{type:"boolean",default:false},ignoreExport:{type:"boolean",default:false}},additionalProperties:false}],messages:{unnecessarilyRenamed:"{{type}} {{name}} unnecessarily renamed."}},create(context){const sourceCode=context.getSourceCode(),options=context.options[0]||{},ignoreDestructuring=options.ignoreDestructuring===true,ignoreImport=options.ignoreImport===true,ignoreExport=options.ignoreExport===true;function reportError(node,initial,type){const name=initial.type==="Identifier"?initial.name:initial.value;return context.report({node,messageId:"unnecessarilyRenamed",data:{name,type},fix(fixer){const replacementNode=node.type==="Property"?node.value:node.local;if(sourceCode.getCommentsInside(node).length>sourceCode.getCommentsInside(replacementNode).length){return null;}if(replacementNode.type==="AssignmentPattern"&&astUtils.isParenthesised(sourceCode,replacementNode.left)){return null;}return fixer.replaceText(node,sourceCode.getText(replacementNode));}});}return {ObjectPattern:function(node){if(ignoreDestructuring){return;}for(const property of node.properties){if(property.type!=="Property"||property.shorthand||property.computed){continue;}const key=property.key.type==="Identifier"&&property.key.name||property.key.type==="Literal"&&property.key.value;const renamedKey=property.value.type==="AssignmentPattern"?property.value.left.name:property.value.name;if(key===renamedKey){reportError(property,property.key,"Destructuring assignment");}}},ImportSpecifier:function(node){if(ignoreImport){return;}if(node.imported.name===node.local.name&&node.imported.range[0]!==node.local.range[0]){reportError(node,node.imported,"Import");}},ExportSpecifier:function(node){if(ignoreExport){return;}if(node.local.name===node.exported.name&&node.local.range[0]!==node.exported.range[0]){reportError(node,node.local,"Export");}}};}};function remove(array,element){const index=array.indexOf(element);if(index!==-1){array.splice(index,1);}}function isRemovable(node){return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);}function isInFinally(node){for(let currentNode=node;currentNode&&currentNode.parent&&!astUtils.isFunction(currentNode);currentNode=currentNode.parent){if(currentNode.parent.type==="TryStatement"&&currentNode.parent.finalizer===currentNode){return true;}}return false;}var noUselessReturn={meta:{type:"suggestion",docs:{description:"disallow redundant return statements",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-useless-return"},fixable:"code",schema:[],messages:{unnecessaryReturn:"Unnecessary return statement."}},create(context){const segmentInfoMap=new WeakMap();const usedUnreachableSegments=new WeakSet();const sourceCode=context.getSourceCode();let scopeInfo=null;function isReturned(segment){const info=segmentInfoMap.get(segment);return !info||info.returned;}function getUselessReturns(uselessReturns,prevSegments,providedTraversedSegments){const traversedSegments=providedTraversedSegments||new WeakSet();for(const segment of prevSegments){if(!segment.reachable){if(!traversedSegments.has(segment)){traversedSegments.add(segment);getUselessReturns(uselessReturns,segment.allPrevSegments.filter(isReturned),traversedSegments);}continue;}uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);}return uselessReturns;}function markReturnStatementsOnSegmentAsUsed(segment){if(!segment.reachable){usedUnreachableSegments.add(segment);segment.allPrevSegments.filter(isReturned).filter(prevSegment=>!usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);return;}const info=segmentInfoMap.get(segment);for(const node of info.uselessReturns){remove(scopeInfo.uselessReturns,node);}info.uselessReturns=[];}function markReturnStatementsOnCurrentSegmentsAsUsed(){scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);}return {onCodePathStart(codePath){scopeInfo={upper:scopeInfo,uselessReturns:[],codePath};},onCodePathEnd(){for(const node of scopeInfo.uselessReturns){context.report({node,loc:node.loc,messageId:"unnecessaryReturn",fix(fixer){if(isRemovable(node)&&!sourceCode.getCommentsInside(node).length){return new fixTracker(fixer,sourceCode).retainEnclosingFunction(node).remove(node);}return null;}});}scopeInfo=scopeInfo.upper;},onCodePathSegmentStart(segment){const info={uselessReturns:getUselessReturns([],segment.allPrevSegments),returned:false};segmentInfoMap.set(segment,info);},ReturnStatement(node){if(node.argument){markReturnStatementsOnCurrentSegmentsAsUsed();}if(node.argument||astUtils.isInLoop(node)||isInFinally(node)||!scopeInfo.codePath.currentSegments.some(s=>s.reachable)){return;}for(const segment of scopeInfo.codePath.currentSegments){const info=segmentInfoMap.get(segment);if(info){info.uselessReturns.push(node);info.returned=true;}}scopeInfo.uselessReturns.push(node);},ClassDeclaration:markReturnStatementsOnCurrentSegmentsAsUsed,ContinueStatement:markReturnStatementsOnCurrentSegmentsAsUsed,DebuggerStatement:markReturnStatementsOnCurrentSegmentsAsUsed,DoWhileStatement:markReturnStatementsOnCurrentSegmentsAsUsed,EmptyStatement:markReturnStatementsOnCurrentSegmentsAsUsed,ExpressionStatement:markReturnStatementsOnCurrentSegmentsAsUsed,ForInStatement:markReturnStatementsOnCurrentSegmentsAsUsed,ForOfStatement:markReturnStatementsOnCurrentSegmentsAsUsed,ForStatement:markReturnStatementsOnCurrentSegmentsAsUsed,IfStatement:markReturnStatementsOnCurrentSegmentsAsUsed,ImportDeclaration:markReturnStatementsOnCurrentSegmentsAsUsed,LabeledStatement:markReturnStatementsOnCurrentSegmentsAsUsed,SwitchStatement:markReturnStatementsOnCurrentSegmentsAsUsed,ThrowStatement:markReturnStatementsOnCurrentSegmentsAsUsed,TryStatement:markReturnStatementsOnCurrentSegmentsAsUsed,VariableDeclaration:markReturnStatementsOnCurrentSegmentsAsUsed,WhileStatement:markReturnStatementsOnCurrentSegmentsAsUsed,WithStatement:markReturnStatementsOnCurrentSegmentsAsUsed,ExportNamedDeclaration:markReturnStatementsOnCurrentSegmentsAsUsed,ExportDefaultDeclaration:markReturnStatementsOnCurrentSegmentsAsUsed,ExportAllDeclaration:markReturnStatementsOnCurrentSegmentsAsUsed};}};function isGlobal(variable){return Boolean(variable.scope)&&variable.scope.type==="global";}function getEnclosingFunctionScope(scope){let currentScope=scope;while(currentScope.type!=="function"&&currentScope.type!=="global"){currentScope=currentScope.upper;}return currentScope;}function isReferencedInClosure(variable){const enclosingFunctionScope=getEnclosingFunctionScope(variable.scope);return variable.references.some(reference=>getEnclosingFunctionScope(reference.from)!==enclosingFunctionScope);}function isLoopAssignee(node){return (node.parent.type==="ForOfStatement"||node.parent.type==="ForInStatement")&&node===node.parent.left;}function isDeclarationInitialized(node){return node.declarations.every(declarator=>declarator.init!==null);}const SCOPE_NODE_TYPE=/^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;function getScopeNode(node){for(let currentNode=node;currentNode;currentNode=currentNode.parent){if(SCOPE_NODE_TYPE.test(currentNode.type)){return currentNode;}}return null;}function isRedeclared(variable){return variable.defs.length>=2;}function isUsedFromOutsideOf(scopeNode){function isOutsideOfScope(reference){const scope=scopeNode.range;const id=reference.identifier.range;return id[0]<scope[0]||id[1]>scope[1];}return function(variable){return variable.references.some(isOutsideOfScope);};}function hasReferenceInTDZ(node){const initStart=node.range[0];const initEnd=node.range[1];return variable=>{const id=variable.defs[0].name;const idStart=id.range[0];const defaultValue=id.parent.type==="AssignmentPattern"?id.parent.right:null;const defaultStart=defaultValue&&defaultValue.range[0];const defaultEnd=defaultValue&&defaultValue.range[1];return variable.references.some(reference=>{const start=reference.identifier.range[0];const end=reference.identifier.range[1];return !reference.init&&(start<idStart||defaultValue!==null&&start>=defaultStart&&end<=defaultEnd||start>=initStart&&end<=initEnd);});};}function hasNameDisallowedForLetDeclarations(variable){return variable.name==="let";}var noVar={meta:{type:"suggestion",docs:{description:"require `let` or `const` instead of `var`",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/no-var"},schema:[],fixable:"code",messages:{unexpectedVar:"Unexpected var, use let or const instead."}},create(context){const sourceCode=context.getSourceCode();function hasSelfReferenceInTDZ(declarator){if(!declarator.init){return false;}const variables=context.getDeclaredVariables(declarator);return variables.some(hasReferenceInTDZ(declarator.init));}function canFix(node){const variables=context.getDeclaredVariables(node);const scopeNode=getScopeNode(node);if(node.parent.type==="SwitchCase"||node.declarations.some(hasSelfReferenceInTDZ)||variables.some(isGlobal)||variables.some(isRedeclared)||variables.some(isUsedFromOutsideOf(scopeNode))||variables.some(hasNameDisallowedForLetDeclarations)){return false;}if(astUtils.isInLoop(node)){if(variables.some(isReferencedInClosure)){return false;}if(!isLoopAssignee(node)&&!isDeclarationInitialized(node)){return false;}}if(!isLoopAssignee(node)&&!(node.parent.type==="ForStatement"&&node.parent.init===node)&&!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)){return false;}return true;}function report(node){context.report({node,messageId:"unexpectedVar",fix(fixer){const varToken=sourceCode.getFirstToken(node,{filter:t=>t.value==="var"});return canFix(node)?fixer.replaceText(varToken,"let"):null;}});}return {"VariableDeclaration:exit"(node){if(node.kind==="var"){report(node);}}};}};var noVoid={meta:{type:"suggestion",docs:{description:"disallow `void` operators",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-void"},messages:{noVoid:"Expected 'undefined' and instead saw 'void'."},schema:[{type:"object",properties:{allowAsStatement:{type:"boolean",default:false}},additionalProperties:false}]},create(context){const allowAsStatement=context.options[0]&&context.options[0].allowAsStatement;return {'UnaryExpression[operator="void"]'(node){if(allowAsStatement&&node.parent&&node.parent.type==="ExpressionStatement"){return;}context.report({node,messageId:"noVoid"});}};}};const{escapeRegExp}=lodash__default['default'];const CHAR_LIMIT=40;var noWarningComments={meta:{type:"suggestion",docs:{description:"disallow specified warning terms in comments",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/no-warning-comments"},schema:[{type:"object",properties:{terms:{type:"array",items:{type:"string"}},location:{enum:["start","anywhere"]}},additionalProperties:false}],messages:{unexpectedComment:"Unexpected '{{matchedTerm}}' comment: '{{comment}}'."}},create(context){const sourceCode=context.getSourceCode(),configuration=context.options[0]||{},warningTerms=configuration.terms||["todo","fixme","xxx"],location=configuration.location||"start";const warningRegExps=warningTerms.map(function(term){const escaped=escapeRegExp(term);let prefix;const suffix=/\w$/u.test(term)?"\\b":"";if(location==="start"){prefix="^\\s*";}else if(/^\w/u.test(term)){prefix="\\b";}else {prefix="";}if(location==="start"){return new RegExp(prefix+escaped+suffix,"iu");}return new RegExp(prefix+escaped+suffix+"|\\b"+term+"\\b","iu");});function commentContainsWarningTerm(comment){const matches=[];warningRegExps.forEach((regex,index)=>{if(regex.test(comment)){matches.push(warningTerms[index]);}});return matches;}function checkComment(node){const comment=node.value;if(astUtils.isDirectiveComment(node)&&/\bno-warning-comments\b/u.test(comment)){return;}const matches=commentContainsWarningTerm(comment);matches.forEach(matchedTerm=>{let commentToDisplay="";let truncated=false;for(const c of comment.trim().split(/\s+/u)){const tmp=commentToDisplay?`${commentToDisplay} ${c}`:c;if(tmp.length<=CHAR_LIMIT){commentToDisplay=tmp;}else {truncated=true;break;}}context.report({node,messageId:"unexpectedComment",data:{matchedTerm,comment:`${commentToDisplay}${truncated?"...":""}`}});});}return {Program(){const comments=sourceCode.getAllComments();comments.filter(token=>token.type!=="Shebang").forEach(checkComment);}};}};var noWhitespaceBeforeProperty={meta:{type:"layout",docs:{description:"disallow whitespace before properties",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/no-whitespace-before-property"},fixable:"whitespace",schema:[],messages:{unexpectedWhitespace:"Unexpected whitespace before property {{propName}}."}},create(context){const sourceCode=context.getSourceCode();function reportError(node,leftToken,rightToken){context.report({node,messageId:"unexpectedWhitespace",data:{propName:sourceCode.getText(node.property)},fix(fixer){let replacementText="";if(!node.computed&&!node.optional&&astUtils.isDecimalInteger(node.object)){return null;}if(sourceCode.commentsExistBetween(leftToken,rightToken)){return null;}if(node.optional){replacementText="?.";}else if(!node.computed){replacementText=".";}return fixer.replaceTextRange([leftToken.range[1],rightToken.range[0]],replacementText);}});}return {MemberExpression(node){let rightToken;let leftToken;if(!astUtils.isTokenOnSameLine(node.object,node.property)){return;}if(node.computed){rightToken=sourceCode.getTokenBefore(node.property,astUtils.isOpeningBracketToken);leftToken=sourceCode.getTokenBefore(rightToken,node.optional?1:0);}else {rightToken=sourceCode.getFirstToken(node.property);leftToken=sourceCode.getTokenBefore(rightToken,1);}if(sourceCode.isSpaceBetweenTokens(leftToken,rightToken)){reportError(node,leftToken,rightToken);}}};}};var noWith={meta:{type:"suggestion",docs:{description:"disallow `with` statements",category:"Best Practices",recommended:true,url:"https://eslint.org/docs/rules/no-with"},schema:[],messages:{unexpectedWith:"Unexpected use of 'with' statement."}},create(context){return {WithStatement(node){context.report({node,messageId:"unexpectedWith"});}};}};const POSITION_SCHEMA={enum:["beside","below","any"]};var nonblockStatementBodyPosition={meta:{type:"layout",docs:{description:"enforce the location of single-line statements",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/nonblock-statement-body-position"},fixable:"whitespace",schema:[POSITION_SCHEMA,{properties:{overrides:{properties:{if:POSITION_SCHEMA,else:POSITION_SCHEMA,while:POSITION_SCHEMA,do:POSITION_SCHEMA,for:POSITION_SCHEMA},additionalProperties:false}},additionalProperties:false}],messages:{expectNoLinebreak:"Expected no linebreak before this statement.",expectLinebreak:"Expected a linebreak before this statement."}},create(context){const sourceCode=context.getSourceCode();function getOption(keywordName){return context.options[1]&&context.options[1].overrides&&context.options[1].overrides[keywordName]||context.options[0]||"beside";}function validateStatement(node,keywordName){const option=getOption(keywordName);if(node.type==="BlockStatement"||option==="any"){return;}const tokenBefore=sourceCode.getTokenBefore(node);if(tokenBefore.loc.end.line===node.loc.start.line&&option==="below"){context.report({node,messageId:"expectLinebreak",fix:fixer=>fixer.insertTextBefore(node,"\n")});}else if(tokenBefore.loc.end.line!==node.loc.start.line&&option==="beside"){context.report({node,messageId:"expectNoLinebreak",fix(fixer){if(sourceCode.getText().slice(tokenBefore.range[1],node.range[0]).trim()){return null;}return fixer.replaceTextRange([tokenBefore.range[1],node.range[0]]," ");}});}}return {IfStatement(node){validateStatement(node.consequent,"if");if(node.alternate&&node.alternate.type!=="IfStatement"){validateStatement(node.alternate,"else");}},WhileStatement:node=>validateStatement(node.body,"while"),DoWhileStatement:node=>validateStatement(node.body,"do"),ForStatement:node=>validateStatement(node.body,"for"),ForInStatement:node=>validateStatement(node.body,"for"),ForOfStatement:node=>validateStatement(node.body,"for")};}};const OPTION_VALUE={oneOf:[{enum:["always","never"]},{type:"object",properties:{multiline:{type:"boolean"},minProperties:{type:"integer",minimum:0},consistent:{type:"boolean"}},additionalProperties:false,minProperties:1}]};function normalizeOptionValue(value){let multiline=false;let minProperties=Number.POSITIVE_INFINITY;let consistent=false;if(value){if(value==="always"){minProperties=0;}else if(value==="never"){minProperties=Number.POSITIVE_INFINITY;}else {multiline=Boolean(value.multiline);minProperties=value.minProperties||Number.POSITIVE_INFINITY;consistent=Boolean(value.consistent);}}else {consistent=true;}return {multiline,minProperties,consistent};}function normalizeOptions(options){const isNodeSpecificOption=lodash__default['default'].overSome([lodash__default['default'].isPlainObject,lodash__default['default'].isString]);if(lodash__default['default'].isPlainObject(options)&&Object.values(options).some(isNodeSpecificOption)){return {ObjectExpression:normalizeOptionValue(options.ObjectExpression),ObjectPattern:normalizeOptionValue(options.ObjectPattern),ImportDeclaration:normalizeOptionValue(options.ImportDeclaration),ExportNamedDeclaration:normalizeOptionValue(options.ExportDeclaration)};}const value=normalizeOptionValue(options);return {ObjectExpression:value,ObjectPattern:value,ImportDeclaration:value,ExportNamedDeclaration:value};}function areLineBreaksRequired(node,options,first,last){let objectProperties;if(node.type==="ObjectExpression"||node.type==="ObjectPattern"){objectProperties=node.properties;}else {objectProperties=node.specifiers.filter(s=>s.type==="ImportSpecifier"||s.type==="ExportSpecifier");}return objectProperties.length>=options.minProperties||options.multiline&&objectProperties.length>0&&first.loc.start.line!==last.loc.end.line;}var objectCurlyNewline={meta:{type:"layout",docs:{description:"enforce consistent line breaks after opening and before closing braces",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/object-curly-newline"},fixable:"whitespace",schema:[{oneOf:[OPTION_VALUE,{type:"object",properties:{ObjectExpression:OPTION_VALUE,ObjectPattern:OPTION_VALUE,ImportDeclaration:OPTION_VALUE,ExportDeclaration:OPTION_VALUE},additionalProperties:false,minProperties:1}]}],messages:{unexpectedLinebreakBeforeClosingBrace:"Unexpected line break before this closing brace.",unexpectedLinebreakAfterOpeningBrace:"Unexpected line break after this opening brace.",expectedLinebreakBeforeClosingBrace:"Expected a line break before this closing brace.",expectedLinebreakAfterOpeningBrace:"Expected a line break after this opening brace."}},create(context){const sourceCode=context.getSourceCode();const normalizedOptions=normalizeOptions(context.options[0]);function check(node){const options=normalizedOptions[node.type];if(node.type==="ImportDeclaration"&&!node.specifiers.some(specifier=>specifier.type==="ImportSpecifier")||node.type==="ExportNamedDeclaration"&&!node.specifiers.some(specifier=>specifier.type==="ExportSpecifier")){return;}const openBrace=sourceCode.getFirstToken(node,token=>token.value==="{");let closeBrace;if(node.typeAnnotation){closeBrace=sourceCode.getTokenBefore(node.typeAnnotation);}else {closeBrace=sourceCode.getLastToken(node,token=>token.value==="}");}let first=sourceCode.getTokenAfter(openBrace,{includeComments:true});let last=sourceCode.getTokenBefore(closeBrace,{includeComments:true});const needsLineBreaks=areLineBreaksRequired(node,options,first,last);const hasCommentsFirstToken=astUtils.isCommentToken(first);const hasCommentsLastToken=astUtils.isCommentToken(last);first=sourceCode.getTokenAfter(openBrace);last=sourceCode.getTokenBefore(closeBrace);if(needsLineBreaks){if(astUtils.isTokenOnSameLine(openBrace,first)){context.report({messageId:"expectedLinebreakAfterOpeningBrace",node,loc:openBrace.loc,fix(fixer){if(hasCommentsFirstToken){return null;}return fixer.insertTextAfter(openBrace,"\n");}});}if(astUtils.isTokenOnSameLine(last,closeBrace)){context.report({messageId:"expectedLinebreakBeforeClosingBrace",node,loc:closeBrace.loc,fix(fixer){if(hasCommentsLastToken){return null;}return fixer.insertTextBefore(closeBrace,"\n");}});}}else {const consistent=options.consistent;const hasLineBreakBetweenOpenBraceAndFirst=!astUtils.isTokenOnSameLine(openBrace,first);const hasLineBreakBetweenCloseBraceAndLast=!astUtils.isTokenOnSameLine(last,closeBrace);if(!consistent&&hasLineBreakBetweenOpenBraceAndFirst||consistent&&hasLineBreakBetweenOpenBraceAndFirst&&!hasLineBreakBetweenCloseBraceAndLast){context.report({messageId:"unexpectedLinebreakAfterOpeningBrace",node,loc:openBrace.loc,fix(fixer){if(hasCommentsFirstToken){return null;}return fixer.removeRange([openBrace.range[1],first.range[0]]);}});}if(!consistent&&hasLineBreakBetweenCloseBraceAndLast||consistent&&!hasLineBreakBetweenOpenBraceAndFirst&&hasLineBreakBetweenCloseBraceAndLast){context.report({messageId:"unexpectedLinebreakBeforeClosingBrace",node,loc:closeBrace.loc,fix(fixer){if(hasCommentsLastToken){return null;}return fixer.removeRange([last.range[1],closeBrace.range[0]]);}});}}}return {ObjectExpression:check,ObjectPattern:check,ImportDeclaration:check,ExportNamedDeclaration:check};}};var objectCurlySpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing inside braces",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/object-curly-spacing"},fixable:"whitespace",schema:[{enum:["always","never"]},{type:"object",properties:{arraysInObjects:{type:"boolean"},objectsInObjects:{type:"boolean"}},additionalProperties:false}],messages:{requireSpaceBefore:"A space is required before '{{token}}'.",requireSpaceAfter:"A space is required after '{{token}}'.",unexpectedSpaceBefore:"There should be no space before '{{token}}'.",unexpectedSpaceAfter:"There should be no space after '{{token}}'."}},create(context){const spaced=context.options[0]==="always",sourceCode=context.getSourceCode();function isOptionSet(option){return context.options[1]?context.options[1][option]===!spaced:false;}const options={spaced,arraysInObjectsException:isOptionSet("arraysInObjects"),objectsInObjectsException:isOptionSet("objectsInObjects")};function reportNoBeginningSpace(node,token){const nextToken=context.getSourceCode().getTokenAfter(token,{includeComments:true});context.report({node,loc:{start:token.loc.end,end:nextToken.loc.start},messageId:"unexpectedSpaceAfter",data:{token:token.value},fix(fixer){return fixer.removeRange([token.range[1],nextToken.range[0]]);}});}function reportNoEndingSpace(node,token){const previousToken=context.getSourceCode().getTokenBefore(token,{includeComments:true});context.report({node,loc:{start:previousToken.loc.end,end:token.loc.start},messageId:"unexpectedSpaceBefore",data:{token:token.value},fix(fixer){return fixer.removeRange([previousToken.range[1],token.range[0]]);}});}function reportRequiredBeginningSpace(node,token){context.report({node,loc:token.loc,messageId:"requireSpaceAfter",data:{token:token.value},fix(fixer){return fixer.insertTextAfter(token," ");}});}function reportRequiredEndingSpace(node,token){context.report({node,loc:token.loc,messageId:"requireSpaceBefore",data:{token:token.value},fix(fixer){return fixer.insertTextBefore(token," ");}});}function validateBraceSpacing(node,first,second,penultimate,last){if(astUtils.isTokenOnSameLine(first,second)){const firstSpaced=sourceCode.isSpaceBetweenTokens(first,second);if(options.spaced&&!firstSpaced){reportRequiredBeginningSpace(node,first);}if(!options.spaced&&firstSpaced&&second.type!=="Line"){reportNoBeginningSpace(node,first);}}if(astUtils.isTokenOnSameLine(penultimate,last)){const shouldCheckPenultimate=options.arraysInObjectsException&&astUtils.isClosingBracketToken(penultimate)||options.objectsInObjectsException&&astUtils.isClosingBraceToken(penultimate);const penultimateType=shouldCheckPenultimate&&sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;const closingCurlyBraceMustBeSpaced=options.arraysInObjectsException&&penultimateType==="ArrayExpression"||options.objectsInObjectsException&&(penultimateType==="ObjectExpression"||penultimateType==="ObjectPattern")?!options.spaced:options.spaced;const lastSpaced=sourceCode.isSpaceBetweenTokens(penultimate,last);if(closingCurlyBraceMustBeSpaced&&!lastSpaced){reportRequiredEndingSpace(node,last);}if(!closingCurlyBraceMustBeSpaced&&lastSpaced){reportNoEndingSpace(node,last);}}}function getClosingBraceOfObject(node){const lastProperty=node.properties[node.properties.length-1];return sourceCode.getTokenAfter(lastProperty,astUtils.isClosingBraceToken);}function checkForObject(node){if(node.properties.length===0){return;}const first=sourceCode.getFirstToken(node),last=getClosingBraceOfObject(node),second=sourceCode.getTokenAfter(first,{includeComments:true}),penultimate=sourceCode.getTokenBefore(last,{includeComments:true});validateBraceSpacing(node,first,second,penultimate,last);}return {ObjectPattern:checkForObject,ObjectExpression:checkForObject,ImportDeclaration:function(node){if(node.specifiers.length===0){return;}let firstSpecifier=node.specifiers[0];const lastSpecifier=node.specifiers[node.specifiers.length-1];if(lastSpecifier.type!=="ImportSpecifier"){return;}if(firstSpecifier.type!=="ImportSpecifier"){firstSpecifier=node.specifiers[1];}const first=sourceCode.getTokenBefore(firstSpecifier),last=sourceCode.getTokenAfter(lastSpecifier,astUtils.isNotCommaToken),second=sourceCode.getTokenAfter(first,{includeComments:true}),penultimate=sourceCode.getTokenBefore(last,{includeComments:true});validateBraceSpacing(node,first,second,penultimate,last);},ExportNamedDeclaration:function(node){if(node.specifiers.length===0){return;}const firstSpecifier=node.specifiers[0],lastSpecifier=node.specifiers[node.specifiers.length-1],first=sourceCode.getTokenBefore(firstSpecifier),last=sourceCode.getTokenAfter(lastSpecifier,astUtils.isNotCommaToken),second=sourceCode.getTokenAfter(first,{includeComments:true}),penultimate=sourceCode.getTokenBefore(last,{includeComments:true});validateBraceSpacing(node,first,second,penultimate,last);}};}};var objectPropertyNewline={meta:{type:"layout",docs:{description:"enforce placing object properties on separate lines",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/object-property-newline"},schema:[{type:"object",properties:{allowAllPropertiesOnSameLine:{type:"boolean",default:false},allowMultiplePropertiesPerLine:{type:"boolean",default:false}},additionalProperties:false}],fixable:"whitespace",messages:{propertiesOnNewlineAll:"Object properties must go on a new line if they aren't all on the same line.",propertiesOnNewline:"Object properties must go on a new line."}},create(context){const allowSameLine=context.options[0]&&(context.options[0].allowAllPropertiesOnSameLine||context.options[0].allowMultiplePropertiesPerLine);const messageId=allowSameLine?"propertiesOnNewlineAll":"propertiesOnNewline";const sourceCode=context.getSourceCode();return {ObjectExpression(node){if(allowSameLine){if(node.properties.length>1){const firstTokenOfFirstProperty=sourceCode.getFirstToken(node.properties[0]);const lastTokenOfLastProperty=sourceCode.getLastToken(node.properties[node.properties.length-1]);if(firstTokenOfFirstProperty.loc.end.line===lastTokenOfLastProperty.loc.start.line){return;}}}for(let i=1;i<node.properties.length;i++){const lastTokenOfPreviousProperty=sourceCode.getLastToken(node.properties[i-1]);const firstTokenOfCurrentProperty=sourceCode.getFirstToken(node.properties[i]);if(lastTokenOfPreviousProperty.loc.end.line===firstTokenOfCurrentProperty.loc.start.line){context.report({node,loc:firstTokenOfCurrentProperty.loc,messageId,fix(fixer){const comma=sourceCode.getTokenBefore(firstTokenOfCurrentProperty);const rangeAfterComma=[comma.range[1],firstTokenOfCurrentProperty.range[0]];if(sourceCode.text.slice(rangeAfterComma[0],rangeAfterComma[1]).trim()){return null;}return fixer.replaceTextRange(rangeAfterComma,"\n");}});}}}};}};const OPTIONS={always:"always",never:"never",methods:"methods",properties:"properties",consistent:"consistent",consistentAsNeeded:"consistent-as-needed"};var objectShorthand={meta:{type:"suggestion",docs:{description:"require or disallow method and property shorthand syntax for object literals",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/object-shorthand"},fixable:"code",schema:{anyOf:[{type:"array",items:[{enum:["always","methods","properties","never","consistent","consistent-as-needed"]}],minItems:0,maxItems:1},{type:"array",items:[{enum:["always","methods","properties"]},{type:"object",properties:{avoidQuotes:{type:"boolean"}},additionalProperties:false}],minItems:0,maxItems:2},{type:"array",items:[{enum:["always","methods"]},{type:"object",properties:{ignoreConstructors:{type:"boolean"},avoidQuotes:{type:"boolean"},avoidExplicitReturnArrows:{type:"boolean"}},additionalProperties:false}],minItems:0,maxItems:2}]},messages:{expectedAllPropertiesShorthanded:"Expected shorthand for all properties.",expectedLiteralMethodLongform:"Expected longform method syntax for string literal keys.",expectedPropertyShorthand:"Expected property shorthand.",expectedPropertyLongform:"Expected longform property syntax.",expectedMethodShorthand:"Expected method shorthand.",expectedMethodLongform:"Expected longform method syntax.",unexpectedMix:"Unexpected mix of shorthand and non-shorthand properties."}},create(context){const APPLY=context.options[0]||OPTIONS.always;const APPLY_TO_METHODS=APPLY===OPTIONS.methods||APPLY===OPTIONS.always;const APPLY_TO_PROPS=APPLY===OPTIONS.properties||APPLY===OPTIONS.always;const APPLY_NEVER=APPLY===OPTIONS.never;const APPLY_CONSISTENT=APPLY===OPTIONS.consistent;const APPLY_CONSISTENT_AS_NEEDED=APPLY===OPTIONS.consistentAsNeeded;const PARAMS=context.options[1]||{};const IGNORE_CONSTRUCTORS=PARAMS.ignoreConstructors;const AVOID_QUOTES=PARAMS.avoidQuotes;const AVOID_EXPLICIT_RETURN_ARROWS=!!PARAMS.avoidExplicitReturnArrows;const sourceCode=context.getSourceCode();function isConstructor(name){const match=/[^_$0-9]/u.exec(name);if(!match){return false;}const firstChar=name.charAt(match.index);return firstChar===firstChar.toUpperCase();}function canHaveShorthand(property){return property.kind!=="set"&&property.kind!=="get"&&property.type!=="SpreadElement"&&property.type!=="SpreadProperty"&&property.type!=="ExperimentalSpreadProperty";}function isStringLiteral(node){return node.type==="Literal"&&typeof node.value==="string";}function isShorthand(property){return property.shorthand||property.method;}function isRedundant(property){const value=property.value;if(value.type==="FunctionExpression"){return !value.id;}if(value.type==="Identifier"){return astUtils.getStaticPropertyName(property)===value.name;}return false;}function checkConsistency(node,checkRedundancy){const properties=node.properties.filter(canHaveShorthand);if(properties.length>0){const shorthandProperties=properties.filter(isShorthand);if(shorthandProperties.length!==properties.length){if(shorthandProperties.length>0){context.report({node,messageId:"unexpectedMix"});}else if(checkRedundancy){const canAlwaysUseShorthand=properties.every(isRedundant);if(canAlwaysUseShorthand){context.report({node,messageId:"expectedAllPropertiesShorthanded"});}}}}}function makeFunctionShorthand(fixer,node){const firstKeyToken=node.computed?sourceCode.getFirstToken(node,astUtils.isOpeningBracketToken):sourceCode.getFirstToken(node.key);const lastKeyToken=node.computed?sourceCode.getFirstTokenBetween(node.key,node.value,astUtils.isClosingBracketToken):sourceCode.getLastToken(node.key);const keyText=sourceCode.text.slice(firstKeyToken.range[0],lastKeyToken.range[1]);let keyPrefix="";if(sourceCode.commentsExistBetween(lastKeyToken,node.value)){return null;}if(node.value.async){keyPrefix+="async ";}if(node.value.generator){keyPrefix+="*";}const fixRange=[firstKeyToken.range[0],node.range[1]];const methodPrefix=keyPrefix+keyText;if(node.value.type==="FunctionExpression"){const functionToken=sourceCode.getTokens(node.value).find(token=>token.type==="Keyword"&&token.value==="function");const tokenBeforeParams=node.value.generator?sourceCode.getTokenAfter(functionToken):functionToken;return fixer.replaceTextRange(fixRange,methodPrefix+sourceCode.text.slice(tokenBeforeParams.range[1],node.value.range[1]));}const arrowToken=sourceCode.getTokenBefore(node.value.body,astUtils.isArrowToken);const fnBody=sourceCode.text.slice(arrowToken.range[1],node.value.range[1]);let shouldAddParensAroundParameters=false;let tokenBeforeParams;if(node.value.params.length===0){tokenBeforeParams=sourceCode.getFirstToken(node.value,astUtils.isOpeningParenToken);}else {tokenBeforeParams=sourceCode.getTokenBefore(node.value.params[0]);}if(node.value.params.length===1){const hasParen=astUtils.isOpeningParenToken(tokenBeforeParams);const isTokenOutsideNode=tokenBeforeParams.range[0]<node.range[0];shouldAddParensAroundParameters=!hasParen||isTokenOutsideNode;}const sliceStart=shouldAddParensAroundParameters?node.value.params[0].range[0]:tokenBeforeParams.range[0];const sliceEnd=sourceCode.getTokenBefore(arrowToken).range[1];const oldParamText=sourceCode.text.slice(sliceStart,sliceEnd);const newParamText=shouldAddParensAroundParameters?`(${oldParamText})`:oldParamText;return fixer.replaceTextRange(fixRange,methodPrefix+newParamText+fnBody);}function makeFunctionLongform(fixer,node){const firstKeyToken=node.computed?sourceCode.getTokens(node).find(token=>token.value==="["):sourceCode.getFirstToken(node.key);const lastKeyToken=node.computed?sourceCode.getTokensBetween(node.key,node.value).find(token=>token.value==="]"):sourceCode.getLastToken(node.key);const keyText=sourceCode.text.slice(firstKeyToken.range[0],lastKeyToken.range[1]);let functionHeader="function";if(node.value.async){functionHeader=`async ${functionHeader}`;}if(node.value.generator){functionHeader=`${functionHeader}*`;}return fixer.replaceTextRange([node.range[0],lastKeyToken.range[1]],`${keyText}: ${functionHeader}`);}const lexicalScopeStack=[];const arrowsWithLexicalIdentifiers=new WeakSet();const argumentsIdentifiers=new WeakSet();function enterFunction(){lexicalScopeStack.unshift(new Set());context.getScope().variables.filter(variable=>variable.name==="arguments").forEach(variable=>{variable.references.map(ref=>ref.identifier).forEach(identifier=>argumentsIdentifiers.add(identifier));});}function exitFunction(){lexicalScopeStack.shift();}function reportLexicalIdentifier(){lexicalScopeStack[0].forEach(arrowFunction=>arrowsWithLexicalIdentifiers.add(arrowFunction));}return {Program:enterFunction,FunctionDeclaration:enterFunction,FunctionExpression:enterFunction,"Program:exit":exitFunction,"FunctionDeclaration:exit":exitFunction,"FunctionExpression:exit":exitFunction,ArrowFunctionExpression(node){lexicalScopeStack[0].add(node);},"ArrowFunctionExpression:exit"(node){lexicalScopeStack[0].delete(node);},ThisExpression:reportLexicalIdentifier,Super:reportLexicalIdentifier,MetaProperty(node){if(node.meta.name==="new"&&node.property.name==="target"){reportLexicalIdentifier();}},Identifier(node){if(argumentsIdentifiers.has(node)){reportLexicalIdentifier();}},ObjectExpression(node){if(APPLY_CONSISTENT){checkConsistency(node,false);}else if(APPLY_CONSISTENT_AS_NEEDED){checkConsistency(node,true);}},"Property:exit"(node){const isConciseProperty=node.method||node.shorthand;if(node.parent.type==="ObjectPattern"){return;}if(node.kind==="get"||node.kind==="set"){return;}if(node.computed&&node.value.type!=="FunctionExpression"&&node.value.type!=="ArrowFunctionExpression"){return;}if(isConciseProperty){if(node.method&&(APPLY_NEVER||AVOID_QUOTES&&isStringLiteral(node.key))){const messageId=APPLY_NEVER?"expectedMethodLongform":"expectedLiteralMethodLongform";context.report({node,messageId,fix:fixer=>makeFunctionLongform(fixer,node)});}else if(APPLY_NEVER){context.report({node,messageId:"expectedPropertyLongform",fix:fixer=>fixer.insertTextAfter(node.key,`: ${node.key.name}`)});}}else if(APPLY_TO_METHODS&&!node.value.id&&(node.value.type==="FunctionExpression"||node.value.type==="ArrowFunctionExpression")){if(IGNORE_CONSTRUCTORS&&node.key.type==="Identifier"&&isConstructor(node.key.name)){return;}if(AVOID_QUOTES&&isStringLiteral(node.key)){return;}if(node.value.type==="FunctionExpression"||node.value.type==="ArrowFunctionExpression"&&node.value.body.type==="BlockStatement"&&AVOID_EXPLICIT_RETURN_ARROWS&&!arrowsWithLexicalIdentifiers.has(node.value)){context.report({node,messageId:"expectedMethodShorthand",fix:fixer=>makeFunctionShorthand(fixer,node)});}}else if(node.value.type==="Identifier"&&node.key.name===node.value.name&&APPLY_TO_PROPS){context.report({node,messageId:"expectedPropertyShorthand",fix(fixer){return fixer.replaceText(node,node.value.name);}});}else if(node.value.type==="Identifier"&&node.key.type==="Literal"&&node.key.value===node.value.name&&APPLY_TO_PROPS){if(AVOID_QUOTES){return;}context.report({node,messageId:"expectedPropertyShorthand",fix(fixer){return fixer.replaceText(node,node.value.name);}});}}};}};var oneVarDeclarationPerLine={meta:{type:"suggestion",docs:{description:"require or disallow newlines around variable declarations",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/one-var-declaration-per-line"},schema:[{enum:["always","initializations"]}],fixable:"whitespace",messages:{expectVarOnNewline:"Expected variable declaration to be on a new line."}},create(context){const always=context.options[0]==="always";function isForTypeSpecifier(keyword){return keyword==="ForStatement"||keyword==="ForInStatement"||keyword==="ForOfStatement";}return {VariableDeclaration:function(node){if(isForTypeSpecifier(node.parent.type)){return;}const declarations=node.declarations;let prev;declarations.forEach(current=>{if(prev&&prev.loc.end.line===current.loc.start.line){if(always||prev.init||current.init){context.report({node,messageId:"expectVarOnNewline",loc:current.loc,fix:fixer=>fixer.insertTextBefore(current,"\n")});}}prev=current;});}};}};function isInStatementList(node){return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);}var oneVar={meta:{type:"suggestion",docs:{description:"enforce variables to be declared either together or separately in functions",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/one-var"},fixable:"code",schema:[{oneOf:[{enum:["always","never","consecutive"]},{type:"object",properties:{separateRequires:{type:"boolean"},var:{enum:["always","never","consecutive"]},let:{enum:["always","never","consecutive"]},const:{enum:["always","never","consecutive"]}},additionalProperties:false},{type:"object",properties:{initialized:{enum:["always","never","consecutive"]},uninitialized:{enum:["always","never","consecutive"]}},additionalProperties:false}]}],messages:{combineUninitialized:"Combine this with the previous '{{type}}' statement with uninitialized variables.",combineInitialized:"Combine this with the previous '{{type}}' statement with initialized variables.",splitUninitialized:"Split uninitialized '{{type}}' declarations into multiple statements.",splitInitialized:"Split initialized '{{type}}' declarations into multiple statements.",splitRequires:"Split requires to be separated into a single block.",combine:"Combine this with the previous '{{type}}' statement.",split:"Split '{{type}}' declarations into multiple statements."}},create(context){const MODE_ALWAYS="always";const MODE_NEVER="never";const MODE_CONSECUTIVE="consecutive";const mode=context.options[0]||"always";const options={};if(typeof mode==="string"){options.var={uninitialized:mode,initialized:mode};options.let={uninitialized:mode,initialized:mode};options.const={uninitialized:mode,initialized:mode};}else if(typeof mode==="object"){options.separateRequires=!!mode.separateRequires;options.var={uninitialized:mode.var,initialized:mode.var};options.let={uninitialized:mode.let,initialized:mode.let};options.const={uninitialized:mode.const,initialized:mode.const};if(Object.prototype.hasOwnProperty.call(mode,"uninitialized")){options.var.uninitialized=mode.uninitialized;options.let.uninitialized=mode.uninitialized;options.const.uninitialized=mode.uninitialized;}if(Object.prototype.hasOwnProperty.call(mode,"initialized")){options.var.initialized=mode.initialized;options.let.initialized=mode.initialized;options.const.initialized=mode.initialized;}}const sourceCode=context.getSourceCode();const functionStack=[];const blockStack=[];function startBlock(){blockStack.push({let:{initialized:false,uninitialized:false},const:{initialized:false,uninitialized:false}});}function startFunction(){functionStack.push({initialized:false,uninitialized:false});startBlock();}function endBlock(){blockStack.pop();}function endFunction(){functionStack.pop();endBlock();}function isRequire(decl){return decl.init&&decl.init.type==="CallExpression"&&decl.init.callee.name==="require";}function recordTypes(statementType,declarations,currentScope){for(let i=0;i<declarations.length;i++){if(declarations[i].init===null){if(options[statementType]&&options[statementType].uninitialized===MODE_ALWAYS){currentScope.uninitialized=true;}}else {if(options[statementType]&&options[statementType].initialized===MODE_ALWAYS){if(options.separateRequires&&isRequire(declarations[i])){currentScope.required=true;}else {currentScope.initialized=true;}}}}}function getCurrentScope(statementType){let currentScope;if(statementType==="var"){currentScope=functionStack[functionStack.length-1];}else if(statementType==="let"){currentScope=blockStack[blockStack.length-1].let;}else if(statementType==="const"){currentScope=blockStack[blockStack.length-1].const;}return currentScope;}function countDeclarations(declarations){const counts={uninitialized:0,initialized:0};for(let i=0;i<declarations.length;i++){if(declarations[i].init===null){counts.uninitialized++;}else {counts.initialized++;}}return counts;}function hasOnlyOneStatement(statementType,declarations){const declarationCounts=countDeclarations(declarations);const currentOptions=options[statementType]||{};const currentScope=getCurrentScope(statementType);const hasRequires=declarations.some(isRequire);if(currentOptions.uninitialized===MODE_ALWAYS&&currentOptions.initialized===MODE_ALWAYS){if(currentScope.uninitialized||currentScope.initialized){if(!hasRequires){return false;}}}if(declarationCounts.uninitialized>0){if(currentOptions.uninitialized===MODE_ALWAYS&&currentScope.uninitialized){return false;}}if(declarationCounts.initialized>0){if(currentOptions.initialized===MODE_ALWAYS&&currentScope.initialized){if(!hasRequires){return false;}}}if(currentScope.required&&hasRequires){return false;}recordTypes(statementType,declarations,currentScope);return true;}function joinDeclarations(declarations){const declaration=declarations[0];const body=Array.isArray(declaration.parent.parent.body)?declaration.parent.parent.body:[];const currentIndex=body.findIndex(node=>node.range[0]===declaration.parent.range[0]);const previousNode=body[currentIndex-1];return fixer=>{const type=sourceCode.getTokenBefore(declaration);const prevSemi=sourceCode.getTokenBefore(type);const res=[];if(previousNode&&previousNode.kind===sourceCode.getText(type)){if(prevSemi.value===";"){res.push(fixer.replaceText(prevSemi,","));}else {res.push(fixer.insertTextAfter(prevSemi,","));}res.push(fixer.replaceText(type,""));}return res;};}function splitDeclarations(declaration){const{parent}=declaration;if(!isInStatementList(parent.type==="ExportNamedDeclaration"?parent:declaration)){return null;}return fixer=>declaration.declarations.map(declarator=>{const tokenAfterDeclarator=sourceCode.getTokenAfter(declarator);if(tokenAfterDeclarator===null){return null;}const afterComma=sourceCode.getTokenAfter(tokenAfterDeclarator,{includeComments:true});if(tokenAfterDeclarator.value!==","){return null;}const exportPlacement=declaration.parent.type==="ExportNamedDeclaration"?"export ":"";if(afterComma.range[0]===tokenAfterDeclarator.range[1]){return fixer.replaceText(tokenAfterDeclarator,`; ${exportPlacement}${declaration.kind} `);}if(afterComma.loc.start.line>tokenAfterDeclarator.loc.end.line||afterComma.type==="Line"||afterComma.type==="Block"){let lastComment=afterComma;while(lastComment.type==="Line"||lastComment.type==="Block"){lastComment=sourceCode.getTokenAfter(lastComment,{includeComments:true});}return fixer.replaceTextRange([tokenAfterDeclarator.range[0],lastComment.range[0]],`;${sourceCode.text.slice(tokenAfterDeclarator.range[1],lastComment.range[0])}${exportPlacement}${declaration.kind} `);}return fixer.replaceText(tokenAfterDeclarator,`; ${exportPlacement}${declaration.kind}`);}).filter(x=>x);}return {Program:startFunction,FunctionDeclaration:startFunction,FunctionExpression:startFunction,ArrowFunctionExpression:startFunction,BlockStatement:startBlock,ForStatement:startBlock,ForInStatement:startBlock,ForOfStatement:startBlock,SwitchStatement:startBlock,VariableDeclaration:function(node){const parent=node.parent;const type=node.kind;if(!options[type]){return;}const declarations=node.declarations;const declarationCounts=countDeclarations(declarations);const mixedRequires=declarations.some(isRequire)&&!declarations.every(isRequire);if(options[type].initialized===MODE_ALWAYS){if(options.separateRequires&&mixedRequires){context.report({node,messageId:"splitRequires"});}}const nodeIndex=parent.body&&parent.body.length>0&&parent.body.indexOf(node)||0;if(nodeIndex>0){const previousNode=parent.body[nodeIndex-1];const isPreviousNodeDeclaration=previousNode.type==="VariableDeclaration";const declarationsWithPrevious=declarations.concat(previousNode.declarations||[]);if(isPreviousNodeDeclaration&&previousNode.kind===type&&!(declarationsWithPrevious.some(isRequire)&&!declarationsWithPrevious.every(isRequire))){const previousDeclCounts=countDeclarations(previousNode.declarations);if(options[type].initialized===MODE_CONSECUTIVE&&options[type].uninitialized===MODE_CONSECUTIVE){context.report({node,messageId:"combine",data:{type},fix:joinDeclarations(declarations)});}else if(options[type].initialized===MODE_CONSECUTIVE&&declarationCounts.initialized>0&&previousDeclCounts.initialized>0){context.report({node,messageId:"combineInitialized",data:{type},fix:joinDeclarations(declarations)});}else if(options[type].uninitialized===MODE_CONSECUTIVE&&declarationCounts.uninitialized>0&&previousDeclCounts.uninitialized>0){context.report({node,messageId:"combineUninitialized",data:{type},fix:joinDeclarations(declarations)});}}}if(!hasOnlyOneStatement(type,declarations)){if(options[type].initialized===MODE_ALWAYS&&options[type].uninitialized===MODE_ALWAYS){context.report({node,messageId:"combine",data:{type},fix:joinDeclarations(declarations)});}else {if(options[type].initialized===MODE_ALWAYS&&declarationCounts.initialized>0){context.report({node,messageId:"combineInitialized",data:{type},fix:joinDeclarations(declarations)});}if(options[type].uninitialized===MODE_ALWAYS&&declarationCounts.uninitialized>0){if(node.parent.left===node&&(node.parent.type==="ForInStatement"||node.parent.type==="ForOfStatement")){return;}context.report({node,messageId:"combineUninitialized",data:{type},fix:joinDeclarations(declarations)});}}}if(parent.type!=="ForStatement"||parent.init!==node){const totalDeclarations=declarationCounts.uninitialized+declarationCounts.initialized;if(totalDeclarations>1){if(options[type].initialized===MODE_NEVER&&options[type].uninitialized===MODE_NEVER){context.report({node,messageId:"split",data:{type},fix:splitDeclarations(node)});}else if(options[type].initialized===MODE_NEVER&&declarationCounts.initialized>0){context.report({node,messageId:"splitInitialized",data:{type},fix:splitDeclarations(node)});}else if(options[type].uninitialized===MODE_NEVER&&declarationCounts.uninitialized>0){context.report({node,messageId:"splitUninitialized",data:{type},fix:splitDeclarations(node)});}}}},"ForStatement:exit":endBlock,"ForOfStatement:exit":endBlock,"ForInStatement:exit":endBlock,"SwitchStatement:exit":endBlock,"BlockStatement:exit":endBlock,"Program:exit":endFunction,"FunctionDeclaration:exit":endFunction,"FunctionExpression:exit":endFunction,"ArrowFunctionExpression:exit":endFunction};}};function isCommutativeOperatorWithShorthand(operator){return ["*","&","^","|"].indexOf(operator)>=0;}function isNonCommutativeOperatorWithShorthand(operator){return ["+","-","/","%","<<",">>",">>>","**"].indexOf(operator)>=0;}function canBeFixed(node){return node.type==="Identifier"||node.type==="MemberExpression"&&(node.object.type==="Identifier"||node.object.type==="ThisExpression")&&(!node.computed||node.property.type==="Literal");}var operatorAssignment={meta:{type:"suggestion",docs:{description:"require or disallow assignment operator shorthand where possible",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/operator-assignment"},schema:[{enum:["always","never"]}],fixable:"code",messages:{replaced:"Assignment can be replaced with operator assignment.",unexpected:"Unexpected operator assignment shorthand."}},create(context){const sourceCode=context.getSourceCode();function getOperatorToken(node){return sourceCode.getFirstTokenBetween(node.left,node.right,token=>token.value===node.operator);}return {AssignmentExpression:context.options[0]!=="never"?function(node){if(node.operator!=="="||node.right.type!=="BinaryExpression"){return;}const left=node.left;const expr=node.right;const operator=expr.operator;if(isCommutativeOperatorWithShorthand(operator)||isNonCommutativeOperatorWithShorthand(operator)){if(astUtils.isSameReference(left,expr.left,true)){context.report({node,messageId:"replaced",fix(fixer){if(canBeFixed(left)&&canBeFixed(expr.left)){const equalsToken=getOperatorToken(node);const operatorToken=getOperatorToken(expr);const leftText=sourceCode.getText().slice(node.range[0],equalsToken.range[0]);const rightText=sourceCode.getText().slice(operatorToken.range[1],node.right.range[1]);if(sourceCode.commentsExistBetween(equalsToken,operatorToken)){return null;}return fixer.replaceText(node,`${leftText}${expr.operator}=${rightText}`);}return null;}});}else if(astUtils.isSameReference(left,expr.right,true)&&isCommutativeOperatorWithShorthand(operator)){context.report({node,messageId:"replaced"});}}}:function(node){if(node.operator!=="="&&!astUtils.isLogicalAssignmentOperator(node.operator)){context.report({node,messageId:"unexpected",fix(fixer){if(canBeFixed(node.left)){const firstToken=sourceCode.getFirstToken(node);const operatorToken=getOperatorToken(node);const leftText=sourceCode.getText().slice(node.range[0],operatorToken.range[0]);const newOperator=node.operator.slice(0,-1);let rightText;if(sourceCode.commentsExistBetween(firstToken,operatorToken)){return null;}if(astUtils.getPrecedence(node.right)<=astUtils.getPrecedence({type:"BinaryExpression",operator:newOperator})&&!astUtils.isParenthesised(sourceCode,node.right)){rightText=`${sourceCode.text.slice(operatorToken.range[1],node.right.range[0])}(${sourceCode.getText(node.right)})`;}else {const tokenAfterOperator=sourceCode.getTokenAfter(operatorToken,{includeComments:true});let rightTextPrefix="";if(operatorToken.range[1]===tokenAfterOperator.range[0]&&!astUtils.canTokensBeAdjacent({type:"Punctuator",value:newOperator},tokenAfterOperator)){rightTextPrefix=" ";}rightText=`${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1],node.range[1])}`;}return fixer.replaceText(node,`${leftText}= ${leftText}${newOperator}${rightText}`);}return null;}});}}};}};var operatorLinebreak={meta:{type:"layout",docs:{description:"enforce consistent linebreak style for operators",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/operator-linebreak"},schema:[{enum:["after","before","none",null]},{type:"object",properties:{overrides:{type:"object",additionalProperties:{enum:["after","before","none","ignore"]}}},additionalProperties:false}],fixable:"code",messages:{operatorAtBeginning:"'{{operator}}' should be placed at the beginning of the line.",operatorAtEnd:"'{{operator}}' should be placed at the end of the line.",badLinebreak:"Bad line breaking before and after '{{operator}}'.",noLinebreak:"There should be no line break before or after '{{operator}}'."}},create(context){const usedDefaultGlobal=!context.options[0];const globalStyle=context.options[0]||"after";const options=context.options[1]||{};const styleOverrides=options.overrides?Object.assign({},options.overrides):{};if(usedDefaultGlobal&&!styleOverrides["?"]){styleOverrides["?"]="before";}if(usedDefaultGlobal&&!styleOverrides[":"]){styleOverrides[":"]="before";}const sourceCode=context.getSourceCode();function getFixer(operatorToken,desiredStyle){return fixer=>{const tokenBefore=sourceCode.getTokenBefore(operatorToken);const tokenAfter=sourceCode.getTokenAfter(operatorToken);const textBefore=sourceCode.text.slice(tokenBefore.range[1],operatorToken.range[0]);const textAfter=sourceCode.text.slice(operatorToken.range[1],tokenAfter.range[0]);const hasLinebreakBefore=!astUtils.isTokenOnSameLine(tokenBefore,operatorToken);const hasLinebreakAfter=!astUtils.isTokenOnSameLine(operatorToken,tokenAfter);let newTextBefore,newTextAfter;if(hasLinebreakBefore!==hasLinebreakAfter&&desiredStyle!=="none"){if(sourceCode.getTokenBefore(operatorToken,{includeComments:true})!==tokenBefore&&sourceCode.getTokenAfter(operatorToken,{includeComments:true})!==tokenAfter){return null;}newTextBefore=textAfter;newTextAfter=textBefore;}else {const LINEBREAK_REGEX=astUtils.createGlobalLinebreakMatcher();newTextBefore=desiredStyle==="before"||textBefore.trim()?textBefore:textBefore.replace(LINEBREAK_REGEX,"");newTextAfter=desiredStyle==="after"||textAfter.trim()?textAfter:textAfter.replace(LINEBREAK_REGEX,"");if(newTextBefore===textBefore&&newTextAfter===textAfter){return null;}}if(newTextAfter===""&&tokenAfter.type==="Punctuator"&&"+-".includes(operatorToken.value)&&tokenAfter.value===operatorToken.value){newTextAfter+=" ";}return fixer.replaceTextRange([tokenBefore.range[1],tokenAfter.range[0]],newTextBefore+operatorToken.value+newTextAfter);};}function validateNode(node,leftSide){const operatorToken=sourceCode.getTokenAfter(leftSide,astUtils.isNotClosingParenToken);const leftToken=sourceCode.getTokenBefore(operatorToken);const rightToken=sourceCode.getTokenAfter(operatorToken);const operator=operatorToken.value;const operatorStyleOverride=styleOverrides[operator];const style=operatorStyleOverride||globalStyle;const fix=getFixer(operatorToken,style);if(astUtils.isTokenOnSameLine(leftToken,operatorToken)&&astUtils.isTokenOnSameLine(operatorToken,rightToken));else if(operatorStyleOverride!=="ignore"&&!astUtils.isTokenOnSameLine(leftToken,operatorToken)&&!astUtils.isTokenOnSameLine(operatorToken,rightToken)){context.report({node,loc:operatorToken.loc,messageId:"badLinebreak",data:{operator},fix});}else if(style==="before"&&astUtils.isTokenOnSameLine(leftToken,operatorToken)){context.report({node,loc:operatorToken.loc,messageId:"operatorAtBeginning",data:{operator},fix});}else if(style==="after"&&astUtils.isTokenOnSameLine(operatorToken,rightToken)){context.report({node,loc:operatorToken.loc,messageId:"operatorAtEnd",data:{operator},fix});}else if(style==="none"){context.report({node,loc:operatorToken.loc,messageId:"noLinebreak",data:{operator},fix});}}function validateBinaryExpression(node){validateNode(node,node.left);}return {BinaryExpression:validateBinaryExpression,LogicalExpression:validateBinaryExpression,AssignmentExpression:validateBinaryExpression,VariableDeclarator(node){if(node.init){validateNode(node,node.id);}},ConditionalExpression(node){validateNode(node,node.test);validateNode(node,node.consequent);}};}};var paddedBlocks={meta:{type:"layout",docs:{description:"require or disallow padding within blocks",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/padded-blocks"},fixable:"whitespace",schema:[{oneOf:[{enum:["always","never"]},{type:"object",properties:{blocks:{enum:["always","never"]},switches:{enum:["always","never"]},classes:{enum:["always","never"]}},additionalProperties:false,minProperties:1}]},{type:"object",properties:{allowSingleLineBlocks:{type:"boolean"}},additionalProperties:false}],messages:{alwaysPadBlock:"Block must be padded by blank lines.",neverPadBlock:"Block must not be padded by blank lines."}},create(context){const options={};const typeOptions=context.options[0]||"always";const exceptOptions=context.options[1]||{};if(typeof typeOptions==="string"){const shouldHavePadding=typeOptions==="always";options.blocks=shouldHavePadding;options.switches=shouldHavePadding;options.classes=shouldHavePadding;}else {if(Object.prototype.hasOwnProperty.call(typeOptions,"blocks")){options.blocks=typeOptions.blocks==="always";}if(Object.prototype.hasOwnProperty.call(typeOptions,"switches")){options.switches=typeOptions.switches==="always";}if(Object.prototype.hasOwnProperty.call(typeOptions,"classes")){options.classes=typeOptions.classes==="always";}}if(Object.prototype.hasOwnProperty.call(exceptOptions,"allowSingleLineBlocks")){options.allowSingleLineBlocks=exceptOptions.allowSingleLineBlocks===true;}const sourceCode=context.getSourceCode();function getOpenBrace(node){if(node.type==="SwitchStatement"){return sourceCode.getTokenBefore(node.cases[0]);}return sourceCode.getFirstToken(node);}function isComment(node){return node.type==="Line"||node.type==="Block";}function isPaddingBetweenTokens(first,second){return second.loc.start.line-first.loc.end.line>=2;}function getFirstBlockToken(token){let prev,first=token;do{prev=first;first=sourceCode.getTokenAfter(first,{includeComments:true});}while(isComment(first)&&first.loc.start.line===prev.loc.end.line);return first;}function getLastBlockToken(token){let last=token,next;do{next=last;last=sourceCode.getTokenBefore(last,{includeComments:true});}while(isComment(last)&&last.loc.end.line===next.loc.start.line);return last;}function requirePaddingFor(node){switch(node.type){case"BlockStatement":return options.blocks;case"SwitchStatement":return options.switches;case"ClassBody":return options.classes;default:throw new Error("unreachable");}}function checkPadding(node){const openBrace=getOpenBrace(node),firstBlockToken=getFirstBlockToken(openBrace),tokenBeforeFirst=sourceCode.getTokenBefore(firstBlockToken,{includeComments:true}),closeBrace=sourceCode.getLastToken(node),lastBlockToken=getLastBlockToken(closeBrace),tokenAfterLast=sourceCode.getTokenAfter(lastBlockToken,{includeComments:true}),blockHasTopPadding=isPaddingBetweenTokens(tokenBeforeFirst,firstBlockToken),blockHasBottomPadding=isPaddingBetweenTokens(lastBlockToken,tokenAfterLast);if(options.allowSingleLineBlocks&&astUtils.isTokenOnSameLine(tokenBeforeFirst,tokenAfterLast)){return;}if(requirePaddingFor(node)){if(!blockHasTopPadding){context.report({node,loc:{start:tokenBeforeFirst.loc.start,end:firstBlockToken.loc.start},fix(fixer){return fixer.insertTextAfter(tokenBeforeFirst,"\n");},messageId:"alwaysPadBlock"});}if(!blockHasBottomPadding){context.report({node,loc:{end:tokenAfterLast.loc.start,start:lastBlockToken.loc.end},fix(fixer){return fixer.insertTextBefore(tokenAfterLast,"\n");},messageId:"alwaysPadBlock"});}}else {if(blockHasTopPadding){context.report({node,loc:{start:tokenBeforeFirst.loc.start,end:firstBlockToken.loc.start},fix(fixer){return fixer.replaceTextRange([tokenBeforeFirst.range[1],firstBlockToken.range[0]-firstBlockToken.loc.start.column],"\n");},messageId:"neverPadBlock"});}if(blockHasBottomPadding){context.report({node,loc:{end:tokenAfterLast.loc.start,start:lastBlockToken.loc.end},messageId:"neverPadBlock",fix(fixer){return fixer.replaceTextRange([lastBlockToken.range[1],tokenAfterLast.range[0]-tokenAfterLast.loc.start.column],"\n");}});}}}const rule={};if(Object.prototype.hasOwnProperty.call(options,"switches")){rule.SwitchStatement=function(node){if(node.cases.length===0){return;}checkPadding(node);};}if(Object.prototype.hasOwnProperty.call(options,"blocks")){rule.BlockStatement=function(node){if(node.body.length===0){return;}checkPadding(node);};}if(Object.prototype.hasOwnProperty.call(options,"classes")){rule.ClassBody=function(node){if(node.body.length===0){return;}checkPadding(node);};}return rule;}};`[${Array.from(astUtils.LINEBREAKS).join("")}]`;const PADDING_LINE_SEQUENCE=new RegExp("^(\\s*?)\\s*(\\s*;?)$","u");const CJS_EXPORT=/^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;const CJS_IMPORT=/^require\(/u;function newKeywordTester(keyword){return {test:(node,sourceCode)=>sourceCode.getFirstToken(node).value===keyword};}function newSinglelineKeywordTester(keyword){return {test:(node,sourceCode)=>node.loc.start.line===node.loc.end.line&&sourceCode.getFirstToken(node).value===keyword};}function newMultilineKeywordTester(keyword){return {test:(node,sourceCode)=>node.loc.start.line!==node.loc.end.line&&sourceCode.getFirstToken(node).value===keyword};}function newNodeTypeTester(type){return {test:node=>node.type===type};}function isIIFEStatement(node){if(node.type==="ExpressionStatement"){let call=astUtils.skipChainExpression(node.expression);if(call.type==="UnaryExpression"){call=astUtils.skipChainExpression(call.argument);}return call.type==="CallExpression"&&astUtils.isFunction(call.callee);}return false;}function isBlockLikeStatement(sourceCode,node){if(node.type==="DoWhileStatement"&&node.body.type==="BlockStatement"){return true;}if(isIIFEStatement(node)){return true;}const lastToken=sourceCode.getLastToken(node,astUtils.isNotSemicolonToken);const belongingNode=lastToken&&astUtils.isClosingBraceToken(lastToken)?sourceCode.getNodeByRangeIndex(lastToken.range[0]):null;return Boolean(belongingNode)&&(belongingNode.type==="BlockStatement"||belongingNode.type==="SwitchStatement");}function isDirective(node,sourceCode){return node.type==="ExpressionStatement"&&(node.parent.type==="Program"||node.parent.type==="BlockStatement"&&astUtils.isFunction(node.parent.parent))&&node.expression.type==="Literal"&&typeof node.expression.value==="string"&&!astUtils.isParenthesised(sourceCode,node.expression);}function isDirectivePrologue(node,sourceCode){if(isDirective(node,sourceCode)){for(const sibling of node.parent.body){if(sibling===node){break;}if(!isDirective(sibling,sourceCode)){return false;}}return true;}return false;}function getActualLastToken(sourceCode,node){const semiToken=sourceCode.getLastToken(node);const prevToken=sourceCode.getTokenBefore(semiToken);const nextToken=sourceCode.getTokenAfter(semiToken);const isSemicolonLessStyle=Boolean(prevToken&&nextToken&&prevToken.range[0]>=node.range[0]&&astUtils.isSemicolonToken(semiToken)&&semiToken.loc.start.line!==prevToken.loc.end.line&&semiToken.loc.end.line===nextToken.loc.start.line);return isSemicolonLessStyle?prevToken:semiToken;}function replacerToRemovePaddingLines(_,trailingSpaces,indentSpaces){return trailingSpaces+indentSpaces;}function verifyForAny(){}function verifyForNever(context,_,nextNode,paddingLines){if(paddingLines.length===0){return;}context.report({node:nextNode,messageId:"unexpectedBlankLine",fix(fixer){if(paddingLines.length>=2){return null;}const prevToken=paddingLines[0][0];const nextToken=paddingLines[0][1];const start=prevToken.range[1];const end=nextToken.range[0];const text=context.getSourceCode().text.slice(start,end).replace(PADDING_LINE_SEQUENCE,replacerToRemovePaddingLines);return fixer.replaceTextRange([start,end],text);}});}function verifyForAlways(context,prevNode,nextNode,paddingLines){if(paddingLines.length>0){return;}context.report({node:nextNode,messageId:"expectedBlankLine",fix(fixer){const sourceCode=context.getSourceCode();let prevToken=getActualLastToken(sourceCode,prevNode);const nextToken=sourceCode.getFirstTokenBetween(prevToken,nextNode,{includeComments:true,filter(token){if(astUtils.isTokenOnSameLine(prevToken,token)){prevToken=token;return false;}return true;}})||nextNode;const insertText=astUtils.isTokenOnSameLine(prevToken,nextToken)?"\n\n":"\n";return fixer.insertTextAfter(prevToken,insertText);}});}const PaddingTypes={any:{verify:verifyForAny},never:{verify:verifyForNever},always:{verify:verifyForAlways}};const StatementTypes={"*":{test:()=>true},"block-like":{test:(node,sourceCode)=>isBlockLikeStatement(sourceCode,node)},"cjs-export":{test:(node,sourceCode)=>node.type==="ExpressionStatement"&&node.expression.type==="AssignmentExpression"&&CJS_EXPORT.test(sourceCode.getText(node.expression.left))},"cjs-import":{test:(node,sourceCode)=>node.type==="VariableDeclaration"&&node.declarations.length>0&&Boolean(node.declarations[0].init)&&CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))},directive:{test:isDirectivePrologue},expression:{test:(node,sourceCode)=>node.type==="ExpressionStatement"&&!isDirectivePrologue(node,sourceCode)},iife:{test:isIIFEStatement},"multiline-block-like":{test:(node,sourceCode)=>node.loc.start.line!==node.loc.end.line&&isBlockLikeStatement(sourceCode,node)},"multiline-expression":{test:(node,sourceCode)=>node.loc.start.line!==node.loc.end.line&&node.type==="ExpressionStatement"&&!isDirectivePrologue(node,sourceCode)},"multiline-const":newMultilineKeywordTester("const"),"multiline-let":newMultilineKeywordTester("let"),"multiline-var":newMultilineKeywordTester("var"),"singleline-const":newSinglelineKeywordTester("const"),"singleline-let":newSinglelineKeywordTester("let"),"singleline-var":newSinglelineKeywordTester("var"),block:newNodeTypeTester("BlockStatement"),empty:newNodeTypeTester("EmptyStatement"),function:newNodeTypeTester("FunctionDeclaration"),break:newKeywordTester("break"),case:newKeywordTester("case"),class:newKeywordTester("class"),const:newKeywordTester("const"),continue:newKeywordTester("continue"),debugger:newKeywordTester("debugger"),default:newKeywordTester("default"),do:newKeywordTester("do"),export:newKeywordTester("export"),for:newKeywordTester("for"),if:newKeywordTester("if"),import:newKeywordTester("import"),let:newKeywordTester("let"),return:newKeywordTester("return"),switch:newKeywordTester("switch"),throw:newKeywordTester("throw"),try:newKeywordTester("try"),var:newKeywordTester("var"),while:newKeywordTester("while"),with:newKeywordTester("with")};var paddingLineBetweenStatements={meta:{type:"layout",docs:{description:"require or disallow padding lines between statements",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/padding-line-between-statements"},fixable:"whitespace",schema:{definitions:{paddingType:{enum:Object.keys(PaddingTypes)},statementType:{anyOf:[{enum:Object.keys(StatementTypes)},{type:"array",items:{enum:Object.keys(StatementTypes)},minItems:1,uniqueItems:true,additionalItems:false}]}},type:"array",items:{type:"object",properties:{blankLine:{$ref:"#/definitions/paddingType"},prev:{$ref:"#/definitions/statementType"},next:{$ref:"#/definitions/statementType"}},additionalProperties:false,required:["blankLine","prev","next"]},additionalItems:false},messages:{unexpectedBlankLine:"Unexpected blank line before this statement.",expectedBlankLine:"Expected blank line before this statement."}},create(context){const sourceCode=context.getSourceCode();const configureList=context.options||[];let scopeInfo=null;function enterScope(){scopeInfo={upper:scopeInfo,prevNode:null};}function exitScope(){scopeInfo=scopeInfo.upper;}function match(node,type){let innerStatementNode=node;while(innerStatementNode.type==="LabeledStatement"){innerStatementNode=innerStatementNode.body;}if(Array.isArray(type)){return type.some(match.bind(null,innerStatementNode));}return StatementTypes[type].test(innerStatementNode,sourceCode);}function getPaddingType(prevNode,nextNode){for(let i=configureList.length-1;i>=0;--i){const configure=configureList[i];const matched=match(prevNode,configure.prev)&&match(nextNode,configure.next);if(matched){return PaddingTypes[configure.blankLine];}}return PaddingTypes.any;}function getPaddingLineSequences(prevNode,nextNode){const pairs=[];let prevToken=getActualLastToken(sourceCode,prevNode);if(nextNode.loc.start.line-prevToken.loc.end.line>=2){do{const token=sourceCode.getTokenAfter(prevToken,{includeComments:true});if(token.loc.start.line-prevToken.loc.end.line>=2){pairs.push([prevToken,token]);}prevToken=token;}while(prevToken.range[0]<nextNode.range[0]);}return pairs;}function verify(node){const parentType=node.parent.type;const validParent=astUtils.STATEMENT_LIST_PARENTS.has(parentType)||parentType==="SwitchStatement";if(!validParent){return;}const prevNode=scopeInfo.prevNode;if(prevNode){const type=getPaddingType(prevNode,node);const paddingLines=getPaddingLineSequences(prevNode,node);type.verify(context,prevNode,node,paddingLines);}scopeInfo.prevNode=node;}return {Program:enterScope,BlockStatement:enterScope,SwitchStatement:enterScope,"Program:exit":exitScope,"BlockStatement:exit":exitScope,"SwitchStatement:exit":exitScope,":statement":verify,SwitchCase:function(node){verify(node);enterScope();},"SwitchCase:exit":exitScope};}};function isFunctionName(variable){return variable&&variable.defs[0].type==="FunctionName";}function checkMetaProperty(node,metaName,propertyName){return node.meta.name===metaName&&node.property.name===propertyName;}function getVariableOfArguments$1(scope){const variables=scope.variables;for(let i=0;i<variables.length;++i){const variable=variables[i];if(variable.name==="arguments"){return variable.identifiers.length===0?variable:null;}}return null;}function getCallbackInfo(node){const retv={isCallback:false,isLexicalThis:false};let currentNode=node;let parent=node.parent;let bound=false;while(currentNode){switch(parent.type){case"LogicalExpression":case"ChainExpression":case"ConditionalExpression":break;case"MemberExpression":if(parent.object===currentNode&&!parent.property.computed&&parent.property.type==="Identifier"&&parent.property.name==="bind"){const maybeCallee=parent.parent.type==="ChainExpression"?parent.parent:parent;if(astUtils.isCallee(maybeCallee)){if(!bound){bound=true;retv.isLexicalThis=maybeCallee.parent.arguments.length===1&&maybeCallee.parent.arguments[0].type==="ThisExpression";}parent=maybeCallee.parent;}else {return retv;}}else {return retv;}break;case"CallExpression":case"NewExpression":if(parent.callee!==currentNode){retv.isCallback=true;}return retv;default:return retv;}currentNode=parent;parent=parent.parent;}throw new Error("unreachable");}function hasDuplicateParams(paramsList){return paramsList.every(param=>param.type==="Identifier")&&paramsList.length!==new Set(paramsList.map(param=>param.name)).size;}var preferArrowCallback={meta:{type:"suggestion",docs:{description:"require using arrow functions for callbacks",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/prefer-arrow-callback"},schema:[{type:"object",properties:{allowNamedFunctions:{type:"boolean",default:false},allowUnboundThis:{type:"boolean",default:true}},additionalProperties:false}],fixable:"code",messages:{preferArrowCallback:"Unexpected function expression."}},create(context){const options=context.options[0]||{};const allowUnboundThis=options.allowUnboundThis!==false;const allowNamedFunctions=options.allowNamedFunctions;const sourceCode=context.getSourceCode();let stack=[];function enterScope(){stack.push({this:false,super:false,meta:false});}function exitScope(){return stack.pop();}return {Program(){stack=[];},ThisExpression(){const info=stack[stack.length-1];if(info){info.this=true;}},Super(){const info=stack[stack.length-1];if(info){info.super=true;}},MetaProperty(node){const info=stack[stack.length-1];if(info&&checkMetaProperty(node,"new","target")){info.meta=true;}},FunctionDeclaration:enterScope,"FunctionDeclaration:exit":exitScope,FunctionExpression:enterScope,"FunctionExpression:exit"(node){const scopeInfo=exitScope();if(allowNamedFunctions&&node.id&&node.id.name){return;}if(node.generator){return;}const nameVar=context.getDeclaredVariables(node)[0];if(isFunctionName(nameVar)&&nameVar.references.length>0){return;}const variable=getVariableOfArguments$1(context.getScope());if(variable&&variable.references.length>0){return;}const callbackInfo=getCallbackInfo(node);if(callbackInfo.isCallback&&(!allowUnboundThis||!scopeInfo.this||callbackInfo.isLexicalThis)&&!scopeInfo.super&&!scopeInfo.meta){context.report({node,messageId:"preferArrowCallback",*fix(fixer){if(!callbackInfo.isLexicalThis&&scopeInfo.this||hasDuplicateParams(node.params)){return;}if(callbackInfo.isLexicalThis){const memberNode=node.parent;if(memberNode.type!=="MemberExpression"){return;}const callNode=memberNode.parent;const firstTokenToRemove=sourceCode.getTokenAfter(memberNode.object,astUtils.isNotClosingParenToken);const lastTokenToRemove=sourceCode.getLastToken(callNode);if(astUtils.isParenthesised(sourceCode,memberNode)){return;}if(sourceCode.commentsExistBetween(firstTokenToRemove,lastTokenToRemove)){return;}yield fixer.removeRange([firstTokenToRemove.range[0],lastTokenToRemove.range[1]]);}const functionToken=sourceCode.getFirstToken(node,node.async?1:0);const leftParenToken=sourceCode.getTokenAfter(functionToken,astUtils.isOpeningParenToken);if(sourceCode.commentsExistBetween(functionToken,leftParenToken)){yield fixer.remove(functionToken);if(node.id){yield fixer.remove(node.id);}}else {yield fixer.removeRange([functionToken.range[0],leftParenToken.range[0]]);}yield fixer.insertTextBefore(node.body,"=> ");let replacedNode=callbackInfo.isLexicalThis?node.parent.parent:node;if(replacedNode.type==="ChainExpression"){replacedNode=replacedNode.parent;}if(replacedNode.parent.type!=="CallExpression"&&replacedNode.parent.type!=="ConditionalExpression"&&!astUtils.isParenthesised(sourceCode,replacedNode)&&!astUtils.isParenthesised(sourceCode,node)){yield fixer.insertTextBefore(replacedNode,"(");yield fixer.insertTextAfter(replacedNode,")");}}});}}};}};const PATTERN_TYPE=/^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;const DECLARATION_HOST_TYPE=/^(?:Program|BlockStatement|SwitchCase)$/u;const DESTRUCTURING_HOST_TYPE=/^(?:VariableDeclarator|AssignmentExpression)$/u;function isInitOfForStatement(node){return node.parent.type==="ForStatement"&&node.parent.init===node;}function canBecomeVariableDeclaration(identifier){let node=identifier.parent;while(PATTERN_TYPE.test(node.type)){node=node.parent;}return node.type==="VariableDeclarator"||node.type==="AssignmentExpression"&&node.parent.type==="ExpressionStatement"&&DECLARATION_HOST_TYPE.test(node.parent.parent.type);}function isOuterVariableInDestructing(name,initScope){if(initScope.through.find(ref=>ref.resolved&&ref.resolved.name===name)){return true;}const variable=astUtils.getVariableByName(initScope,name);if(variable!==null){return variable.defs.some(def=>def.type==="Parameter");}return false;}function getDestructuringHost(reference){if(!reference.isWrite()){return null;}let node=reference.identifier.parent;while(PATTERN_TYPE.test(node.type)){node=node.parent;}if(!DESTRUCTURING_HOST_TYPE.test(node.type)){return null;}return node;}function hasMemberExpressionAssignment(node){switch(node.type){case"ObjectPattern":return node.properties.some(prop=>{if(prop){return hasMemberExpressionAssignment(prop.argument||prop.value);}return false;});case"ArrayPattern":return node.elements.some(element=>{if(element){return hasMemberExpressionAssignment(element);}return false;});case"AssignmentPattern":return hasMemberExpressionAssignment(node.left);case"MemberExpression":return true;}return false;}function getIdentifierIfShouldBeConst(variable,ignoreReadBeforeAssign){if(variable.eslintUsed&&variable.scope.type==="global"){return null;}let writer=null;let isReadBeforeInit=false;const references=variable.references;for(let i=0;i<references.length;++i){const reference=references[i];if(reference.isWrite()){const isReassigned=writer!==null&&writer.identifier!==reference.identifier;if(isReassigned){return null;}const destructuringHost=getDestructuringHost(reference);if(destructuringHost!==null&&destructuringHost.left!==void 0){const leftNode=destructuringHost.left;let hasOuterVariables=false,hasNonIdentifiers=false;if(leftNode.type==="ObjectPattern"){const properties=leftNode.properties;hasOuterVariables=properties.filter(prop=>prop.value).map(prop=>prop.value.name).some(name=>isOuterVariableInDestructing(name,variable.scope));hasNonIdentifiers=hasMemberExpressionAssignment(leftNode);}else if(leftNode.type==="ArrayPattern"){const elements=leftNode.elements;hasOuterVariables=elements.map(element=>element&&element.name).some(name=>isOuterVariableInDestructing(name,variable.scope));hasNonIdentifiers=hasMemberExpressionAssignment(leftNode);}if(hasOuterVariables||hasNonIdentifiers){return null;}}writer=reference;}else if(reference.isRead()&&writer===null){if(ignoreReadBeforeAssign){return null;}isReadBeforeInit=true;}}const shouldBeConst=writer!==null&&writer.from===variable.scope&&canBecomeVariableDeclaration(writer.identifier);if(!shouldBeConst){return null;}if(isReadBeforeInit){return variable.defs[0].name;}return writer.identifier;}function groupByDestructuring(variables,ignoreReadBeforeAssign){const identifierMap=new Map();for(let i=0;i<variables.length;++i){const variable=variables[i];const references=variable.references;const identifier=getIdentifierIfShouldBeConst(variable,ignoreReadBeforeAssign);let prevId=null;for(let j=0;j<references.length;++j){const reference=references[j];const id=reference.identifier;if(id===prevId){continue;}prevId=id;const group=getDestructuringHost(reference);if(group){if(identifierMap.has(group)){identifierMap.get(group).push(identifier);}else {identifierMap.set(group,[identifier]);}}}}return identifierMap;}function findUp(node,type,shouldStop){if(!node||shouldStop(node)){return null;}if(node.type===type){return node;}return findUp(node.parent,type,shouldStop);}var preferConst={meta:{type:"suggestion",docs:{description:"require `const` declarations for variables that are never reassigned after declared",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/prefer-const"},fixable:"code",schema:[{type:"object",properties:{destructuring:{enum:["any","all"],default:"any"},ignoreReadBeforeAssign:{type:"boolean",default:false}},additionalProperties:false}],messages:{useConst:"'{{name}}' is never reassigned. Use 'const' instead."}},create(context){const options=context.options[0]||{};const sourceCode=context.getSourceCode();const shouldMatchAnyDestructuredVariable=options.destructuring!=="all";const ignoreReadBeforeAssign=options.ignoreReadBeforeAssign===true;const variables=[];let reportCount=0;let checkedId=null;let checkedName="";function checkGroup(nodes){const nodesToReport=nodes.filter(Boolean);if(nodes.length&&(shouldMatchAnyDestructuredVariable||nodesToReport.length===nodes.length)){const varDeclParent=findUp(nodes[0],"VariableDeclaration",parentNode=>parentNode.type.endsWith("Statement"));const isVarDecParentNull=varDeclParent===null;if(!isVarDecParentNull&&varDeclParent.declarations.length>0){const firstDeclaration=varDeclParent.declarations[0];if(firstDeclaration.init){const firstDecParent=firstDeclaration.init.parent;if(firstDecParent.type==="VariableDeclarator"){if(firstDecParent.id.name!==checkedName){checkedName=firstDecParent.id.name;reportCount=0;}if(firstDecParent.id.type==="ObjectPattern"){if(firstDecParent.init.name!==checkedName){checkedName=firstDecParent.init.name;reportCount=0;}}if(firstDecParent.id!==checkedId){checkedId=firstDecParent.id;reportCount=0;}}}}let shouldFix=varDeclParent&&(varDeclParent.parent.type==="ForInStatement"||varDeclParent.parent.type==="ForOfStatement"||varDeclParent.declarations.every(declaration=>declaration.init))&&nodesToReport.length===nodes.length;if(!isVarDecParentNull&&varDeclParent.declarations&&varDeclParent.declarations.length!==1){if(varDeclParent&&varDeclParent.declarations&&varDeclParent.declarations.length>=1){reportCount+=nodesToReport.length;shouldFix=shouldFix&&reportCount===varDeclParent.declarations.length;}}nodesToReport.forEach(node=>{context.report({node,messageId:"useConst",data:node,fix:shouldFix?fixer=>{const letKeywordToken=sourceCode.getFirstToken(varDeclParent,t=>t.value===varDeclParent.kind);return new fixTracker(fixer,sourceCode).retainRange(varDeclParent.range).replaceTextRange(letKeywordToken.range,"const");}:null});});}}return {"Program:exit"(){groupByDestructuring(variables,ignoreReadBeforeAssign).forEach(checkGroup);},VariableDeclaration(node){if(node.kind==="let"&&!isInitOfForStatement(node)){variables.push(...context.getDeclaredVariables(node));}}};}};const PRECEDENCE_OF_ASSIGNMENT_EXPR=astUtils.getPrecedence({type:"AssignmentExpression"});var preferDestructuring={meta:{type:"suggestion",docs:{description:"require destructuring from arrays and/or objects",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/prefer-destructuring"},fixable:"code",schema:[{oneOf:[{type:"object",properties:{VariableDeclarator:{type:"object",properties:{array:{type:"boolean"},object:{type:"boolean"}},additionalProperties:false},AssignmentExpression:{type:"object",properties:{array:{type:"boolean"},object:{type:"boolean"}},additionalProperties:false}},additionalProperties:false},{type:"object",properties:{array:{type:"boolean"},object:{type:"boolean"}},additionalProperties:false}]},{type:"object",properties:{enforceForRenamedProperties:{type:"boolean"}},additionalProperties:false}],messages:{preferDestructuring:"Use {{type}} destructuring."}},create(context){const enabledTypes=context.options[0];const enforceForRenamedProperties=context.options[1]&&context.options[1].enforceForRenamedProperties;let normalizedOptions={VariableDeclarator:{array:true,object:true},AssignmentExpression:{array:true,object:true}};if(enabledTypes){normalizedOptions=typeof enabledTypes.array!=="undefined"||typeof enabledTypes.object!=="undefined"?{VariableDeclarator:enabledTypes,AssignmentExpression:enabledTypes}:enabledTypes;}function shouldCheck(nodeType,destructuringType){return normalizedOptions&&normalizedOptions[nodeType]&&normalizedOptions[nodeType][destructuringType];}function isArrayIndexAccess(node){return Number.isInteger(node.property.value);}function report(reportNode,type,fix){context.report({node:reportNode,messageId:"preferDestructuring",data:{type},fix});}function shouldFix(node){return node.type==="VariableDeclarator"&&node.id.type==="Identifier"&&node.init.type==="MemberExpression"&&!node.init.computed&&node.init.property.type==="Identifier"&&node.id.name===node.init.property.name;}function fixIntoObjectDestructuring(fixer,node){const rightNode=node.init;const sourceCode=context.getSourceCode();if(sourceCode.getCommentsInside(node).length>sourceCode.getCommentsInside(rightNode.object).length){return null;}let objectText=sourceCode.getText(rightNode.object);if(astUtils.getPrecedence(rightNode.object)<PRECEDENCE_OF_ASSIGNMENT_EXPR){objectText=`(${objectText})`;}return fixer.replaceText(node,`{${rightNode.property.name}} = ${objectText}`);}function performCheck(leftNode,rightNode,reportNode){if(rightNode.type!=="MemberExpression"||rightNode.object.type==="Super"){return;}if(isArrayIndexAccess(rightNode)){if(shouldCheck(reportNode.type,"array")){report(reportNode,"array",null);}return;}const fix=shouldFix(reportNode)?fixer=>fixIntoObjectDestructuring(fixer,reportNode):null;if(shouldCheck(reportNode.type,"object")&&enforceForRenamedProperties){report(reportNode,"object",fix);return;}if(shouldCheck(reportNode.type,"object")){const property=rightNode.property;if(property.type==="Literal"&&leftNode.name===property.value||property.type==="Identifier"&&leftNode.name===property.name&&!rightNode.computed){report(reportNode,"object",fix);}}}return {VariableDeclarator:function(node){if(!node.init){return;}if(node.init.type!=="MemberExpression"){return;}performCheck(node.id,node.init,node);},AssignmentExpression:function(node){if(node.operator==="="){performCheck(node.left,node.right,node);}}};}};const{CALL:CALL$4,ReferenceTracker:ReferenceTracker$4}=eslintUtils__default['default'];const PRECEDENCE_OF_EXPONENTIATION_EXPR=astUtils.getPrecedence({type:"BinaryExpression",operator:"**"});function doesBaseNeedParens(base){return astUtils.getPrecedence(base)<=PRECEDENCE_OF_EXPONENTIATION_EXPR||base.type==="AwaitExpression"||base.type==="UnaryExpression";}function doesExponentNeedParens(exponent){return astUtils.getPrecedence(exponent)<PRECEDENCE_OF_EXPONENTIATION_EXPR;}function doesExponentiationExpressionNeedParens(node,sourceCode){const parent=node.parent.type==="ChainExpression"?node.parent.parent:node.parent;const needsParens=parent.type==="ClassDeclaration"||parent.type.endsWith("Expression")&&astUtils.getPrecedence(parent)>=PRECEDENCE_OF_EXPONENTIATION_EXPR&&!(parent.type==="BinaryExpression"&&parent.operator==="**"&&parent.right===node)&&!((parent.type==="CallExpression"||parent.type==="NewExpression")&&parent.arguments.includes(node))&&!(parent.type==="MemberExpression"&&parent.computed&&parent.property===node)&&!(parent.type==="ArrayExpression");return needsParens&&!astUtils.isParenthesised(sourceCode,node);}function parenthesizeIfShould(text,shouldParenthesize){return shouldParenthesize?`(${text})`:text;}var preferExponentiationOperator={meta:{type:"suggestion",docs:{description:"disallow the use of `Math.pow` in favor of the `**` operator",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/prefer-exponentiation-operator"},schema:[],fixable:"code",messages:{useExponentiation:"Use the '**' operator instead of 'Math.pow'."}},create(context){const sourceCode=context.getSourceCode();function report(node){context.report({node,messageId:"useExponentiation",fix(fixer){if(node.arguments.length!==2||node.arguments.some(arg=>arg.type==="SpreadElement")||sourceCode.getCommentsInside(node).length>0){return null;}const base=node.arguments[0],exponent=node.arguments[1],baseText=sourceCode.getText(base),exponentText=sourceCode.getText(exponent),shouldParenthesizeBase=doesBaseNeedParens(base),shouldParenthesizeExponent=doesExponentNeedParens(exponent),shouldParenthesizeAll=doesExponentiationExpressionNeedParens(node,sourceCode);let prefix="",suffix="";if(!shouldParenthesizeAll){if(!shouldParenthesizeBase){const firstReplacementToken=sourceCode.getFirstToken(base),tokenBefore=sourceCode.getTokenBefore(node);if(tokenBefore&&tokenBefore.range[1]===node.range[0]&&!astUtils.canTokensBeAdjacent(tokenBefore,firstReplacementToken)){prefix=" ";}}if(!shouldParenthesizeExponent){const lastReplacementToken=sourceCode.getLastToken(exponent),tokenAfter=sourceCode.getTokenAfter(node);if(tokenAfter&&node.range[1]===tokenAfter.range[0]&&!astUtils.canTokensBeAdjacent(lastReplacementToken,tokenAfter)){suffix=" ";}}}const baseReplacement=parenthesizeIfShould(baseText,shouldParenthesizeBase),exponentReplacement=parenthesizeIfShould(exponentText,shouldParenthesizeExponent),replacement=parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`,shouldParenthesizeAll);return fixer.replaceText(node,`${prefix}${replacement}${suffix}`);}});}return {Program(){const scope=context.getScope();const tracker=new ReferenceTracker$4(scope);const trackMap={Math:{pow:{[CALL$4]:true}}};for(const{node}of tracker.iterateGlobalReferences(trackMap)){report(node);}}};}};const{CALL:CALL$3,CONSTRUCT:CONSTRUCT$2,ReferenceTracker:ReferenceTracker$3,getStringIfConstant:getStringIfConstant$1}=eslintUtils__default['default'];const parser$2=new regexpp__default['default'].RegExpParser();var preferNamedCaptureGroup={meta:{type:"suggestion",docs:{description:"enforce using named capture group in regular expression",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/prefer-named-capture-group"},schema:[],messages:{required:"Capture group '{{group}}' should be converted to a named or non-capturing group."}},create(context){function checkRegex(pattern,node,uFlag){let ast;try{ast=parser$2.parsePattern(pattern,0,pattern.length,uFlag);}catch{return;}regexpp__default['default'].visitRegExpAST(ast,{onCapturingGroupEnter(group){if(!group.name){context.report({node,messageId:"required",data:{group:group.raw}});}}});}return {Literal(node){if(node.regex){checkRegex(node.regex.pattern,node,node.regex.flags.includes("u"));}},Program(){const scope=context.getScope();const tracker=new ReferenceTracker$3(scope);const traceMap={RegExp:{[CALL$3]:true,[CONSTRUCT$2]:true}};for(const{node}of tracker.iterateGlobalReferences(traceMap)){const regex=getStringIfConstant$1(node.arguments[0]);const flags=getStringIfConstant$1(node.arguments[1]);if(regex){checkRegex(regex,node,flags&&flags.includes("u"));}}}};}};const radixMap=new Map([[2,{system:"binary",literalPrefix:"0b"}],[8,{system:"octal",literalPrefix:"0o"}],[16,{system:"hexadecimal",literalPrefix:"0x"}]]);function isParseInt(calleeNode){return astUtils.isSpecificId(calleeNode,"parseInt")||astUtils.isSpecificMemberAccess(calleeNode,"Number","parseInt");}var preferNumericLiterals={meta:{type:"suggestion",docs:{description:"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/prefer-numeric-literals"},schema:[],messages:{useLiteral:"Use {{system}} literals instead of {{functionName}}()."},fixable:"code"},create(context){const sourceCode=context.getSourceCode();return {"CallExpression[arguments.length=2]"(node){const[strNode,radixNode]=node.arguments,str=astUtils.getStaticStringValue(strNode),radix=radixNode.value;if(str!==null&&astUtils.isStringLiteral(strNode)&&radixNode.type==="Literal"&&typeof radix==="number"&&radixMap.has(radix)&&isParseInt(node.callee)){const{system,literalPrefix}=radixMap.get(radix);context.report({node,messageId:"useLiteral",data:{system,functionName:sourceCode.getText(node.callee)},fix(fixer){if(sourceCode.getCommentsInside(node).length){return null;}const replacement=`${literalPrefix}${str}`;if(+replacement!==parseInt(str,radix)){return null;}const tokenBefore=sourceCode.getTokenBefore(node),tokenAfter=sourceCode.getTokenAfter(node);let prefix="",suffix="";if(tokenBefore&&tokenBefore.range[1]===node.range[0]&&!astUtils.canTokensBeAdjacent(tokenBefore,replacement)){prefix=" ";}if(tokenAfter&&node.range[1]===tokenAfter.range[0]&&!astUtils.canTokensBeAdjacent(replacement,tokenAfter)){suffix=" ";}return fixer.replaceText(node,`${prefix}${replacement}${suffix}`);}});}}};}};const{CALL:CALL$2,ReferenceTracker:ReferenceTracker$2}=eslintUtils__default['default'];const{isCommaToken,isOpeningParenToken,isClosingParenToken,isParenthesised}=astUtils;const ANY_SPACE=/\s/u;function hasArraySpread(node){return node.arguments.some(arg=>arg.type==="SpreadElement");}function isAccessorProperty(node){return node.type==="Property"&&(node.kind==="get"||node.kind==="set");}function hasAccessors(node){return node.properties.some(isAccessorProperty);}function hasArgumentsWithAccessors(node){return node.arguments.filter(arg=>arg.type==="ObjectExpression").some(hasAccessors);}function needsParens(node,sourceCode){const parent=node.parent;switch(parent.type){case"VariableDeclarator":case"ArrayExpression":case"ReturnStatement":case"CallExpression":case"Property":return false;case"AssignmentExpression":return parent.left===node&&!isParenthesised(sourceCode,node);default:return !isParenthesised(sourceCode,node);}}function argNeedsParens(node,sourceCode){switch(node.type){case"AssignmentExpression":case"ArrowFunctionExpression":case"ConditionalExpression":return !isParenthesised(sourceCode,node);default:return false;}}function getParenTokens(node,leftArgumentListParen,sourceCode){const parens=[sourceCode.getFirstToken(node),sourceCode.getLastToken(node)];let leftNext=sourceCode.getTokenBefore(node);let rightNext=sourceCode.getTokenAfter(node);while(leftNext&&rightNext&&leftNext.range[0]>leftArgumentListParen.range[0]&&isOpeningParenToken(leftNext)&&isClosingParenToken(rightNext)){parens.push(leftNext,rightNext);leftNext=sourceCode.getTokenBefore(leftNext);rightNext=sourceCode.getTokenAfter(rightNext);}return parens.sort((a,b)=>a.range[0]-b.range[0]);}function getStartWithSpaces(token,sourceCode){const text=sourceCode.text;let start=token.range[0];{const prevToken=sourceCode.getTokenBefore(token,{includeComments:true});if(prevToken&&prevToken.type==="Line"){return start;}}while(ANY_SPACE.test(text[start-1]||"")){start-=1;}return start;}function getEndWithSpaces(token,sourceCode){const text=sourceCode.text;let end=token.range[1];while(ANY_SPACE.test(text[end]||"")){end+=1;}return end;}function defineFixer(node,sourceCode){return function*(fixer){const leftParen=sourceCode.getTokenAfter(node.callee,isOpeningParenToken);const rightParen=sourceCode.getLastToken(node);yield fixer.removeRange([node.range[0],leftParen.range[0]]);if(needsParens(node,sourceCode)){yield fixer.replaceText(leftParen,"({");yield fixer.replaceText(rightParen,"})");}else {yield fixer.replaceText(leftParen,"{");yield fixer.replaceText(rightParen,"}");}for(const argNode of node.arguments){const innerParens=getParenTokens(argNode,leftParen,sourceCode);const left=innerParens.shift();const right=innerParens.pop();if(argNode.type==="ObjectExpression"){const maybeTrailingComma=sourceCode.getLastToken(argNode,1);const maybeArgumentComma=sourceCode.getTokenAfter(right);for(const innerParen of innerParens){yield fixer.remove(innerParen);}const leftRange=[left.range[0],getEndWithSpaces(left,sourceCode)];const rightRange=[Math.max(getStartWithSpaces(right,sourceCode),leftRange[1]),right.range[1]];yield fixer.removeRange(leftRange);yield fixer.removeRange(rightRange);if((argNode.properties.length===0||isCommaToken(maybeTrailingComma))&&isCommaToken(maybeArgumentComma)){yield fixer.remove(maybeArgumentComma);}}else {if(argNeedsParens(argNode,sourceCode)){yield fixer.insertTextBefore(left,"...(");yield fixer.insertTextAfter(right,")");}else {yield fixer.insertTextBefore(left,"...");}}}};}var preferObjectSpread={meta:{type:"suggestion",docs:{description:"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/prefer-object-spread"},schema:[],fixable:"code",messages:{useSpreadMessage:"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",useLiteralMessage:"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."}},create(context){const sourceCode=context.getSourceCode();return {Program(){const scope=context.getScope();const tracker=new ReferenceTracker$2(scope);const trackMap={Object:{assign:{[CALL$2]:true}}};for(const{node}of tracker.iterateGlobalReferences(trackMap)){if(node.arguments.length>=1&&node.arguments[0].type==="ObjectExpression"&&!hasArraySpread(node)&&!(node.arguments.length>1&&hasArgumentsWithAccessors(node))){const messageId=node.arguments.length===1?"useLiteralMessage":"useSpreadMessage";const fix=defineFixer(node,sourceCode);context.report({node,messageId,fix});}}}};}};var preferPromiseRejectErrors={meta:{type:"suggestion",docs:{description:"require using Error objects as Promise rejection reasons",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/prefer-promise-reject-errors"},fixable:null,schema:[{type:"object",properties:{allowEmptyReject:{type:"boolean",default:false}},additionalProperties:false}],messages:{rejectAnError:"Expected the Promise rejection reason to be an Error."}},create(context){const ALLOW_EMPTY_REJECT=context.options.length&&context.options[0].allowEmptyReject;function checkRejectCall(callExpression){if(!callExpression.arguments.length&&ALLOW_EMPTY_REJECT){return;}if(!callExpression.arguments.length||!astUtils.couldBeError(callExpression.arguments[0])||callExpression.arguments[0].type==="Identifier"&&callExpression.arguments[0].name==="undefined"){context.report({node:callExpression,messageId:"rejectAnError"});}}function isPromiseRejectCall(node){return astUtils.isSpecificMemberAccess(node.callee,"Promise","reject");}return {CallExpression(node){if(isPromiseRejectCall(node)){checkRejectCall(node);}},"NewExpression:exit"(node){if(node.callee.type==="Identifier"&&node.callee.name==="Promise"&&node.arguments.length&&astUtils.isFunction(node.arguments[0])&&node.arguments[0].params.length>1&&node.arguments[0].params[1].type==="Identifier"){context.getDeclaredVariables(node.arguments[0]).find(variable=>variable.name===node.arguments[0].params[1].name).references.filter(ref=>ref.isRead()).filter(ref=>ref.identifier.parent.type==="CallExpression"&&ref.identifier===ref.identifier.parent.callee).forEach(ref=>checkRejectCall(ref.identifier.parent));}}};}};var preferReflect={meta:{type:"suggestion",docs:{description:"require `Reflect` methods where applicable",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/prefer-reflect"},deprecated:true,replacedBy:[],schema:[{type:"object",properties:{exceptions:{type:"array",items:{enum:["apply","call","delete","defineProperty","getOwnPropertyDescriptor","getPrototypeOf","setPrototypeOf","isExtensible","getOwnPropertyNames","preventExtensions"]},uniqueItems:true}},additionalProperties:false}],messages:{preferReflect:"Avoid using {{existing}}, instead use {{substitute}}."}},create(context){const existingNames={apply:"Function.prototype.apply",call:"Function.prototype.call",defineProperty:"Object.defineProperty",getOwnPropertyDescriptor:"Object.getOwnPropertyDescriptor",getPrototypeOf:"Object.getPrototypeOf",setPrototypeOf:"Object.setPrototypeOf",isExtensible:"Object.isExtensible",getOwnPropertyNames:"Object.getOwnPropertyNames",preventExtensions:"Object.preventExtensions"};const reflectSubstitutes={apply:"Reflect.apply",call:"Reflect.apply",defineProperty:"Reflect.defineProperty",getOwnPropertyDescriptor:"Reflect.getOwnPropertyDescriptor",getPrototypeOf:"Reflect.getPrototypeOf",setPrototypeOf:"Reflect.setPrototypeOf",isExtensible:"Reflect.isExtensible",getOwnPropertyNames:"Reflect.getOwnPropertyNames",preventExtensions:"Reflect.preventExtensions"};const exceptions=(context.options[0]||{}).exceptions||[];function report(node,existing,substitute){context.report({node,messageId:"preferReflect",data:{existing,substitute}});}return {CallExpression(node){const methodName=(node.callee.property||{}).name;const isReflectCall=(node.callee.object||{}).name==="Reflect";const hasReflectSubstitute=Object.prototype.hasOwnProperty.call(reflectSubstitutes,methodName);const userConfiguredException=exceptions.indexOf(methodName)!==-1;if(hasReflectSubstitute&&!isReflectCall&&!userConfiguredException){report(node,existingNames[methodName],reflectSubstitutes[methodName]);}},UnaryExpression(node){const isDeleteOperator=node.operator==="delete";const targetsIdentifier=node.argument.type==="Identifier";const userConfiguredException=exceptions.indexOf("delete")!==-1;if(isDeleteOperator&&!targetsIdentifier&&!userConfiguredException){report(node,"the delete keyword","Reflect.deleteProperty");}}};}};const{CALL:CALL$1,CONSTRUCT:CONSTRUCT$1,ReferenceTracker:ReferenceTracker$1,findVariable}=eslintUtils__default['default'];function isStringLiteral(node){return node.type==="Literal"&&typeof node.value==="string";}function isRegexLiteral(node){return node.type==="Literal"&&Object.prototype.hasOwnProperty.call(node,"regex");}function isStaticTemplateLiteral$1(node){return node.type==="TemplateLiteral"&&node.expressions.length===0;}var preferRegexLiterals={meta:{type:"suggestion",docs:{description:"disallow use of the `RegExp` constructor in favor of regular expression literals",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/prefer-regex-literals"},schema:[{type:"object",properties:{disallowRedundantWrapping:{type:"boolean",default:false}},additionalProperties:false}],messages:{unexpectedRegExp:"Use a regular expression literal instead of the 'RegExp' constructor.",unexpectedRedundantRegExp:"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.",unexpectedRedundantRegExpWithFlags:"Use regular expression literal with flags instead of the 'RegExp' constructor."}},create(context){const[{disallowRedundantWrapping=false}={}]=context.options;function isGlobalReference(node){const scope=context.getScope();const variable=findVariable(scope,node);return variable!==null&&variable.scope.type==="global"&&variable.defs.length===0;}function isStringRawTaggedStaticTemplateLiteral(node){return node.type==="TaggedTemplateExpression"&&astUtils.isSpecificMemberAccess(node.tag,"String","raw")&&isGlobalReference(astUtils.skipChainExpression(node.tag).object)&&isStaticTemplateLiteral$1(node.quasi);}function isStaticString(node){return isStringLiteral(node)||isStaticTemplateLiteral$1(node)||isStringRawTaggedStaticTemplateLiteral(node);}function hasOnlyStaticStringArguments(node){const args=node.arguments;if((args.length===1||args.length===2)&&args.every(isStaticString)){return true;}return false;}function isUnnecessarilyWrappedRegexLiteral(node){const args=node.arguments;if(args.length===1&&isRegexLiteral(args[0])){return true;}if(args.length===2&&isRegexLiteral(args[0])&&isStaticString(args[1])){return true;}return false;}return {Program(){const scope=context.getScope();const tracker=new ReferenceTracker$1(scope);const traceMap={RegExp:{[CALL$1]:true,[CONSTRUCT$1]:true}};for(const{node}of tracker.iterateGlobalReferences(traceMap)){if(disallowRedundantWrapping&&isUnnecessarilyWrappedRegexLiteral(node)){if(node.arguments.length===2){context.report({node,messageId:"unexpectedRedundantRegExpWithFlags"});}else {context.report({node,messageId:"unexpectedRedundantRegExp"});}}else if(hasOnlyStaticStringArguments(node)){context.report({node,messageId:"unexpectedRegExp"});}}}};}};function getVariableOfArguments(scope){const variables=scope.variables;for(let i=0;i<variables.length;++i){const variable=variables[i];if(variable.name==="arguments"){return variable.identifiers.length===0?variable:null;}}return null;}function isNotNormalMemberAccess(reference){const id=reference.identifier;const parent=id.parent;return !(parent.type==="MemberExpression"&&parent.object===id&&!parent.computed);}var preferRestParams={meta:{type:"suggestion",docs:{description:"require rest parameters instead of `arguments`",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/prefer-rest-params"},schema:[],messages:{preferRestParams:"Use the rest parameters instead of 'arguments'."}},create(context){function report(reference){context.report({node:reference.identifier,loc:reference.identifier.loc,messageId:"preferRestParams"});}function checkForArguments(){const argumentsVar=getVariableOfArguments(context.getScope());if(argumentsVar){argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);}}return {"FunctionDeclaration:exit":checkForArguments,"FunctionExpression:exit":checkForArguments};}};function isVariadicApplyCalling(node){return astUtils.isSpecificMemberAccess(node.callee,null,"apply")&&node.arguments.length===2&&node.arguments[1].type!=="ArrayExpression"&&node.arguments[1].type!=="SpreadElement";}function isValidThisArg(expectedThis,thisArg,context){if(!expectedThis){return astUtils.isNullOrUndefined(thisArg);}return astUtils.equalTokens(expectedThis,thisArg,context);}var preferSpread={meta:{type:"suggestion",docs:{description:"require spread operators instead of `.apply()`",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/prefer-spread"},schema:[],fixable:null,messages:{preferSpread:"Use the spread operator instead of '.apply()'."}},create(context){const sourceCode=context.getSourceCode();return {CallExpression(node){if(!isVariadicApplyCalling(node)){return;}const applied=astUtils.skipChainExpression(astUtils.skipChainExpression(node.callee).object);const expectedThis=applied.type==="MemberExpression"?applied.object:null;const thisArg=node.arguments[0];if(isValidThisArg(expectedThis,thisArg,sourceCode)){context.report({node,messageId:"preferSpread"});}}};}};function isConcatenation(node){return node.type==="BinaryExpression"&&node.operator==="+";}function getTopConcatBinaryExpression(node){let currentNode=node;while(isConcatenation(currentNode.parent)){currentNode=currentNode.parent;}return currentNode;}function hasOctalOrNonOctalDecimalEscapeSequence(node){if(isConcatenation(node)){return hasOctalOrNonOctalDecimalEscapeSequence(node.left)||hasOctalOrNonOctalDecimalEscapeSequence(node.right);}if(node.type==="Literal"&&typeof node.value==="string"){return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);}return false;}function hasStringLiteral(node){if(isConcatenation(node)){return hasStringLiteral(node.right)||hasStringLiteral(node.left);}return astUtils.isStringLiteral(node);}function hasNonStringLiteral(node){if(isConcatenation(node)){return hasNonStringLiteral(node.right)||hasNonStringLiteral(node.left);}return !astUtils.isStringLiteral(node);}function startsWithTemplateCurly(node){if(node.type==="BinaryExpression"){return startsWithTemplateCurly(node.left);}if(node.type==="TemplateLiteral"){return node.expressions.length&&node.quasis.length&&node.quasis[0].range[0]===node.quasis[0].range[1];}return node.type!=="Literal"||typeof node.value!=="string";}function endsWithTemplateCurly(node){if(node.type==="BinaryExpression"){return startsWithTemplateCurly(node.right);}if(node.type==="TemplateLiteral"){return node.expressions.length&&node.quasis.length&&node.quasis[node.quasis.length-1].range[0]===node.quasis[node.quasis.length-1].range[1];}return node.type!=="Literal"||typeof node.value!=="string";}var preferTemplate={meta:{type:"suggestion",docs:{description:"require template literals instead of string concatenation",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/prefer-template"},schema:[],fixable:"code",messages:{unexpectedStringConcatenation:"Unexpected string concatenation."}},create(context){const sourceCode=context.getSourceCode();let done=Object.create(null);function getTextBetween(node1,node2){const allTokens=[node1].concat(sourceCode.getTokensBetween(node1,node2)).concat(node2);const sourceText=sourceCode.getText();return allTokens.slice(0,-1).reduce((accumulator,token,index)=>accumulator+sourceText.slice(token.range[1],allTokens[index+1].range[0]),"");}function getTemplateLiteral(currentNode,textBeforeNode,textAfterNode){if(currentNode.type==="Literal"&&typeof currentNode.value==="string"){return `\`${currentNode.raw.slice(1,-1).replace(/\\*(\$\{|`)/gu,matched=>{if(matched.lastIndexOf("\\")%2){return `\\${matched}`;}return matched;}).replace(new RegExp(`\\\\${currentNode.raw[0]}`,"gu"),currentNode.raw[0])}\``;}if(currentNode.type==="TemplateLiteral"){return sourceCode.getText(currentNode);}if(isConcatenation(currentNode)&&hasStringLiteral(currentNode)&&hasNonStringLiteral(currentNode)){const plusSign=sourceCode.getFirstTokenBetween(currentNode.left,currentNode.right,token=>token.value==="+");const textBeforePlus=getTextBetween(currentNode.left,plusSign);const textAfterPlus=getTextBetween(plusSign,currentNode.right);const leftEndsWithCurly=endsWithTemplateCurly(currentNode.left);const rightStartsWithCurly=startsWithTemplateCurly(currentNode.right);if(leftEndsWithCurly){return getTemplateLiteral(currentNode.left,textBeforeNode,textBeforePlus+textAfterPlus).slice(0,-1)+getTemplateLiteral(currentNode.right,null,textAfterNode).slice(1);}if(rightStartsWithCurly){return getTemplateLiteral(currentNode.left,textBeforeNode,null).slice(0,-1)+getTemplateLiteral(currentNode.right,textBeforePlus+textAfterPlus,textAfterNode).slice(1);}return `${getTemplateLiteral(currentNode.left,textBeforeNode,null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right,textAfterNode,null)}`;}return `\`\${${textBeforeNode||""}${sourceCode.getText(currentNode)}${textAfterNode||""}}\``;}function fixNonStringBinaryExpression(fixer,node){const topBinaryExpr=getTopConcatBinaryExpression(node.parent);if(hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)){return null;}return fixer.replaceText(topBinaryExpr,getTemplateLiteral(topBinaryExpr,null,null));}function checkForStringConcat(node){if(!astUtils.isStringLiteral(node)||!isConcatenation(node.parent)){return;}const topBinaryExpr=getTopConcatBinaryExpression(node.parent);if(done[topBinaryExpr.range[0]]){return;}done[topBinaryExpr.range[0]]=true;if(hasNonStringLiteral(topBinaryExpr)){context.report({node:topBinaryExpr,messageId:"unexpectedStringConcatenation",fix:fixer=>fixNonStringBinaryExpression(fixer,node)});}}return {Program(){done=Object.create(null);},Literal:checkForStringConcat,TemplateLiteral:checkForStringConcat};}};var quoteProps={meta:{type:"suggestion",docs:{description:"require quotes around object literal property names",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/quote-props"},schema:{anyOf:[{type:"array",items:[{enum:["always","as-needed","consistent","consistent-as-needed"]}],minItems:0,maxItems:1},{type:"array",items:[{enum:["always","as-needed","consistent","consistent-as-needed"]},{type:"object",properties:{keywords:{type:"boolean"},unnecessary:{type:"boolean"},numbers:{type:"boolean"}},additionalProperties:false}],minItems:0,maxItems:2}]},fixable:"code",messages:{requireQuotesDueToReservedWord:"Properties should be quoted as '{{property}}' is a reserved word.",inconsistentlyQuotedProperty:"Inconsistently quoted property '{{key}}' found.",unnecessarilyQuotedProperty:"Unnecessarily quoted property '{{property}}' found.",unquotedReservedProperty:"Unquoted reserved word '{{property}}' used as key.",unquotedNumericProperty:"Unquoted number literal '{{property}}' used as key.",unquotedPropertyFound:"Unquoted property '{{property}}' found.",redundantQuoting:"Properties shouldn't be quoted as all quotes are redundant."}},create(context){const MODE=context.options[0],KEYWORDS=context.options[1]&&context.options[1].keywords,CHECK_UNNECESSARY=!context.options[1]||context.options[1].unnecessary!==false,NUMBERS=context.options[1]&&context.options[1].numbers,sourceCode=context.getSourceCode();function isKeyword(tokenStr){return keywords.indexOf(tokenStr)>=0;}function areQuotesRedundant(rawKey,tokens,skipNumberLiterals){return tokens.length===1&&tokens[0].start===0&&tokens[0].end===rawKey.length&&(["Identifier","Keyword","Null","Boolean"].indexOf(tokens[0].type)>=0||tokens[0].type==="Numeric"&&!skipNumberLiterals&&String(+tokens[0].value)===tokens[0].value);}function getUnquotedKey(key){return key.type==="Identifier"?key.name:key.value;}function getQuotedKey(key){if(key.type==="Literal"&&typeof key.value==="string"){return sourceCode.getText(key);}return `"${key.type==="Identifier"?key.name:key.value}"`;}function checkUnnecessaryQuotes(node){const key=node.key;if(node.method||node.computed||node.shorthand){return;}if(key.type==="Literal"&&typeof key.value==="string"){let tokens;try{tokens=espree__default['default'].tokenize(key.value);}catch{return;}if(tokens.length!==1){return;}const isKeywordToken=isKeyword(tokens[0].value);if(isKeywordToken&&KEYWORDS){return;}if(CHECK_UNNECESSARY&&areQuotesRedundant(key.value,tokens,NUMBERS)){context.report({node,messageId:"unnecessarilyQuotedProperty",data:{property:key.value},fix:fixer=>fixer.replaceText(key,getUnquotedKey(key))});}}else if(KEYWORDS&&key.type==="Identifier"&&isKeyword(key.name)){context.report({node,messageId:"unquotedReservedProperty",data:{property:key.name},fix:fixer=>fixer.replaceText(key,getQuotedKey(key))});}else if(NUMBERS&&key.type==="Literal"&&astUtils.isNumericLiteral(key)){context.report({node,messageId:"unquotedNumericProperty",data:{property:key.value},fix:fixer=>fixer.replaceText(key,getQuotedKey(key))});}}function checkOmittedQuotes(node){const key=node.key;if(!node.method&&!node.computed&&!node.shorthand&&!(key.type==="Literal"&&typeof key.value==="string")){context.report({node,messageId:"unquotedPropertyFound",data:{property:key.name||key.value},fix:fixer=>fixer.replaceText(key,getQuotedKey(key))});}}function checkConsistency(node,checkQuotesRedundancy){const quotedProps=[],unquotedProps=[];let keywordKeyName=null,necessaryQuotes=false;node.properties.forEach(property=>{const key=property.key;if(!key||property.method||property.computed||property.shorthand){return;}if(key.type==="Literal"&&typeof key.value==="string"){quotedProps.push(property);if(checkQuotesRedundancy){let tokens;try{tokens=espree__default['default'].tokenize(key.value);}catch{necessaryQuotes=true;return;}necessaryQuotes=necessaryQuotes||!areQuotesRedundant(key.value,tokens)||KEYWORDS&&isKeyword(tokens[0].value);}}else if(KEYWORDS&&checkQuotesRedundancy&&key.type==="Identifier"&&isKeyword(key.name)){unquotedProps.push(property);necessaryQuotes=true;keywordKeyName=key.name;}else {unquotedProps.push(property);}});if(checkQuotesRedundancy&&quotedProps.length&&!necessaryQuotes){quotedProps.forEach(property=>{context.report({node:property,messageId:"redundantQuoting",fix:fixer=>fixer.replaceText(property.key,getUnquotedKey(property.key))});});}else if(unquotedProps.length&&keywordKeyName){unquotedProps.forEach(property=>{context.report({node:property,messageId:"requireQuotesDueToReservedWord",data:{property:keywordKeyName},fix:fixer=>fixer.replaceText(property.key,getQuotedKey(property.key))});});}else if(quotedProps.length&&unquotedProps.length){unquotedProps.forEach(property=>{context.report({node:property,messageId:"inconsistentlyQuotedProperty",data:{key:property.key.name||property.key.value},fix:fixer=>fixer.replaceText(property.key,getQuotedKey(property.key))});});}}return {Property(node){if(MODE==="always"||!MODE){checkOmittedQuotes(node);}if(MODE==="as-needed"){checkUnnecessaryQuotes(node);}},ObjectExpression(node){if(MODE==="consistent"){checkConsistency(node,false);}if(MODE==="consistent-as-needed"){checkConsistency(node,true);}}};}};const QUOTE_SETTINGS={double:{quote:"\"",alternateQuote:"'",description:"doublequote"},single:{quote:"'",alternateQuote:"\"",description:"singlequote"},backtick:{quote:"`",alternateQuote:"\"",description:"backtick"}};const UNESCAPED_LINEBREAK_PATTERN=new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils.LINEBREAKS).join("")}]`,"u");QUOTE_SETTINGS.double.convert=QUOTE_SETTINGS.single.convert=QUOTE_SETTINGS.backtick.convert=function(str){const newQuote=this.quote;const oldQuote=str[0];if(newQuote===oldQuote){return str;}return newQuote+str.slice(1,-1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu,(match,escaped,newline)=>{if(escaped===oldQuote||oldQuote==="`"&&escaped==="${"){return escaped;}if(match===newQuote||newQuote==="`"&&match==="${"){return `\\${match}`;}if(newline&&oldQuote==="`"){return "\\n";}return match;})+newQuote;};const AVOID_ESCAPE="avoid-escape";var quotes={meta:{type:"layout",docs:{description:"enforce the consistent use of either backticks, double, or single quotes",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/quotes"},fixable:"code",schema:[{enum:["single","double","backtick"]},{anyOf:[{enum:["avoid-escape"]},{type:"object",properties:{avoidEscape:{type:"boolean"},allowTemplateLiterals:{type:"boolean"}},additionalProperties:false}]}],messages:{wrongQuotes:"Strings must use {{description}}."}},create(context){const quoteOption=context.options[0],settings=QUOTE_SETTINGS[quoteOption||"double"],options=context.options[1],allowTemplateLiterals=options&&options.allowTemplateLiterals===true,sourceCode=context.getSourceCode();let avoidEscape=options&&options.avoidEscape===true;if(options===AVOID_ESCAPE){avoidEscape=true;}function isJSXLiteral(node){return node.parent.type==="JSXAttribute"||node.parent.type==="JSXElement"||node.parent.type==="JSXFragment";}function isDirective(node){return node.type==="ExpressionStatement"&&node.expression.type==="Literal"&&typeof node.expression.value==="string";}function isPartOfDirectivePrologue(node){const block=node.parent.parent;if(block.type!=="Program"&&(block.type!=="BlockStatement"||!astUtils.isFunction(block.parent))){return false;}for(let i=0;i<block.body.length;++i){const statement=block.body[i];if(statement===node.parent){return true;}if(!isDirective(statement)){break;}}return false;}function isAllowedAsNonBacktick(node){const parent=node.parent;switch(parent.type){case"ExpressionStatement":return isPartOfDirectivePrologue(node);case"Property":case"MethodDefinition":return parent.key===node&&!parent.computed;case"ImportDeclaration":case"ExportNamedDeclaration":case"ExportAllDeclaration":return parent.source===node;default:return false;}}function isUsingFeatureOfTemplateLiteral(node){const hasTag=node.parent.type==="TaggedTemplateExpression"&&node===node.parent.quasi;if(hasTag){return true;}const hasStringInterpolation=node.expressions.length>0;if(hasStringInterpolation){return true;}const isMultilineString=node.quasis.length>=1&&UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);if(isMultilineString){return true;}return false;}return {Literal(node){const val=node.value,rawVal=node.raw;if(settings&&typeof val==="string"){let isValid=quoteOption==="backtick"&&isAllowedAsNonBacktick(node)||isJSXLiteral(node)||astUtils.isSurroundedBy(rawVal,settings.quote);if(!isValid&&avoidEscape){isValid=astUtils.isSurroundedBy(rawVal,settings.alternateQuote)&&rawVal.indexOf(settings.quote)>=0;}if(!isValid){context.report({node,messageId:"wrongQuotes",data:{description:settings.description},fix(fixer){if(quoteOption==="backtick"&&astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)){return null;}return fixer.replaceText(node,settings.convert(node.raw));}});}}},TemplateLiteral(node){if(allowTemplateLiterals||quoteOption==="backtick"||isUsingFeatureOfTemplateLiteral(node)){return;}context.report({node,messageId:"wrongQuotes",data:{description:settings.description},fix(fixer){if(isPartOfDirectivePrologue(node)){return null;}return fixer.replaceText(node,settings.convert(sourceCode.getText(node)));}});}};}};const MODE_ALWAYS="always",MODE_AS_NEEDED="as-needed";const validRadixValues=new Set(Array.from({length:35},(_,index)=>index+2));function isShadowed(variable){return variable.defs.length>=1;}function isParseIntMethod(node){return node.type==="MemberExpression"&&!node.computed&&node.property.type==="Identifier"&&node.property.name==="parseInt";}function isValidRadix(radix){return !(radix.type==="Literal"&&!validRadixValues.has(radix.value)||radix.type==="Identifier"&&radix.name==="undefined");}function isDefaultRadix(radix){return radix.type==="Literal"&&radix.value===10;}var radix={meta:{type:"suggestion",docs:{description:"enforce the consistent use of the radix argument when using `parseInt()`",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/radix"},schema:[{enum:["always","as-needed"]}],messages:{missingParameters:"Missing parameters.",redundantRadix:"Redundant radix parameter.",missingRadix:"Missing radix parameter.",invalidRadix:"Invalid radix parameter, must be an integer between 2 and 36."}},create(context){const mode=context.options[0]||MODE_ALWAYS;function checkArguments(node){const args=node.arguments;switch(args.length){case 0:context.report({node,messageId:"missingParameters"});break;case 1:if(mode===MODE_ALWAYS){context.report({node,messageId:"missingRadix"});}break;default:if(mode===MODE_AS_NEEDED&&isDefaultRadix(args[1])){context.report({node,messageId:"redundantRadix"});}else if(!isValidRadix(args[1])){context.report({node,messageId:"invalidRadix"});}break;}}return {"Program:exit"(){const scope=context.getScope();let variable=astUtils.getVariableByName(scope,"parseInt");if(variable&&!isShadowed(variable)){variable.references.forEach(reference=>{const node=reference.identifier;if(astUtils.isCallee(node)){checkArguments(node.parent);}});}variable=astUtils.getVariableByName(scope,"Number");if(variable&&!isShadowed(variable)){variable.references.forEach(reference=>{const node=reference.identifier.parent;const maybeCallee=node.parent.type==="ChainExpression"?node.parent:node;if(isParseIntMethod(node)&&astUtils.isCallee(maybeCallee)){checkArguments(maybeCallee.parent);}});}}};}};function createReferenceMap(scope,outReferenceMap=new Map()){for(const reference of scope.references){outReferenceMap.set(reference.identifier,reference);}for(const childScope of scope.childScopes){if(childScope.type!=="function"){createReferenceMap(childScope,outReferenceMap);}}return outReferenceMap;}function getWriteExpr(reference){if(reference.writeExpr){return reference.writeExpr;}let node=reference.identifier;while(node){const t=node.parent.type;if(t==="AssignmentExpression"&&node.parent.left===node){return node.parent.right;}if(t==="MemberExpression"&&node.parent.object===node){node=node.parent;continue;}break;}return null;}function isLocalVariableWithoutEscape(variable,isMemberAccess){if(!variable){return false;}if(isMemberAccess&&variable.defs.some(d=>d.type==="Parameter")){return false;}const functionScope=variable.scope.variableScope;return variable.references.every(reference=>reference.from.variableScope===functionScope);}class SegmentInfo{constructor(){this.info=new WeakMap();}initialize(segment){const outdatedReadVariableNames=new Set();const freshReadVariableNames=new Set();for(const prevSegment of segment.prevSegments){const info=this.info.get(prevSegment);if(info){info.outdatedReadVariableNames.forEach(Set.prototype.add,outdatedReadVariableNames);info.freshReadVariableNames.forEach(Set.prototype.add,freshReadVariableNames);}}this.info.set(segment,{outdatedReadVariableNames,freshReadVariableNames});}markAsRead(segments,variableName){for(const segment of segments){const info=this.info.get(segment);if(info){info.freshReadVariableNames.add(variableName);info.outdatedReadVariableNames.delete(variableName);}}}makeOutdated(segments){for(const segment of segments){const info=this.info.get(segment);if(info){info.freshReadVariableNames.forEach(Set.prototype.add,info.outdatedReadVariableNames);info.freshReadVariableNames.clear();}}}isOutdated(segments,variableName){for(const segment of segments){const info=this.info.get(segment);if(info&&info.outdatedReadVariableNames.has(variableName)){return true;}}return false;}}var requireAtomicUpdates={meta:{type:"problem",docs:{description:"disallow assignments that can lead to race conditions due to usage of `await` or `yield`",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/require-atomic-updates"},fixable:null,schema:[],messages:{nonAtomicUpdate:"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`."}},create(context){const sourceCode=context.getSourceCode();const assignmentReferences=new Map();const segmentInfo=new SegmentInfo();let stack=null;return {onCodePathStart(codePath){const scope=context.getScope();const shouldVerify=scope.type==="function"&&(scope.block.async||scope.block.generator);stack={upper:stack,codePath,referenceMap:shouldVerify?createReferenceMap(scope):null};},onCodePathEnd(){stack=stack.upper;},onCodePathSegmentStart(segment){segmentInfo.initialize(segment);},Identifier(node){const{codePath,referenceMap}=stack;const reference=referenceMap&&referenceMap.get(node);if(!reference){return;}const name=reference.identifier.name;const variable=reference.resolved;const writeExpr=getWriteExpr(reference);const isMemberAccess=reference.identifier.parent.type==="MemberExpression";if(reference.isRead()&&!(writeExpr&&writeExpr.parent.operator==="=")){segmentInfo.markAsRead(codePath.currentSegments,name);}if(writeExpr&&writeExpr.parent.right===writeExpr&&!isLocalVariableWithoutEscape(variable,isMemberAccess)){let refs=assignmentReferences.get(writeExpr);if(!refs){refs=[];assignmentReferences.set(writeExpr,refs);}refs.push(reference);}},":expression:exit"(node){const{codePath,referenceMap}=stack;if(!referenceMap){return;}if(node.type==="AwaitExpression"||node.type==="YieldExpression"){segmentInfo.makeOutdated(codePath.currentSegments);}const references=assignmentReferences.get(node);if(references){assignmentReferences.delete(node);for(const reference of references){const name=reference.identifier.name;if(segmentInfo.isOutdated(codePath.currentSegments,name)){context.report({node:node.parent,messageId:"nonAtomicUpdate",data:{value:sourceCode.getText(node.parent.left)}});}}}}};}};function capitalizeFirstLetter(text){return text[0].toUpperCase()+text.slice(1);}var requireAwait={meta:{type:"suggestion",docs:{description:"disallow async functions which have no `await` expression",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/require-await"},schema:[],messages:{missingAwait:"{{name}} has no 'await' expression."}},create(context){const sourceCode=context.getSourceCode();let scopeInfo=null;function enterFunction(){scopeInfo={upper:scopeInfo,hasAwait:false};}function exitFunction(node){if(!node.generator&&node.async&&!scopeInfo.hasAwait&&!astUtils.isEmptyFunction(node)){context.report({node,loc:astUtils.getFunctionHeadLoc(node,sourceCode),messageId:"missingAwait",data:{name:capitalizeFirstLetter(astUtils.getFunctionNameWithKind(node))}});}scopeInfo=scopeInfo.upper;}return {FunctionDeclaration:enterFunction,FunctionExpression:enterFunction,ArrowFunctionExpression:enterFunction,"FunctionDeclaration:exit":exitFunction,"FunctionExpression:exit":exitFunction,"ArrowFunctionExpression:exit":exitFunction,AwaitExpression(){if(!scopeInfo){return;}scopeInfo.hasAwait=true;},ForOfStatement(node){if(!scopeInfo){return;}if(node.await){scopeInfo.hasAwait=true;}}};}};var requireJsdoc={meta:{type:"suggestion",docs:{description:"require JSDoc comments",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/require-jsdoc"},schema:[{type:"object",properties:{require:{type:"object",properties:{ClassDeclaration:{type:"boolean",default:false},MethodDefinition:{type:"boolean",default:false},FunctionDeclaration:{type:"boolean",default:true},ArrowFunctionExpression:{type:"boolean",default:false},FunctionExpression:{type:"boolean",default:false}},additionalProperties:false,default:{}}},additionalProperties:false}],deprecated:true,replacedBy:[],messages:{missingJSDocComment:"Missing JSDoc comment."}},create(context){const source=context.getSourceCode();const options=Object.assign({FunctionDeclaration:true,MethodDefinition:false,ClassDeclaration:false,ArrowFunctionExpression:false,FunctionExpression:false},context.options[0]&&context.options[0].require);function report(node){context.report({node,messageId:"missingJSDocComment"});}function checkJsDoc(node){const jsdocComment=source.getJSDocComment(node);if(!jsdocComment){report(node);}}return {FunctionDeclaration(node){if(options.FunctionDeclaration){checkJsDoc(node);}},FunctionExpression(node){if(options.MethodDefinition&&node.parent.type==="MethodDefinition"||options.FunctionExpression&&(node.parent.type==="VariableDeclarator"||node.parent.type==="Property"&&node===node.parent.value)){checkJsDoc(node);}},ClassDeclaration(node){if(options.ClassDeclaration){checkJsDoc(node);}},ArrowFunctionExpression(node){if(options.ArrowFunctionExpression&&node.parent.type==="VariableDeclarator"){checkJsDoc(node);}}};}};const{CALL,CONSTRUCT,ReferenceTracker,getStringIfConstant}=eslintUtils__default['default'];var requireUnicodeRegexp={meta:{type:"suggestion",docs:{description:"enforce the use of `u` flag on RegExp",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/require-unicode-regexp"},messages:{requireUFlag:"Use the 'u' flag."},schema:[]},create(context){return {"Literal[regex]"(node){const flags=node.regex.flags||"";if(!flags.includes("u")){context.report({node,messageId:"requireUFlag"});}},Program(){const scope=context.getScope();const tracker=new ReferenceTracker(scope);const trackMap={RegExp:{[CALL]:true,[CONSTRUCT]:true}};for(const{node}of tracker.iterateGlobalReferences(trackMap)){const flagsNode=node.arguments[1];const flags=getStringIfConstant(flagsNode,scope);if(!flagsNode||typeof flags==="string"&&!flags.includes("u")){context.report({node,messageId:"requireUFlag"});}}}};}};var requireYield={meta:{type:"suggestion",docs:{description:"require generator functions to contain `yield`",category:"ECMAScript 6",recommended:true,url:"https://eslint.org/docs/rules/require-yield"},schema:[],messages:{missingYield:"This generator function does not have 'yield'."}},create(context){const stack=[];function beginChecking(node){if(node.generator){stack.push(0);}}function endChecking(node){if(!node.generator){return;}const countYield=stack.pop();if(countYield===0&&node.body.body.length>0){context.report({node,messageId:"missingYield"});}}return {FunctionDeclaration:beginChecking,"FunctionDeclaration:exit":endChecking,FunctionExpression:beginChecking,"FunctionExpression:exit":endChecking,YieldExpression(){if(stack.length>0){stack[stack.length-1]+=1;}}};}};var restSpreadSpacing={meta:{type:"layout",docs:{description:"enforce spacing between rest and spread operators and their expressions",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/rest-spread-spacing"},fixable:"whitespace",schema:[{enum:["always","never"]}],messages:{unexpectedWhitespace:"Unexpected whitespace after {{type}} operator.",expectedWhitespace:"Expected whitespace after {{type}} operator."}},create(context){const sourceCode=context.getSourceCode(),alwaysSpace=context.options[0]==="always";function checkWhiteSpace(node){const operator=sourceCode.getFirstToken(node),nextToken=sourceCode.getTokenAfter(operator),hasWhitespace=sourceCode.isSpaceBetweenTokens(operator,nextToken);let type;switch(node.type){case"SpreadElement":type="spread";if(node.parent.type==="ObjectExpression"){type+=" property";}break;case"RestElement":type="rest";if(node.parent.type==="ObjectPattern"){type+=" property";}break;case"ExperimentalSpreadProperty":type="spread property";break;case"ExperimentalRestProperty":type="rest property";break;default:return;}if(alwaysSpace&&!hasWhitespace){context.report({node,loc:operator.loc,messageId:"expectedWhitespace",data:{type},fix(fixer){return fixer.replaceTextRange([operator.range[1],nextToken.range[0]]," ");}});}else if(!alwaysSpace&&hasWhitespace){context.report({node,loc:{start:operator.loc.end,end:nextToken.loc.start},messageId:"unexpectedWhitespace",data:{type},fix(fixer){return fixer.removeRange([operator.range[1],nextToken.range[0]]);}});}}return {SpreadElement:checkWhiteSpace,RestElement:checkWhiteSpace,ExperimentalSpreadProperty:checkWhiteSpace,ExperimentalRestProperty:checkWhiteSpace};}};var semiSpacing={meta:{type:"layout",docs:{description:"enforce consistent spacing before and after semicolons",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/semi-spacing"},fixable:"whitespace",schema:[{type:"object",properties:{before:{type:"boolean",default:false},after:{type:"boolean",default:true}},additionalProperties:false}],messages:{unexpectedWhitespaceBefore:"Unexpected whitespace before semicolon.",unexpectedWhitespaceAfter:"Unexpected whitespace after semicolon.",missingWhitespaceBefore:"Missing whitespace before semicolon.",missingWhitespaceAfter:"Missing whitespace after semicolon."}},create(context){const config=context.options[0],sourceCode=context.getSourceCode();let requireSpaceBefore=false,requireSpaceAfter=true;if(typeof config==="object"){requireSpaceBefore=config.before;requireSpaceAfter=config.after;}function hasLeadingSpace(token){const tokenBefore=sourceCode.getTokenBefore(token);return tokenBefore&&astUtils.isTokenOnSameLine(tokenBefore,token)&&sourceCode.isSpaceBetweenTokens(tokenBefore,token);}function hasTrailingSpace(token){const tokenAfter=sourceCode.getTokenAfter(token);return tokenAfter&&astUtils.isTokenOnSameLine(token,tokenAfter)&&sourceCode.isSpaceBetweenTokens(token,tokenAfter);}function isLastTokenInCurrentLine(token){const tokenAfter=sourceCode.getTokenAfter(token);return !(tokenAfter&&astUtils.isTokenOnSameLine(token,tokenAfter));}function isFirstTokenInCurrentLine(token){const tokenBefore=sourceCode.getTokenBefore(token);return !(tokenBefore&&astUtils.isTokenOnSameLine(token,tokenBefore));}function isBeforeClosingParen(token){const nextToken=sourceCode.getTokenAfter(token);return nextToken&&astUtils.isClosingBraceToken(nextToken)||astUtils.isClosingParenToken(nextToken);}function checkSemicolonSpacing(token,node){if(astUtils.isSemicolonToken(token)){if(hasLeadingSpace(token)){if(!requireSpaceBefore){const tokenBefore=sourceCode.getTokenBefore(token);const loc={start:tokenBefore.loc.end,end:token.loc.start};context.report({node,loc,messageId:"unexpectedWhitespaceBefore",fix(fixer){return fixer.removeRange([tokenBefore.range[1],token.range[0]]);}});}}else {if(requireSpaceBefore){const loc=token.loc;context.report({node,loc,messageId:"missingWhitespaceBefore",fix(fixer){return fixer.insertTextBefore(token," ");}});}}if(!isFirstTokenInCurrentLine(token)&&!isLastTokenInCurrentLine(token)&&!isBeforeClosingParen(token)){if(hasTrailingSpace(token)){if(!requireSpaceAfter){const tokenAfter=sourceCode.getTokenAfter(token);const loc={start:token.loc.end,end:tokenAfter.loc.start};context.report({node,loc,messageId:"unexpectedWhitespaceAfter",fix(fixer){return fixer.removeRange([token.range[1],tokenAfter.range[0]]);}});}}else {if(requireSpaceAfter){const loc=token.loc;context.report({node,loc,messageId:"missingWhitespaceAfter",fix(fixer){return fixer.insertTextAfter(token," ");}});}}}}}function checkNode(node){const token=sourceCode.getLastToken(node);checkSemicolonSpacing(token,node);}return {VariableDeclaration:checkNode,ExpressionStatement:checkNode,BreakStatement:checkNode,ContinueStatement:checkNode,DebuggerStatement:checkNode,DoWhileStatement:checkNode,ReturnStatement:checkNode,ThrowStatement:checkNode,ImportDeclaration:checkNode,ExportNamedDeclaration:checkNode,ExportAllDeclaration:checkNode,ExportDefaultDeclaration:checkNode,ForStatement(node){if(node.init){checkSemicolonSpacing(sourceCode.getTokenAfter(node.init),node);}if(node.test){checkSemicolonSpacing(sourceCode.getTokenAfter(node.test),node);}}};}};const SELECTOR=`:matches(${"BreakStatement,ContinueStatement,DebuggerStatement,DoWhileStatement,ExportAllDeclaration,ExportDefaultDeclaration,ExportNamedDeclaration,ExpressionStatement,ImportDeclaration,ReturnStatement,ThrowStatement,VariableDeclaration"})`;function getChildren(node){const t=node.type;if(t==="BlockStatement"||t==="Program"){return node.body;}if(t==="SwitchCase"){return node.consequent;}return null;}function isLastChild(node){const t=node.parent.type;if(t==="IfStatement"&&node.parent.consequent===node&&node.parent.alternate){return true;}if(t==="DoWhileStatement"){return true;}const nodeList=getChildren(node.parent);return nodeList!==null&&nodeList[nodeList.length-1]===node;}var semiStyle={meta:{type:"layout",docs:{description:"enforce location of semicolons",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/semi-style"},schema:[{enum:["last","first"]}],fixable:"whitespace",messages:{expectedSemiColon:"Expected this semicolon to be at {{pos}}."}},create(context){const sourceCode=context.getSourceCode();const option=context.options[0]||"last";function check(semiToken,expected){const prevToken=sourceCode.getTokenBefore(semiToken);const nextToken=sourceCode.getTokenAfter(semiToken);const prevIsSameLine=!prevToken||astUtils.isTokenOnSameLine(prevToken,semiToken);const nextIsSameLine=!nextToken||astUtils.isTokenOnSameLine(semiToken,nextToken);if(expected==="last"&&!prevIsSameLine||expected==="first"&&!nextIsSameLine){context.report({loc:semiToken.loc,messageId:"expectedSemiColon",data:{pos:expected==="last"?"the end of the previous line":"the beginning of the next line"},fix(fixer){if(prevToken&&nextToken&&sourceCode.commentsExistBetween(prevToken,nextToken)){return null;}const start=prevToken?prevToken.range[1]:semiToken.range[0];const end=nextToken?nextToken.range[0]:semiToken.range[1];const text=expected==="last"?";\n":"\n;";return fixer.replaceTextRange([start,end],text);}});}}return {[SELECTOR](node){if(option==="first"&&isLastChild(node)){return;}const lastToken=sourceCode.getLastToken(node);if(astUtils.isSemicolonToken(lastToken)){check(lastToken,option);}},ForStatement(node){const firstSemi=node.init&&sourceCode.getTokenAfter(node.init,astUtils.isSemicolonToken);const secondSemi=node.test&&sourceCode.getTokenAfter(node.test,astUtils.isSemicolonToken);if(firstSemi){check(firstSemi,"last");}if(secondSemi){check(secondSemi,"last");}}};}};var semi={meta:{type:"layout",docs:{description:"require or disallow semicolons instead of ASI",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/semi"},fixable:"code",schema:{anyOf:[{type:"array",items:[{enum:["never"]},{type:"object",properties:{beforeStatementContinuationChars:{enum:["always","any","never"]}},additionalProperties:false}],minItems:0,maxItems:2},{type:"array",items:[{enum:["always"]},{type:"object",properties:{omitLastInOneLineBlock:{type:"boolean"}},additionalProperties:false}],minItems:0,maxItems:2}]},messages:{missingSemi:"Missing semicolon.",extraSemi:"Extra semicolon."}},create(context){const options=context.options[1];const never=context.options[0]==="never";const exceptOneLine=Boolean(options&&options.omitLastInOneLineBlock);const beforeStatementContinuationChars=options&&options.beforeStatementContinuationChars||"any";const sourceCode=context.getSourceCode();function report(node,missing){const lastToken=sourceCode.getLastToken(node);let messageId,fix,loc;if(!missing){messageId="missingSemi";loc={start:lastToken.loc.end,end:astUtils.getNextLocation(sourceCode,lastToken.loc.end)};fix=function(fixer){return fixer.insertTextAfter(lastToken,";");};}else {messageId="extraSemi";loc=lastToken.loc;fix=function(fixer){return new fixTracker(fixer,sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);};}context.report({node,loc,messageId,fix});}function isRedundantSemi(semiToken){const nextToken=sourceCode.getTokenAfter(semiToken);return !nextToken||astUtils.isClosingBraceToken(nextToken)||astUtils.isSemicolonToken(nextToken);}function isEndOfArrowBlock(lastToken){if(!astUtils.isClosingBraceToken(lastToken)){return false;}const node=sourceCode.getNodeByRangeIndex(lastToken.range[0]);return node.type==="BlockStatement"&&node.parent.type==="ArrowFunctionExpression";}function isOnSameLineWithNextToken(node){const prevToken=sourceCode.getLastToken(node,1);const nextToken=sourceCode.getTokenAfter(node);return !!nextToken&&astUtils.isTokenOnSameLine(prevToken,nextToken);}function maybeAsiHazardAfter(node){const t=node.type;if(t==="DoWhileStatement"||t==="BreakStatement"||t==="ContinueStatement"||t==="DebuggerStatement"||t==="ImportDeclaration"||t==="ExportAllDeclaration"){return false;}if(t==="ReturnStatement"){return Boolean(node.argument);}if(t==="ExportNamedDeclaration"){return Boolean(node.declaration);}if(isEndOfArrowBlock(sourceCode.getLastToken(node,1))){return false;}return true;}function maybeAsiHazardBefore(token){return Boolean(token)&&/^[-[(/+`]/u.test(token.value)&&token.value!=="++"&&token.value!=="--";}function canRemoveSemicolon(node){if(isRedundantSemi(sourceCode.getLastToken(node))){return true;}if(isOnSameLineWithNextToken(node)){return false;}if(beforeStatementContinuationChars==="never"&&!maybeAsiHazardAfter(node)){return true;}if(!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))){return true;}return false;}function isOneLinerBlock(node){const parent=node.parent;const nextToken=sourceCode.getTokenAfter(node);if(!nextToken||nextToken.value!=="}"){return false;}return !!parent&&parent.type==="BlockStatement"&&parent.loc.start.line===parent.loc.end.line;}function checkForSemicolon(node){const isSemi=astUtils.isSemicolonToken(sourceCode.getLastToken(node));if(never){if(isSemi&&canRemoveSemicolon(node)){report(node,true);}else if(!isSemi&&beforeStatementContinuationChars==="always"&&maybeAsiHazardBefore(sourceCode.getTokenAfter(node))){report(node);}}else {const oneLinerBlock=exceptOneLine&&isOneLinerBlock(node);if(isSemi&&oneLinerBlock){report(node,true);}else if(!isSemi&&!oneLinerBlock){report(node);}}}return {VariableDeclaration:function(node){const parent=node.parent;if((parent.type!=="ForStatement"||parent.init!==node)&&(!/^For(?:In|Of)Statement/u.test(parent.type)||parent.left!==node)){checkForSemicolon(node);}},ExpressionStatement:checkForSemicolon,ReturnStatement:checkForSemicolon,ThrowStatement:checkForSemicolon,DoWhileStatement:checkForSemicolon,DebuggerStatement:checkForSemicolon,BreakStatement:checkForSemicolon,ContinueStatement:checkForSemicolon,ImportDeclaration:checkForSemicolon,ExportAllDeclaration:checkForSemicolon,ExportNamedDeclaration(node){if(!node.declaration){checkForSemicolon(node);}},ExportDefaultDeclaration(node){if(!/(?:Class|Function)Declaration/u.test(node.declaration.type)){checkForSemicolon(node);}}};}};var sortImports={meta:{type:"suggestion",docs:{description:"enforce sorted import declarations within modules",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/sort-imports"},schema:[{type:"object",properties:{ignoreCase:{type:"boolean",default:false},memberSyntaxSortOrder:{type:"array",items:{enum:["none","all","multiple","single"]},uniqueItems:true,minItems:4,maxItems:4},ignoreDeclarationSort:{type:"boolean",default:false},ignoreMemberSort:{type:"boolean",default:false},allowSeparatedGroups:{type:"boolean",default:false}},additionalProperties:false}],fixable:"code",messages:{sortImportsAlphabetically:"Imports should be sorted alphabetically.",sortMembersAlphabetically:"Member '{{memberName}}' of the import declaration should be sorted alphabetically.",unexpectedSyntaxOrder:"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax."}},create(context){const configuration=context.options[0]||{},ignoreCase=configuration.ignoreCase||false,ignoreDeclarationSort=configuration.ignoreDeclarationSort||false,ignoreMemberSort=configuration.ignoreMemberSort||false,memberSyntaxSortOrder=configuration.memberSyntaxSortOrder||["none","all","multiple","single"],allowSeparatedGroups=configuration.allowSeparatedGroups||false,sourceCode=context.getSourceCode();let previousDeclaration=null;function usedMemberSyntax(node){if(node.specifiers.length===0){return "none";}if(node.specifiers[0].type==="ImportNamespaceSpecifier"){return "all";}if(node.specifiers.length===1){return "single";}return "multiple";}function getMemberParameterGroupIndex(node){return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));}function getFirstLocalMemberName(node){if(node.specifiers[0]){return node.specifiers[0].local.name;}return null;}function getNumberOfLinesBetween(left,right){return Math.max(right.loc.start.line-left.loc.end.line-1,0);}return {ImportDeclaration(node){if(!ignoreDeclarationSort){if(previousDeclaration&&allowSeparatedGroups&&getNumberOfLinesBetween(previousDeclaration,node)>0){previousDeclaration=null;}if(previousDeclaration){const currentMemberSyntaxGroupIndex=getMemberParameterGroupIndex(node),previousMemberSyntaxGroupIndex=getMemberParameterGroupIndex(previousDeclaration);let currentLocalMemberName=getFirstLocalMemberName(node),previousLocalMemberName=getFirstLocalMemberName(previousDeclaration);if(ignoreCase){previousLocalMemberName=previousLocalMemberName&&previousLocalMemberName.toLowerCase();currentLocalMemberName=currentLocalMemberName&&currentLocalMemberName.toLowerCase();}if(currentMemberSyntaxGroupIndex!==previousMemberSyntaxGroupIndex){if(currentMemberSyntaxGroupIndex<previousMemberSyntaxGroupIndex){context.report({node,messageId:"unexpectedSyntaxOrder",data:{syntaxA:memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],syntaxB:memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]}});}}else {if(previousLocalMemberName&&currentLocalMemberName&&currentLocalMemberName<previousLocalMemberName){context.report({node,messageId:"sortImportsAlphabetically"});}}}previousDeclaration=node;}if(!ignoreMemberSort){const importSpecifiers=node.specifiers.filter(specifier=>specifier.type==="ImportSpecifier");const getSortableName=ignoreCase?specifier=>specifier.local.name.toLowerCase():specifier=>specifier.local.name;const firstUnsortedIndex=importSpecifiers.map(getSortableName).findIndex((name,index,array)=>array[index-1]>name);if(firstUnsortedIndex!==-1){context.report({node:importSpecifiers[firstUnsortedIndex],messageId:"sortMembersAlphabetically",data:{memberName:importSpecifiers[firstUnsortedIndex].local.name},fix(fixer){if(importSpecifiers.some(specifier=>sourceCode.getCommentsBefore(specifier).length||sourceCode.getCommentsAfter(specifier).length)){return null;}return fixer.replaceTextRange([importSpecifiers[0].range[0],importSpecifiers[importSpecifiers.length-1].range[1]],importSpecifiers.slice().sort((specifierA,specifierB)=>{const aName=getSortableName(specifierA);const bName=getSortableName(specifierB);return aName>bName?1:-1;}).reduce((sourceText,specifier,index)=>{const textAfterSpecifier=index===importSpecifiers.length-1?"":sourceCode.getText().slice(importSpecifiers[index].range[1],importSpecifiers[index+1].range[0]);return sourceText+sourceCode.getText(specifier)+textAfterSpecifier;},""));}});}}}};}};function getPropertyName(node){const staticName=astUtils.getStaticPropertyName(node);if(staticName!==null){return staticName;}return node.key.name||null;}const isValidOrders={asc(a,b){return a<=b;},ascI(a,b){return a.toLowerCase()<=b.toLowerCase();},ascN(a,b){return naturalCompare__default['default'](a,b)<=0;},ascIN(a,b){return naturalCompare__default['default'](a.toLowerCase(),b.toLowerCase())<=0;},desc(a,b){return isValidOrders.asc(b,a);},descI(a,b){return isValidOrders.ascI(b,a);},descN(a,b){return isValidOrders.ascN(b,a);},descIN(a,b){return isValidOrders.ascIN(b,a);}};var sortKeys={meta:{type:"suggestion",docs:{description:"require object keys to be sorted",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/sort-keys"},schema:[{enum:["asc","desc"]},{type:"object",properties:{caseSensitive:{type:"boolean",default:true},natural:{type:"boolean",default:false},minKeys:{type:"integer",minimum:2,default:2}},additionalProperties:false}],messages:{sortKeys:"Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'."}},create(context){const order=context.options[0]||"asc";const options=context.options[1];const insensitive=options&&options.caseSensitive===false;const natural=options&&options.natural;const minKeys=options&&options.minKeys;const isValidOrder=isValidOrders[order+(insensitive?"I":"")+(natural?"N":"")];let stack=null;return {ObjectExpression(node){stack={upper:stack,prevName:null,numKeys:node.properties.length};},"ObjectExpression:exit"(){stack=stack.upper;},SpreadElement(node){if(node.parent.type==="ObjectExpression"){stack.prevName=null;}},Property(node){if(node.parent.type==="ObjectPattern"){return;}const prevName=stack.prevName;const numKeys=stack.numKeys;const thisName=getPropertyName(node);if(thisName!==null){stack.prevName=thisName;}if(prevName===null||thisName===null||numKeys<minKeys){return;}if(!isValidOrder(prevName,thisName)){context.report({node,loc:node.key.loc,messageId:"sortKeys",data:{thisName,prevName,order,insensitive:insensitive?"insensitive ":"",natural:natural?"natural ":""}});}}};}};var sortVars={meta:{type:"suggestion",docs:{description:"require variables within the same declaration block to be sorted",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/sort-vars"},schema:[{type:"object",properties:{ignoreCase:{type:"boolean",default:false}},additionalProperties:false}],fixable:"code",messages:{sortVars:"Variables within the same declaration block should be sorted alphabetically."}},create(context){const configuration=context.options[0]||{},ignoreCase=configuration.ignoreCase||false,sourceCode=context.getSourceCode();return {VariableDeclaration(node){const idDeclarations=node.declarations.filter(decl=>decl.id.type==="Identifier");const getSortableName=ignoreCase?decl=>decl.id.name.toLowerCase():decl=>decl.id.name;const unfixable=idDeclarations.some(decl=>decl.init!==null&&decl.init.type!=="Literal");let fixed=false;idDeclarations.slice(1).reduce((memo,decl)=>{const lastVariableName=getSortableName(memo),currentVariableName=getSortableName(decl);if(currentVariableName<lastVariableName){context.report({node:decl,messageId:"sortVars",fix(fixer){if(unfixable||fixed){return null;}return fixer.replaceTextRange([idDeclarations[0].range[0],idDeclarations[idDeclarations.length-1].range[1]],idDeclarations.slice().sort((declA,declB)=>{const aName=getSortableName(declA);const bName=getSortableName(declB);return aName>bName?1:-1;}).reduce((sourceText,identifier,index)=>{const textAfterIdentifier=index===idDeclarations.length-1?"":sourceCode.getText().slice(idDeclarations[index].range[1],idDeclarations[index+1].range[0]);return sourceText+sourceCode.getText(identifier)+textAfterIdentifier;},""));}});fixed=true;return memo;}return decl;},idDeclarations[0]);}};}};function isFunctionBody(node){const parent=node.parent;return node.type==="BlockStatement"&&astUtils.isFunction(parent)&&parent.body===node;}var spaceBeforeBlocks={meta:{type:"layout",docs:{description:"enforce consistent spacing before blocks",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/space-before-blocks"},fixable:"whitespace",schema:[{oneOf:[{enum:["always","never"]},{type:"object",properties:{keywords:{enum:["always","never","off"]},functions:{enum:["always","never","off"]},classes:{enum:["always","never","off"]}},additionalProperties:false}]}],messages:{unexpectedSpace:"Unexpected space before opening brace.",missingSpace:"Missing space before opening brace."}},create(context){const config=context.options[0],sourceCode=context.getSourceCode();let alwaysFunctions=true,alwaysKeywords=true,alwaysClasses=true,neverFunctions=false,neverKeywords=false,neverClasses=false;if(typeof config==="object"){alwaysFunctions=config.functions==="always";alwaysKeywords=config.keywords==="always";alwaysClasses=config.classes==="always";neverFunctions=config.functions==="never";neverKeywords=config.keywords==="never";neverClasses=config.classes==="never";}else if(config==="never"){alwaysFunctions=false;alwaysKeywords=false;alwaysClasses=false;neverFunctions=true;neverKeywords=true;neverClasses=true;}function isConflicted(precedingToken,node){return astUtils.isArrowToken(precedingToken)||astUtils.isKeywordToken(precedingToken)&&!isFunctionBody(node);}function checkPrecedingSpace(node){const precedingToken=sourceCode.getTokenBefore(node);if(precedingToken&&!isConflicted(precedingToken,node)&&astUtils.isTokenOnSameLine(precedingToken,node)){const hasSpace=sourceCode.isSpaceBetweenTokens(precedingToken,node);let requireSpace;let requireNoSpace;if(isFunctionBody(node)){requireSpace=alwaysFunctions;requireNoSpace=neverFunctions;}else if(node.type==="ClassBody"){requireSpace=alwaysClasses;requireNoSpace=neverClasses;}else {requireSpace=alwaysKeywords;requireNoSpace=neverKeywords;}if(requireSpace&&!hasSpace){context.report({node,messageId:"missingSpace",fix(fixer){return fixer.insertTextBefore(node," ");}});}else if(requireNoSpace&&hasSpace){context.report({node,messageId:"unexpectedSpace",fix(fixer){return fixer.removeRange([precedingToken.range[1],node.range[0]]);}});}}}return {BlockStatement:checkPrecedingSpace,ClassBody:checkPrecedingSpace,SwitchStatement:function(node){const cases=node.cases;let openingBrace;if(cases.length>0){openingBrace=sourceCode.getTokenBefore(cases[0]);}else {openingBrace=sourceCode.getLastToken(node,1);}checkPrecedingSpace(openingBrace);}};}};var spaceBeforeFunctionParen={meta:{type:"layout",docs:{description:"enforce consistent spacing before `function` definition opening parenthesis",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/space-before-function-paren"},fixable:"whitespace",schema:[{oneOf:[{enum:["always","never"]},{type:"object",properties:{anonymous:{enum:["always","never","ignore"]},named:{enum:["always","never","ignore"]},asyncArrow:{enum:["always","never","ignore"]}},additionalProperties:false}]}],messages:{unexpectedSpace:"Unexpected space before function parentheses.",missingSpace:"Missing space before function parentheses."}},create(context){const sourceCode=context.getSourceCode();const baseConfig=typeof context.options[0]==="string"?context.options[0]:"always";const overrideConfig=typeof context.options[0]==="object"?context.options[0]:{};function isNamedFunction(node){if(node.id){return true;}const parent=node.parent;return parent.type==="MethodDefinition"||parent.type==="Property"&&(parent.kind==="get"||parent.kind==="set"||parent.method);}function getConfigForFunction(node){if(node.type==="ArrowFunctionExpression"){if(node.async&&astUtils.isOpeningParenToken(sourceCode.getFirstToken(node,{skip:1}))){return overrideConfig.asyncArrow||baseConfig;}}else if(isNamedFunction(node)){return overrideConfig.named||baseConfig;}else if(!node.generator){return overrideConfig.anonymous||baseConfig;}return "ignore";}function checkFunction(node){const functionConfig=getConfigForFunction(node);if(functionConfig==="ignore"){return;}const rightToken=sourceCode.getFirstToken(node,astUtils.isOpeningParenToken);const leftToken=sourceCode.getTokenBefore(rightToken);const hasSpacing=sourceCode.isSpaceBetweenTokens(leftToken,rightToken);if(hasSpacing&&functionConfig==="never"){context.report({node,loc:{start:leftToken.loc.end,end:rightToken.loc.start},messageId:"unexpectedSpace",fix(fixer){const comments=sourceCode.getCommentsBefore(rightToken);if(comments.some(comment=>comment.type==="Line")){return null;}return fixer.replaceTextRange([leftToken.range[1],rightToken.range[0]],comments.reduce((text,comment)=>text+sourceCode.getText(comment),""));}});}else if(!hasSpacing&&functionConfig==="always"){context.report({node,loc:rightToken.loc,messageId:"missingSpace",fix:fixer=>fixer.insertTextAfter(leftToken," ")});}}return {ArrowFunctionExpression:checkFunction,FunctionDeclaration:checkFunction,FunctionExpression:checkFunction};}};var spaceInParens={meta:{type:"layout",docs:{description:"enforce consistent spacing inside parentheses",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/space-in-parens"},fixable:"whitespace",schema:[{enum:["always","never"]},{type:"object",properties:{exceptions:{type:"array",items:{enum:["{}","[]","()","empty"]},uniqueItems:true}},additionalProperties:false}],messages:{missingOpeningSpace:"There must be a space after this paren.",missingClosingSpace:"There must be a space before this paren.",rejectedOpeningSpace:"There should be no space after this paren.",rejectedClosingSpace:"There should be no space before this paren."}},create(context){const ALWAYS=context.options[0]==="always",exceptionsArrayOptions=context.options[1]&&context.options[1].exceptions||[],options={};let exceptions;if(exceptionsArrayOptions.length){options.braceException=exceptionsArrayOptions.includes("{}");options.bracketException=exceptionsArrayOptions.includes("[]");options.parenException=exceptionsArrayOptions.includes("()");options.empty=exceptionsArrayOptions.includes("empty");}function getExceptions(){const openers=[],closers=[];if(options.braceException){openers.push("{");closers.push("}");}if(options.bracketException){openers.push("[");closers.push("]");}if(options.parenException){openers.push("(");closers.push(")");}if(options.empty){openers.push(")");closers.push("(");}return {openers,closers};}const sourceCode=context.getSourceCode();function isOpenerException(token){return exceptions.openers.includes(token.value);}function isCloserException(token){return exceptions.closers.includes(token.value);}function openerMissingSpace(openingParenToken,tokenAfterOpeningParen){if(sourceCode.isSpaceBetweenTokens(openingParenToken,tokenAfterOpeningParen)){return false;}if(!options.empty&&astUtils.isClosingParenToken(tokenAfterOpeningParen)){return false;}if(ALWAYS){return !isOpenerException(tokenAfterOpeningParen);}return isOpenerException(tokenAfterOpeningParen);}function openerRejectsSpace(openingParenToken,tokenAfterOpeningParen){if(!astUtils.isTokenOnSameLine(openingParenToken,tokenAfterOpeningParen)){return false;}if(tokenAfterOpeningParen.type==="Line"){return false;}if(!sourceCode.isSpaceBetweenTokens(openingParenToken,tokenAfterOpeningParen)){return false;}if(ALWAYS){return isOpenerException(tokenAfterOpeningParen);}return !isOpenerException(tokenAfterOpeningParen);}function closerMissingSpace(tokenBeforeClosingParen,closingParenToken){if(sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen,closingParenToken)){return false;}if(!options.empty&&astUtils.isOpeningParenToken(tokenBeforeClosingParen)){return false;}if(ALWAYS){return !isCloserException(tokenBeforeClosingParen);}return isCloserException(tokenBeforeClosingParen);}function closerRejectsSpace(tokenBeforeClosingParen,closingParenToken){if(!astUtils.isTokenOnSameLine(tokenBeforeClosingParen,closingParenToken)){return false;}if(!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen,closingParenToken)){return false;}if(ALWAYS){return isCloserException(tokenBeforeClosingParen);}return !isCloserException(tokenBeforeClosingParen);}return {Program:function(node){exceptions=getExceptions();const tokens=sourceCode.tokensAndComments;tokens.forEach((token,i)=>{const prevToken=tokens[i-1];const nextToken=tokens[i+1];if(!astUtils.isOpeningParenToken(token)&&!astUtils.isClosingParenToken(token)){return;}if(token.value==="("&&openerMissingSpace(token,nextToken)){context.report({node,loc:token.loc,messageId:"missingOpeningSpace",fix(fixer){return fixer.insertTextAfter(token," ");}});}if(token.value==="("&&openerRejectsSpace(token,nextToken)){context.report({node,loc:{start:token.loc.end,end:nextToken.loc.start},messageId:"rejectedOpeningSpace",fix(fixer){return fixer.removeRange([token.range[1],nextToken.range[0]]);}});}if(token.value===")"&&closerMissingSpace(prevToken,token)){context.report({node,loc:token.loc,messageId:"missingClosingSpace",fix(fixer){return fixer.insertTextBefore(token," ");}});}if(token.value===")"&&closerRejectsSpace(prevToken,token)){context.report({node,loc:{start:prevToken.loc.end,end:token.loc.start},messageId:"rejectedClosingSpace",fix(fixer){return fixer.removeRange([prevToken.range[1],token.range[0]]);}});}});}};}};var spaceInfixOps={meta:{type:"layout",docs:{description:"require spacing around infix operators",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/space-infix-ops"},fixable:"whitespace",schema:[{type:"object",properties:{int32Hint:{type:"boolean",default:false}},additionalProperties:false}],messages:{missingSpace:"Operator '{{operator}}' must be spaced."}},create(context){const int32Hint=context.options[0]?context.options[0].int32Hint===true:false;const sourceCode=context.getSourceCode();function getFirstNonSpacedToken(left,right,op){const operator=sourceCode.getFirstTokenBetween(left,right,token=>token.value===op);const prev=sourceCode.getTokenBefore(operator);const next=sourceCode.getTokenAfter(operator);if(!sourceCode.isSpaceBetweenTokens(prev,operator)||!sourceCode.isSpaceBetweenTokens(operator,next)){return operator;}return null;}function report(mainNode,culpritToken){context.report({node:mainNode,loc:culpritToken.loc,messageId:"missingSpace",data:{operator:culpritToken.value},fix(fixer){const previousToken=sourceCode.getTokenBefore(culpritToken);const afterToken=sourceCode.getTokenAfter(culpritToken);let fixString="";if(culpritToken.range[0]-previousToken.range[1]===0){fixString=" ";}fixString+=culpritToken.value;if(afterToken.range[0]-culpritToken.range[1]===0){fixString+=" ";}return fixer.replaceText(culpritToken,fixString);}});}function checkBinary(node){const leftNode=node.left.typeAnnotation?node.left.typeAnnotation:node.left;const rightNode=node.right;const operator=node.operator||"=";const nonSpacedNode=getFirstNonSpacedToken(leftNode,rightNode,operator);if(nonSpacedNode){if(!(int32Hint&&sourceCode.getText(node).endsWith("|0"))){report(node,nonSpacedNode);}}}return {AssignmentExpression:checkBinary,AssignmentPattern:checkBinary,BinaryExpression:checkBinary,LogicalExpression:checkBinary,ConditionalExpression:function(node){const nonSpacedConsequentNode=getFirstNonSpacedToken(node.test,node.consequent,"?");const nonSpacedAlternateNode=getFirstNonSpacedToken(node.consequent,node.alternate,":");if(nonSpacedConsequentNode){report(node,nonSpacedConsequentNode);}if(nonSpacedAlternateNode){report(node,nonSpacedAlternateNode);}},VariableDeclarator:function(node){const leftNode=node.id.typeAnnotation?node.id.typeAnnotation:node.id;const rightNode=node.init;if(rightNode){const nonSpacedNode=getFirstNonSpacedToken(leftNode,rightNode,"=");if(nonSpacedNode){report(node,nonSpacedNode);}}}};}};var spaceUnaryOps={meta:{type:"layout",docs:{description:"enforce consistent spacing before or after unary operators",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/space-unary-ops"},fixable:"whitespace",schema:[{type:"object",properties:{words:{type:"boolean",default:true},nonwords:{type:"boolean",default:false},overrides:{type:"object",additionalProperties:{type:"boolean"}}},additionalProperties:false}],messages:{unexpectedBefore:"Unexpected space before unary operator '{{operator}}'.",unexpectedAfter:"Unexpected space after unary operator '{{operator}}'.",unexpectedAfterWord:"Unexpected space after unary word operator '{{word}}'.",wordOperator:"Unary word operator '{{word}}' must be followed by whitespace.",operator:"Unary operator '{{operator}}' must be followed by whitespace.",beforeUnaryExpressions:"Space is required before unary expressions '{{token}}'."}},create(context){const options=context.options[0]||{words:true,nonwords:false};const sourceCode=context.getSourceCode();function isFirstBangInBangBangExpression(node){return node&&node.type==="UnaryExpression"&&node.argument.operator==="!"&&node.argument&&node.argument.type==="UnaryExpression"&&node.argument.operator==="!";}function overrideExistsForOperator(operator){return options.overrides&&Object.prototype.hasOwnProperty.call(options.overrides,operator);}function overrideEnforcesSpaces(operator){return options.overrides[operator];}function verifyWordHasSpaces(node,firstToken,secondToken,word){if(secondToken.range[0]===firstToken.range[1]){context.report({node,messageId:"wordOperator",data:{word},fix(fixer){return fixer.insertTextAfter(firstToken," ");}});}}function verifyWordDoesntHaveSpaces(node,firstToken,secondToken,word){if(astUtils.canTokensBeAdjacent(firstToken,secondToken)){if(secondToken.range[0]>firstToken.range[1]){context.report({node,messageId:"unexpectedAfterWord",data:{word},fix(fixer){return fixer.removeRange([firstToken.range[1],secondToken.range[0]]);}});}}}function checkUnaryWordOperatorForSpaces(node,firstToken,secondToken,word){if(overrideExistsForOperator(word)){if(overrideEnforcesSpaces(word)){verifyWordHasSpaces(node,firstToken,secondToken,word);}else {verifyWordDoesntHaveSpaces(node,firstToken,secondToken,word);}}else if(options.words){verifyWordHasSpaces(node,firstToken,secondToken,word);}else {verifyWordDoesntHaveSpaces(node,firstToken,secondToken,word);}}function verifyNonWordsHaveSpaces(node,firstToken,secondToken){if(node.prefix){if(isFirstBangInBangBangExpression(node)){return;}if(firstToken.range[1]===secondToken.range[0]){context.report({node,messageId:"operator",data:{operator:firstToken.value},fix(fixer){return fixer.insertTextAfter(firstToken," ");}});}}else {if(firstToken.range[1]===secondToken.range[0]){context.report({node,messageId:"beforeUnaryExpressions",data:{token:secondToken.value},fix(fixer){return fixer.insertTextBefore(secondToken," ");}});}}}function verifyNonWordsDontHaveSpaces(node,firstToken,secondToken){if(node.prefix){if(secondToken.range[0]>firstToken.range[1]){context.report({node,messageId:"unexpectedAfter",data:{operator:firstToken.value},fix(fixer){if(astUtils.canTokensBeAdjacent(firstToken,secondToken)){return fixer.removeRange([firstToken.range[1],secondToken.range[0]]);}return null;}});}}else {if(secondToken.range[0]>firstToken.range[1]){context.report({node,messageId:"unexpectedBefore",data:{operator:secondToken.value},fix(fixer){return fixer.removeRange([firstToken.range[1],secondToken.range[0]]);}});}}}function checkForSpaces(node){const tokens=node.type==="UpdateExpression"&&!node.prefix?sourceCode.getLastTokens(node,2):sourceCode.getFirstTokens(node,2);const firstToken=tokens[0];const secondToken=tokens[1];if((node.type==="NewExpression"||node.prefix)&&firstToken.type==="Keyword"){checkUnaryWordOperatorForSpaces(node,firstToken,secondToken,firstToken.value);return;}const operator=node.prefix?tokens[0].value:tokens[1].value;if(overrideExistsForOperator(operator)){if(overrideEnforcesSpaces(operator)){verifyNonWordsHaveSpaces(node,firstToken,secondToken);}else {verifyNonWordsDontHaveSpaces(node,firstToken,secondToken);}}else if(options.nonwords){verifyNonWordsHaveSpaces(node,firstToken,secondToken);}else {verifyNonWordsDontHaveSpaces(node,firstToken,secondToken);}}return {UnaryExpression:checkForSpaces,UpdateExpression:checkForSpaces,NewExpression:checkForSpaces,YieldExpression:function(node){const tokens=sourceCode.getFirstTokens(node,3);if(!node.argument||node.delegate){return;}checkUnaryWordOperatorForSpaces(node,tokens[0],tokens[1],"yield");},AwaitExpression:function(node){const tokens=sourceCode.getFirstTokens(node,3);checkUnaryWordOperatorForSpaces(node,tokens[0],tokens[1],"await");}};}};function escape$1(s){return `(?:${lodash__default['default'].escapeRegExp(s)})`;}function escapeAndRepeat(s){return `${escape$1(s)}+`;}function parseMarkersOption(markers){if(markers.indexOf("*")===-1){return markers.concat("*");}return markers;}function createExceptionsPattern(exceptions){let pattern="";if(exceptions.length===0){pattern+="\\s";}else {pattern+="(?:\\s|";if(exceptions.length===1){pattern+=escapeAndRepeat(exceptions[0]);}else {pattern+="(?:";pattern+=exceptions.map(escapeAndRepeat).join("|");pattern+=")";}pattern+=`(?:$|[${Array.from(astUtils.LINEBREAKS).join("")}]))`;}return pattern;}function createAlwaysStylePattern(markers,exceptions){let pattern="^";if(markers.length===1){pattern+=escape$1(markers[0]);}else {pattern+="(?:";pattern+=markers.map(escape$1).join("|");pattern+=")";}pattern+="?";pattern+=createExceptionsPattern(exceptions);return new RegExp(pattern,"u");}function createNeverStylePattern(markers){const pattern=`^(${markers.map(escape$1).join("|")})?[ \t]+`;return new RegExp(pattern,"u");}var spacedComment={meta:{type:"suggestion",docs:{description:"enforce consistent spacing after the `//` or `/*` in a comment",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/spaced-comment"},fixable:"whitespace",schema:[{enum:["always","never"]},{type:"object",properties:{exceptions:{type:"array",items:{type:"string"}},markers:{type:"array",items:{type:"string"}},line:{type:"object",properties:{exceptions:{type:"array",items:{type:"string"}},markers:{type:"array",items:{type:"string"}}},additionalProperties:false},block:{type:"object",properties:{exceptions:{type:"array",items:{type:"string"}},markers:{type:"array",items:{type:"string"}},balanced:{type:"boolean",default:false}},additionalProperties:false}},additionalProperties:false}],messages:{unexpectedSpaceAfterMarker:"Unexpected space or tab after marker ({{refChar}}) in comment.",expectedExceptionAfter:"Expected exception block, space or tab after '{{refChar}}' in comment.",unexpectedSpaceBefore:"Unexpected space or tab before '*/' in comment.",unexpectedSpaceAfter:"Unexpected space or tab after '{{refChar}}' in comment.",expectedSpaceBefore:"Expected space or tab before '*/' in comment.",expectedSpaceAfter:"Expected space or tab after '{{refChar}}' in comment."}},create(context){const sourceCode=context.getSourceCode();const requireSpace=context.options[0]!=="never";const config=context.options[1]||{};const balanced=config.block&&config.block.balanced;const styleRules=["block","line"].reduce((rule,type)=>{const markers=parseMarkersOption(config[type]&&config[type].markers||config.markers||[]);const exceptions=config[type]&&config[type].exceptions||config.exceptions||[];rule[type]={beginRegex:requireSpace?createAlwaysStylePattern(markers,exceptions):createNeverStylePattern(markers),endRegex:balanced&&requireSpace?new RegExp(`${createExceptionsPattern(exceptions)}$`,"u"):new RegExp("[ \t]+$","u"),hasExceptions:exceptions.length>0,captureMarker:new RegExp(`^(${markers.map(escape$1).join("|")})`,"u"),markers:new Set(markers)};return rule;},{});function reportBegin(node,messageId,match,refChar){const type=node.type.toLowerCase(),commentIdentifier=type==="block"?"/*":"//";context.report({node,fix(fixer){const start=node.range[0];let end=start+2;if(requireSpace){if(match){end+=match[0].length;}return fixer.insertTextAfterRange([start,end]," ");}end+=match[0].length;return fixer.replaceTextRange([start,end],commentIdentifier+(match[1]?match[1]:""));},messageId,data:{refChar}});}function reportEnd(node,messageId,match){context.report({node,fix(fixer){if(requireSpace){return fixer.insertTextAfterRange([node.range[0],node.range[1]-2]," ");}const end=node.range[1]-2,start=end-match[0].length;return fixer.replaceTextRange([start,end],"");},messageId});}function checkCommentForSpace(node){const type=node.type.toLowerCase(),rule=styleRules[type],commentIdentifier=type==="block"?"/*":"//";if(node.value.length===0||rule.markers.has(node.value)){return;}const beginMatch=rule.beginRegex.exec(node.value);const endMatch=rule.endRegex.exec(node.value);if(requireSpace){if(!beginMatch){const hasMarker=rule.captureMarker.exec(node.value);const marker=hasMarker?commentIdentifier+hasMarker[0]:commentIdentifier;if(rule.hasExceptions){reportBegin(node,"expectedExceptionAfter",hasMarker,marker);}else {reportBegin(node,"expectedSpaceAfter",hasMarker,marker);}}if(balanced&&type==="block"&&!endMatch){reportEnd(node,"expectedSpaceBefore");}}else {if(beginMatch){if(!beginMatch[1]){reportBegin(node,"unexpectedSpaceAfter",beginMatch,commentIdentifier);}else {reportBegin(node,"unexpectedSpaceAfterMarker",beginMatch,beginMatch[1]);}}if(balanced&&type==="block"&&endMatch){reportEnd(node,"unexpectedSpaceBefore",endMatch);}}}return {Program(){const comments=sourceCode.getAllComments();comments.filter(token=>token.type!=="Shebang").forEach(checkCommentForSpace);}};}};function getUseStrictDirectives(statements){const directives=[];for(let i=0;i<statements.length;i++){const statement=statements[i];if(statement.type==="ExpressionStatement"&&statement.expression.type==="Literal"&&statement.expression.value==="use strict"){directives[i]=statement;}else {break;}}return directives;}function isSimpleParameter(node){return node.type==="Identifier";}function isSimpleParameterList(params){return params.every(isSimpleParameter);}var strict={meta:{type:"suggestion",docs:{description:"require or disallow strict mode directives",category:"Strict Mode",recommended:false,url:"https://eslint.org/docs/rules/strict"},schema:[{enum:["never","global","function","safe"]}],fixable:"code",messages:{function:"Use the function form of 'use strict'.",global:"Use the global form of 'use strict'.",multiple:"Multiple 'use strict' directives.",never:"Strict mode is not permitted.",unnecessary:"Unnecessary 'use strict' directive.",module:"'use strict' is unnecessary inside of modules.",implied:"'use strict' is unnecessary when implied strict mode is enabled.",unnecessaryInClasses:"'use strict' is unnecessary inside of classes.",nonSimpleParameterList:"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",wrap:"Wrap {{name}} in a function with 'use strict' directive."}},create(context){const ecmaFeatures=context.parserOptions.ecmaFeatures||{},scopes=[],classScopes=[];let mode=context.options[0]||"safe";if(ecmaFeatures.impliedStrict){mode="implied";}else if(mode==="safe"){mode=ecmaFeatures.globalReturn?"global":"function";}function shouldFix(errorType){return errorType==="multiple"||errorType==="unnecessary"||errorType==="module"||errorType==="implied"||errorType==="unnecessaryInClasses";}function getFixFunction(node){return fixer=>fixer.remove(node);}function reportSlice(nodes,start,end,messageId,fix){nodes.slice(start,end).forEach(node=>{context.report({node,messageId,fix:fix?getFixFunction(node):null});});}function reportAll(nodes,messageId,fix){reportSlice(nodes,0,nodes.length,messageId,fix);}function reportAllExceptFirst(nodes,messageId,fix){reportSlice(nodes,1,nodes.length,messageId,fix);}function enterFunctionInFunctionMode(node,useStrictDirectives){const isInClass=classScopes.length>0,isParentGlobal=scopes.length===0&&classScopes.length===0,isParentStrict=scopes.length>0&&scopes[scopes.length-1],isStrict=useStrictDirectives.length>0;if(isStrict){if(!isSimpleParameterList(node.params)){context.report({node:useStrictDirectives[0],messageId:"nonSimpleParameterList"});}else if(isParentStrict){context.report({node:useStrictDirectives[0],messageId:"unnecessary",fix:getFixFunction(useStrictDirectives[0])});}else if(isInClass){context.report({node:useStrictDirectives[0],messageId:"unnecessaryInClasses",fix:getFixFunction(useStrictDirectives[0])});}reportAllExceptFirst(useStrictDirectives,"multiple",true);}else if(isParentGlobal){if(isSimpleParameterList(node.params)){context.report({node,messageId:"function"});}else {context.report({node,messageId:"wrap",data:{name:astUtils.getFunctionNameWithKind(node)}});}}scopes.push(isParentStrict||isStrict);}function exitFunctionInFunctionMode(){scopes.pop();}function enterFunction(node){const isBlock=node.body.type==="BlockStatement",useStrictDirectives=isBlock?getUseStrictDirectives(node.body.body):[];if(mode==="function"){enterFunctionInFunctionMode(node,useStrictDirectives);}else if(useStrictDirectives.length>0){if(isSimpleParameterList(node.params)){reportAll(useStrictDirectives,mode,shouldFix(mode));}else {context.report({node:useStrictDirectives[0],messageId:"nonSimpleParameterList"});reportAllExceptFirst(useStrictDirectives,"multiple",true);}}}const rule={Program(node){const useStrictDirectives=getUseStrictDirectives(node.body);if(node.sourceType==="module"){mode="module";}if(mode==="global"){if(node.body.length>0&&useStrictDirectives.length===0){context.report({node,messageId:"global"});}reportAllExceptFirst(useStrictDirectives,"multiple",true);}else {reportAll(useStrictDirectives,mode,shouldFix(mode));}},FunctionDeclaration:enterFunction,FunctionExpression:enterFunction,ArrowFunctionExpression:enterFunction};if(mode==="function"){Object.assign(rule,{ClassBody(){classScopes.push(true);},"ClassBody:exit"(){classScopes.pop();},"FunctionDeclaration:exit":exitFunctionInFunctionMode,"FunctionExpression:exit":exitFunctionInFunctionMode,"ArrowFunctionExpression:exit":exitFunctionInFunctionMode});}return rule;}};var switchColonSpacing={meta:{type:"layout",docs:{description:"enforce spacing around colons of switch statements",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/switch-colon-spacing"},schema:[{type:"object",properties:{before:{type:"boolean",default:false},after:{type:"boolean",default:true}},additionalProperties:false}],fixable:"whitespace",messages:{expectedBefore:"Expected space(s) before this colon.",expectedAfter:"Expected space(s) after this colon.",unexpectedBefore:"Unexpected space(s) before this colon.",unexpectedAfter:"Unexpected space(s) after this colon."}},create(context){const sourceCode=context.getSourceCode();const options=context.options[0]||{};const beforeSpacing=options.before===true;const afterSpacing=options.after!==false;function getColonToken(node){if(node.test){return sourceCode.getTokenAfter(node.test,astUtils.isColonToken);}return sourceCode.getFirstToken(node,1);}function isValidSpacing(left,right,expected){return astUtils.isClosingBraceToken(right)||!astUtils.isTokenOnSameLine(left,right)||sourceCode.isSpaceBetweenTokens(left,right)===expected;}function commentsExistBetween(left,right){return sourceCode.getFirstTokenBetween(left,right,{includeComments:true,filter:astUtils.isCommentToken})!==null;}function fix(fixer,left,right,spacing){if(commentsExistBetween(left,right)){return null;}if(spacing){return fixer.insertTextAfter(left," ");}return fixer.removeRange([left.range[1],right.range[0]]);}return {SwitchCase(node){const colonToken=getColonToken(node);const beforeToken=sourceCode.getTokenBefore(colonToken);const afterToken=sourceCode.getTokenAfter(colonToken);if(!isValidSpacing(beforeToken,colonToken,beforeSpacing)){context.report({node,loc:colonToken.loc,messageId:beforeSpacing?"expectedBefore":"unexpectedBefore",fix:fixer=>fix(fixer,beforeToken,colonToken,beforeSpacing)});}if(!isValidSpacing(colonToken,afterToken,afterSpacing)){context.report({node,loc:colonToken.loc,messageId:afterSpacing?"expectedAfter":"unexpectedAfter",fix:fixer=>fix(fixer,colonToken,afterToken,afterSpacing)});}}};}};var symbolDescription={meta:{type:"suggestion",docs:{description:"require symbol descriptions",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/symbol-description"},fixable:null,schema:[],messages:{expected:"Expected Symbol to have a description."}},create(context){function checkArgument(node){if(node.arguments.length===0){context.report({node,messageId:"expected"});}}return {"Program:exit"(){const scope=context.getScope();const variable=astUtils.getVariableByName(scope,"Symbol");if(variable&&variable.defs.length===0){variable.references.forEach(reference=>{const node=reference.identifier;if(astUtils.isCallee(node)){checkArgument(node.parent);}});}}};}};var templateCurlySpacing={meta:{type:"layout",docs:{description:"require or disallow spacing around embedded expressions of template strings",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/template-curly-spacing"},fixable:"whitespace",schema:[{enum:["always","never"]}],messages:{expectedBefore:"Expected space(s) before '}'.",expectedAfter:"Expected space(s) after '${'.",unexpectedBefore:"Unexpected space(s) before '}'.",unexpectedAfter:"Unexpected space(s) after '${'."}},create(context){const sourceCode=context.getSourceCode();const always=context.options[0]==="always";function checkSpacingBefore(token){if(!token.value.startsWith("}")){return;}const prevToken=sourceCode.getTokenBefore(token,{includeComments:true}),hasSpace=sourceCode.isSpaceBetween(prevToken,token);if(!astUtils.isTokenOnSameLine(prevToken,token)){return;}if(always&&!hasSpace){context.report({loc:{start:token.loc.start,end:{line:token.loc.start.line,column:token.loc.start.column+1}},messageId:"expectedBefore",fix:fixer=>fixer.insertTextBefore(token," ")});}if(!always&&hasSpace){context.report({loc:{start:prevToken.loc.end,end:token.loc.start},messageId:"unexpectedBefore",fix:fixer=>fixer.removeRange([prevToken.range[1],token.range[0]])});}}function checkSpacingAfter(token){if(!token.value.endsWith("${")){return;}const nextToken=sourceCode.getTokenAfter(token,{includeComments:true}),hasSpace=sourceCode.isSpaceBetween(token,nextToken);if(!astUtils.isTokenOnSameLine(token,nextToken)){return;}if(always&&!hasSpace){context.report({loc:{start:{line:token.loc.end.line,column:token.loc.end.column-2},end:token.loc.end},messageId:"expectedAfter",fix:fixer=>fixer.insertTextAfter(token," ")});}if(!always&&hasSpace){context.report({loc:{start:token.loc.end,end:nextToken.loc.start},messageId:"unexpectedAfter",fix:fixer=>fixer.removeRange([token.range[1],nextToken.range[0]])});}}return {TemplateElement(node){const token=sourceCode.getFirstToken(node);checkSpacingBefore(token);checkSpacingAfter(token);}};}};var templateTagSpacing={meta:{type:"layout",docs:{description:"require or disallow spacing between template tags and their literals",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/template-tag-spacing"},fixable:"whitespace",schema:[{enum:["always","never"]}],messages:{unexpected:"Unexpected space between template tag and template literal.",missing:"Missing space between template tag and template literal."}},create(context){const never=context.options[0]!=="always";const sourceCode=context.getSourceCode();return {TaggedTemplateExpression:function(node){const tagToken=sourceCode.getTokenBefore(node.quasi);const literalToken=sourceCode.getFirstToken(node.quasi);const hasWhitespace=sourceCode.isSpaceBetweenTokens(tagToken,literalToken);if(never&&hasWhitespace){context.report({node,loc:{start:tagToken.loc.end,end:literalToken.loc.start},messageId:"unexpected",fix(fixer){const comments=sourceCode.getCommentsBefore(node.quasi);if(comments.some(comment=>comment.type==="Line")){return null;}return fixer.replaceTextRange([tagToken.range[1],literalToken.range[0]],comments.reduce((text,comment)=>text+sourceCode.getText(comment),""));}});}else if(!never&&!hasWhitespace){context.report({node,loc:{start:node.loc.start,end:literalToken.loc.start},messageId:"missing",fix(fixer){return fixer.insertTextAfter(tagToken," ");}});}}};}};var unicodeBom={meta:{type:"layout",docs:{description:"require or disallow Unicode byte order mark (BOM)",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/unicode-bom"},fixable:"whitespace",schema:[{enum:["always","never"]}],messages:{expected:"Expected Unicode BOM (Byte Order Mark).",unexpected:"Unexpected Unicode BOM (Byte Order Mark)."}},create(context){return {Program:function(node){const sourceCode=context.getSourceCode(),location={column:0,line:1},requireBOM=context.options[0]||"never";if(!sourceCode.hasBOM&&requireBOM==="always"){context.report({node,loc:location,messageId:"expected",fix(fixer){return fixer.insertTextBeforeRange([0,1],"\uFEFF");}});}else if(sourceCode.hasBOM&&requireBOM==="never"){context.report({node,loc:location,messageId:"unexpected",fix(fixer){return fixer.removeRange([-1,0]);}});}}};}};function isNaNIdentifier(node){return Boolean(node)&&node.type==="Identifier"&&node.name==="NaN";}var useIsnan={meta:{type:"problem",docs:{description:"require calls to `isNaN()` when checking for `NaN`",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/use-isnan"},schema:[{type:"object",properties:{enforceForSwitchCase:{type:"boolean",default:true},enforceForIndexOf:{type:"boolean",default:false}},additionalProperties:false}],messages:{comparisonWithNaN:"Use the isNaN function to compare with NaN.",switchNaN:"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.",caseNaN:"'case NaN' can never match. Use Number.isNaN before the switch.",indexOfNaN:"Array prototype method '{{ methodName }}' cannot find NaN."}},create(context){const enforceForSwitchCase=!context.options[0]||context.options[0].enforceForSwitchCase;const enforceForIndexOf=context.options[0]&&context.options[0].enforceForIndexOf;function checkSwitchStatement(node){if(isNaNIdentifier(node.discriminant)){context.report({node,messageId:"switchNaN"});}for(const switchCase of node.cases){if(isNaNIdentifier(switchCase.test)){context.report({node:switchCase,messageId:"caseNaN"});}}}function checkCallExpression(node){const callee=astUtils.skipChainExpression(node.callee);if(callee.type==="MemberExpression"){const methodName=astUtils.getStaticPropertyName(callee);if((methodName==="indexOf"||methodName==="lastIndexOf")&&node.arguments.length===1&&isNaNIdentifier(node.arguments[0])){context.report({node,messageId:"indexOfNaN",data:{methodName}});}}}const listeners={BinaryExpression:function(node){if(/^(?:[<>]|[!=]=)=?$/u.test(node.operator)&&(isNaNIdentifier(node.left)||isNaNIdentifier(node.right))){context.report({node,messageId:"comparisonWithNaN"});}}};if(enforceForSwitchCase){listeners.SwitchStatement=checkSwitchStatement;}if(enforceForIndexOf){listeners.CallExpression=checkCallExpression;}return listeners;}};var validJsdoc={meta:{type:"suggestion",docs:{description:"enforce valid JSDoc comments",category:"Possible Errors",recommended:false,url:"https://eslint.org/docs/rules/valid-jsdoc"},schema:[{type:"object",properties:{prefer:{type:"object",additionalProperties:{type:"string"}},preferType:{type:"object",additionalProperties:{type:"string"}},requireReturn:{type:"boolean",default:true},requireParamDescription:{type:"boolean",default:true},requireReturnDescription:{type:"boolean",default:true},matchDescription:{type:"string"},requireReturnType:{type:"boolean",default:true},requireParamType:{type:"boolean",default:true}},additionalProperties:false}],fixable:"code",messages:{unexpectedTag:"Unexpected @{{title}} tag; function has no return statement.",expected:"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",use:"Use @{{name}} instead.",useType:"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",syntaxError:"JSDoc syntax error.",missingBrace:"JSDoc type missing brace.",missingParamDesc:"Missing JSDoc parameter description for '{{name}}'.",missingParamType:"Missing JSDoc parameter type for '{{name}}'.",missingReturnType:"Missing JSDoc return type.",missingReturnDesc:"Missing JSDoc return description.",missingReturn:"Missing JSDoc @{{returns}} for function.",missingParam:"Missing JSDoc for parameter '{{name}}'.",duplicateParam:"Duplicate JSDoc parameter '{{name}}'.",unsatisfiedDesc:"JSDoc description does not satisfy the regex pattern."},deprecated:true,replacedBy:[]},create(context){const options=context.options[0]||{},prefer=options.prefer||{},sourceCode=context.getSourceCode(),requireReturn=options.requireReturn!==false,requireParamDescription=options.requireParamDescription!==false,requireReturnDescription=options.requireReturnDescription!==false,requireReturnType=options.requireReturnType!==false,requireParamType=options.requireParamType!==false,preferType=options.preferType||{},checkPreferType=Object.keys(preferType).length!==0;const fns=[];function isTypeClass(node){return node.type==="ClassExpression"||node.type==="ClassDeclaration";}function startFunction(node){fns.push({returnPresent:node.type==="ArrowFunctionExpression"&&node.body.type!=="BlockStatement"||isTypeClass(node)||node.async});}function isValidReturnType(tag){return tag.type===null||tag.type.name==="void"||tag.type.type==="UndefinedLiteral";}function canTypeBeValidated(type){return type!=="UndefinedLiteral"&&type!=="NullLiteral"&&type!=="NullableLiteral"&&type!=="FunctionType"&&type!=="AllLiteral";}function getCurrentExpectedTypes(type){let currentType;if(type.name){currentType=type;}else if(type.expression){currentType=type.expression;}return {currentType,expectedTypeName:currentType&&preferType[currentType.name]};}function getAbsoluteRange(jsdocComment,parsedJsdocNode){return {start:sourceCode.getLocFromIndex(jsdocComment.range[0]+2+parsedJsdocNode.range[0]),end:sourceCode.getLocFromIndex(jsdocComment.range[0]+2+parsedJsdocNode.range[1])};}function validateType(jsdocNode,type){if(!type||!canTypeBeValidated(type.type)){return;}const typesToCheck=[];let elements=[];switch(type.type){case"TypeApplication":elements=type.applications[0].type==="UnionType"?type.applications[0].elements:type.applications;typesToCheck.push(getCurrentExpectedTypes(type));break;case"RecordType":elements=type.fields;break;case"UnionType":case"ArrayType":elements=type.elements;break;case"FieldType":if(type.value){typesToCheck.push(getCurrentExpectedTypes(type.value));}break;default:typesToCheck.push(getCurrentExpectedTypes(type));}elements.forEach(validateType.bind(null,jsdocNode));typesToCheck.forEach(typeToCheck=>{if(typeToCheck.expectedTypeName&&typeToCheck.expectedTypeName!==typeToCheck.currentType.name){context.report({node:jsdocNode,messageId:"useType",loc:getAbsoluteRange(jsdocNode,typeToCheck.currentType),data:{currentTypeName:typeToCheck.currentType.name,expectedTypeName:typeToCheck.expectedTypeName},fix(fixer){return fixer.replaceTextRange(typeToCheck.currentType.range.map(indexInComment=>jsdocNode.range[0]+2+indexInComment),typeToCheck.expectedTypeName);}});}});}function checkJSDoc(node){const jsdocNode=sourceCode.getJSDocComment(node),functionData=fns.pop(),paramTagsByName=Object.create(null),paramTags=[];let hasReturns=false,returnsTag,hasConstructor=false,isInterface=false,isOverride=false,isAbstract=false;if(jsdocNode){let jsdoc;try{jsdoc=doctrine__default['default'].parse(jsdocNode.value,{strict:true,unwrap:true,sloppy:true,range:true});}catch(ex){if(/braces/iu.test(ex.message)){context.report({node:jsdocNode,messageId:"missingBrace"});}else {context.report({node:jsdocNode,messageId:"syntaxError"});}return;}jsdoc.tags.forEach(tag=>{switch(tag.title.toLowerCase()){case"param":case"arg":case"argument":paramTags.push(tag);break;case"return":case"returns":hasReturns=true;returnsTag=tag;break;case"constructor":case"class":hasConstructor=true;break;case"override":case"inheritdoc":isOverride=true;break;case"abstract":case"virtual":isAbstract=true;break;case"interface":isInterface=true;break;}if(Object.prototype.hasOwnProperty.call(prefer,tag.title)&&tag.title!==prefer[tag.title]){const entireTagRange=getAbsoluteRange(jsdocNode,tag);context.report({node:jsdocNode,messageId:"use",loc:{start:entireTagRange.start,end:{line:entireTagRange.start.line,column:entireTagRange.start.column+`@${tag.title}`.length}},data:{name:prefer[tag.title]},fix(fixer){return fixer.replaceTextRange([jsdocNode.range[0]+tag.range[0]+3,jsdocNode.range[0]+tag.range[0]+tag.title.length+3],prefer[tag.title]);}});}if(checkPreferType&&tag.type){validateType(jsdocNode,tag.type);}});paramTags.forEach(param=>{if(requireParamType&&!param.type){context.report({node:jsdocNode,messageId:"missingParamType",loc:getAbsoluteRange(jsdocNode,param),data:{name:param.name}});}if(!param.description&&requireParamDescription){context.report({node:jsdocNode,messageId:"missingParamDesc",loc:getAbsoluteRange(jsdocNode,param),data:{name:param.name}});}if(paramTagsByName[param.name]){context.report({node:jsdocNode,messageId:"duplicateParam",loc:getAbsoluteRange(jsdocNode,param),data:{name:param.name}});}else if(param.name.indexOf(".")===-1){paramTagsByName[param.name]=param;}});if(hasReturns){if(!requireReturn&&!functionData.returnPresent&&(returnsTag.type===null||!isValidReturnType(returnsTag))&&!isAbstract){context.report({node:jsdocNode,messageId:"unexpectedTag",loc:getAbsoluteRange(jsdocNode,returnsTag),data:{title:returnsTag.title}});}else {if(requireReturnType&&!returnsTag.type){context.report({node:jsdocNode,messageId:"missingReturnType"});}if(!isValidReturnType(returnsTag)&&!returnsTag.description&&requireReturnDescription){context.report({node:jsdocNode,messageId:"missingReturnDesc"});}}}if(!isOverride&&!hasReturns&&!hasConstructor&&!isInterface&&node.parent.kind!=="get"&&node.parent.kind!=="constructor"&&node.parent.kind!=="set"&&!isTypeClass(node)){if(requireReturn||functionData.returnPresent&&!node.async){context.report({node:jsdocNode,messageId:"missingReturn",data:{returns:prefer.returns||"returns"}});}}const jsdocParamNames=Object.keys(paramTagsByName);if(node.params){node.params.forEach((param,paramsIndex)=>{const bindingParam=param.type==="AssignmentPattern"?param.left:param;if(bindingParam.type==="Identifier"){const name=bindingParam.name;if(jsdocParamNames[paramsIndex]&&name!==jsdocParamNames[paramsIndex]){context.report({node:jsdocNode,messageId:"expected",loc:getAbsoluteRange(jsdocNode,paramTagsByName[jsdocParamNames[paramsIndex]]),data:{name,jsdocName:jsdocParamNames[paramsIndex]}});}else if(!paramTagsByName[name]&&!isOverride){context.report({node:jsdocNode,messageId:"missingParam",data:{name}});}}});}if(options.matchDescription){const regex=new RegExp(options.matchDescription,"u");if(!regex.test(jsdoc.description)){context.report({node:jsdocNode,messageId:"unsatisfiedDesc"});}}}}return {ArrowFunctionExpression:startFunction,FunctionExpression:startFunction,FunctionDeclaration:startFunction,ClassExpression:startFunction,ClassDeclaration:startFunction,"ArrowFunctionExpression:exit":checkJSDoc,"FunctionExpression:exit":checkJSDoc,"FunctionDeclaration:exit":checkJSDoc,"ClassExpression:exit":checkJSDoc,"ClassDeclaration:exit":checkJSDoc,ReturnStatement:function(node){const functionState=fns[fns.length-1];if(functionState&&node.argument!==null){functionState.returnPresent=true;}}};}};var validTypeof={meta:{type:"problem",docs:{description:"enforce comparing `typeof` expressions against valid strings",category:"Possible Errors",recommended:true,url:"https://eslint.org/docs/rules/valid-typeof"},schema:[{type:"object",properties:{requireStringLiterals:{type:"boolean",default:false}},additionalProperties:false}],messages:{invalidValue:"Invalid typeof comparison value.",notString:"Typeof comparisons should be to string literals."}},create(context){const VALID_TYPES=["symbol","undefined","object","boolean","number","string","function","bigint"],OPERATORS=["==","===","!=","!=="];const requireStringLiterals=context.options[0]&&context.options[0].requireStringLiterals;function isTypeofExpression(node){return node.type==="UnaryExpression"&&node.operator==="typeof";}return {UnaryExpression(node){if(isTypeofExpression(node)){const parent=context.getAncestors().pop();if(parent.type==="BinaryExpression"&&OPERATORS.indexOf(parent.operator)!==-1){const sibling=parent.left===node?parent.right:parent.left;if(sibling.type==="Literal"||sibling.type==="TemplateLiteral"&&!sibling.expressions.length){const value=sibling.type==="Literal"?sibling.value:sibling.quasis[0].value.cooked;if(VALID_TYPES.indexOf(value)===-1){context.report({node:sibling,messageId:"invalidValue"});}}else if(requireStringLiterals&&!isTypeofExpression(sibling)){context.report({node:sibling,messageId:"notString"});}}}}};}};var varsOnTop={meta:{type:"suggestion",docs:{description:"require `var` declarations be placed at the top of their containing scope",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/vars-on-top"},schema:[],messages:{top:"All 'var' declarations must be at the top of the function scope."}},create(context){function looksLikeDirective(node){return node.type==="ExpressionStatement"&&node.expression.type==="Literal"&&typeof node.expression.value==="string";}function looksLikeImport(node){return node.type==="ImportDeclaration"||node.type==="ImportSpecifier"||node.type==="ImportDefaultSpecifier"||node.type==="ImportNamespaceSpecifier";}function isVariableDeclaration(node){return node.type==="VariableDeclaration"||node.type==="ExportNamedDeclaration"&&node.declaration&&node.declaration.type==="VariableDeclaration";}function isVarOnTop(node,statements){const l=statements.length;let i=0;for(;i<l;++i){if(!looksLikeDirective(statements[i])&&!looksLikeImport(statements[i])){break;}}for(;i<l;++i){if(!isVariableDeclaration(statements[i])){return false;}if(statements[i]===node){return true;}}return false;}function globalVarCheck(node,parent){if(!isVarOnTop(node,parent.body)){context.report({node,messageId:"top"});}}function blockScopeVarCheck(node,parent,grandParent){if(!(/Function/u.test(grandParent.type)&&parent.type==="BlockStatement"&&isVarOnTop(node,parent.body))){context.report({node,messageId:"top"});}}return {"VariableDeclaration[kind='var']"(node){if(node.parent.type==="ExportNamedDeclaration"){globalVarCheck(node.parent,node.parent.parent);}else if(node.parent.type==="Program"){globalVarCheck(node,node.parent);}else {blockScopeVarCheck(node,node.parent,node.parent.parent);}}};}};function isCalleeOfNewExpression(node){const maybeCallee=node.parent.type==="ChainExpression"?node.parent:node;return maybeCallee.parent.type==="NewExpression"&&maybeCallee.parent.callee===maybeCallee;}var wrapIife={meta:{type:"layout",docs:{description:"require parentheses around immediate `function` invocations",category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/wrap-iife"},schema:[{enum:["outside","inside","any"]},{type:"object",properties:{functionPrototypeMethods:{type:"boolean",default:false}},additionalProperties:false}],fixable:"code",messages:{wrapInvocation:"Wrap an immediate function invocation in parentheses.",wrapExpression:"Wrap only the function expression in parens.",moveInvocation:"Move the invocation into the parens that contain the function."}},create(context){const style=context.options[0]||"outside";const includeFunctionPrototypeMethods=context.options[1]&&context.options[1].functionPrototypeMethods;const sourceCode=context.getSourceCode();function isWrappedInAnyParens(node){return astUtils.isParenthesised(sourceCode,node);}function isWrappedInGroupingParens(node){return eslintUtils__default['default'].isParenthesized(1,node,sourceCode);}function getFunctionNodeFromIIFE(node){const callee=astUtils.skipChainExpression(node.callee);if(callee.type==="FunctionExpression"){return callee;}if(includeFunctionPrototypeMethods&&callee.type==="MemberExpression"&&callee.object.type==="FunctionExpression"&&(astUtils.getStaticPropertyName(callee)==="call"||astUtils.getStaticPropertyName(callee)==="apply")){return callee.object;}return null;}return {CallExpression(node){const innerNode=getFunctionNodeFromIIFE(node);if(!innerNode){return;}const isCallExpressionWrapped=isWrappedInAnyParens(node),isFunctionExpressionWrapped=isWrappedInAnyParens(innerNode);if(!isCallExpressionWrapped&&!isFunctionExpressionWrapped){context.report({node,messageId:"wrapInvocation",fix(fixer){const nodeToSurround=style==="inside"?innerNode:node;return fixer.replaceText(nodeToSurround,`(${sourceCode.getText(nodeToSurround)})`);}});}else if(style==="inside"&&!isFunctionExpressionWrapped){context.report({node,messageId:"wrapExpression",fix(fixer){if(isWrappedInGroupingParens(node)&&!isCalleeOfNewExpression(node)){const parenAfter=sourceCode.getTokenAfter(node);return fixer.replaceTextRange([innerNode.range[1],parenAfter.range[1]],`)${sourceCode.getText().slice(innerNode.range[1],parenAfter.range[0])}`);}return fixer.replaceText(innerNode,`(${sourceCode.getText(innerNode)})`);}});}else if(style==="outside"&&!isCallExpressionWrapped){context.report({node,messageId:"moveInvocation",fix(fixer){const parenAfter=sourceCode.getTokenAfter(innerNode);return fixer.replaceTextRange([parenAfter.range[0],node.range[1]],`${sourceCode.getText().slice(parenAfter.range[1],node.range[1])})`);}});}}};}};var wrapRegex={meta:{type:"layout",docs:{description:"require parenthesis around regex literals",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/wrap-regex"},schema:[],fixable:"code",messages:{requireParens:"Wrap the regexp literal in parens to disambiguate the slash."}},create(context){const sourceCode=context.getSourceCode();return {Literal(node){const token=sourceCode.getFirstToken(node),nodeType=token.type;if(nodeType==="RegularExpression"){const beforeToken=sourceCode.getTokenBefore(node);const afterToken=sourceCode.getTokenAfter(node);const ancestors=context.getAncestors();const grandparent=ancestors[ancestors.length-1];if(grandparent.type==="MemberExpression"&&grandparent.object===node&&!(beforeToken&&beforeToken.value==="("&&afterToken&&afterToken.value===")")){context.report({node,messageId:"requireParens",fix:fixer=>fixer.replaceText(node,`(${sourceCode.getText(node)})`)});}}}};}};var yieldStarSpacing={meta:{type:"layout",docs:{description:"require or disallow spacing around the `*` in `yield*` expressions",category:"ECMAScript 6",recommended:false,url:"https://eslint.org/docs/rules/yield-star-spacing"},fixable:"whitespace",schema:[{oneOf:[{enum:["before","after","both","neither"]},{type:"object",properties:{before:{type:"boolean"},after:{type:"boolean"}},additionalProperties:false}]}],messages:{missingBefore:"Missing space before *.",missingAfter:"Missing space after *.",unexpectedBefore:"Unexpected space before *.",unexpectedAfter:"Unexpected space after *."}},create(context){const sourceCode=context.getSourceCode();const mode=function(option){if(!option||typeof option==="string"){return {before:{before:true,after:false},after:{before:false,after:true},both:{before:true,after:true},neither:{before:false,after:false}}[option||"after"];}return option;}(context.options[0]);function checkSpacing(side,leftToken,rightToken){if(sourceCode.isSpaceBetweenTokens(leftToken,rightToken)!==mode[side]){const after=leftToken.value==="*";const spaceRequired=mode[side];const node=after?leftToken:rightToken;let messageId="";if(spaceRequired){messageId=side==="before"?"missingBefore":"missingAfter";}else {messageId=side==="before"?"unexpectedBefore":"unexpectedAfter";}context.report({node,messageId,fix(fixer){if(spaceRequired){if(after){return fixer.insertTextAfter(node," ");}return fixer.insertTextBefore(node," ");}return fixer.removeRange([leftToken.range[1],rightToken.range[0]]);}});}}return {YieldExpression:function(node){if(!node.delegate){return;}const tokens=sourceCode.getFirstTokens(node,3);const yieldToken=tokens[0];const starToken=tokens[1];const nextToken=tokens[2];checkSpacing("before",yieldToken,starToken);checkSpacing("after",starToken,nextToken);}};}};function isComparisonOperator(operator){return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);}function isEqualityOperator(operator){return /^(==|===)$/u.test(operator);}function isRangeTestOperator(operator){return ["<","<="].indexOf(operator)>=0;}function isNegativeNumericLiteral(node){return node.type==="UnaryExpression"&&node.operator==="-"&&node.prefix&&astUtils.isNumericLiteral(node.argument);}function isStaticTemplateLiteral(node){return node.type==="TemplateLiteral"&&node.expressions.length===0;}function looksLikeLiteral(node){return isNegativeNumericLiteral(node)||isStaticTemplateLiteral(node);}function getNormalizedLiteral(node){if(node.type==="Literal"){return node;}if(isNegativeNumericLiteral(node)){return {type:"Literal",value:-node.argument.value,raw:`-${node.argument.value}`};}if(isStaticTemplateLiteral(node)){return {type:"Literal",value:node.quasis[0].value.cooked,raw:node.quasis[0].value.raw};}return null;}var yoda={meta:{type:"suggestion",docs:{description:'require or disallow "Yoda" conditions',category:"Best Practices",recommended:false,url:"https://eslint.org/docs/rules/yoda"},schema:[{enum:["always","never"]},{type:"object",properties:{exceptRange:{type:"boolean",default:false},onlyEquality:{type:"boolean",default:false}},additionalProperties:false}],fixable:"code",messages:{expected:"Expected literal to be on the {{expectedSide}} side of {{operator}}."}},create(context){const always=context.options[0]==="always";const exceptRange=context.options[1]&&context.options[1].exceptRange;const onlyEquality=context.options[1]&&context.options[1].onlyEquality;const sourceCode=context.getSourceCode();function isRangeTest(node){const left=node.left,right=node.right;return node.type==="LogicalExpression"&&left.type==="BinaryExpression"&&right.type==="BinaryExpression"&&isRangeTestOperator(left.operator)&&isRangeTestOperator(right.operator)&&(function(){if(node.operator==="&&"&&astUtils.isSameReference(left.right,right.left)){const leftLiteral=getNormalizedLiteral(left.left);const rightLiteral=getNormalizedLiteral(right.right);if(leftLiteral===null&&rightLiteral===null){return false;}if(rightLiteral===null||leftLiteral===null){return true;}if(leftLiteral.value<=rightLiteral.value){return true;}}return false;}()||function(){if(node.operator==="||"&&astUtils.isSameReference(left.left,right.right)){const leftLiteral=getNormalizedLiteral(left.right);const rightLiteral=getNormalizedLiteral(right.left);if(leftLiteral===null&&rightLiteral===null){return false;}if(rightLiteral===null||leftLiteral===null){return true;}if(leftLiteral.value<=rightLiteral.value){return true;}}return false;}())&&function(){return astUtils.isParenthesised(sourceCode,node);}();}const OPERATOR_FLIP_MAP={"===":"===","!==":"!==","==":"==","!=":"!=","<":">",">":"<","<=":">=",">=":"<="};function getFlippedString(node){const operatorToken=sourceCode.getFirstTokenBetween(node.left,node.right,token=>token.value===node.operator);const lastLeftToken=sourceCode.getTokenBefore(operatorToken);const firstRightToken=sourceCode.getTokenAfter(operatorToken);const source=sourceCode.getText();const leftText=source.slice(node.range[0],lastLeftToken.range[1]);const textBeforeOperator=source.slice(lastLeftToken.range[1],operatorToken.range[0]);const textAfterOperator=source.slice(operatorToken.range[1],firstRightToken.range[0]);const rightText=source.slice(firstRightToken.range[0],node.range[1]);const tokenBefore=sourceCode.getTokenBefore(node);const tokenAfter=sourceCode.getTokenAfter(node);let prefix="";let suffix="";if(tokenBefore&&tokenBefore.range[1]===node.range[0]&&!astUtils.canTokensBeAdjacent(tokenBefore,firstRightToken)){prefix=" ";}if(tokenAfter&&node.range[1]===tokenAfter.range[0]&&!astUtils.canTokensBeAdjacent(lastLeftToken,tokenAfter)){suffix=" ";}return prefix+rightText+textBeforeOperator+OPERATOR_FLIP_MAP[operatorToken.value]+textAfterOperator+leftText+suffix;}return {BinaryExpression(node){const expectedLiteral=always?node.left:node.right;const expectedNonLiteral=always?node.right:node.left;if((expectedNonLiteral.type==="Literal"||looksLikeLiteral(expectedNonLiteral))&&!(expectedLiteral.type==="Literal"||looksLikeLiteral(expectedLiteral))&&!(!isEqualityOperator(node.operator)&&onlyEquality)&&isComparisonOperator(node.operator)&&!(exceptRange&&isRangeTest(context.getAncestors().pop()))){context.report({node,messageId:"expected",data:{operator:node.operator,expectedSide:always?"left":"right"},fix:fixer=>fixer.replaceText(node,getFlippedString(node))});}}};}};var coreRules={"accessor-pairs":accessorPairs,"array-bracket-newline":arrayBracketNewline,"array-bracket-spacing":arrayBracketSpacing,"array-callback-return":arrayCallbackReturn,"array-element-newline":arrayElementNewline,"arrow-body-style":arrowBodyStyle,"arrow-parens":arrowParens,"arrow-spacing":arrowSpacing,"block-scoped-var":blockScopedVar,"block-spacing":blockSpacing,"brace-style":braceStyle,"callback-return":callbackReturn,"camelcase":camelcase,"capitalized-comments":capitalizedComments,"class-methods-use-this":classMethodsUseThis,"comma-dangle":commaDangle,"comma-spacing":commaSpacing,"comma-style":commaStyle,"complexity":complexity,"computed-property-spacing":computedPropertySpacing,"consistent-return":consistentReturn,"consistent-this":consistentThis,"constructor-super":constructorSuper,"curly":curly,"default-case-last":defaultCaseLast,"default-case":defaultCase,"default-param-last":defaultParamLast,"dot-location":dotLocation,"dot-notation":dotNotation,"eol-last":eolLast,"eqeqeq":eqeqeq,"for-direction":forDirection,"func-call-spacing":funcCallSpacing,"func-name-matching":funcNameMatching,"func-names":funcNames,"func-style":funcStyle,"function-call-argument-newline":functionCallArgumentNewline,"function-paren-newline":functionParenNewline,"generator-star-spacing":generatorStarSpacing,"getter-return":getterReturn,"global-require":globalRequire,"grouped-accessor-pairs":groupedAccessorPairs,"guard-for-in":guardForIn,"handle-callback-err":handleCallbackErr,"id-blacklist":idBlacklist,"id-denylist":idDenylist,"id-length":idLength,"id-match":idMatch,"implicit-arrow-linebreak":implicitArrowLinebreak,"indent-legacy":indentLegacy,"indent":indent,"init-declarations":initDeclarations,"jsx-quotes":jsxQuotes,"key-spacing":keySpacing,"keyword-spacing":keywordSpacing,"line-comment-position":lineCommentPosition,"linebreak-style":linebreakStyle,"lines-around-comment":linesAroundComment,"lines-around-directive":linesAroundDirective,"lines-between-class-members":linesBetweenClassMembers,"max-classes-per-file":maxClassesPerFile,"max-depth":maxDepth,"max-len":maxLen,"max-lines-per-function":maxLinesPerFunction,"max-lines":maxLines,"max-nested-callbacks":maxNestedCallbacks,"max-params":maxParams,"max-statements-per-line":maxStatementsPerLine,"max-statements":maxStatements,"multiline-comment-style":multilineCommentStyle,"multiline-ternary":multilineTernary,"new-cap":newCap,"new-parens":newParens,"newline-after-var":newlineAfterVar,"newline-before-return":newlineBeforeReturn,"newline-per-chained-call":newlinePerChainedCall,"no-alert":noAlert,"no-array-constructor":noArrayConstructor,"no-async-promise-executor":noAsyncPromiseExecutor,"no-await-in-loop":noAwaitInLoop,"no-bitwise":noBitwise,"no-buffer-constructor":noBufferConstructor,"no-caller":noCaller,"no-case-declarations":noCaseDeclarations,"no-catch-shadow":noCatchShadow,"no-class-assign":noClassAssign,"no-compare-neg-zero":noCompareNegZero,"no-cond-assign":noCondAssign,"no-confusing-arrow":noConfusingArrow,"no-console":noConsole,"no-const-assign":noConstAssign,"no-constant-condition":noConstantCondition,"no-constructor-return":noConstructorReturn,"no-continue":noContinue,"no-control-regex":noControlRegex,"no-debugger":noDebugger,"no-delete-var":noDeleteVar,"no-div-regex":noDivRegex,"no-dupe-args":noDupeArgs,"no-dupe-class-members":noDupeClassMembers,"no-dupe-else-if":noDupeElseIf,"no-dupe-keys":noDupeKeys,"no-duplicate-case":noDuplicateCase,"no-duplicate-imports":noDuplicateImports,"no-else-return":noElseReturn,"no-empty-character-class":noEmptyCharacterClass,"no-empty-function":noEmptyFunction,"no-empty-pattern":noEmptyPattern,"no-empty":noEmpty,"no-eq-null":noEqNull,"no-eval":noEval,"no-ex-assign":noExAssign,"no-extend-native":noExtendNative,"no-extra-bind":noExtraBind,"no-extra-boolean-cast":noExtraBooleanCast,"no-extra-label":noExtraLabel,"no-extra-parens":noExtraParens,"no-extra-semi":noExtraSemi,"no-fallthrough":noFallthrough,"no-floating-decimal":noFloatingDecimal,"no-func-assign":noFuncAssign,"no-global-assign":noGlobalAssign,"no-implicit-coercion":noImplicitCoercion,"no-implicit-globals":noImplicitGlobals,"no-implied-eval":noImpliedEval,"no-import-assign":noImportAssign,"no-inline-comments":noInlineComments,"no-inner-declarations":noInnerDeclarations,"no-invalid-regexp":noInvalidRegexp,"no-invalid-this":noInvalidThis,"no-irregular-whitespace":noIrregularWhitespace,"no-iterator":noIterator,"no-label-var":noLabelVar,"no-labels":noLabels,"no-lone-blocks":noLoneBlocks,"no-lonely-if":noLonelyIf,"no-loop-func":noLoopFunc,"no-loss-of-precision":noLossOfPrecision,"no-magic-numbers":noMagicNumbers,"no-misleading-character-class":noMisleadingCharacterClass,"no-mixed-operators":noMixedOperators,"no-mixed-requires":noMixedRequires,"no-mixed-spaces-and-tabs":noMixedSpacesAndTabs,"no-multi-assign":noMultiAssign,"no-multi-spaces":noMultiSpaces,"no-multi-str":noMultiStr,"no-multiple-empty-lines":noMultipleEmptyLines,"no-native-reassign":noNativeReassign,"no-negated-condition":noNegatedCondition,"no-negated-in-lhs":noNegatedInLhs,"no-nested-ternary":noNestedTernary,"no-new-func":noNewFunc,"no-new-object":noNewObject,"no-new-require":noNewRequire,"no-new-symbol":noNewSymbol,"no-new-wrappers":noNewWrappers,"no-new":noNew,"no-nonoctal-decimal-escape":noNonoctalDecimalEscape,"no-obj-calls":noObjCalls,"no-octal-escape":noOctalEscape,"no-octal":noOctal,"no-param-reassign":noParamReassign,"no-path-concat":noPathConcat,"no-plusplus":noPlusplus,"no-process-env":noProcessEnv,"no-process-exit":noProcessExit,"no-promise-executor-return":noPromiseExecutorReturn,"no-proto":noProto,"no-prototype-builtins":noPrototypeBuiltins,"no-redeclare":noRedeclare,"no-regex-spaces":noRegexSpaces,"no-restricted-exports":noRestrictedExports,"no-restricted-globals":noRestrictedGlobals,"no-restricted-imports":noRestrictedImports,"no-restricted-modules":noRestrictedModules,"no-restricted-properties":noRestrictedProperties,"no-restricted-syntax":noRestrictedSyntax,"no-return-assign":noReturnAssign,"no-return-await":noReturnAwait,"no-script-url":noScriptUrl,"no-self-assign":noSelfAssign,"no-self-compare":noSelfCompare,"no-sequences":noSequences,"no-setter-return":noSetterReturn,"no-shadow-restricted-names":noShadowRestrictedNames,"no-shadow":noShadow,"no-spaced-func":noSpacedFunc,"no-sparse-arrays":noSparseArrays,"no-sync":noSync,"no-tabs":noTabs,"no-template-curly-in-string":noTemplateCurlyInString,"no-ternary":noTernary,"no-this-before-super":noThisBeforeSuper,"no-throw-literal":noThrowLiteral,"no-trailing-spaces":noTrailingSpaces,"no-undef-init":noUndefInit,"no-undef":noUndef,"no-undefined":noUndefined,"no-underscore-dangle":noUnderscoreDangle,"no-unexpected-multiline":noUnexpectedMultiline,"no-unmodified-loop-condition":noUnmodifiedLoopCondition,"no-unneeded-ternary":noUnneededTernary,"no-unreachable-loop":noUnreachableLoop,"no-unreachable":noUnreachable,"no-unsafe-finally":noUnsafeFinally,"no-unsafe-negation":noUnsafeNegation,"no-unsafe-optional-chaining":noUnsafeOptionalChaining,"no-unused-expressions":noUnusedExpressions,"no-unused-labels":noUnusedLabels,"no-unused-vars":noUnusedVars,"no-use-before-define":noUseBeforeDefine,"no-useless-backreference":noUselessBackreference,"no-useless-call":noUselessCall,"no-useless-catch":noUselessCatch,"no-useless-computed-key":noUselessComputedKey,"no-useless-concat":noUselessConcat,"no-useless-constructor":noUselessConstructor,"no-useless-escape":noUselessEscape,"no-useless-rename":noUselessRename,"no-useless-return":noUselessReturn,"no-var":noVar,"no-void":noVoid,"no-warning-comments":noWarningComments,"no-whitespace-before-property":noWhitespaceBeforeProperty,"no-with":noWith,"nonblock-statement-body-position":nonblockStatementBodyPosition,"object-curly-newline":objectCurlyNewline,"object-curly-spacing":objectCurlySpacing,"object-property-newline":objectPropertyNewline,"object-shorthand":objectShorthand,"one-var-declaration-per-line":oneVarDeclarationPerLine,"one-var":oneVar,"operator-assignment":operatorAssignment,"operator-linebreak":operatorLinebreak,"padded-blocks":paddedBlocks,"padding-line-between-statements":paddingLineBetweenStatements,"prefer-arrow-callback":preferArrowCallback,"prefer-const":preferConst,"prefer-destructuring":preferDestructuring,"prefer-exponentiation-operator":preferExponentiationOperator,"prefer-named-capture-group":preferNamedCaptureGroup,"prefer-numeric-literals":preferNumericLiterals,"prefer-object-spread":preferObjectSpread,"prefer-promise-reject-errors":preferPromiseRejectErrors,"prefer-reflect":preferReflect,"prefer-regex-literals":preferRegexLiterals,"prefer-rest-params":preferRestParams,"prefer-spread":preferSpread,"prefer-template":preferTemplate,"quote-props":quoteProps,"quotes":quotes,"radix":radix,"require-atomic-updates":requireAtomicUpdates,"require-await":requireAwait,"require-jsdoc":requireJsdoc,"require-unicode-regexp":requireUnicodeRegexp,"require-yield":requireYield,"rest-spread-spacing":restSpreadSpacing,"semi-spacing":semiSpacing,"semi-style":semiStyle,"semi":semi,"sort-imports":sortImports,"sort-keys":sortKeys,"sort-vars":sortVars,"space-before-blocks":spaceBeforeBlocks,"space-before-function-paren":spaceBeforeFunctionParen,"space-in-parens":spaceInParens,"space-infix-ops":spaceInfixOps,"space-unary-ops":spaceUnaryOps,"spaced-comment":spacedComment,"strict":strict,"switch-colon-spacing":switchColonSpacing,"symbol-description":symbolDescription,"template-curly-spacing":templateCurlySpacing,"template-tag-spacing":templateTagSpacing,"unicode-bom":unicodeBom,"use-isnan":useIsnan,"valid-jsdoc":validJsdoc,"valid-typeof":validTypeof,"vars-on-top":varsOnTop,"wrap-iife":wrapIife,"wrap-regex":wrapRegex,"yield-star-spacing":yieldStarSpacing,"yoda":yoda};var coreRules_1=coreRules;

class Linter extends indexB5dc13bc.linter_1 {
  constructor() {
    super();
    this.defineRules(coreRules_1);
  }

}

var dist = Linter;

//import plugin from "@typescript-eslint/eslint-plugin"
//import * as parser from "@typescript-eslint/parser"

const linter = new class extends dist {
  constructor() {
    super();
    this.defineParser("@typescript-eslint/parser", parser);

    for (const name of Object.keys(plugin.rules)) {
      this.defineRule(`@typescript-eslint/${name}`, plugin.rules[name]);
    }
  }

}();

export { linter };
